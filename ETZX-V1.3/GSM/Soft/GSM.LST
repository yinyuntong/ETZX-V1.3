C51 COMPILER V8.08   GSM                                                                   09/25/2012 08:54:10 PAGE 1   


C51 COMPILER V8.08, COMPILATION OF MODULE GSM
OBJECT MODULE PLACED IN GSM.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE GSM.C BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #define _IN_GSM_
   2          #include "config.h"
   3          
   4          void AffirmUartCom(void)
   5          {
   6   1              UartSendString("AT");
   7   1              UartSendByte(0x0d);             //回车
   8   1              UartSendByte(0x0a);             //换行
   9   1      }
  10          
  11          
  12          void LoopDispOff(void)  //回显关闭
  13          {
  14   1              UartSendString("ATE0");
  15   1              UartSendByte(0x0d);             //回车
  16   1              UartSendByte(0x0a);             //换行  
  17   1      }
  18          
  19          void LoopDispOn(void)   //回显打开
  20          {
  21   1              UartSendString("ATE1");
  22   1              UartSendByte(0x0d);             //回车
  23   1              UartSendByte(0x0a);             //换行  
  24   1      }
  25          
  26          
  27          void SIMStateQuery(void)        //SIM状态查询
  28          {
  29   1              UartSendString("AT+CPIN?");
  30   1              UartSendByte(0x0d);             //回车
  31   1              UartSendByte(0x0a);             //换行
  32   1      }
  33          
  34          
  35          void SignalIntensionQuery(void) //网络信号强度查询
  36          {
  37   1              UartSendString("AT+CSQ");
  38   1              UartSendByte(0x0d);             //回车
  39   1              UartSendByte(0x0a);             //换行  
  40   1      }
  41          
  42          
  43          void NetOPSQuery(void)          //网络运营商注册查询
  44          {
  45   1              UartSendString("AT+COPS?");
  46   1              UartSendByte(0x0d);             //回车
  47   1              UartSendByte(0x0a);             //换行  
  48   1      
  49   1      }
  50          
  51          
  52          void GSMModuleInfoQuery(void)   //模块信息查询
  53          {
  54   1              UartSendString("ATI");
  55   1              UartSendByte(0x0d);             //回车
C51 COMPILER V8.08   GSM                                                                   09/25/2012 08:54:10 PAGE 2   

  56   1              UartSendByte(0x0a);             //换行  
  57   1      
  58   1      }
  59          
  60          void GSMUartAutoBrtSet(void)    //自适应波特率设置
  61          {
  62   1              UartSendString("AT+IPR=0");
  63   1              UartSendByte(0x0d);             //回车
  64   1              UartSendByte(0x0a);             //换行  
  65   1      }
  66          
  67          
  68          
  69          void GSMUartBrtSet(uint16 UartBrt)      //设置GSM模块波特率UartBrt=0:为自适应波特率
  70          {                                                                               //最高为57600   //再高单片机串口收发数据不正确
  71   1              uint8 BaudRate[5];
  72   1              BaudRate[0]     = UartBrt/10000+0x30;
  73   1              UartBrt         = UartBrt%10000;
  74   1              BaudRate[1]     = UartBrt/1000+0x30;
  75   1              UartBrt         = UartBrt%1000;
  76   1              BaudRate[2]     = UartBrt/100+0x30;
  77   1              UartBrt         = UartBrt%100;
  78   1              BaudRate[3]     = UartBrt/10+0x30;
  79   1              UartBrt         = UartBrt%10;
  80   1              BaudRate[4]     = UartBrt+0x30;
  81   1      
  82   1              
  83   1              UartSendString("AT+IPR=");
  84   1              Send_Data(BaudRate,5);
  85   1              UartSendByte(0x0d);             //回车
  86   1              UartSendByte(0x0a);             //换行
  87   1      
  88   1      }
  89          
  90          
  91          void GSMPathQuery(void)
  92          {
  93   1              UartSendString("AT^SWSPATH?");
  94   1              UartSendByte(0x0d);             //回车
  95   1              UartSendByte(0x0a);             //换行  
  96   1      }
  97          
  98          void EchoRestrainQuery(void)    //回声抑制功能查询
  99          {
 100   1              UartSendString("AT^ECHO?");
 101   1              UartSendByte(0x0d);             //回车
 102   1              UartSendByte(0x0a);             //换行          
 103   1      }
 104          
 105          
 106          void EchoRestrainSet(uint8 Parameter)   //回声抑制功能设置
 107          {
 108   1              UartSendString("AT^ECHO=");
 109   1              UartSendByte(0x30+Parameter);   
 110   1              UartSendByte(0x0d);             //回车
 111   1              UartSendByte(0x0a);             //换行          
 112   1      }
 113          
 114          
 115          
 116          
 117          void GSMSWPathSet(uint8 path)
C51 COMPILER V8.08   GSM                                                                   09/25/2012 08:54:10 PAGE 3   

 118          {
 119   1              if(path>=2) return;
 120   1      
 121   1              UartSendString("AT^SWSPATH=");
 122   1              UartSendByte(0x30+path);        
 123   1              UartSendByte(0x0d);             //回车
 124   1              UartSendByte(0x0a);             //换行          
 125   1      }
 126          
 127          
 128          void GSMSPKVoiceSet(uint8 Voice)
 129          {
 130   1              
 131   1              UartSendString("AT+CLVL=");
 132   1              UartSendByte(0x30+Voice);       //设置扬声器音量
 133   1              UartSendByte(0x0d);             //回车
 134   1              UartSendByte(0x0a);             //换行  
 135   1      }
 136          
 137          
 138          void GSMMICGainSet(uint8 Gain)
 139          {
 140   1              UartSendString("AT+CMIC=");
 141   1              UartSendByte(0x30+Gain);        //设置麦克风增益
 142   1              UartSendByte(0x0d);             //回车
 143   1              UartSendByte(0x0a);             //换行  
 144   1      }
 145          
 146          
 147          
 148          void GSMCall(void)      //模块主叫
 149          {
 150   1              uint8 TelPhoneNum[TEL_NUM_LEN+1];
 151   1              uint8 i;
 152   1              memcpy(TelPhoneNum,stLocalControl.stEepromCfgData.byTelNum,stLocalControl.stEepromCfgData.byTelNumValidLe
             -n);
 153   1              for(i=0;i<stLocalControl.stEepromCfgData.byTelNumValidLen;i++) TelPhoneNum[i]=TelPhoneNum[i]+0x30;
 154   1              
 155   1              UartSendString("ATD");
 156   1              for(i=0;i<stLocalControl.stEepromCfgData.byTelNumValidLen;i++)
 157   1              {
 158   2                       UartSendByte(TelPhoneNum[i]);
 159   2              }
 160   1      //      Send_Data(TelPhoneNum,TEL_NUM_LEN);     //发送电话号码
 161   1              UartSendByte(';');      
 162   1              UartSendByte(0x0d);             //回车
 163   1              UartSendByte(0x0a);             //换行  
 164   1      }
 165          
 166          void GSMHandUp(void)    //GSM模块主动挂断
 167          {
 168   1              UartSendString("AT+CHUP");
 169   1              UartSendByte(0x0d);             //回车
 170   1              UartSendByte(0x0a);             //换行          
 171   1      }
 172          
 173          
 174          void GSMInit(void)
 175          {
 176   1              GSM_PWR_SW =1;
 177   1              GSM_ON_OFF =1;  
 178   1              Delayms(500);           //上电时间最小值250ms
C51 COMPILER V8.08   GSM                                                                   09/25/2012 08:54:10 PAGE 4   

 179   1      
 180   1              GSM_ON_OFF =0;
 181   1              Delayms(750);           //复位时间 750ms
 182   1              GSM_ON_OFF =1;
 183   1      }
 184          
 185          
 186          void GSMRestar(void)    //GSM模块重启
 187          {
 188   1              GSM_RST =0;
 189   1              Delayms(50);
 190   1              GSM_RST =1;
 191   1      }
 192          
 193          
 194          uint8 GSMCallTreat(void)
 195          {
 196   1              uint16 i;
 197   1              if(((stLocalControl.stEepromCfgData.byTelFuncState&0x01)==0)||(stLocalControl.stEepromCfgData.byTelNumVal
             -idLen==0)) return 0;
 198   1              RePeat=0;
 199   1      RE_GSM_CALL:    
 200   1              while(RePeat<3)
 201   1              {
 202   2                      GSMCall();
 203   2                      i=5000;         //延时5S
 204   2                      while(!bUartRecFinished)
 205   2                      {
 206   3                              Delayms(1);
 207   3                              if(--i==0)      break;
 208   3                      }
 209   2      
 210   2                      if(bUartRecFinished)
 211   2                      {
 212   3                              bUartRecFinished=0;
 213   3                              if(UartRecTreat("^ORIG: 1,0\r\n\r\nOK",(uint8)strlen("^ORIG: 1,0\r\n\r\nOK")))
 214   3                              {//收到第一步
 215   4                              
 216   4                                      i=2000; //延时2S
 217   4                                      while(!bUartRecFinished)
 218   4                                      {
 219   5                                              Delayms(1);
 220   5                                              if(--i==0)      break;
 221   5                                      }
 222   4                                      if(bUartRecFinished)
 223   4                                      {
 224   5                                              bUartRecFinished=0; 
 225   5                                              if(UartRecTreat("^CONF: 1",(uint8)strlen("^CONF: 1")))
 226   5                                              {//收到第二步数据^CONF: 1
 227   6                                              
 228   6                                                      GSM_STATE_LED = LED_ON;
 229   6                                                      //break;
 230   6                                                      return 1;
 231   6                                              }
 232   5      
 233   5                                      }
 234   4                              }
 235   3                      }
 236   2      //              else 
 237   2      //              {
 238   2      //未收到任何数据
 239   2                              Delayms(2000);
C51 COMPILER V8.08   GSM                                                                   09/25/2012 08:54:10 PAGE 5   

 240   2                              RePeat++;
 241   2                              goto RE_GSM_CALL;
 242   2      //              }
 243   2              }
 244   1              return 0;
 245   1      }
 246          
 247          
 248          uint8 GSMHandUpTreat(void)
 249          {
 250   1              uint16 i;
 251   1              if(((stLocalControl.stEepromCfgData.byTelFuncState&0x01)==0)||(stLocalControl.stEepromCfgData.byTelNumVal
             -idLen==0)) return 0;  
 252   1              RePeat=0;
 253   1      RE_GSM_HUNDUP:  
 254   1              while(RePeat<3)
 255   1              {
 256   2                      GSMHandUp();
 257   2                      i=2000;         //延时2S
 258   2                      while(!bUartRecFinished)
 259   2                      {
 260   3                              Delayms(1);
 261   3                              if(--i==0)      break;
 262   3                      }
 263   2      
 264   2                      if(bUartRecFinished)
 265   2                      {
 266   3                              bUartRecFinished=0;
 267   3                              if(UartRecTreat("OK",(uint8)strlen("OK")))
 268   3                              {//收到第一步
 269   4                                      //GSM_STATE_LED = LED_OFF;
 270   4                                      //break;
 271   4                                      return 1;
 272   4                                      
 273   4                              }
 274   3                      }
 275   2                      Delayms(2000);
 276   2                      RePeat++;
 277   2                      goto RE_GSM_HUNDUP;
 278   2              }
 279   1              return 0;
 280   1      
 281   1      }
 282          
 283          
 284          
 285          
 286          
 287          
 288          
 289          
 290          
 291          
 292          
 293          
 294          
 295          
 296          
 297          
 298          
 299          
 300          
C51 COMPILER V8.08   GSM                                                                   09/25/2012 08:54:10 PAGE 6   

 301          
 302          
 303          
 304          
 305          
 306          
 307          
 308          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    909    ----
   CONSTANT SIZE    =    160    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      26
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
