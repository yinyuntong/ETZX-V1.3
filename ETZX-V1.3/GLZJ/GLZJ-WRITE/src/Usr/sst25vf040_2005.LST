C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 1   


C51 COMPILER V8.08, COMPILATION OF MODULE SST25VF040_2005
OBJECT MODULE PLACED IN sst25vf040_2005.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE sst25vf040_2005.C LARGE BROWSE DEBUG OBJECTEXTEND CODE LISTINCLUDE SYMBOLS

line level    source

   1          /*Software Driver
   2          
   3          SST25VF040B 4 Mbit(512K x 8) Serial Flash Memory
   4          
   5          November 4th, 2005, Rev. 1.0
   6          
   7          ABOUT THE SOFTWARE
   8          This application note provides software driver examples for SST25VF040B,
   9          Serial Flash. Extensive comments are included in each routine to describe 
  10          the function of each routine.  The interface coding uses polling method 
  11          rather than the SPI protocol to interface with these serial devices.  The
  12          functions are differentiated below in terms of the communication protocols
  13          (uses Mode 0) and specific device operation instructions. This code has been 
  14          designed to compile using the Keil compiler.
  15          
  16          
  17          ABOUT THE SST25VF040B
  18          
  19          Companion product datasheets for the SST25VF040B should be reviewed in 
  20          conjunction with this application note for a complete understanding 
  21          of the device.
  22          
  23          
  24          Device Communication Protocol(pinout related) functions:
  25          
  26          Functions                               Function
  27          ------------------------------------------------------------------
  28          init                                    Initializes clock to set up mode 0.
  29          Send_Byte                               Sends one byte using SI pin to send and 
  30                                                          shift out 1-bit per clock rising edge
  31          Get_Byte                                Receives one byte using SO pin to receive and shift 
  32                                                          in 1-bit per clock falling edge
  33          Poll_SO                                 Used in the polling for RY/BY# of SO during AAI programming
  34          CE_High                                 Sets Chip Enable pin of the serial flash to high
  35          CE_Low                                  Clears Chip Enable of the serial flash to low
  36          Hold_Low                                Clears Hold pin to make serial flash hold
  37          Unhold                                  Unholds the serial flash
  38          WP_Low                                  Clears WP pin to make serial flash write protected
  39          UnWP                                    Disables write protection pin
  40          
  41          Note:  The pin names of the SST25VF040B are used in this application note. The associated test code
  42          will not compile unless these pinouts (SCK, SI, SO, SO, CE, WP, Hold) are pre-defined on your
  43          software which should reflect your hardware interfaced.          
  44          
  45          
  46          Device Operation Instruction functions:
  47          
  48          Functions                               Function
  49          ------------------------------------------------------------------
  50          Read_Status_Register    Reads the status register of the serial flash
  51          EWSR                                    Enables the Write Status Register
  52          WRSR                                    Performs a write to the status register
  53          WREN                                    Write enables the serial flash
  54          WRDI                                    Write disables the serial flash
  55          EBSY                                    Enable SO to output RY/BY# status during AAI programming
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 2   

  56          DBSY                                    Disable SO to output RY/BY# status during AAI programming
  57          Read_ID                                 Reads the manufacturer ID and device ID
  58          Jedec_ID_Read                   Reads the Jedec ID
  59          Read                                    Reads one byte from the serial flash and returns byte(max of 25 MHz CLK frequency)
  60          Read_Cont                               Reads multiple bytes(max of 25 MHz CLK frequency)
  61          HighSpeed_Read                  Reads one byte from the serial flash and returns byte(max of 50 MHz CLK frequency)
  62          HighSpeed_Read_Cont             Reads multiple bytes(max of 50 MHz CLK frequency)
  63          Byte_Program                    Program one byte to the serial flash
  64          Auto_Add_IncA                   Initial Auto Address Increment process
  65          Auto_Add_IncB                   Successive Auto_Address_Increment process after AAI initiation
  66          Auto_Add_IncA_EBSY              Initial Auto Address Increment process with EBSY
  67          Auto_Add_IncB_EBSY              Successive Auto_Address_Increment process after AAI initiation with EBSY and WRDI/DBSY
  68          Chip_Erase                              Erases entire serial flash
  69          Sector_Erase                    Erases one sector (4 KB) of the serial flash
  70          Block_Erase_32K                 Erases 32 KByte block memory of the serial flash
  71          Block_Erase_64K                 Erases 64 KByte block memory of the serial flash
  72          Wait_Busy                               Polls status register until busy bit is low
  73          Wait_Busy_AAI                   Polls status register until busy bit is low for AAI programming
  74          WREN_Check                              Checks to see if WEL is set
  75          WREN_AAI_Check                  Checks to see if WEL and AAI mode is set
  76          
  77          */
  78          
  79                                                                               
  80          /*"C" LANGUAGE DRIVERS */
  81          
  82          /********************************************************************/
  83          /* Copyright Silicon Storage Technology, Inc. (SST), 1994-2005      */
  84          /* Example "C" language Driver of SST25VF040B Serial Flash                      */
  85          /* Conrado Canio, Silicon Storage Technology, Inc.                  */
  86          /*                                                                  */
  87          /* Revision 1.0, November 4th, 2005                                                                     */   
  88          /*                                                                  */
  89          /*                                                                                                                                      */
  90          /********************************************************************/
  91          
  92          #define _IN_SST25VF_
  93          #include "config.h"
   1      =1  /*
   2      =1  ************************Copyright(c)************************
   3      =1  *                                  ºþÄÏÎõÍú´ï¿Æ¼¼ÓÐÏÞ¹«Ë¾
   4      =1  *                               All Rights Reserved
   5      =1  *                                        
   6      =1  *
   7      =1  *-----------------------ÎÄ¼þÐÅÏ¢---------------------------
   8      =1  *ÎÄ¼þÃû³Æ               :config.h
   9      =1  *ÎÄ¼þÃèÊö               :ÅäÖÃÍ·ÎÄ¼þ
  10      =1  *´´½¨ÈË                 :³ÂÎÀ¹ú
  11      =1  *´´½¨ÈÕÆÚ               :2008-9-22
  12      =1  *°æ±¾ºÅ                 :V1.0
  13      =1  *×¢ÊÍ                   :                                       
  14      =1  *----------------------------------------------------------
  15      =1  *ÐÞ¸ÄÈË                         :
  16      =1  *ÐÞ¸ÄÈÕÆÚ                       :
  17      =1  *°æ±¾ºÅ                 :
  18      =1  *×¢ÊÍ                   :
  19      =1  ***********************************************************
  20      =1  */
  21      =1  //ÏµÍ³Í·ÎÄ¼þ
  22      =1  #pragma REGPARMS          
  23      =1  #include <intrins.h>
   1      =2  /*--------------------------------------------------------------------------
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 3   

   2      =2  INTRINS.H
   3      =2  
   4      =2  Intrinsic functions for C51.
   5      =2  Copyright (c) 1988-2004 Keil Elektronik GmbH and Keil Software, Inc.
   6      =2  All rights reserved.
   7      =2  --------------------------------------------------------------------------*/
   8      =2  
   9      =2  #ifndef __INTRINS_H__
  10      =2  #define __INTRINS_H__
  11      =2  
  12      =2  extern void          _nop_     (void);
  13      =2  extern bit           _testbit_ (bit);
  14      =2  extern unsigned char _cror_    (unsigned char, unsigned char);
  15      =2  extern unsigned int  _iror_    (unsigned int,  unsigned char);
  16      =2  extern unsigned long _lror_    (unsigned long, unsigned char);
  17      =2  extern unsigned char _crol_    (unsigned char, unsigned char);
  18      =2  extern unsigned int  _irol_    (unsigned int,  unsigned char);
  19      =2  extern unsigned long _lrol_    (unsigned long, unsigned char);
  20      =2  extern unsigned char _chkfloat_(float);
  21      =2  extern void          _push_    (unsigned char _sfr);
  22      =2  extern void          _pop_     (unsigned char _sfr);
  23      =2  
  24      =2  #endif
  25      =2  
  24      =1  #include <absacc.h>
   1      =2  /*--------------------------------------------------------------------------
   2      =2  ABSACC.H
   3      =2  
   4      =2  Direct access to 8051, extended 8051 and Philips 80C51MX memory areas.
   5      =2  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =2  All rights reserved.
   7      =2  --------------------------------------------------------------------------*/
   8      =2  
   9      =2  #ifndef __ABSACC_H__
  10      =2  #define __ABSACC_H__
  11      =2  
  12      =2  #define CBYTE ((unsigned char volatile code  *) 0)
  13      =2  #define DBYTE ((unsigned char volatile data  *) 0)
  14      =2  #define PBYTE ((unsigned char volatile pdata *) 0)
  15      =2  #define XBYTE ((unsigned char volatile xdata *) 0)
  16      =2  
  17      =2  #define CWORD ((unsigned int volatile code  *) 0)
  18      =2  #define DWORD ((unsigned int volatile data  *) 0)
  19      =2  #define PWORD ((unsigned int volatile pdata *) 0)
  20      =2  #define XWORD ((unsigned int volatile xdata *) 0)
  21      =2  
  22      =2  
  23      =2  #ifdef __CX51__
           =2 #define FVAR(object, addr)   (*((object volatile far *) (addr)))
           =2 #define FARRAY(object, base) ((object volatile far *) (base))
           =2 #define FCVAR(object, addr)   (*((object const far *) (addr)))
           =2 #define FCARRAY(object, base) ((object const far *) (base))
           =2 #else
  29      =2  #define FVAR(object, addr)    (*((object volatile far *) ((addr)+0x10000L)))
  30      =2  #define FCVAR(object, addr)   (*((object const far *) ((addr)+0x810000L)))
  31      =2  #define FARRAY(object, base)  ((object volatile far *) ((base)+0x10000L))
  32      =2  #define FCARRAY(object, base) ((object const far *) ((base)+0x810000L))
  33      =2  #endif
  34      =2  
  35      =2  #endif
  25      =1  #include <stdio.h>
   1      =2  /*--------------------------------------------------------------------------
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 4   

   2      =2  STDIO.H
   3      =2  
   4      =2  Prototypes for standard I/O functions.
   5      =2  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =2  All rights reserved.
   7      =2  --------------------------------------------------------------------------*/
   8      =2  
   9      =2  #ifndef __STDIO_H__
  10      =2  #define __STDIO_H__
  11      =2  
  12      =2  #ifndef EOF
  13      =2   #define EOF -1
  14      =2  #endif
  15      =2  
  16      =2  #ifndef NULL
  17      =2   #define NULL ((void *) 0)
  18      =2  #endif
  19      =2  
  20      =2  #ifndef _SIZE_T
  21      =2   #define _SIZE_T
  22      =2   typedef unsigned int size_t;
  23      =2  #endif
  24      =2  
  25      =2  #pragma SAVE
  26      =2  #pragma REGPARMS
  27      =2  extern char _getkey (void);
  28      =2  extern char getchar (void);
  29      =2  extern char ungetchar (char);
  30      =2  extern char putchar (char);
  31      =2  extern int printf   (const char *, ...);
  32      =2  extern int sprintf  (char *, const char *, ...);
  33      =2  extern int vprintf  (const char *, char *);
  34      =2  extern int vsprintf (char *, const char *, char *);
  35      =2  extern char *gets (char *, int n);
  36      =2  extern int scanf (const char *, ...);
  37      =2  extern int sscanf (char *, const char *, ...);
  38      =2  extern int puts (const char *);
  39      =2  
  40      =2  #pragma RESTORE
  41      =2  
  42      =2  #endif
  43      =2  
  26      =1  #include <string.h>
   1      =2  /*--------------------------------------------------------------------------
   2      =2  STRING.H
   3      =2  
   4      =2  String functions.
   5      =2  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =2  All rights reserved.
   7      =2  --------------------------------------------------------------------------*/
   8      =2  
   9      =2  #ifndef __STRING_H__
  10      =2  #define __STRING_H__
  11      =2  
  12      =2  #ifndef _SIZE_T
           =2  #define _SIZE_T
           =2  typedef unsigned int size_t;
           =2 #endif
  16      =2  
  17      =2  #ifndef NULL
           =2  #define NULL ((void *) 0L)
           =2 #endif
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 5   

  20      =2  
  21      =2  #pragma SAVE
  22      =2  #pragma REGPARMS
  23      =2  extern char *strcat (char *s1, char *s2);                               //×Ö·û´®Æ´½Óº¯Êý
  24      =2  extern char *strncat (char *s1, char *s2, int n);
  25      =2  
  26      =2  extern char strcmp (char *s1, char *s2);                                //´®±È½Ï        
  27      =2  extern char strncmp (char *s1, char *s2, int n);            // ½«Ò»¸ö´®ÖÐµÄÒ»²¿·ÖÓëÁíÒ»¸ö´®±È½Ï, ²»¹Ü´óÐ¡Ð´
  28      =2  
  29      =2  extern char *strcpy (char *s1, char *s2);                               //¿½±´Ò»¸ö×Ö·û´®µ½ÁíÒ»¸ö×Ö·û´®
  30      =2  extern char *strncpy (char *s1, char *s2, int n);
  31      =2  
  32      =2  extern int strlen (char *);
  33      =2  
  34      =2  extern char *strchr (const char *s, char c);            //ÔÚÒ»¸ö´®ÖÐ²éÕÒ¸ø¶¨×Ö·ûµÄµÚÒ»¸öÆ¥ÅäÖ®´¦
  35      =2  extern int strpos (const char *s, char c);
  36      =2  extern char *strrchr (const char *s, char c);           //              ÔÚ´®ÖÐ²éÕÒÖ¸¶¨×Ö·ûµÄ×îºóÒ»¸ö³öÏÖ
  37      =2  extern int strrpos (const char *s, char c);
  38      =2  
  39      =2  extern int strspn (char *s, char *set);                         //ÔÚ´®ÖÐ²éÕÒµÚÒ»¸ö¸ø¶¨×Ö·û¼¯ÄÚÈÝµÄ¶Î
  40      =2  extern int strcspn (char *s, char *set);
  41      =2  extern char *strpbrk (char *s, char *set);                              //ÔÚ´®ÖÐ²éÕÒ¸ø¶¨×Ö·û¼¯ÖÐµÄ×Ö·û
  42      =2  extern char *strrpbrk (char *s, char *set);
  43      =2  extern char *strstr  (char *s, char *sub);
  44      =2  extern char *strtok  (char *str, const char *set);                      //²éÕÒÓÉÔÚµÚ¶þ¸ö´®ÖÐÖ¸¶¨µÄ·Ö½ç·û·Ö¸ô¿ªµÄµ¥´Ê
  45      =2  
  46      =2  extern char memcmp (void *s1, void *s2, int n);
  47      =2  extern void *memcpy (void *s1, void *s2, int n);
  48      =2  extern void *memchr (void *s, char val, int n);
  49      =2  extern void *memccpy (void *s1, void *s2, char val, int n);
  50      =2  extern void *memmove (void *s1, void *s2, int n);
  51      =2  extern void *memset  (void *s, char val, int n);                //½«Ò»¸ö´®ÖÐµÄËùÓÐ×Ö·û¶¼ÉèÎªÖ¸¶¨×Ö·û
  52      =2  #pragma RESTORE
  53      =2  
  54      =2  #endif
  27      =1  #include <math.h> 
   1      =2  /*--------------------------------------------------------------------------
   2      =2  MATH.H
   3      =2  
   4      =2  Prototypes for mathematic functions.
   5      =2  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =2  All rights reserved.
   7      =2  --------------------------------------------------------------------------*/
   8      =2  
   9      =2  #ifndef __MATH_H__
  10      =2  #define __MATH_H__
  11      =2  
  12      =2  #pragma SAVE
  13      =2  #pragma REGPARMS
  14      =2  extern char  cabs  (char  val);
  15      =2  extern int    abs  (int   val);
  16      =2  extern long  labs  (long  val);
  17      =2  extern float fabs  (float val);
  18      =2  extern float sqrt  (float val);
  19      =2  extern float exp   (float val);
  20      =2  extern float log   (float val);
  21      =2  extern float log10 (float val);
  22      =2  extern float sin   (float val);
  23      =2  extern float cos   (float val);
  24      =2  extern float tan   (float val);
  25      =2  extern float asin  (float val);
  26      =2  extern float acos  (float val);
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 6   

  27      =2  extern float atan  (float val);
  28      =2  extern float sinh  (float val);
  29      =2  extern float cosh  (float val);
  30      =2  extern float tanh  (float val);
  31      =2  extern float atan2 (float y, float x);
  32      =2  
  33      =2  extern float ceil  (float val);
  34      =2  extern float floor (float val);
  35      =2  extern float modf  (float val, float *n);
  36      =2  extern float fmod  (float x, float y);
  37      =2  extern float pow   (float x, float y);
  38      =2  
  39      =2  #pragma RESTORE
  40      =2  
  41      =2  #endif
  28      =1  #include "STC12C56.H"
   1      =2  /*------------------------------------------------*/
   2      =2  /* --- ºê¾§¿Æ¼¼ STCMCU ---------------------------*/
   3      =2  /* --- Mobile: (86)13922805190 -------------------*/
   4      =2  /* --- Fax: 86-755-82944243 ----------------------*/
   5      =2  /* --- Tel: 86-755-82948412 ----------------------*/
   6      =2  /* --- Web: www.STCMCU.com -----------------------*/
   7      =2  /* ÊÊÓÃÓÚ: STC12C56xx    STC12LE56xx  ------------*/
   8      =2  /* ------- STC12C56xxAD  STC12LE56xxAD  ----------*/
   9      =2  /*------------------------------------------------*/
  10      =2  
  11      =2  #ifndef __STC12C56_H__
  12      =2  #define __STC12C56_H__
  13      =2  
  14      =2  //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -//////
  15      =2  
  16      =2  sfr  PSW        =   0xd0;       //³ÌÐò×´Ì¬×Ö            Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
  17      =2                                  //Î»ÃèÊö                CY      AC      F0      RS1     RS0     OV      F1
             -      P
  18      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
  19      =2  
  20      =2  sbit CY         =   PSW^7;      //½øÎ»±êÖ¾
  21      =2  sbit AC         =   PSW^6;      //¸¨Öú½øÎ»±êÖ¾
  22      =2  sbit F0         =   PSW^5;      //ÓÃ»§±êÖ¾
  23      =2  sbit RS1        =   PSW^4;      //¼Ä´æÆ÷×éÑ¡ÔñÎ»1
  24      =2  sbit RS0        =   PSW^3;      //¼Ä´æÆ÷×éÑ¡ÔñÎ»0
  25      =2  sbit OV         =   PSW^2;      //Òç³ö±êÖ¾
  26      =2  sbit P          =   PSW^0;      //ACCµÄÅ¼Ð£ÑéÎ»
  27      =2  
  28      =2  /////////////////////////////////
  29      =2  
  30      =2  sfr  ACC        =   0xe0;       //ÀÛ¼ÓÆ÷                Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
  31      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
  32      =2  
  33      =2  sbit ACC7       =   ACC^7;      //ÀÛ¼ÓÆ÷µÚ7Î»
  34      =2  sbit ACC6       =   ACC^6;      //ÀÛ¼ÓÆ÷µÚ6Î»
  35      =2  sbit ACC5       =   ACC^5;      //ÀÛ¼ÓÆ÷µÚ5Î»
  36      =2  sbit ACC4       =   ACC^4;      //ÀÛ¼ÓÆ÷µÚ4Î»
  37      =2  sbit ACC3       =   ACC^3;      //ÀÛ¼ÓÆ÷µÚ3Î»
  38      =2  sbit ACC2       =   ACC^2;      //ÀÛ¼ÓÆ÷µÚ2Î»
  39      =2  sbit ACC1       =   ACC^1;      //ÀÛ¼ÓÆ÷µÚ1Î»
  40      =2  sbit ACC0       =   ACC^0;      //ÀÛ¼ÓÆ÷µÚ0Î»
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 7   

  41      =2  
  42      =2  /////////////////////////////////
  43      =2  
  44      =2  sfr  B          =   0xf0;       //B¼Ä´æÆ÷               Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
  45      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
  46      =2  
  47      =2  /////////////////////////////////
  48      =2  
  49      =2  sfr  SP         =   0x81;       //¶ÑÕ»Ö¸Õë              Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
  50      =2                                  //³õÊ¼Öµ=0000,0111      0       0       0       0       0       1       1 
             -      1
  51      =2  
  52      =2  /////////////////////////////////
  53      =2  
  54      =2  sfr  DPL        =   0x82;       //Êý¾ÝÖ¸ÕëµÍ×Ö½Ú        Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
  55      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
  56      =2  
  57      =2  /////////////////////////////////
  58      =2  
  59      =2  sfr  DPH        =   0x83;       //Êý¾ÝÖ¸Õë¸ß×Ö½Ú        Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
  60      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
  61      =2  
  62      =2  //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -//////
  63      =2  
  64      =2  sfr  PCON       =   0x87;       //µçÔ´¿ØÖÆ¼Ä´æÆ÷        Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
  65      =2                                  //Î»ÃèÊö                SMOD    SMOD0   LVDF    POF     GF1     GF0     PD
             -      IDL
  66      =2                                  //³õÊ¼Öµ=0011,0000      0       0       1       1       0       0       0 
             -      0
  67      =2  
  68      =2  #define SMOD        0x80        //´®¿Ú²¨ÌØÂÊ±¶ËÙÎ»,ÖÃ1¿ÉÊ¹²¨ÌØÂÊ¿ì1±¶
  69      =2  #define SMOD0       0x40        //FE/SM0Ñ¡ÔñÎ»,0:SCON.7ÎªSM0 1:SCON.7ÎªFE
  70      =2  #define LVDF        0x20        //µÍÑ¹¼ì²âÖÐ¶ÏÇëÇóÎ»,ÓÉÓ²¼þÖÃ1,ÐèÓÉÈí¼þÇå0
  71      =2  #define POF         0x10        //ÉÏµç¸´Î»±êÖ¾Î»,ÉÏµçÊ±ÓÉÓ²¼þÖÃ1,ÐèÓÉÈí¼þÇå0
  72      =2  #define GF1         0x08        //Í¨ÓÃ±êÖ¾Î»1
  73      =2  #define GF0         0x04        //Í¨ÓÃ±êÖ¾Î»0
  74      =2  #define PD          0x02        //µôµç¿ØÖÆÎ»,Ð´1¿ÉÒÔÊ¹MCU½øÈëPowerDownÄ£Ê½
  75      =2  #define IDL         0x01        //¿ÕÏÐ¿ØÖÆÎ»,Ð´1¿ÉÒÔÊ¹MCU½øÈëIdleÄ£Ê½
  76      =2  
  77      =2  /////////////////////////////////
  78      =2  
  79      =2  sfr  WAKE_CLKO  =   0x8f;       //µôµç»½ÐÑ/Ê±ÖÓÊä³ö¿ØÖÆ Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
  80      =2                                  //Î»ÃèÊö          PCAWAKEUP RXDPINIE T1PINIE T0PINIE    -       -      T1V
             -LKO  T0CLKO
  81      =2                                  //³õÊ¼Öµ=0000,xx00      0       0       0       0       x       x       0 
             -      0
  82      =2  
  83      =2  #define PCAWAKEUP   0x80        //ÔÊÐíPCAµÄÉÏÉýÑØ/ÏÂ½µÑØÖÐ¶Ï»½ÐÑµôµçMCU
  84      =2  #define RXD_PIN_IE  0x40        //ÔÊÐíRXD(P3.0)ÏÂ½µÑØÖÃÎ»RIÖÐ¶ÏÊ±»½ÐÑµôµçMCU(±ØÐë´ò¿ªÏàÓ¦ÖÐ¶Ï)
  85      =2  #define T1_PIN_IE   0x20        //ÔÊÐíT1(P3.5)ÏÂ½µÑØÖÃÎ»T1ÖÐ¶ÏÊ±»½ÐÑµôµçMCU(±ØÐë´ò¿ªÏàÓ¦ÖÐ¶Ï)
  86      =2  #define T0_PIN_IE   0x10        //ÔÊÐíT0(P3.4)ÏÂ½µÑØÖÃÎ»T0ÖÐ¶ÏÊ±»½ÐÑµôµçMCU(±ØÐë´ò¿ªÏàÓ¦ÖÐ¶Ï)
  87      =2  #define T1CLKOEN    0x02        //´ò¿ªP3.5½ÅµÄ¶¨Ê±Æ÷1Ê±ÖÓÒç³öÂö³å,Êä³öµÄÊ±ÖÓÆµÂÊÎª1/2±¶µÄT1Òç³öÂÊ
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 8   

  88      =2  #define T0CLKOEN    0x01        //´ò¿ªP3.4½ÅµÄ¶¨Ê±Æ÷0Ê±ÖÓÒç³öÂö³å,Êä³öµÄÊ±ÖÓÆµÂÊÎª1/2±¶µÄT0Òç³öÂÊ
  89      =2  
  90      =2  /////////////////////////////////
  91      =2  
  92      =2  sfr  CLK_DIV    =   0xc7;       //Ê±ÖÓ·ÖÆµ¼Ä´æÆ÷        Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
  93      =2                                  //Î»ÃèÊö                -       -       -       -       -       CLKS2   CL
             -KS1   CLKS0
  94      =2                                  //³õÊ¼Öµ=xxxx,x000      x       x       x       x       x       0       0 
             -      0
  95      =2  
  96      =2  #define FOSCD1      0x00        //ÏµÍ³Ê±ÖÓÎªFosc
  97      =2  #define FOSCD2      0x01        //ÏµÍ³Ê±ÖÓÎªFosc/2
  98      =2  #define FOSCD4      0x02        //ÏµÍ³Ê±ÖÓÎªFosc/4
  99      =2  #define FOSCD8      0x03        //ÏµÍ³Ê±ÖÓÎªFosc/8
 100      =2  #define FOSCD16     0x04        //ÏµÍ³Ê±ÖÓÎªFosc/16
 101      =2  #define FOSCD32     0x05        //ÏµÍ³Ê±ÖÓÎªFosc/32
 102      =2  #define FOSCD64     0x06        //ÏµÍ³Ê±ÖÓÎªFosc/64
 103      =2  #define FOSCD128    0x07        //ÏµÍ³Ê±ÖÓÎªFosc/128
 104      =2  
 105      =2  /////////////////////////////////
 106      =2  
 107      =2  sfr  WDT_CONTR  =   0xe1;       //¿´ÃÅ¹·¶¨Ê±Æ÷¿ØÖÆÆ÷    Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 108      =2                                  //Î»ÃèÊö             WDT_FLAG   -       EN_WDT  CLR_WDT IDL_WDT PS2     PS
             -1     PS0
 109      =2                                  //³õÊ¼Öµ=0x00,0000      0       x       0       0       0       0       0 
             -      0
 110      =2  
 111      =2  #define WDT_FLAG    0x80        //¿´ÃÅ¹·¸´Î»±êÖ¾,µ±¿´ÃÅ¹·Òç³ö²úÉú¸´Î»ºó,Ó²¼þ×Ô¶¯ÖÃ1,ÐèÒªÓÉÈí¼þÇå0
 112      =2  #define EN_WDT      0x20        //Èí¼þÊ¹ÄÜ¿´ÃÅ¹·,´ò¿ªºó²»ÄÜÓÃÈí¼þµÄ·½Ê½¹Ø±Õ
 113      =2  #define CLR_WDT     0x10        //Çå¿´ÃÅ¹·¶¨Ê±Æ÷
 114      =2  #define IDLE_WDT    0x08        //IDLEÄ£Ê½ÏÂ,¿´ÃÅ¹·¶¨Ê±Æ÷ÊÇ·ñ¼ÌÐø¼ÆÊ±
 115      =2  
 116      =2  //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -//////
 117      =2  
 118      =2  sfr  AUXR       =   0x8e;       //¸¨Öú¼Ä´æÆ÷            Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 119      =2                                  //Î»ÃèÊö                T0x12   T1x12   UM0x6   EADCI   ESPI    ELVDI   - 
             -      -
 120      =2                                  //³õÊ¼Öµ=0000,00xx      0       0       0       0       0       0       x 
             -      x
 121      =2  
 122      =2  #define T0x12       0x80        //¶¨Ê±Æ÷0Ê±ÖÓ¿ØÖÆ,0:Fosc/12(´«Í³µÄ12·ÖÆµ) 1:Fosc/1(1TÄ£Ê½,²»·ÖÆµ,¼´12±¶ÓÚ´
             -«Í³ËÙ¶È)
 123      =2  #define T1x12       0x40        //¶¨Ê±Æ÷1Ê±ÖÓ¿ØÖÆ,0:Fosc/12(´«Í³µÄ12·ÖÆµ) 1:Fosc/1(1TÄ£Ê½,²»·ÖÆµ,¼´12±¶ÓÚ´
             -«Í³ËÙ¶È)
 124      =2  #define UR0x6       0x20        //´®¿ÚÄ£Ê½0µÄÊ±ÖÓ¿ØÖÆ,0:Fosc/12(´«Í³µÄ12·ÖÆµ) 1:Fosc/2(2·ÖÆµ,,¼´6±¶ÓÚ´«Í³Ë
             -Ù¶È)
 125      =2  #define EADCI       0x10        //Ê¹ÄÜADCÖÐ¶ÏÎ»
 126      =2  #define ESPI        0x08        //Ê¹ÄÜSPIÖÐ¶ÏÎ»
 127      =2  #define ELVDI       0x04        //Ê¹ÄÜLVDÖÐ¶ÏÎ»
 128      =2  
 129      =2  //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -//////
 130      =2  
 131      =2  sfr  P0         =   0x80;       //I/O¶Ë¿Ú0              Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 132      =2                                  //Î»ÃèÊö                -       -       -       -       P0.3    P0.2    P0
             -.1    P0.0
 133      =2                                  //³õÊ¼Öµ=xxxx,1111      x       x       x       x       1       1       1 
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 9   

             -      1
 134      =2  
 135      =2  sbit P03        =   P0^3;       //I/O¿ÚP0.3
 136      =2  sbit P02        =   P0^2;       //I/O¿ÚP0.2
 137      =2  sbit P01        =   P0^1;       //I/O¿ÚP0.1
 138      =2  sbit P00        =   P0^0;       //I/O¿ÚP0.0
 139      =2  
 140      =2  /////////////////////////////////
 141      =2  
 142      =2  sfr  P1         =   0x90;       //I/O¶Ë¿Ú0              Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 143      =2                                  //Î»ÃèÊö                P1.7    P1.6    P1.5    P1.4    P1.3    P1.2    P1
             -.1    P1.0
 144      =2                                  //³õÊ¼Öµ=1111,1111      1       1       1       1       1       1       1 
             -      1
 145      =2  
 146      =2  sbit P17        =   P1^7;       //I/O¿ÚP1.7
 147      =2  sbit P16        =   P1^6;       //I/O¿ÚP1.6
 148      =2  sbit P15        =   P1^5;       //I/O¿ÚP1.5
 149      =2  sbit P14        =   P1^4;       //I/O¿ÚP1.4
 150      =2  sbit P13        =   P1^3;       //I/O¿ÚP1.3
 151      =2  sbit P12        =   P1^2;       //I/O¿ÚP1.2
 152      =2  sbit P11        =   P1^1;       //I/O¿ÚP1.1
 153      =2  sbit P10        =   P1^0;       //I/O¿ÚP1.0
 154      =2  
 155      =2  sbit ADCIN7     =   P1^7;       //ADCÍ¨µÀ7µÄÄ£ÄâÐÅºÅÊäÈë½Å
 156      =2  sbit ADCIN6     =   P1^6;       //ADCÍ¨µÀ6µÄÄ£ÄâÐÅºÅÊäÈë½Å
 157      =2  sbit ADCIN5     =   P1^5;       //ADCÍ¨µÀ5µÄÄ£ÄâÐÅºÅÊäÈë½Å
 158      =2  sbit ADCIN4     =   P1^4;       //ADCÍ¨µÀ4µÄÄ£ÄâÐÅºÅÊäÈë½Å
 159      =2  sbit ADCIN3     =   P1^3;       //ADCÍ¨µÀ3µÄÄ£ÄâÐÅºÅÊäÈë½Å
 160      =2  sbit ADCIN2     =   P1^2;       //ADCÍ¨µÀ2µÄÄ£ÄâÐÅºÅÊäÈë½Å
 161      =2  sbit ADCIN1     =   P1^1;       //ADCÍ¨µÀ1µÄÄ£ÄâÐÅºÅÊäÈë½Å
 162      =2  sbit ADCIN0     =   P1^0;       //ADCÍ¨µÀ0µÄÄ£ÄâÐÅºÅÊäÈë½Å
 163      =2  
 164      =2  sbit SPISCLK    =   P1^7;       //SPI×ÜÏßµÄÊ±ÖÓ½Å
 165      =2  sbit SPIMISO    =   P1^6;       //SPI×ÜÏßµÄÖ÷³ö´ÓÈë½Å
 166      =2  sbit SPIMOSI    =   P1^5;       //SPI×ÜÏßµÄÖ÷Èë´Ó³ö½Å
 167      =2  sbit SPISS      =   P1^4;       //SPI×ÜÏßµÄ´Ó»úÑ¡Ôñ½Å
 168      =2  
 169      =2  sbit T1CLKO     =   P1^1;       //¶¨Ê±Æ÷1Ê±ÖÓÒç³öÂö³åÊä³ö½Å
 170      =2  sbit T0CLKO     =   P1^0;       //¶¨Ê±Æ÷0Ê±ÖÓÒç³öÂö³åÊä³ö½Å
 171      =2  
 172      =2  /////////////////////////////////
 173      =2  
 174      =2  sfr  P2         =   0xa0;       //I/O¶Ë¿Ú2              Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 175      =2                                  //Î»ÃèÊö                P2.7    P2.6    P2.5    P2.4    P2.3    P2.2    P2
             -.1    P2.0
 176      =2                                  //³õÊ¼Öµ=1111,1111      1       1       1       1       1       1       1 
             -      1
 177      =2  
 178      =2  sbit P27        =   P2^7;       //I/O¿ÚP2.7
 179      =2  sbit P26        =   P2^6;       //I/O¿ÚP2.6
 180      =2  sbit P25        =   P2^5;       //I/O¿ÚP2.5
 181      =2  sbit P24        =   P2^4;       //I/O¿ÚP2.4
 182      =2  sbit P23        =   P2^3;       //I/O¿ÚP2.3
 183      =2  sbit P22        =   P2^2;       //I/O¿ÚP2.2
 184      =2  sbit P21        =   P2^1;       //I/O¿ÚP2.1
 185      =2  sbit P20        =   P2^0;       //I/O¿ÚP2.0
 186      =2  
 187      =2  sbit CEX3       =   P2^4;       //±È½Ï/²¶»ñ/PWM3Íâ²¿Òý½Å
 188      =2  sbit CEX2       =   P2^0;       //±È½Ï/²¶»ñ/PWM2Íâ²¿Òý½Å
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 10  

 189      =2  
 190      =2  /////////////////////////////////
 191      =2  
 192      =2  sfr  P3         =   0xb0;       //I/O¶Ë¿Ú3              Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 193      =2                                  //Î»ÃèÊö                P3.7    -       P3.5    P3.4    P3.3    P3.2    P3
             -.1    P3.0
 194      =2                                  //³õÊ¼Öµ=1x11,1111      1       x       1       1       1       1       1 
             -      1
 195      =2  
 196      =2  sbit P37        =   P3^7;       //I/O¿ÚP3.7
 197      =2  sbit P35        =   P3^5;       //I/O¿ÚP3.5
 198      =2  sbit P34        =   P3^4;       //I/O¿ÚP3.4
 199      =2  sbit P33        =   P3^3;       //I/O¿ÚP3.3
 200      =2  sbit P32        =   P3^2;       //I/O¿ÚP3.2
 201      =2  sbit P31        =   P3^1;       //I/O¿ÚP3.1
 202      =2  sbit P30        =   P3^0;       //I/O¿ÚP3.0
 203      =2  
 204      =2  sbit RXD        =   P3^0;       //´®¿Ú1µÄÊý¾Ý½ÓÊÕ¿Ú
 205      =2  sbit TXD        =   P3^1;       //´®¿Ú1µÄÊý¾Ý·¢ËÍ¿Ú
 206      =2  sbit INT0       =   P3^2;       //Íâ²¿ÖÐ¶Ï0µÄÐÅºÅÊäÈë¿Ú
 207      =2  sbit INT1       =   P3^3;       //Íâ²¿ÖÐ¶Ï1µÄÐÅºÅÊä³ö¿Ú
 208      =2  sbit T0         =   P3^4;       //¶¨Ê±Æ÷0µÄÍâ²¿ÐÅºÅÊäÈë¿Ú
 209      =2  sbit T1         =   P3^5;       //¶¨Ê±Æ÷1µÄÍâ²¿ÐÅºÅÊäÈë¿Ú
 210      =2  
 211      =2  sbit CEX0       =   P3^7;       //±È½Ï/²¶»ñ/PWM0Íâ²¿Òý½Å
 212      =2  sbit CEX1       =   P3^5;       //±È½Ï/²¶»ñ/PWM1Íâ²¿Òý½Å
 213      =2  sbit ECI        =   P3^4;       //±È½Ï/²¶»ñ/PWMÄ£¿éµÄÍâ²¿Ê±ÖÓÊäÈë½Å(×î´óÖµÎªFosc/2)
 214      =2  
 215      =2  /////////////////////////////////
 216      =2  
 217      =2  sfr  P1M0       =   0x91;       //I/O¿Ú1Ä£Ê½¿ØÖÆÆ÷1     Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 218      =2                                  //³õ/Ê¼Öµ=0000,0000     0       0       0       0       0       0       0 
             -      0
 219      =2  
 220      =2  /////////////////////////////////
 221      =2  
 222      =2  sfr  P1M1       =   0x92;       //I/O¿Ú1Ä£Ê½¿ØÖÆÆ÷0     Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 223      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 224      =2  
 225      =2  /////////////////////////////////
 226      =2  
 227      =2  sfr  P0M0       =   0x93;       //I/O¿Ú0Ä£Ê½¿ØÖÆÆ÷1     Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 228      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 229      =2  
 230      =2  /////////////////////////////////
 231      =2  
 232      =2  sfr  P0M1       =   0x94;       //I/O¿Ú0Ä£Ê½¿ØÖÆÆ÷0     Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 233      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 234      =2  
 235      =2  /////////////////////////////////
 236      =2  
 237      =2  sfr  P2M0       =   0x95;       //I/O¿Ú2Ä£Ê½¿ØÖÆÆ÷1     Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 238      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 11  

             -      0
 239      =2  
 240      =2  /////////////////////////////////
 241      =2  
 242      =2  sfr  P2M1       =   0x96;       //I/O¿Ú2Ä£Ê½¿ØÖÆÆ÷0     Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 243      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 244      =2  
 245      =2  /////////////////////////////////
 246      =2  
 247      =2  sfr  P3M0       =   0xb1;       //I/O¿Ú3Ä£Ê½¿ØÖÆÆ÷1     Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 248      =2                                  //³õ/Ê¼Öµ=0000,0000     0       0       0       0       0       0       0 
             -      0
 249      =2  
 250      =2  /////////////////////////////////
 251      =2  
 252      =2  sfr  P3M1       =   0xb2;       //I/O¿Ú3Ä£Ê½¿ØÖÆÆ÷0     Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 253      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 254      =2  
 255      =2  /////////////////////////////////
 256      =2  
 257      =2  // PxM0 PxM1
 258      =2  //  0    0     ×¼Ë«Ïò¿Ú
 259      =2  //  0    1     Ç¿ÍÆÍìÊä³ö
 260      =2  //  1    0     ¸ß×èÊäÈëÌ¬
 261      =2  //  1    1     ¿ªÂ©Êä³ö
 262      =2  
 263      =2  //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -//////
 264      =2  
 265      =2  sfr  IE         =   0xa8;       //ÖÐ¶ÏÊ¹ÄÜ¼Ä´æÆ÷        Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 266      =2                                  //Î»ÃèÊö                EA   EPCA_LVD EADC_SPI  ES      ET1     EX1     ET
             -0     EX0
 267      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 268      =2  
 269      =2  sbit EA         =   IE^7;       //×ÜÖÐ¶Ï¿ª¹Ø
 270      =2  sbit EPCA_LVD   =   IE^6;       //PCAºÍLVD×ÜÖÐ¶ÏÊ¹ÄÜÎ»,Òª´ò¿ªPCA/LVDÖÐ¶Ï,»¹ÐèÒªÊ¹ÄÜCCAPMn.ECCFn/AUXR.ELVDI
 271      =2  sbit EADC_SPI   =   IE^5;       //ADCºÍSPI×ÜÖÐ¶ÏÊ¹ÄÜÎ»,Òª´ò¿ªADC/SPIÖÐ¶Ï,»¹ÐèÒªÊ¹ÄÜAUXR.EADCI/AUXR.ESPII
 272      =2  sbit ES         =   IE^4;       //´®¿ÚÖÐ¶ÏÊ¹ÄÜÎ»
 273      =2  sbit ET1        =   IE^3;       //¶¨Ê±Æ÷1ÖÐ¶ÏÊ¹ÄÜÎ»
 274      =2  sbit EX1        =   IE^2;       //Íâ²¿ÖÐ¶Ï1ÖÐ¶ÏÊ¹ÄÜÎ»
 275      =2  sbit ET0        =   IE^1;       //¶¨Ê±Æ÷0ÖÐ¶ÏÊ¹ÄÜÎ»
 276      =2  sbit EX0        =   IE^0;       //Íâ²¿ÖÐ¶Ï0ÖÐ¶ÏÊ¹ÄÜÎ»
 277      =2  
 278      =2  /////////////////////////////////
 279      =2  
 280      =2  #define X0_INTNO    0           //Íâ²¿ÖÐ¶Ï0ÖÐ¶ÏºÅ,Èë¿ÚµØÖ·Îª0003H
 281      =2  #define T0_INTNO    1           //¶¨Ê±Æ÷0ÖÐ¶ÏºÅ,Èë¿ÚµØÖ·Îª000BH
 282      =2  #define X1_INTNO    2           //Íâ²¿ÖÐ¶Ï1ÖÐ¶ÏºÅ,Èë¿ÚµØÖ·Îª0013H
 283      =2  #define T1_INTNO    3           //¶¨Ê±Æ÷1ÖÐ¶ÏºÅ,Èë¿ÚµØÖ·Îª001BH
 284      =2  #define UART_INTNO  4           //´®¿ÚÖÐ¶ÏºÅ,Èë¿ÚµØÖ·Îª0023H
 285      =2  #define ADC_SPI_INTNO   5       //SPI/ADCÖÐ¶ÏºÅ,Èë¿ÚµØÖ·Îª002BH
 286      =2  #define PCA_LVD_INTNO   6       //PCA/LVDÖÐ¶ÏºÅ,Èë¿ÚµØÖ·Îª0033H
 287      =2  
 288      =2  /////////////////////////////////
 289      =2  
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 12  

 290      =2  sfr  IPH        =   0xb7;       //ÖÐ¶ÏÓÅÏÈ¼¶¼Ä´æÆ÷¸ßÎ»  Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 291      =2                                  //Î»ÃèÊö                -    PCA_LVDH PADC_SPIH PSH     PT1H    PX1H    PT
             -0H    PX0H
 292      =2                                  //³õÊ¼Öµ=x000,0000      x       0       0       0       0       0       0 
             -      0
 293      =2  
 294      =2  #define PPCA_LVDH   0x40        //PCA/LVDÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆ¸ßÎ»
 295      =2  #define PADC_SPIH   0x20        //ADC/SPIÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆ¸ßÎ»
 296      =2  #define PSH         0x10        //´®¿ÚÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆ¸ßÎ»
 297      =2  #define PT1H        0x08        //¶¨Ê±Æ÷1ÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆ¸ßÎ»
 298      =2  #define PX1H        0x04        //Íâ²¿ÖÐ¶Ï1ÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆ¸ßÎ»
 299      =2  #define PT0H        0x02        //¶¨Ê±Æ÷0ÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆ¸ßÎ»
 300      =2  #define PX0H        0x01        //Íâ²¿ÖÐ¶Ï0ÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆ¸ßÎ»
 301      =2  
 302      =2  /////////////////////////////////
 303      =2  
 304      =2  sfr  IP         =   0xb8;       //ÖÐ¶ÏÓÅÏÈ¼¶¼Ä´æÆ÷      Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 305      =2                                  //Î»ÃèÊö                -    PPCA_LVD PADC_SPI  PS      PT1     PX1     PT
             -0     PX0
 306      =2                                  //³õÊ¼Öµ=x000,0000      x       0       0       0       0       0       0 
             -      0
 307      =2  
 308      =2  sbit PPCA_LVD   =   IP^6;       //PCA/LVDÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆµÍÎ»
 309      =2  sbit PADC_SPI   =   IP^5;       //ADC/SPIÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆµÍÎ»
 310      =2  sbit PS         =   IP^4;       //´®¿ÚÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆµÍÎ»
 311      =2  sbit PT1        =   IP^3;       //¶¨Ê±Æ÷1ÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆµÍÎ»
 312      =2  sbit PX1        =   IP^2;       //Íâ²¿ÖÐ¶Ï1ÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆµÍÎ»
 313      =2  sbit PT0        =   IP^1;       //¶¨Ê±Æ÷0ÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆµÍÎ»
 314      =2  sbit PX0        =   IP^0;       //Íâ²¿ÖÐ¶Ï0ÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆµÍÎ»
 315      =2  
 316      =2  //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -//////
 317      =2  
 318      =2  sfr  TCON       =   0x88;       //¶¨Ê±Æ÷0/1¿ØÖÆ¼Ä´æÆ÷   Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 319      =2                                  //Î»ÃèÊö                TF1     TR1     TF0     TR0     IE1     IT1     IE
             -0     IT0
 320      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 321      =2  
 322      =2  sbit TF1        = TCON^7;       //¶¨Ê±Æ÷1Òç³ö±êÖ¾,ÓÉÓ²¼þÖÃ1,¿ÉÓÉÈí¼þÇå0»òÕßÔÚÖÐ¶Ï´¦Àí³ÌÐòÍê³ÉºóÓÉÓ²¼þ×Ô¶¯Ç
             -å0
 323      =2  sbit TR1        = TCON^6;       //¶¨Ê±Æ÷1µÄÆô¶¯¿ØÖÆÎ»,1:Æô¶¯¶¨Ê±Æ÷ 0:Í£Ö¹¶¨Ê±Æ÷
 324      =2  sbit TF0        = TCON^5;       //¶¨Ê±Æ÷0Òç³ö±êÖ¾,ÓÉÓ²¼þÖÃ1,¿ÉÓÉÈí¼þÇå0»òÕßÔÚÖÐ¶Ï´¦Àí³ÌÐòÍê³ÉºóÓÉÓ²¼þ×Ô¶¯Ç
             -å0
 325      =2  sbit TR0        = TCON^4;       //¶¨Ê±Æ÷0µÄÆô¶¯¿ØÖÆÎ»,1:Æô¶¯¶¨Ê±Æ÷ 0:Í£Ö¹¶¨Ê±Æ÷
 326      =2  sbit IE1        = TCON^3;       //Íâ²¿ÖÐ¶Ï1µÄÖÐ¶ÏÇëÇóÎ»,ÓÉÓ²¼þÖÃ1,¿ÉÓÉÈí¼þÇå0»òÕßÔÚÖÐ¶Ï´¦Àí³ÌÐòÍê³ÉºóÓÉÓ²¼
             -þ×Ô¶¯Çå0
 327      =2  sbit IT1        = TCON^2;       //Íâ²¿ÖÐ¶Ï1µÄ´¥·¢ÀàÐÍ,0:µÍµçÆ½´¥·¢Íâ²¿ÖÐ¶Ï 1:ÏÂ½µÑØ´¥·¢Íâ²¿ÖÐ¶Ï
 328      =2  sbit IE0        = TCON^1;       //Íâ²¿ÖÐ¶Ï0µÄÖÐ¶ÏÇëÇóÎ»,ÓÉÓ²¼þÖÃ1,¿ÉÓÉÈí¼þÇå0»òÕßÔÚÖÐ¶Ï´¦Àí³ÌÐòÍê³ÉºóÓÉÓ²¼
             -þ×Ô¶¯Çå0
 329      =2  sbit IT0        = TCON^0;       //Íâ²¿ÖÐ¶Ï0µÄ´¥·¢ÀàÐÍ,0:µÍµçÆ½´¥·¢Íâ²¿ÖÐ¶Ï 1:ÏÂ½µÑØ´¥·¢Íâ²¿ÖÐ¶Ï
 330      =2  
 331      =2  /////////////////////////////////
 332      =2  
 333      =2  sfr  TMOD       =   0x89;       //¶¨Ê±Æ÷0/1Ä£Ê½¼Ä´æÆ÷   Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 334      =2                                  //Î»ÃèÊö                GATE    C/T#    M1      M0      GATE    C/T#    M1
             -      M0
 335      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 13  

             -      0
 336      =2  
 337      =2  #define GATE1       0x80        //¶¨Ê±Æ÷1Æô¶¯¿ØÖÆÎ»,0:TR1Îª1Ê±Æô¶¯¶¨Ê±Æ÷1 1:TR1Îª1ÇÒINT1Îª¸ßµçÆ½Ê±²ÅÆô¶¯¶¨
             -Ê±Æ÷1
 338      =2  #define C_T1        0x40        //¶¨Ê±Æ÷/¼ÆÊýÆ÷Ñ¡ÔñÎ»,0:¶¨Ê±Æ÷(Ê±ÖÓÔ´ÎªÄÚ²¿Ê±ÖÓ) 1:¼ÆÊýÆ÷(Ê±ÖÓÔ´ÎªT1Òý½ÅµÄ
             -Íâ²¿Ê±ÖÓ)
 339      =2  #define T1_M0       0x00        //¶¨Ê±Æ÷1²Ù×÷Ä£Ê½0:13Î»¶¨Ê±Æ÷
 340      =2  #define T1_M1       0x10        //¶¨Ê±Æ÷1²Ù×÷Ä£Ê½1:16Î»¶¨Ê±Æ÷
 341      =2  #define T1_M2       0x20        //¶¨Ê±Æ÷1²Ù×÷Ä£Ê½2:8Î»×Ô¶¯ÖØÔØ¶¨Ê±Æ÷
 342      =2  #define T1_M3       0x30        //¶¨Ê±Æ÷1²Ù×÷Ä£Ê½3:¶¨Ê±Æ÷1Í£Ö¹
 343      =2  #define GATE0       0x08        //¶¨Ê±Æ÷1Æô¶¯¿ØÖÆÎ»,0:TR0Îª1Ê±Æô¶¯¶¨Ê±Æ÷1 1:TR0Îª1ÇÒINT0Îª¸ßµçÆ½Ê±²ÅÆô¶¯¶¨
             -Ê±Æ÷0
 344      =2  #define C_T0        0x04        //¶¨Ê±Æ÷/¼ÆÊýÆ÷Ñ¡ÔñÎ»,0:¶¨Ê±Æ÷(Ê±ÖÓÔ´ÎªÄÚ²¿Ê±ÖÓ) 1:¼ÆÊýÆ÷(Ê±ÖÓÔ´ÎªT0Òý½ÅµÄ
             -Íâ²¿Ê±ÖÓ)
 345      =2  #define T0_M0       0x00        //¶¨Ê±Æ÷0²Ù×÷Ä£Ê½0:13Î»¶¨Ê±Æ÷
 346      =2  #define T0_M1       0x01        //¶¨Ê±Æ÷0²Ù×÷Ä£Ê½1:16Î»¶¨Ê±Æ÷
 347      =2  #define T0_M2       0x02        //¶¨Ê±Æ÷0²Ù×÷Ä£Ê½2:8Î»×Ô¶¯ÖØÔØ¶¨Ê±Æ÷
 348      =2  #define T0_M3       0x03        //¶¨Ê±Æ÷0²Ù×÷Ä£Ê½3:TL0ºÍTH0ÎªÁ½×é¶ÀÁ¢8Î»¶¨Ê±Æ÷
 349      =2  
 350      =2  /////////////////////////////////
 351      =2  
 352      =2  sfr  TL0        = 0x8a;         //¶¨Ê±Æ÷0µÄµÍ8Î»¼ÆÊýÖµ  Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 353      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 354      =2  
 355      =2  /////////////////////////////////
 356      =2  
 357      =2  sfr  TL1        = 0x8b;         //¶¨Ê±Æ÷1µÄµÍ8Î»¼ÆÊýÖµ  Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 358      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 359      =2  
 360      =2  /////////////////////////////////
 361      =2  
 362      =2  sfr  TH0        = 0x8c;         //¶¨Ê±Æ÷0µÄ¸ß8Î»¼ÆÊýÖµ  Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 363      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 364      =2  
 365      =2  /////////////////////////////////
 366      =2  
 367      =2  sfr  TH1        = 0x8d;         //¶¨Ê±Æ÷1µÄ¸ß8Î»¼ÆÊýÖµ  Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 368      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 369      =2  
 370      =2  //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -//////
 371      =2  
 372      =2  sfr  SCON       =   0x98;       //´®¿Ú¿ØÖÆ¼Ä´æÆ÷        Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 373      =2                                  //Î»ÃèÊö                SM0/FE  SM1     SM2     REN     TB8     RB8     TI
             -      Ri
 374      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 375      =2  
 376      =2  sbit FE         =   SCON^7;     //Ö¡´íÎó¼ì²âÎ»,µ±´®¿ÚÄ£¿éÔÚ½ÓÊÕÊý¾ÝÊ±Ã»ÓÐ¼ì²âµ½ÕýÈ·µÄÍ£Ö¹Î»Ê±,FE±»Ó²¼þÖÃ1,
             -ÐèÒªÓÉÈí¼þÀ´Çå0(µ±SMOD0Îª1Ê±,FEÓÐÐ§)
 377      =2  sbit SM0        =   SCON^7;     //´®¿ÚÄ£Ê½ÉèÖÃÎ»
 378      =2  sbit SM1        =   SCON^6;     //SM0/SM1=0/0:ÒÆÎ»¼Ä´æÆ÷ 0/1:8Î»¿É±ä²¨ÌØÂÊ 1/0:9Î»¹Ì¶¨²¨ÌØÂÊ 1/1:9Î»¿É±ä²¨
             -ÌØÂÊ
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 14  

 379      =2  sbit SM2        =   SCON^5;     //×Ô¶¯µØÖ·Ê¶±ðÊ¹ÄÜÎ»
 380      =2  sbit REN        =   SCON^4;     //Ê¹ÄÜ´®¿Ú½ÓÊÕÄ£¿é
 381      =2  sbit TB8        =   SCON^3;     //·¢ËÍµÄµÚ9Î»Êý¾Ý
 382      =2  sbit RB8        =   SCON^2;     //½ÓÊÕµÄµÚ9Î»Êý¾Ý
 383      =2  sbit TI         =   SCON^1;     //·¢ËÍÍê³ÉÖÐ¶Ï±êÖ¾
 384      =2  sbit RI         =   SCON^0;     //½ÓÊÕÍê³ÉÖÐ¶Ï±êÖ¾
 385      =2  
 386      =2  /////////////////////////////////
 387      =2  
 388      =2  sfr  SBUF       =   0x99;       //´®¿Ú½ÓÊÕ/·¢ËÍÊý¾Ý     Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 389      =2                                  //³õÊ¼Öµ=xxxx,xxxx      x       x       x       x       x       x       x 
             -      x
 390      =2  
 391      =2  /////////////////////////////////
 392      =2  
 393      =2  sfr  SADDR      =   0xa9;       //´®¿ÚÉè±¸´ÓµØÖ·¼Ä´æÆ÷  Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 394      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 395      =2  
 396      =2  /////////////////////////////////
 397      =2  
 398      =2  sfr  SADEN      =   0xb9;       //´®¿ÚÉè±¸´ÓµØÖ·ÆÁ±ÎÎ»  Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 399      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 400      =2  
 401      =2  //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -//////
 402      =2  
 403      =2  sfr  ADC_CONTR  =   0xc5;       //ADC¿ØÖÆ¼Ä´æÆ÷         Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 404      =2                                  //Î»ÃèÊö            ADC_POWER  SPEED1 SPEED0 ADC_FLAG ADC_START CHS2    CH
             -S1    CHS0
 405      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 406      =2  
 407      =2  #define ADC_POWER   0x80        //ADCÄ£¿éµçÔ´¿ØÖÆÎ»
 408      =2  #define ADC_SPEEDLL 0x00        //Ã¿´Î×ª»»ÐèÒª1080¸öÊ±ÖÓÖÜÆÚ
 409      =2  #define ADC_SPEEDL  0x20        //Ã¿´Î×ª»»ÐèÒª810¸öÊ±ÖÓÖÜÆÚ
 410      =2  #define ADC_SPEEDH  0x40        //Ã¿´Î×ª»»ÐèÒª540¸öÊ±ÖÓÖÜÆÚ
 411      =2  #define ADC_SPEEDHH 0x60        //Ã¿´Î×ª»»ÐèÒª270¸öÊ±ÖÓÖÜÆÚ
 412      =2  #define ADC_FLAG    0x10        //ADC×ª»»Íê³É±êÖ¾
 413      =2  #define ADC_START   0x08        //ADC¿ªÊ¼×ª»»¿ØÖÆÎ»
 414      =2  #define ADC_CHS2    0x04        //ADCÍ¨µÀÑ¡ÔñÎ»2
 415      =2  #define ADC_CHS1    0x02        //ADCÍ¨µÀÑ¡ÔñÎ»1
 416      =2  #define ADC_CHS0    0x01        //ADCÍ¨µÀÑ¡ÔñÎ»0
 417      =2  
 418      =2  /////////////////////////////////
 419      =2  
 420      =2  sfr  ADC_DATA   =   0xc6;       //ADC½á¹û¸ß×Ö½Ú         Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 421      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 422      =2  
 423      =2  /////////////////////////////////
 424      =2  
 425      =2  sfr  ADC_LOW2   =   0xbe;       //ADC½á¹ûµÍ×Ö½Ú         Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 426      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 15  

 427      =2  
 428      =2  //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -//////
 429      =2  
 430      =2  sfr  ISP_DATA   =   0xe2;       //ISPÊý¾Ý¼Ä´æÆ÷         Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 431      =2                                  //³õÊ¼Öµ=1111,1111      1       1       1       1       1       1       1 
             -      1
 432      =2  
 433      =2  /////////////////////////////////
 434      =2  
 435      =2  sfr  ISP_ADDRH  =   0xe3;       //ISPµØÖ·¸ßÎ»¼Ä´æÆ÷     Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 436      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 437      =2  
 438      =2  /////////////////////////////////
 439      =2  
 440      =2  sfr  ISP_ADDRL  =   0xe4;       //ISPµØÖ·µÍÎ»¼Ä´æÆ÷     Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 441      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 442      =2  
 443      =2  /////////////////////////////////
 444      =2  
 445      =2  sfr  ISP_CMD    =   0xe5;       //ISPÃüÁî¼Ä´æÆ÷         Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 446      =2                                  //³õÊ¼Öµ=xxxx,xx00      x       x       x       x       x       x       0 
             -      0
 447      =2  
 448      =2  #define ISP_IDLE    0x00        //ISP´ý»úÃüÁî
 449      =2  #define ISP_READ    0x01        //ISP¶Á×Ö½ÚÊý¾ÝÃüÁî
 450      =2  #define ISP_PROGRAM 0x02        //ISP×Ö½Ú±à³ÌÃüÁî
 451      =2  #define ISP_ERASE   0x03        //ISPÉÈÇø²Á³ýÃüÁî(Ã¿ÉÈÇø512×Ö½Ú))
 452      =2  
 453      =2  /////////////////////////////////
 454      =2  
 455      =2  sfr  ISP_TRIG   =   0xe6;       //ISPÃüÁî´¥·¢¼Ä´æÆ÷     Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 456      =2                                  //³õÊ¼Öµ=xxxx,xxxx      x       x       x       x       x       x       x 
             -      x
 457      =2  
 458      =2  #define ISP_TRIG0   0x46        //ISP¹¦ÄÜ´¥·¢ÃüÁî1
 459      =2  #define ISP_TRIG1   0xb9        //ISP¹¦ÄÜ´¥·¢ÃüÁî2
 460      =2  
 461      =2  /////////////////////////////////
 462      =2  
 463      =2  sfr  ISP_CONTR  =   0xe7;       //ISP¿ØÖÆ¼Ä´æÆ÷         Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 464      =2                                  //Î»ÃèÊö                ISPEN   SWBS    SWRST   CMD_FAIL -      WT2     WT
             -1     WT0
 465      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 466      =2  
 467      =2  #define ISPEN       0x80        //ISPÊ¹ÄÜ¿ª¹Ø
 468      =2  #define SWBS        0x40        //ÈíÆô¶¯Ñ¡Ôñ,0:´ÓÓÃ»§APÆô¶¯ 1:´ÓISPÆô¶¯
 469      =2  #define SWRST       0x20        //´¥·¢Èí¼þ¸´Î»
 470      =2  #define CMD_FAIL    0x10        //ISPÃüÁîÊ§°Ü±êÖ¾
 471      =2  
 472      =2  //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -//////
 473      =2  
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 16  

 474      =2  sfr  SPSTAT     =   0x84;       //SPI×´Ì¬¼Ä´æÆ÷         Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 475      =2                                  //Î»ÃèÊö                SPIF    WCOL    -       -       -       -       - 
             -      -
 476      =2                                  //³õÊ¼Öµ=11xx,xxxx      1       1       x       x       x       x       x 
             -      x
 477      =2  
 478      =2  #define SPIF        0x80        //SPI´«ÊäÍê³É±êÖ¾,µ±SPIÖÐ¶ÏÊ¹ÄÜÊ±»á´¥·¢SPIÖÐ¶ÏÇëÇó,ÐèÒªÓÃÈí¼þÏò´ËÎ»Ð´"1"À´
             -Çå0
 479      =2  #define WCOL        0x40        //SPIÐ´³åÍ»±êÖ¾,ÐèÒªÓÃÈí¼þÏò´ËÎ»Ð´"1"À´Çå0
 480      =2  
 481      =2  /////////////////////////////////
 482      =2  
 483      =2  sfr  SPCTL      =   0x85;       //SPI¿ØÖÆ¼Ä´æÆ÷         Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 484      =2                                  //Î»ÃèÊö                SSIG    SPEN    DORD    MSTR    CPOL    CPHA    SP
             -R1    SPR0
 485      =2                                  //³õÊ¼Öµ=0000,0100      0       0       0       0       0       1       0 
             -      0
 486      =2  
 487      =2  #define SSIG        0x80        //SSºöÂÔÎ»,1:ÓÉMSTRÈ·¶¨Ö÷/´Ó 0:ÓÉSS½ÅÈ·¶¨Ö÷/´Ó
 488      =2  #define SPEN        0x40        //SPIÄ£¿éÊ¹ÄÜÎ»
 489      =2  #define DORD        0x20        //SPIÊý¾ÝË³Ðò,1:LSB(ÏÈÊÕ/·¢×îµÍÎ») 0:MSB(ÏÈÊÕ/·¢×î¸ßÎ»)
 490      =2  #define MSTR        0x10        //Ö÷/´ÓÄ£Ê½Ñ¡ÔñÎ»
 491      =2  #define CPOL        0x08        //SPIÊ±ÖÓ¼«ÐÔ
 492      =2  #define CPHA        0x04        //SPIÏàÎ»Ñ¡Ôñ
 493      =2  #define SPSPEEDHH   0x00        //×î¿ìµÄËÙ¶È,CPU_CLK/4
 494      =2  #define SPSPEEDH    0x01        //×î¿ìµÄËÙ¶È,CPU_CLK/16
 495      =2  #define SPSPEEDL    0x02        //×î¿ìµÄËÙ¶È,CPU_CLK/64
 496      =2  #define SPSPEEDLL   0x03        //×î¿ìµÄËÙ¶È,CPU_CLK/128
 497      =2  
 498      =2  /////////////////////////////////
 499      =2  
 500      =2  sfr  SPDAT      =   0x86;       //SPIÊý¾Ý¼Ä´æÆ÷         Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 501      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 502      =2  
 503      =2  //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -//////
 504      =2  
 505      =2  sfr  CCON       =   0xd8;       //PCA¿ØÖÆ¼Ä´æÆ÷         Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 506      =2                                  //Î»ÃèÊö                CF      CR      -       -       CCF3    CCF2    CC
             -F1    CCF0
 507      =2                                  //³õÊ¼Öµ=00xx,0000      0       0       x       x       0       0       0 
             -      0
 508      =2  
 509      =2  sbit CF         =   CCON^7;     //PCA¼ÆÊýÆ÷Òç³ö±êÖ¾,µ±PCAÖÐ¶ÏÊ¹ÄÜÊ±»á´¥·¢PCAÖÐ¶ÏÇëÇó,ÐèÒªÓÃÈí¼þÇå0
 510      =2  sbit CR         =   CCON^6;     //PCA¼ÆÊýÆ÷Æô¶¯¿ØÖÆÎ»,Ð´"1"Æô¶¯¶«¼ÆÊýÆ÷
 511      =2  sbit CCF3       =   CCON^3;     //PCAÄ£¿é3ÖÐ¶Ï±êÖ¾,ÐèÒªÓÃÈí¼þÇå0
 512      =2  sbit CCF2       =   CCON^2;     //PCAÄ£¿é2ÖÐ¶Ï±êÖ¾,ÐèÒªÓÃÈí¼þÇå0
 513      =2  sbit CCF1       =   CCON^1;     //PCAÄ£¿é1ÖÐ¶Ï±êÖ¾,ÐèÒªÓÃÈí¼þÇå0
 514      =2  sbit CCF0       =   CCON^0;     //PCAÄ£¿é0ÖÐ¶Ï±êÖ¾,ÐèÒªÓÃÈí¼þÇå0
 515      =2  
 516      =2  /////////////////////////////////
 517      =2  
 518      =2  sfr  CMOD       =   0xd9;       //PCAÄ£Ê½¼Ä´æÆ÷         Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 519      =2                                  //Î»ÃèÊö                CIDL    -       -       -       CPS2    CPS1    CP
             -S0    ECF
 520      =2                                  //³õÊ¼Öµ=0xxx,0000      0       x       x       x       0       0       0 
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 17  

             -      0
 521      =2  
 522      =2  #define CIDL        0x80        //¼ÆÊ±Æ÷ÕóÁÐ¿ÕÏÐ¿ØÖÆ,0:¿ÕÏÐÄ£Ê½ÏÂPCA¼ÌÐø¹¤×÷ 1:¿ÕÏÐÄ£Ê½ÏÂPCAÍ£Ö¹¹¤×÷
 523      =2  #define PCACLK0     0x00        //Fosc/12
 524      =2  #define PCACLK1     0x02        //Fosc/2
 525      =2  #define PCACLK2     0x04        //¶¨Ê±Æ÷0µÄÒç³öÂÊ
 526      =2  #define PCACLK3     0x06        //ECIÍâ²¿Ê±ÖÓ
 527      =2  #define PCACLK4     0x08        //Fosc/1
 528      =2  #define PCACLK5     0x0a        //Fosc/4
 529      =2  #define PCACLK6     0x0c        //Fosc/6
 530      =2  #define PCACLK7     0x0e        //Fosc/8
 531      =2  #define ECF         0x01        //PCA¼ÆÊýÆ÷Òç³öÖÐ¶ÏÔÊÐíÎ»
 532      =2  
 533      =2  /////////////////////////////////
 534      =2  
 535      =2  sfr  CCAPM0     =   0xda;       //PCAÄ£¿é0Ä£Ê½¼Ä´æÆ÷    Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 536      =2                                  //Î»ÃèÊö                -       ECOM0   CAPP0   CAPN0   MAT0    TOG0    PW
             -M0    ECCF0
 537      =2                                  //³õÊ¼Öµ=x000,0000      x       0       0       0       0       0       0 
             -      0
 538      =2  
 539      =2  #define PCA0_ECOM   0x40        //Ê¹ÄÜ±È½ÏÆ÷0
 540      =2  #define PCA0_CAPP   0x20        //Ê¹ÄÜPCAÄ£¿é0µÄÉÏÉýÑØ²¶»ñ
 541      =2  #define PCA0_CAPN   0x10        //Ê¹ÄÜPCAÄ£¿é0µÄÏÂ½µÑØ²¶»ñ
 542      =2  #define PCA0_MAT    0x08        //Æ¥ÅäÊ¹ÄÜ,µ±PCAµÄ¼ÆÊýÖµÓëÄ£¿é0Éè¶¨µÄÖµÏàÆ¥ÅäÊ±,ÖÃCCON.CCF0
 543      =2  #define PCA0_TOG    0x04        //·­×ª¿ØÖÆÎ»,µ±PCAµÄ¼ÆÊýÖµÓëÄ£¿é0Éè¶¨µÄÖµÏàÆ¥ÅäÊ±,·­×ªCEX0µÄµçÆ½
 544      =2  #define PCA0_PWM    0x02        //Âö¿íµ÷ÖÆÄ£Ê½,Ê¹ÄÜCEX0ÎªÂö¿íµ÷ÖÆÊä³ö¿Ú
 545      =2  #define PCA0_ECCF   0x01        //Ê¹ÄÜCCF0ÖÐ¶Ï
 546      =2  
 547      =2  /////////////////////////////////
 548      =2  
 549      =2  sfr  CCAPM1     =   0xdb;       //PCAÄ£¿é1Ä£Ê½¼Ä´æÆ÷    Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 550      =2                                  //Î»ÃèÊö                -       ECOM1   CAPP1   CAPN1   MAT1    TOG1    PW
             -M1    ECCF1
 551      =2                                  //³õÊ¼Öµ=x000,0000      x       0       0       0       0       0       0 
             -      0
 552      =2  
 553      =2  #define PCA1_ECOM   0x40        //Ê¹ÄÜ±È½ÏÆ÷1
 554      =2  #define PCA1_CAPP   0x20        //Ê¹ÄÜPCAÄ£¿é1µÄÉÏÉýÑØ²¶»ñ
 555      =2  #define PCA1_CAPN   0x10        //Ê¹ÄÜPCAÄ£¿é1µÄÏÂ½µÑØ²¶»ñ
 556      =2  #define PCA1_MAT    0x08        //Æ¥ÅäÊ¹ÄÜ,µ±PCAµÄ¼ÆÊýÖµÓëÄ£¿é1Éè¶¨µÄÖµÏàÆ¥ÅäÊ±,ÖÃCCON.CCF1
 557      =2  #define PCA1_TOG    0x04        //·­×ª¿ØÖÆÎ»,µ±PCAµÄ¼ÆÊýÖµÓëÄ£¿é1Éè¶¨µÄÖµÏàÆ¥ÅäÊ±,·­×ªCEX1µÄµçÆ½
 558      =2  #define PCA1_PWM    0x02        //Âö¿íµ÷ÖÆÄ£Ê½,Ê¹ÄÜCEX1ÎªÂö¿íµ÷ÖÆÊä³ö¿Ú
 559      =2  #define PCA1_ECCF   0x01        //Ê¹ÄÜCCF1ÖÐ¶Ï
 560      =2  
 561      =2  /////////////////////////////////
 562      =2  
 563      =2  sfr  CCAPM2     =   0xdc;       //PCAÄ£¿é2Ä£Ê½¼Ä´æÆ÷    Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 564      =2                                  //Î»ÃèÊö                -       ECOM2   CAPP2   CAPN2   MAT2    TOG2    PW
             -M2    ECCF2
 565      =2                                  //³õÊ¼Öµ=x000,0000      x       0       0       0       0       0       0 
             -      0
 566      =2  
 567      =2  #define PCA2_ECOM   0x40        //Ê¹ÄÜ±È½ÏÆ÷2
 568      =2  #define PCA2_CAPP   0x20        //Ê¹ÄÜPCAÄ£¿é2µÄÉÏÉýÑØ²¶»ñ
 569      =2  #define PCA2_CAPN   0x10        //Ê¹ÄÜPCAÄ£¿é2µÄÏÂ½µÑØ²¶»ñ
 570      =2  #define PCA2_MAT    0x08        //Æ¥ÅäÊ¹ÄÜ,µ±PCAµÄ¼ÆÊýÖµÓëÄ£¿é2Éè¶¨µÄÖµÏàÆ¥ÅäÊ±,ÖÃCCON.CCF2
 571      =2  #define PCA2_TOG    0x04        //·­×ª¿ØÖÆÎ»,µ±PCAµÄ¼ÆÊýÖµÓëÄ£¿é2Éè¶¨µÄÖµÏàÆ¥ÅäÊ±,·­×ªCEX2µÄµçÆ½
 572      =2  #define PCA2_PWM    0x02        //Âö¿íµ÷ÖÆÄ£Ê½,Ê¹ÄÜCEX2ÎªÂö¿íµ÷ÖÆÊä³ö¿Ú
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 18  

 573      =2  #define PCA2_ECCF   0x01        //Ê¹ÄÜCCF2ÖÐ¶Ï
 574      =2  
 575      =2  /////////////////////////////////
 576      =2  
 577      =2  sfr  CCAPM3     =   0xdd;       //PCAÄ£¿é3Ä£Ê½¼Ä´æÆ÷    Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 578      =2                                  //Î»ÃèÊö                -       ECOM3   CAPP3   CAPN3   MAT3    TOG3    PW
             -M3    ECCF3
 579      =2                                  //³õÊ¼Öµ=x000,0000      x       0       0       0       0       0       0 
             -      0
 580      =2  
 581      =2  #define PCA3_ECOM   0x40        //Ê¹ÄÜ±È½ÏÆ÷3
 582      =2  #define PCA3_CAPP   0x20        //Ê¹ÄÜPCAÄ£¿é3µÄÉÏÉýÑØ²¶»ñ
 583      =2  #define PCA3_CAPN   0x10        //Ê¹ÄÜPCAÄ£¿é3µÄÏÂ½µÑØ²¶»ñ
 584      =2  #define PCA3_MAT    0x08        //Æ¥ÅäÊ¹ÄÜ,µ±PCAµÄ¼ÆÊýÖµÓëÄ£¿é3Éè¶¨µÄÖµÏàÆ¥ÅäÊ±,ÖÃCCON.CCF3
 585      =2  #define PCA3_TOG    0x04        //·­×ª¿ØÖÆÎ»,µ±PCAµÄ¼ÆÊýÖµÓëÄ£¿é3Éè¶¨µÄÖµÏàÆ¥ÅäÊ±,·­×ªCEX3µÄµçÆ½
 586      =2  #define PCA3_PWM    0x02        //Âö¿íµ÷ÖÆÄ£Ê½,Ê¹ÄÜCEX3ÎªÂö¿íµ÷ÖÆÊä³ö¿Ú
 587      =2  #define PCA3_ECCF   0x01        //Ê¹ÄÜCCF3ÖÐ¶Ï
 588      =2  
 589      =2  /////////////////////////////////
 590      =2  
 591      =2  //CCAPM0   -   ECOM CAPP CAPN MAT  TOG  PWM  CCF
 592      =2  // 00H     0    0    0    0    0    0    0    0     ÎÞ²Ù×÷,´ý»ú×´Ì¬
 593      =2  // 42H     0    1    0    0    0    0    1    0     8Î»PWMÊä³ö,ÎÞÖÐ¶Ï
 594      =2  // 63H     0    1    1    0    0    0    1    1     8Î»PWMÊä³ö,²úÉúCEX0ÉÏÉýÑØÖÐ¶Ï
 595      =2  // 53H     0    1    0    1    0    0    1    1     8Î»PWMÊä³ö,²úÉúCEX0ÏÂ½µÑØÖÐ¶Ï
 596      =2  // 73H     0    1    1    1    0    0    1    1     8Î»PWMÊä³ö,²úÉúCEX0Ìø±äÖÐ¶Ï
 597      =2  // 20H     0    x    1    0    0    0    0    0     16Î»²¶»ñÄ£Ê½,CEX0ÉÏÉýÑØ´¥·¢²¶»ñ
 598      =2  // 10H     0    x    0    1    0    0    0    0     16Î»²¶»ñÄ£Ê½,CEX0ÏÂ½µÑØ´¥·¢²¶»ñ
 599      =2  // 30H     0    x    1    1    0    0    0    0     16Î»²¶»ñÄ£Ê½,CEX0Ìø±ä´¥·¢²¶»ñ
 600      =2  // 48H     0    1    0    0    1    0    0    0     16Î»Èí¼þ¶¨Ê±Æ÷
 601      =2  // 4CH     0    1    0    0    1    1    0    0     16Î»¸ßËÙÂö³åÊä³ö
 602      =2  
 603      =2  /////////////////////////////////
 604      =2  
 605      =2  sfr  CL         =   0xe9;       //PCA¼ÆÊýÆ÷µÍ8Î»        Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 606      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 607      =2  
 608      =2  /////////////////////////////////
 609      =2  
 610      =2  sfr  CH         =   0xf9;       //PCA¼ÆÊýÆ÷¸ß8Î»        Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 611      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 612      =2  
 613      =2  /////////////////////////////////
 614      =2  
 615      =2  sfr  CCAP0L     =   0xea;       //PCAÄ£¿é0¼Ä´æÆ÷µÍ8Î»   Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 616      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 617      =2  
 618      =2  /////////////////////////////////
 619      =2  
 620      =2  sfr  CCAP1L     =   0xeb;       //PCAÄ£¿é1¼Ä´æÆ÷µÍ8Î»   Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 621      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 622      =2  
 623      =2  /////////////////////////////////
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 19  

 624      =2  
 625      =2  sfr  CCAP2L     =   0xec;       //PCAÄ£¿é2¼Ä´æÆ÷µÍ8Î»   Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 626      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 627      =2  
 628      =2  /////////////////////////////////
 629      =2  
 630      =2  sfr  CCAP3L     =   0xed;       //PCAÄ£¿é3¼Ä´æÆ÷µÍ8Î»   Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 631      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 632      =2  
 633      =2  /////////////////////////////////
 634      =2  
 635      =2  sfr  CCAP0H     =   0xfa;       //PCAÄ£¿é0¼Ä´æÆ÷¸ß8Î»   Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 636      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 637      =2  
 638      =2  /////////////////////////////////
 639      =2  
 640      =2  sfr  CCAP1H     =   0xfb;       //PCAÄ£¿é1¼Ä´æÆ÷¸ß8Î»   Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 641      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 642      =2  
 643      =2  /////////////////////////////////
 644      =2  
 645      =2  sfr  CCAP2H     =   0xfc;       //PCAÄ£¿é2¼Ä´æÆ÷¸ß8Î»   Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 646      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 647      =2  
 648      =2  /////////////////////////////////
 649      =2  
 650      =2  sfr  CCAP3H     =   0xfd;       //PCAÄ£¿é3¼Ä´æÆ÷¸ß8Î»   Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 651      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 652      =2  
 653      =2  /////////////////////////////////
 654      =2  
 655      =2  sfr  PCA_PWM0   =   0xf2;       //PCA0Ä£Ê½PWM¸¨Öú¼Ä´æÆ÷ Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 656      =2                                  //Î»ÃèÊö                -       -       -       -       -       -       EP
             -C0H   EPC0L
 657      =2                                  //³õÊ¼Öµ=xxxx,xx00      x       x       x       x       x       x       0 
             -      0
 658      =2  
 659      =2  /////////////////////////////////
 660      =2  
 661      =2  sfr  PCA_PWM1   =   0xf3;       //PCA1Ä£Ê½PWM¸¨Öú¼Ä´æÆ÷ Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 662      =2                                  //Î»ÃèÊö                -       -       -       -       -       -       EP
             -C1H   EPC1L
 663      =2                                  //³õÊ¼Öµ=xxxx,xx00      x       x       x       x       x       x       0 
             -      0
 664      =2  
 665      =2  /////////////////////////////////
 666      =2  
 667      =2  sfr  PCA_PWM2   =   0xf4;       //PCA2Ä£Ê½PWM¸¨Öú¼Ä´æÆ÷ Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 20  

             -t1    Bit0
 668      =2                                  //Î»ÃèÊö                -       -       -       -       -       -       EP
             -C2H   EPC2L
 669      =2                                  //³õÊ¼Öµ=xxxx,xx00      x       x       x       x       x       x       0 
             -      0
 670      =2  
 671      =2  /////////////////////////////////
 672      =2  
 673      =2  sfr  PCA_PWM3   =   0xf5;       //PCA3Ä£Ê½PWM¸¨Öú¼Ä´æÆ÷ Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 674      =2                                  //Î»ÃèÊö                -       -       -       -       -       -       EP
             -C3H   EPC3L
 675      =2                                  //³õÊ¼Öµ=xxxx,xx00      x       x       x       x       x       x       0 
             -      0
 676      =2  
 677      =2  //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -//////
 678      =2  
 679      =2  #endif
  29      =1  
  30      =1  #define const code 
  31      =1  #ifndef TRUE
  32      =1  #define TRUE  1
  33      =1  #endif 
  34      =1  #ifndef FALSE
  35      =1  #define FALSE 0
  36      =1  #endif
  37      =1  
  38      =1  
  39      =1  #define Bin(b7,b6,b5,b4,b3,b2,b1,b0)    ((b7<<7)|(b6<<6)|(b5<<5)|(b4<<4)|(b3<<3)|(b2<<2)|(b1<<1)|(b0<<0))
  40      =1  
  41      =1  //Ö÷Ïß³ÌÃüÁî
  42      =1  #define BUS0_REC                0x20                                                            //×ÜÏß0½ÓÊÕÍê³É
  43      =1  #define BUS0_SND                0x40                                                            //×ÜÏß0·¢ËÍÍê³É  
  44      =1  #define KEY_DOWN                0x60                                                            //°´¼ü°´ÏÂ
  45      =1  #define KEY_ALWAYS              0x70
  46      =1  #define KEY_UP                  0x80                                                            //°´¼üµ¯Æð
  47      =1  #define TIMER_OUT               0xa0                                                            //³¬Ê±ÃüÁî      
  48      =1  //°´¼ü¶¨Òå      
  49      =1  #define NO_KEY                  0xff                                                            //ÎÞ¼ü°´ÏÂ      
  50      =1  
  51      =1  sbit    MP3_DREQ        =       P3^2;
  52      =1  sbit    KEY_COPY        =       P3^5;
  53      =1  sbit    MP3_XDCS        =       P3^7;
  54      =1  
  55      =1  sbit    PRG_STATE       =       P1^0;
  56      =1  sbit    MP3_XRESET      =       P1^1;
  57      =1  sbit    MP3_XCS         =       P1^2;
  58      =1  sbit    TER_CS          =       P1^3;
  59      =1  sbit    SST25VF_CS              =       P1^4;
  60      =1  sbit    MOSI            =       P1^5;
  61      =1  sbit    MISO            =       P1^6;
  62      =1  sbit    SCLK            =       P1^7;
  63      =1  
  64      =1  
  65      =1  //°üº¬Í·ÎÄ¼þ
  66      =1  #include "OS_CFG.H"
   1      =2  /*********************************************************************************************************
   2      =2  **                                                             Small RTOS(51)
   3      =2  **                                   The Real-Time Kernel(For Keil c51)
   4      =2  **
   5      =2  **                                  (c) Copyright 2002-2002, chenmingji
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 21  

   6      =2  **                                           All Rights Reserved
   7      =2  **
   8      =2  **                                                  V1.20.0
   9      =2  **
  10      =2  **
  11      =2  **--------------ÎÄ¼þÐÅÏ¢--------------------------------------------------------------------------------
  12      =2  **ÎÄ   ¼þ   Ãû: OS_CFG.H
  13      =2  **´´   ½¨   ÈË: ³ÂÃ÷¼Æ
  14      =2  **×îºóÐÞ¸ÄÈÕÆÚ: 2002Äê12ÔÂ30ÈÕ
  15      =2  **Ãè¡¡      Êö: ex1µÄÏµÍ³ÅäÖÃÎÄ¼þ
  16      =2  **
  17      =2  **--------------ÀúÊ·°æ±¾ÐÅÏ¢----------------------------------------------------------------------------
  18      =2  ** ´´½¨ÈË: ³ÂÃ÷¼Æ
  19      =2  ** °æ  ±¾: V0.50
  20      =2  ** ÈÕ¡¡ÆÚ: 2002Äê2ÔÂ22ÈÕ
  21      =2  ** Ãè¡¡Êö: Ô­Ê¼°æ±¾
  22      =2  **
  23      =2  **------------------------------------------------------------------------------------------------------
  24      =2  ** ÐÞ¸ÄÈË: ³ÂÃ÷¼Æ
  25      =2  ** °æ  ±¾: V1.00
  26      =2  ** ÈÕ¡¡ÆÚ: 2002Äê6ÔÂ20ÈÕ
  27      =2  ** Ãè¡¡Êö: Ê¹ÓÃ»§¿ÉÒÔ½øÐÐ¸ü¶àµÄÅäÖÃ
  28      =2  **
  29      =2  **------------------------------------------------------------------------------------------------------
  30      =2  ** ÐÞ¸ÄÈË: ³ÂÃ÷¼Æ
  31      =2  ** °æ  ±¾: V1.10~1.12.1
  32      =2  ** ÈÕ¡¡ÆÚ: 2002Äê9ÔÂ1ÈÕ~2002Äê12ÔÂ2ÈÕ
  33      =2  ** Ãè¡¡Êö: ¸ù¾ÝÐÂ°æ±¾ÐèÒª¸ü¸ÄÒ»Ð©¶¨Òå
  34      =2  **
  35      =2  **------------------------------------------------------------------------------------------------------
  36      =2  ** ÐÞ¸ÄÈË: ³ÂÃ÷¼Æ
  37      =2  ** °æ  ±¾: V1.20.0
  38      =2  ** ÈÕ¡¡ÆÚ: 2003Äê8ÔÂ3ÈÕ
  39      =2  ** Ãè¡¡Êö: ¸ù¾ÝÐÂ°æ±¾ÐèÒªÔö¼ÓÅäÖÃOSWait_EN£»
  40      =2  **         ¼õÉÙÒ»Ð©¹ØÓÚÖÐ¶ÏÇ¶Ì×µÄÅäÖÃ
  41      =2  **
  42      =2  **--------------µ±Ç°°æ±¾ÐÞ¶©------------------------------------------------------------------------------
  43      =2  ** ÐÞ¸ÄÈË: 
  44      =2  ** ÈÕ¡¡ÆÚ:
  45      =2  ** Ãè¡¡Êö:
  46      =2  **
  47      =2  **------------------------------------------------------------------------------------------------------
  48      =2  ********************************************************************************************************/
  49      =2  
  50      =2  #define OS_MAX_TASKS            4           /* ×î´óÈÎÎñÊý1~16                                           */
  51      =2  #define OS_TICKS_PER_SEC        200         /* ÉùÃ÷1ÃëÏµÍ³ÏµÍ³½ÚÅÄÊý                                    */
  52      =2  #define EN_USER_TICK_TIMER      1           /* ½ûÖ¹(0)»òÔÊÐí(1)ÏµÍ³¶¨Ê±ÖÐ¶Ïµ÷ÓÃÓÃ»§º¯ÊýUserTickTimer()  */
  53      =2  #define EN_TIMER_SHARING        1           /* ½ûÖ¹(0)»òÔÊÐí(1)¶¨Ê±Æ÷ÖÐ¶Ïµ÷ÓÃOSTimeTick()               */
  54      =2  #define TICK_TIMER_SHARING      0           /* ¶¨Òå½øÈë¶àÉÙ´ÎÓ²¼þÖÐ¶ÏÎªÒ»´ÎÏµÍ³¶¨Ê±Æ÷ÈíÖÐ¶Ï             */
  55      =2  #define OSWait_EN               1           /* ½ûÖ¹(0)»òÔÊÐí(1)µ÷ÓÃ¼æÈÝº¯ÊýOSWait  */
  56      =2  
  57      =2  
  58      =2  #define EN_OS_Q                 1           /* ½ûÖ¹(0)»òÔÊÐí(1)ÏûÏ¢¶ÓÁÐ                                 */
  59      =2  #define EN_OS_Q_CHK             0           /* ½ûÖ¹(0)»òÔÊÐí(1)Ð£ÑéÏûÏ¢¶ÓÁÐÖ¸Õë                         */
  60      =2  #define OS_Q_MEM_SEL            idata       /* ÏûÏ¢¶ÓÁÐ´æ´¢¿Õ¼äÑ¡Ôñ£¬keil c51ÓÐÓÃ£¬±ØÐëÎªidata¡¢xdata   */
  61      =2                                              /* ²»ÊÇkeil c51Ê±Ëü±ØÐëÎª¿Õ¸ñ                               */
  62      =2  #define EN_OS_Q_PENT            1           /* ½ûÖ¹(0)»òÔÊÐí(1)µÈ´ý¶ÓÁÐÖÐµÄÏûÏ¢                         */
  63      =2  #define EN_OS_Q_ACCEPT          0           /* ½ûÖ¹(0)»òÔÊÐí(1)ÎÞµÈ´ýµÄ´Ó¶ÓÁÐÖÐÈ¡µÃÏûÏ¢                 */
  64      =2  #define EN_OS_Q_POST            1           /* ½ûÖ¹(0)»òÔÊÐí(1)FIFO·½Ê½Ïò¶ÔÁÐ·¢ËÍÏûÏ¢                   */
  65      =2  #define EN_OS_Q_POST_FRONT      0           /* ½ûÖ¹(0)»òÔÊÐí(1)LIFO·½Ê½Ïò¶ÔÁÐ·¢ËÍÏûÏ¢                   */
  66      =2  #define EN_OS_Q_NMsgs           0           /* ½ûÖ¹(0)»òÔÊÐí(1)È¡µÃ¶ÓÁÐÖÐÏûÏ¢Êý                         */
  67      =2  #define EN_OS_Q_SIZE            0           /* ½ûÖ¹(0)»òÔÊÐí(1)È¡µÃ¶ÓÁÐ×ÜÈÝÁ¿                           */
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 22  

  68      =2  #define EN_OS_Q_FLUSH           0           /* ½ûÖ¹(0)»òÔÊÐí(1)Çå¿Õ¶ÓÁÐ                                 */
  69      =2  
  70      =2  #define EN_OS_SEM               0           /* ½ûÖ¹(0)»òÔÊÐí(1)ÐÅºÅÁ¿                                   */
  71      =2  #define EN_OS_SEM_CHK           0           /* ½ûÖ¹(0)»òÔÊÐí(1)Ð£ÑéÐÅºÅÁ¿Ë÷Òý                           */
  72      =2  #define OS_SEM_MEM_SEL          idata       /* ÐÅºÅÁ¿´¢¿Õ¼äÑ¡Ôñ£¬keil c51ÓÐÓÃ£¬±ØÐëÎªidata¡¢xdata       */
  73      =2                                              /* ²»ÊÇkeil c51Ê±Ëü±ØÐëÎª¿Õ¸ñ                               */
  74      =2  #define OS_MAX_SEMS             0           /* ×î´óÐÅºÅÁ¿ÊýÄ¿                                           */
  75      =2  #define EN_OS_SEM_PENT          1           /* ½ûÖ¹(0)»òÔÊÐí(1)µÈ´ýÐÅºÅÁ¿                               */
  76      =2  #define EN_OS_SEM_ACCEPT        1           /* ½ûÖ¹(0)»òÔÊÐí(1)ÎÞµÈ´ýÇëÇóÐÅºÅÁ¿                         */
  77      =2  #define EN_OS_SEM_POST          1           /* ½ûÖ¹(0)»òÔÊÐí(1)ÖÐ·¢ËÍÐÅºÅÁ¿                             */
  78      =2  #define EN_OS_SEM_QUERY         1           /* ½ûÖ¹(0)»òÔÊÐí(1)²éÑ¯ÐÅºÅÁ¿                               */
  79      =2  
  80      =2  #define EN_OS_MEM               0           /* ½ûÖ¹(0)»òÔÊÐí(1)¶¯Ì¬ÄÚ´æ·ÖÅä                             */
  81      =2  #define EN_OS_MEM_FREE          0           /* ½ûÖ¹(0)»òÔÊÐí(1)ÊÍ·Å¶¯Ì¬·ÖÅäµÄÄÚ´æ                        *
             -/
  82      =2  #define EN_OS_MEM_CHK           1           /* ½ûÖ¹(0)»òÔÊÐí(1)ÄÚ´æ»ØÊÕÊ±ÑéÖ¤ÄÚ´æ¿éÊÇ·ñÓÐÐ§               
             -*/
  83      =2  #define EN_UserMemChkErr        0           /* ½ûÖ¹(0)»òÔÊÐí(1)ÄÚ´æ»ØÊÕÑéÖ¤³ö´íµ÷ÓÃÓÃ»§º¯ÊýUserMemChkErr  
             - */
  84      =2  
  85      =2  #if EN_TIMER_SHARING == 0
           =2 #define TIME_ISR_TASK_ID     COMM_TASK_ID   /* ¶¨ÒåÏµÍ³¶¨Ê±Æ÷ÈíÖÐ¶Ï´¥·¢µÄÈÎÎñID                         */
           =2 #endif
  88      =2  
  89      =2  #ifdef IN_OS_CPU_C 
           =2 #if EN_USER_TICK_TIMER > 0      
           =2 //extern void UserTickTimer(void);            /* ÏµÍ³¶¨Ê±ÖÐ¶ÏÖÐµ÷ÓÃµÄÓÃ»§º¯Êý                             
             -   
           =2 //#define UserTickTimer()       {uiIsrTimerCount+=ISR_INC_COUNT;CCAP0L = (uint8)uiIsrTimerCount;CCAP0H = (uint8
             -)(uiIsrTimerCount>>8);CCF0=0;WDT_CONTR = 0x3a;}   /* ÏµÍ³¶¨Ê±ÖÐ¶ÏÖÐµ÷ÓÃµÄÓÃ»§º¯                                                                */
           =2 
           =2 #endif
           =2 #endif
  96      =2  /*********************************************************************************************************
  97      =2  **                            End Of File
  98      =2  ********************************************************************************************************/
  67      =1  #include "OS_CPU.H"
   1      =2  /*********************************************************************************************************
   2      =2  **                                                             Small RTOS 51
   3      =2  **                                   The Real-Time Kernel For Keil c51
   4      =2  **
   5      =2  **                                  (c) Copyright 2002-2003, chenmingji
   6      =2  **                                           All Rights Reserved
   7      =2  **
   8      =2  **                                                  V1.20.0
   9      =2  **
  10      =2  **
  11      =2  **--------------ÎÄ¼þÐÅÏ¢--------------------------------------------------------------------------------
  12      =2  **ÎÄ   ¼þ   Ãû: OS_CPU.h
  13      =2  **´´   ½¨   ÈË: ³ÂÃ÷¼Æ
  14      =2  **×îºóÐÞ¸ÄÈÕÆÚ:  2003Äê8ÔÂ17ÈÕ
  15      =2  **Ãè¡¡      Êö: Small RTOS 51ÓëCPU(¼È8051ÏµÁÐ)Ïà¹ØµÄCÓïÑÔÍ·ÎÄ¼þ,¶¨ÒåÒ»Ð©ÓëCPUÏà¹ØµÄºê¡£
  16      =2  **
  17      =2  **--------------ÀúÊ·°æ±¾ÐÅÏ¢----------------------------------------------------------------------------
  18      =2  ** ´´½¨ÈË: ³ÂÃ÷¼Æ
  19      =2  ** °æ  ±¾: V0.50
  20      =2  ** ÈÕ¡¡ÆÚ: 2002Äê2ÔÂ22ÈÕ
  21      =2  ** Ãè¡¡Êö: Ô­Ê¼°æ±¾
  22      =2  **
  23      =2  **------------------------------------------------------------------------------------------------------
  24      =2  ** ÐÞ¸ÄÈË: ³ÂÃ÷¼Æ
  25      =2  ** °æ  ±¾: V1.00
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 23  

  26      =2  ** ÈÕ¡¡ÆÚ: 2002Äê6ÔÂ20ÈÕ
  27      =2  ** Ãè¡¡Êö: ÎÞ±ä»¯
  28      =2  **
  29      =2  **------------------------------------------------------------------------------------------------------
  30      =2  ** ÐÞ¸ÄÈË: ³ÂÃ÷¼Æ
  31      =2  ** °æ  ±¾: V1.10~1.12.1
  32      =2  ** ÈÕ¡¡ÆÚ: 2002Äê9ÔÂ1ÈÕ~2002Äê12ÔÂ2ÈÕ
  33      =2  ** Ãè¡¡Êö: ¸ù¾ÝÐÂ°æ±¾ÐèÒªÔö¼ÓÒ»Ð©ºê¶¨Òå
  34      =2  **
  35      =2  **------------------------------------------------------------------------------------------------------
  36      =2  ** ÐÞ¸ÄÈË: ³ÂÃ÷¼Æ
  37      =2  ** °æ  ±¾: V1.20.0
  38      =2  ** ÈÕ¡¡ÆÚ: 2003Äê8ÔÂ17ÈÕ
  39      =2  ** Ãè¡¡Êö: ¸ù¾ÝÐÂ°æ±¾ÐèÒªÔö¼ÓEN_REENTRANT
  40      =2  **
  41      =2  **--------------µ±Ç°°æ±¾ÐÞ¶©------------------------------------------------------------------------------
  42      =2  ** ÐÞ¸ÄÈË: 
  43      =2  ** ÈÕ¡¡ÆÚ:
  44      =2  ** Ãè¡¡Êö:
  45      =2  **
  46      =2  **------------------------------------------------------------------------------------------------------
  47      =2  ********************************************************************************************************/
  48      =2  #define EN_SP2        0                                         /* ½ûÖ¹(0)»òÔÊÐí(1)Èí·ÇÆÁ±ÎÖÐ¶Ï           
             -    */
  49      =2  #define EN_REENTRANT  0                                         /* ½ûÖ¹(0)»òÔÊÐí(1)¹ÜÀíÖØÈëÕ»             
             -    */
  50      =2  
  51      =2  #ifdef __C51__
  52      =2  
  53      =2  //#define idata                                   /* ·Çkeil c51Ê±±ØÐë¼ÓÖ¹ÕâÒ»¾ä                           
             -    */
  54      =2  //#define data                                    /* ·Çkeil c51Ê±±ØÐë¼ÓÖ¹ÕâÒ»¾ä                           
             -    */
  55      =2  //#define xdata                                   /* ·Çkeil c51Ê±±ØÐë¼ÓÖ¹ÕâÒ»¾ä                           
             -    */
  56      =2  //#define reentrant                               /* ·Çkeil c51Ê±±ØÐë¼ÓÖ¹ÕâÒ»¾ä                           
             -    */
  57      =2  //#define small                                   /* ·Çkeil c51Ê±±ØÐë¼ÓÖ¹ÕâÒ»¾ä                           
             -    */
  58      =2  //#define code                                    /* ·Çkeil c51Ê±±ØÐë¼ÓÖ¹ÕâÒ»¾ä                           
             -    */
  59      =2  
  60      =2  typedef unsigned char  uint8;                                   /* ¶¨Òå¿ÉÒÆÖ²µÄÎÞ·ûºÅ8Î»ÕûÊý¹Ø¼ü×Ö        
             -    */
  61      =2  typedef signed   char  int8;                                    /* ¶¨Òå¿ÉÒÆÖ²µÄÓÐ·ûºÅ8Î»ÕûÊý¹Ø¼ü×Ö        
             -    */
  62      =2  typedef unsigned int   uint16;                                  /* ¶¨Òå¿ÉÒÆÖ²µÄÎÞ·ûºÅ16Î»ÕûÊý¹Ø¼ü×Ö       
             -    */
  63      =2  typedef signed   int   int16;                                   /* ¶¨Òå¿ÉÒÆÖ²µÄÓÐ·ûºÅ16Î»ÕûÊý¹Ø¼ü×Ö       
             -    */
  64      =2  typedef unsigned long  uint32;                                  /* ¶¨Òå¿ÉÒÆÖ²µÄÎÞ·ûºÅ32Î»ÕûÊý¹Ø¼ü×Ö       
             -    */
  65      =2  typedef signed   long  int32;                                   /* ¶¨Òå¿ÉÒÆÖ²µÄÓÐ·ûºÅ32Î»ÕûÊý¹Ø¼ü×Ö       
             -    */
  66      =2  
  67      =2  extern void OSCPUInit(void) small;
  68      =2  extern void OSTaskStkInit(void (code * task)(void), void xdata *ptos, uint8 TaskID);
  69      =2  extern void OSTaskStkDel(uint8 TaskID) small;
  70      =2  
  71      =2  #ifndef NULL
           =2 #define NULL 0
           =2 #endif
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 24  

  74      =2  
  75      =2  #define  OS_INT_ENTER() OSIntNesting++, EA = 1
  76      =2  
  77      =2  #define  OS_ENTER_CRITICAL()  EA = 0,Os_Enter_Sum++             /* ½ûÖ¹ÖÐ¶Ï                                     */      
  78      =2  #define  OS_EXIT_CRITICAL()   if (--Os_Enter_Sum==0) EA = 1  /* ÔÊÐíÖÐ¶Ï                                        
             -*/         
  79      =2  
  80      =2  #define  HIGH_BYTE  0                                           /* uint16µÄ¸ßÎ»×Ö½Ú                       
             -       */
  81      =2  #define  LOW_BYTE   1                                           /* uint16µÄµÍÎ»×Ö½Ú                       
             -       */
  82      =2  
  83      =2  #define  OS_TASK_SW()         OSCtxSw()                         /* ÈÎÎñÇÐ»»º¯Êý                           
             -       */
  84      =2  
  85      =2  
  86      =2  #define  IDATA_RAM_SIZE  0x100                                  /* idata´óÐ¡                              
             -      */
  87      =2  
  88      =2  extern void OSCtxSw(void);
  89      =2  extern void OSIntCtxSw(void);
  90      =2  #ifndef IN_OS_CPU_C
  91      =2  extern void OSStartHighRdy(void)  small;
  92      =2  #endif
  93      =2  
  94      =2  #define  Sp2Space       8                                       /* ¸ß¼¶ÖÐ¶Ï£¨Èí·ÇÆÁ±ÎÖÐ¶Ï£©¶ÑÕ»´óÐ¡ EN_SP2
             -Îª0Ê±ÎÞÐ§*/
  95      =2  
  96      =2  #define OS_TIME_ISR     6                                       /* ÏµÍ³¶¨Ê±Æ÷Ê¹ÓÃµÄÖÐ¶Ï                   
             -      */
  97      =2  
  98      =2  #endif
  99      =2  
 100      =2  
 101      =2  
 102      =2  #ifndef __C51__   
           =2 SET_EA   MACRO
           =2              SETB     EA
           =2          ENDM
           =2          
           =2 #endif
 108      =2  
 109      =2  /*********************************************************************************************************
 110      =2  **                            End Of File
 111      =2  ********************************************************************************************************/
  68      =1  #include "..\os\OS.H"
   1      =2  /*********************************************************************************************************
   2      =2  **                                                             Small RTOS(51)
   3      =2  **                                   The Real-Time Kernel(For Keil c51)
   4      =2  **
   5      =2  **                                  (c) Copyright 2002-2003, chenmingji
   6      =2  **                                           All Rights Reserved
   7      =2  **
   8      =2  **                                                  V1.20.0
   9      =2  **
  10      =2  **
  11      =2  **--------------ÎÄ¼þÐÅÏ¢--------------------------------------------------------------------------------
  12      =2  **ÎÄ   ¼þ   Ãû: OS.h
  13      =2  **´´   ½¨   ÈË: ³ÂÃ÷¼Æ
  14      =2  **×îºóÐÞ¸ÄÈÕÆÚ:  2003Äê8ÔÂ17ÈÕ
  15      =2  **Ãè¡¡     Êö: Small RTOS(51) CÓïÑÔÍ·ÎÄ¼þ,¶¨ÒåÒ»Ð©ºêºÍÉùÃ÷Ò»Ð©º¯ÊýºÍ±äÁ¿
  16      =2  **
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 25  

  17      =2  **--------------ÀúÊ·°æ±¾ÐÅÏ¢----------------------------------------------------------------------------
  18      =2  ** ´´½¨ÈË: ³ÂÃ÷¼Æ
  19      =2  ** °æ  ±¾: V0.50~V1.00
  20      =2  ** ÈÕ¡¡ÆÚ: 2002Äê2ÔÂ22ÈÕ~2002Äê6ÔÂ20ÈÕ
  21      =2  ** Ãè¡¡Êö: »ù±¾Íê³ÉSmall RTOSºË
  22      =2  **
  23      =2  **------------------------------------------------------------------------------------------------------
  24      =2  ** ÐÞ¸ÄÈË: ³ÂÃ÷¼Æ
  25      =2  ** °æ  ±¾: V1.10~V1.21
  26      =2  ** ÈÕ¡¡ÆÚ: 2002Äê9ÔÂ1ÈÕ~2003Äê1ÔÂ23ÈÕ
  27      =2  ** Ãè¡¡Êö: ÍêÉÆSmall RTOS
  28      =2  **
  29      =2  **------------------------------------------------------------------------------------------------------
  30      =2  ** ÐÞ¸ÄÈË: ³ÂÃ÷¼Æ
  31      =2  ** °æ  ±¾: V1.20.0
  32      =2  ** ÈÕ¡¡ÆÚ: 2003Äê8ÔÂ17ÈÕ
  33      =2  ** Ãè¡¡Êö: Ôö¼ÓÖ§³ÖÈÎÎñ¶¯Ì¬½¨Á¢ºÍÉ¾³ý£¬º¯Êý¹¦ÄÜÏòÒ»°ãµÄRTOS¿¿Æë
  34      =2  **--------------µ±Ç°°æ±¾ÐÞ¶©------------------------------------------------------------------------------
  35      =2  ** ÐÞ¸ÄÈË: 
  36      =2  ** ÈÕ¡¡ÆÚ:
  37      =2  ** Ãè¡¡Êö:
  38      =2  **
  39      =2  **------------------------------------------------------------------------------------------------------
  40      =2  ********************************************************************************************************/
  41      =2  
  42      =2  #define  OS_VERSION    120                              /* ÏµÍ³°æ±¾ºÅ                                   */
  43      =2  
  44      =2  #define  OSVersion()     OS_VERSION                     /* ·µ»ØÏµÍ³°æ±¾                                 */
  45      =2  #define  OSRunningTaskID() OSTaskID                     /* ·µ»Øµ±Ç°ÈÎÎñID                               */
             - 
  46      =2  
  47      =2  #define K_SIG      1                                    /* µÈ´ýÐÅºÅ                                     */
  48      =2  #define K_TMO      2                                    /* µÈ´ý³¬Ê±                                     */
  49      =2  
  50      =2  #define NOT_OK     255                                  /* ²ÎÊý´íÎó                                     */
  51      =2  #define TMO_EVENT  8                                    /* ³¬Ê±µ½                                       */
  52      =2  #define SIG_EVENT  4                                    /* ÓÐÐÅºÅ                                       */
  53      =2  
  54      =2   
  55      =2  #ifndef IN_OS_CORE
  56      =2  
  57      =2  /* ¼æÈÝV1.21.1°æ±¾µÄºê */
  58      =2  #define OSSendSignal(a)     OSTaskResume((a))
  59      =2  #define OSIntSendSignal(a)  OSTaskResume((a))
  60      =2  #define OSClearSignal(a)    OS_TaskSuspend((a))
  61      =2  #define OSTaskCreate(a, b, c) _OSTaskCreate((c),(a),(b))
  62      =2  
  63      =2  
  64      =2  extern uint8 data OSWaitTick[];
  65      =2  extern uint8 code OSMapTbl[];
  66      =2  extern uint8 data Os_Enter_Sum;
  67      =2  extern uint8 data OSTaskID;
  68      =2  extern uint8 data OSNextTaskID;
  69      =2  extern uint8 data OSIntNesting;
  70      =2  
  71      =2  
  72      =2  extern void OSInit(void) small;
  73      =2  /*********************************************************************************************************
  74      =2  ** º¯ÊýÃû³Æ: OSInit
  75      =2  ** ¹¦ÄÜÃèÊö: ÏµÍ³±äÁ¿³õÊ¼»¯
  76      =2  ** Êä¡¡Èë: ÎÞ
  77      =2  ** Êä¡¡³ö: ÎÞ
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 26  

  78      =2  ** È«¾Ö±äÁ¿: 
  79      =2  ** µ÷ÓÃÄ£¿é: OSCPUInit
  80      =2  ********************************************************************************************************/
  81      =2  
  82      =2  extern void OSStart(void);
  83      =2  /*********************************************************************************************************
  84      =2  ** º¯ÊýÃû³Æ: OSStart
  85      =2  ** ¹¦ÄÜÃèÊö: Æô¶¯¶àÈÎÎñ»·¾³
  86      =2  ** Êä¡¡Èë: ÎÞ
  87      =2  ** Êä¡¡³ö : ÎÞ
  88      =2  ** È«¾Ö±äÁ¿: ÎÞ
  89      =2  ** µ÷ÓÃÄ£¿é: OSFindNextRunningTask,OSStartHighRdy
  90      =2  ********************************************************************************************************/
  91      =2  
  92      =2  extern uint8 _OSTaskCreate(uint8 TaskID, void (code * task)(void), void xdata *ptos) small;
  93      =2  /*********************************************************************************************************
  94      =2  ** º¯ÊýÃû³Æ: _OSTaskCreate
  95      =2  ** ¹¦ÄÜÃèÊö: ´´½¨ÈÎÎñ
  96      =2  ** Êä¡¡Èë: TaskID:ÈÎÎñID
  97      =2  **         task  :ÈÎÎñµØÖ·
  98      =2  **         ptos  :ÈÎÎñ¶ÑÕ»£¬ÔÚ51ÖÐÎªÖØÈëÕ»
  99      =2  ** Êä¡¡³ö: ÎÞ
 100      =2  ** È«¾Ö±äÁ¿: 
 101      =2  ** µ÷ÓÃÄ£¿é: ÎÞ
 102      =2  ********************************************************************************************************/
 103      =2  
 104      =2  extern uint8 OSTaskDel(uint8 TaskID) small;
 105      =2  /*********************************************************************************************************
 106      =2  ** º¯ÊýÃû³Æ: OSTaskDel
 107      =2  ** ¹¦ÄÜÃèÊö: ´´½¨ÈÎÎñ
 108      =2  ** Êä¡¡Èë: TaskID:ÈÎÎñID
 109      =2  ** Êä¡¡³ö: ÎÞ
 110      =2  ** È«¾Ö±äÁ¿: 
 111      =2  ** µ÷ÓÃÄ£¿é: ÎÞ
 112      =2  ********************************************************************************************************/
 113      =2         
 114      =2  extern void OSTaskResume(uint8 TaskID) small;
 115      =2  /*********************************************************************************************************
 116      =2  ** º¯ÊýÃû³Æ: OSTaskResume
 117      =2  ** ¹¦ÄÜÃèÊö: ÖÐ»Ö¸´ÈÎÎñ
 118      =2  ** Êä¡¡Èë: TaskID : ÈÎÎñID
 119      =2  ** Êä¡¡³ö: ÎÞ
 120      =2  ** È«¾Ö±äÁ¿: ÎÞ
 121      =2  ** µ÷ÓÃÄ£¿é: OSSched
 122      =2  ********************************************************************************************************/
 123      =2  
 124      =2  extern void OS_TaskSuspend(uint8 TaskID)    small;
 125      =2  /*********************************************************************************************************
 126      =2  ** º¯ÊýÃû³Æ: OS_TaskSuspend
 127      =2  ** ¹¦ÄÜÃèÊö: Ê¹Ö¸¶¨ÈÎÎñÐÝÃß£¬µ«²»½øÐÐÈÎÎñÇÐ»»
 128      =2  ** Êä¡¡Èë: TaskID : ÈÎÎñID
 129      =2  ** Êä¡¡³ö: ÎÞ
 130      =2  ** È«¾Ö±äÁ¿: OSWaitTick
 131      =2  ** µ÷ÓÃÄ£¿é: ÎÞ
 132      =2  **
 133      =2  ** ×÷¡¡Õß: ³ÂÃ÷¼Æ
 134      =2  ** ÈÕ¡¡ÆÚ: 2002Äê6ÔÂ20ÈÕ
 135      =2  **-------------------------------------------------------------------------------------------------------
 136      =2  ** ÐÞ¸ÄÈË:
 137      =2  ** ÈÕ¡¡ÆÚ:
 138      =2  **-------------------------------------------------------------------------------------------------------
 139      =2  ********************************************************************************************************/
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 27  

 140      =2  
 141      =2  extern void OSTaskSuspend(uint8 TaskID)    small;
 142      =2  /*********************************************************************************************************
 143      =2  ** º¯ÊýÃû³Æ: OSTaskSuspend
 144      =2  ** ¹¦ÄÜÃèÊö: Ê¹Ö¸¶¨ÈÎÎñÐÝÃß
 145      =2  ** Êä¡¡Èë: TaskID : ÈÎÎñID
 146      =2  ** Êä¡¡³ö: ÎÞ
 147      =2  ** È«¾Ö±äÁ¿: Îå
 148      =2  ** µ÷ÓÃÄ£¿é: OS_TaskSuspend
 149      =2  **
 150      =2  ** ×÷¡¡Õß: ³ÂÃ÷¼Æ
 151      =2  ** ÈÕ¡¡ÆÚ: 2002Äê6ÔÂ20ÈÕ
 152      =2  **-------------------------------------------------------------------------------------------------------
 153      =2  ** ÐÞ¸ÄÈË:
 154      =2  ** ÈÕ¡¡ÆÚ:
 155      =2  **-------------------------------------------------------------------------------------------------------
 156      =2  ********************************************************************************************************/
 157      =2  
 158      =2  extern void OSTimeDly(uint8 ticks)     small;
 159      =2  /*********************************************************************************************************
 160      =2  ** º¯ÊýÃû³Æ: OSTimeDly
 161      =2  ** ¹¦ÄÜÃèÊö: ÏµÍ³µÈ´ýº¯Êý,ÈÎÎñµ÷ÓÃ´Ëº¯Êý¿ÉÒÔµÈ´ýÒ»¶¨Ê±¼ä
 162      =2  ** Êä¡¡Èë:  ticks : µÈ´ý³¬Ê±Ê±µÄÏµÍ³àÖàªÊý
 163      =2  ** Êä¡¡³ö : ÎÞ
 164      =2  **
 165      =2  ** È«¾Ö±äÁ¿: OSWaitTick
 166      =2  ** µ÷ÓÃÄ£¿é: OSIntTaskResume,OSSched
 167      =2  ********************************************************************************************************/
 168      =2  
 169      =2  extern void OSTimeDlyResume(uint8 TaskID)    small;
 170      =2  /*********************************************************************************************************
 171      =2  ** º¯ÊýÃû³Æ: OSTimeDlyResume
 172      =2  ** ¹¦ÄÜÃèÊö: ÈÃ´¦ÔÚÑÓÊ±ÆÚµÄÈÎÎñ½áÊøÑÓÊ±
 173      =2  ** Êä¡¡Èë:  TaskID : ÈÎÎñID
 174      =2  ** Êä¡¡³ö : ÎÞ
 175      =2  ** È«¾Ö±äÁ¿: OSWaitTick
 176      =2  ** µ÷ÓÃÄ£¿é: OSTaskResume
 177      =2  ********************************************************************************************************/
 178      =2  
 179      =2  extern void  OSTimeTick (void)  small;
 180      =2  /*********************************************************************************************************
 181      =2  ** º¯ÊýÃû³Æ: OSTimeTick
 182      =2  ** ¹¦ÄÜÃèÊö: ÏµÍ³Ê±ÖÓ´¦Àíº¯Êý,´¦Àí¸÷¸öÈÎÎñµÄÑÓÊ±
 183      =2  ** Êä¡¡Èë: ÎÞ
 184      =2  ** Êä¡¡³ö: ÎÞ
 185      =2  ** È«¾Ö±äÁ¿: OSWaitTick
 186      =2  ** µ÷ÓÃÄ£¿é: OSIntSendSignal
 187      =2  ********************************************************************************************************/
 188      =2  
 189      =2  extern uint8 OSWait (uint8 typ, uint8 ticks)    small;
 190      =2  /*********************************************************************************************************
 191      =2  ** º¯ÊýÃû³Æ: OSWait
 192      =2  ** ¹¦ÄÜÃèÊö: ÏµÍ³µÈ´ýº¯Êý,ÈÎÎñµ÷ÓÃ´Ëº¯Êý¿ÉÒÔµÈ´ýÒ»¶¨Ê±¼ä»òÐÅºÅ
 193      =2  ** Êä¡¡Èë: typ: µÈ´ýÊÂ¼þÀàÐÍ,Ä¿Ç°¿ÉÒÔÈ¡ÒÔÏÂÖµ,»òÊÇÆäÖÐÈÎÒâ¸öÖµµÄ°´Î»»ò
 194      =2  **             K_SIG: µÈ´ýÐÅºÅ
 195      =2  **             K_TMO: µÈ´ý³¬Ê±
 196      =2  **        ticks : µÈ´ý³¬Ê±Ê±µÄÏµÍ³àÖàªÊý
 197      =2  ** Êä¡¡³ö : NOT_OK : ²ÎÊý´íÎó
 198      =2  **         TMO_EVENT : ³¬Ê±µ½
 199      =2  **         SIG_EVENT : ÓÐÐÅºÅ
 200      =2  ** È«¾Ö±äÁ¿: OSWaitTick
 201      =2  ** µ÷ÓÃÄ£¿é: OSTaskSuspend,OSTimeDly,OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 28  

 202      =2  ********************************************************************************************************/
 203      =2  
 204      =2  extern uint8 OSIntExit (void)    small;
 205      =2  /*********************************************************************************************************
 206      =2  ** º¯ÊýÃû³Æ: OSIntExit
 207      =2  ** ¹¦ÄÜÃèÊö: ÖÐ¶ÏÍË³ö´¦Àíº¯Êý,ÔÚ´Ë½øÐÐÖÐ¶ÏºóµÄÈÎÎñÇÐ»»
 208      =2  ** Êä¡¡Èë: ÎÞ
 209      =2  ** Êä¡¡³ö: 0:ÎÞÐèÈÎÎñÇÐ»»
 210      =2  **         1:ÐèÒªÈÎÎñÇÐ»»
 211      =2  ** È«¾Ö±äÁ¿: OSIntNesting,OSNextTaskID
 212      =2  ** µ÷ÓÃÄ£¿é: OSIntCtxSw
 213      =2  ********************************************************************************************************/
 214      =2  
 215      =2  extern void OSSched (void)  small;
 216      =2  /*********************************************************************************************************
 217      =2  ** º¯ÊýÃû³Æ: OSSched
 218      =2  ** ¹¦ÄÜÃèÊö: ·ÇÖÐ¶ÏµÄÈÎÎñÇÐ»»º¯Êý
 219      =2  ** Êä¡¡Èë: ÎÞ
 220      =2  ** Êä¡¡³ö: ÎÞ
 221      =2  ** È«¾Ö±äÁ¿: OSIntNesting,OSNextTaskID
 222      =2  ** µ÷ÓÃÄ£¿é: OS_TASK_SW
 223      =2  ********************************************************************************************************/
 224      =2  
 225      =2  extern void OSFindNextRunningTask(void) small;
 226      =2  /*********************************************************************************************************
 227      =2  ** º¯ÊýÃû³Æ: OSFindNextRunningTask
 228      =2  ** ¹¦ÄÜÃèÊö: ²éÕÒÏÂÒ»¸öÓÅÏÈ¼¶×î¸ßµÄ¾ÍÐ÷ÈÎÎñ
 229      =2  ** Êä¡¡Èë: ÎÞ
 230      =2  ** Êä¡¡³ö: OSNextTaskID:´æ´¢²éÕÒ½á¹û
 231      =2  ** È«¾Ö±äÁ¿: OSTaskRuning,OSTaskCreated
 232      =2  ** µ÷ÓÃÄ£¿é: ÎÞ
 233      =2  **
 234      =2  ** ×÷¡¡Õß: ³ÂÃ÷¼Æ
 235      =2  ** ÈÕ¡¡ÆÚ: 2002Äê6ÔÂ20ÈÕ
 236      =2  **-------------------------------------------------------------------------------------------------------
 237      =2  ** ÐÞ¸ÄÈË:
 238      =2  ** ÈÕ¡¡ÆÚ:
 239      =2  **-------------------------------------------------------------------------------------------------------
 240      =2  ********************************************************************************************************/
 241      =2  #endif
 242      =2  
 243      =2  /*********************************************************************************************************
 244      =2  **                            End Of File
 245      =2  ********************************************************************************************************/
  69      =1  #include "..\os\OS_Q.h"
   1      =2  /*********************************************************************************************************
   2      =2  **                                                             Small RTOS(51)
   3      =2  **                                   The Real-Time Kernel(For Keil c51)
   4      =2  **
   5      =2  **                                  (c) Copyright 2002-2003, chenmingji
   6      =2  **                                           All Rights Reserved
   7      =2  **
   8      =2  **                                                  V1.20.0
   9      =2  **
  10      =2  **
  11      =2  **--------------ÎÄ¼þÐÅÏ¢--------------------------------------------------------------------------------
  12      =2  **ÎÄ   ¼þ   Ãû: OS_Q.h
  13      =2  **´´   ½¨   ÈË: ³ÂÃ÷¼Æ
  14      =2  **×îºóÐÞ¸ÄÈÕÆÚ:  2003Äê8ÔÂ3ÈÕ
  15      =2  ** Ãè¡¡Êö: Small RTOS(51)ÏûÏ¢¶ÓÁÐÍ·ÎÄ¼þ£¬¶¨ÒåÒ»Ð©ºêºÍÉùÃ÷Ò»Ð©º¯Êý
  16      =2  **
  17      =2  **--------------ÀúÊ·°æ±¾ÐÅÏ¢----------------------------------------------------------------------------
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 29  

  18      =2  ** ´´½¨ÈË: ³ÂÃ÷¼Æ
  19      =2  ** °æ  ±¾: V1.10~V1.12.0
  20      =2  ** ÈÕ¡¡ÆÚ: 2002Äê6ÔÂ20ÈÕ~2002Äê12ÔÂ30ÈÕ
  21      =2  ** Ãè¡¡Êö: ÍêÉÆÏûÏ¢¶ÓÁÐ´úÂë
  22      =2  **
  23      =2  **------------------------------------------------------------------------------------------------------
  24      =2  ** ÐÞ¸ÄÈË: ³ÂÃ÷¼Æ
  25      =2  ** °æ  ±¾: V1.20.0
  26      =2  ** ÈÕ¡¡ÆÚ: 2003Äê8ÔÂ3ÈÕ
  27      =2  ** Ãè¡¡Êö: É¾³ýOSInt*º¯Êý£¬¸ù¾ÝÐÂ°æ±¾ÒªÇó¸Ä±äÒ»Ð©´úÂë
  28      =2  **
  29      =2  **--------------µ±Ç°°æ±¾ÐÞ¶©-----------------------------------------------------------------------------
  30      =2  ** ÐÞ¸ÄÈË:
  31      =2  ** ÈÕ¡¡ÆÚ:
  32      =2  ** Ãè¡¡Êö:
  33      =2  **
  34      =2  **------------------------------------------------------------------------------------------------------
  35      =2  ********************************************************************************************************/
  36      =2  
  37      =2  
  38      =2  #ifndef NOT_OK
           =2 #define NOT_OK      255                                 /* ²ÎÊý´íÎó                                     */
           =2 #endif
  41      =2  
  42      =2  #define OS_Q_FULL   8                                   /* ¶ÓÁÐÂú                                       */
  43      =2  #define OS_Q_NOT_OK 4                                   /* ÎÞÏûÏ¢                                       */
  44      =2  #define OS_Q_TMO    2                                   /* ³¬Ê±µ½                                       */
  45      =2  #define OS_Q_OK     1                                   /* ²Ù×÷³É¹¦                                     */
  46      =2  
  47      =2  #ifndef IN_OS_Q
  48      =2  extern uint8 OSQCreate(uint8 OS_Q_MEM_SEL *Buf, uint8 SizeOfBuf);
  49      =2  /*********************************************************************************************************
  50      =2  ** º¯ÊýÃû³Æ: OSQCreate
  51      =2  ** ¹¦ÄÜÃèÊö: ³õÊ¼»¯ÏûÏ¢¶ÓÁÐ
  52      =2  ** Êä¡¡Èë: Buf:Îª¶ÓÁÐ·ÖÅäµÄ´æ´¢¿Õ¼äµØÖ·
  53      =2  **         SizeOfBuf:Îª¶ÓÁÐ·ÖÅäµÄ´æ´¢¿Õ¼ä´óÐ¡
  54      =2  ** Êä¡¡³ö: NOT_OK:²ÎÊý´íÎó
  55      =2  **         OS_Q_OK:³É¹¦
  56      =2  ** È«¾Ö±äÁ¿: ÎÞ
  57      =2  ** µ÷ÓÃÄ£¿é: ÎÞ
  58      =2  ********************************************************************************************************/
  59      =2  extern uint8 OSQPend(uint8 data *Ret, uint8 OS_Q_MEM_SEL *Buf, uint8 Tick);
  60      =2  /*********************************************************************************************************
  61      =2  ** º¯ÊýÃû³Æ: OSQPend
  62      =2  ** ¹¦ÄÜÃèÊö: µÈ´ýÏûÏ¢¶ÓÁÐÖÐµÄÏûÏ¢
  63      =2  ** Êä¡¡Èë: Ret:·µ»ØµÄÏûÏ¢
  64      =2  **         Buf:Ö¸Ïò¶ÓÁÐµÄÖ¸Õë
  65      =2  **         Tick:µÈ´ýÊ±¼ä
  66      =2  ** Êä¡¡³ö: NOT_OK:²ÎÊý´íÎó
  67      =2  **         OS_Q_OK:ÊÕµ½ÏûÏ¢
  68      =2  **         OS_Q_TMO:³¬Ê±µ½
  69      =2  **         OS_Q_NOT_OK:ÎÞÏûÏ¢
  70      =2  ** È«¾Ö±äÁ¿: ÎÞ
  71      =2  ** µ÷ÓÃÄ£¿é: OSRunningTaskID,OSClearSignal,OSSched,OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
  72      =2  ********************************************************************************************************/
  73      =2  extern uint8 OSQAccept(uint8 data *Ret, uint8 OS_Q_MEM_SEL *Buf);
  74      =2  /*********************************************************************************************************
  75      =2  ** º¯ÊýÃû³Æ: OSQAccept
  76      =2  ** ¹¦ÄÜÃèÊö: ÎÞµÈ´ý´ÓÏûÏ¢¶ÓÁÐÖÐÈ¡µÃÏûÏ¢
  77      =2  ** Êä¡¡Èë: Ret:·µ»ØµÄÏûÏ¢
  78      =2  **         Buf:Ö¸Ïò¶ÓÁÐµÄÖ¸Õë
  79      =2  ** Êä¡¡³ö: NOT_OK:²ÎÊý´íÎó
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 30  

  80      =2  **         OS_Q_OK:ÊÕµ½ÏûÏ¢
  81      =2  **         OS_Q_TMO:³¬Ê±µ½
  82      =2  **         OS_Q_NOT_OK:ÎÞÏûÏ¢
  83      =2  ** È«¾Ö±äÁ¿: ÎÞ
  84      =2  ** µ÷ÓÃÄ£¿é: OSClearSignal,OSSched,OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
  85      =2  ********************************************************************************************************/
  86      =2  extern uint8 OSQPost(uint8 OS_Q_MEM_SEL *Buf, uint8 Data);
  87      =2  /*********************************************************************************************************
  88      =2  ** º¯ÊýÃû³Æ: OSQPost
  89      =2  ** ¹¦ÄÜÃèÊö: FIFO·½Ê½·¢ËÍÏûÏ¢
  90      =2  ** Êä¡¡Èë: Buf:Ö¸Ïò¶ÓÁÐµÄÖ¸Õë
  91      =2  **         Data:ÏûÏ¢Êý¾Ý
  92      =2  ** Êä¡¡³ö: OS_Q_FULL:¶ÓÁÐÂú
  93      =2  **         OS_Q_OK:·¢ËÍ³É¹¦
  94      =2  ** È«¾Ö±äÁ¿: ÎÞ
  95      =2  ** µ÷ÓÃÄ£¿é: OSQIntPost,OSSched
  96      =2  ********************************************************************************************************/
  97      =2  extern uint8 OSQPostFront(uint8 OS_Q_MEM_SEL *Buf, uint8 Data);
  98      =2  /*********************************************************************************************************
  99      =2  ** º¯ÊýÃû³Æ: OSQPostFront
 100      =2  ** ¹¦ÄÜÃèÊö: LIFO·½Ê½·¢ËÍÏûÏ¢
 101      =2  ** Êä¡¡Èë: Buf:Ö¸Ïò¶ÓÁÐµÄÖ¸Õë
 102      =2  **         Data:ÏûÏ¢Êý¾Ý
 103      =2  ** Êä¡¡³ö: OS_Q_FULL:¶ÓÁÐÂú
 104      =2  **         OS_Q_OK:·¢ËÍ³É¹¦
 105      =2  ** È«¾Ö±äÁ¿: ÎÞ
 106      =2  ** µ÷ÓÃÄ£¿é: OSQIntPostFront,OSSched
 107      =2  ********************************************************************************************************/
 108      =2  /* ¼æÈÝV1.12.1µÄºê */
 109      =2  #define OSQIntPost(Buf, Data) OSQPost(Buf, Data)
 110      =2  #define OSQIntPostFront(Buf, Data) OSQPostFront(Buf, Data)
 111      =2  
 112      =2  extern uint8 OSQNMsgs(uint8 OS_Q_MEM_SEL *Buf);
 113      =2  /*********************************************************************************************************
 114      =2  ** º¯ÊýÃû³Æ: OSQNMsgs
 115      =2  ** ¹¦ÄÜÃèÊö: È¡µÃÏûÏ¢¶ÓÁÐÖÐÏûÏ¢Êý
 116      =2  ** Êä¡¡Èë: Buf:Ö¸Ïò¶ÓÁÐµÄÖ¸Õë
 117      =2  ** Êä¡¡³ö: ÏûÏ¢Êý
 118      =2  ** È«¾Ö±äÁ¿: ÎÞ
 119      =2  ** µ÷ÓÃÄ£¿é: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
 120      =2  ********************************************************************************************************/
 121      =2  extern uint8 OSQSize(uint8 OS_Q_MEM_SEL *Buf);
 122      =2  /*********************************************************************************************************
 123      =2  ** º¯ÊýÃû³Æ: OSQSize
 124      =2  ** ¹¦ÄÜÃèÊö: È¡µÃÏûÏ¢¶ÓÁÐ×ÜÈÝÁ¿
 125      =2  ** Êä¡¡Èë: Buf:Ö¸Ïò¶ÓÁÐµÄÖ¸Õë
 126      =2  ** Êä¡¡³ö: ÏûÏ¢¶ÓÁÐ×ÜÈÝÁ¿
 127      =2  ** È«¾Ö±äÁ¿: ÎÞ
 128      =2  ** µ÷ÓÃÄ£¿é: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
 129      =2  ********************************************************************************************************/
 130      =2  extern void OSQFlush (uint8 OS_Q_MEM_SEL *Buf);
 131      =2  /*********************************************************************************************************
 132      =2  ** º¯ÊýÃû³Æ: OSQFlush
 133      =2  ** ¹¦ÄÜÃèÊö: Çå¿Õ¶ÓÁÐ
 134      =2  ** Êä¡¡Èë: Buf:Ö¸Ïò¶ÓÁÐµÄÖ¸Õë
 135      =2  ** Êä¡¡³ö: ÎÞ
 136      =2  ** È«¾Ö±äÁ¿: ÎÞ
 137      =2  ** µ÷ÓÃÄ£¿é: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
 138      =2  **
 139      =2  ** ×÷¡¡Õß: ³ÂÃ÷¼Æ
 140      =2  ** ÈÕ¡¡ÆÚ: 2002Äê9ÔÂ1ÈÕ
 141      =2  **-------------------------------------------------------------------------------------------------------
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 31  

 142      =2  ** ÐÞ¸ÄÈË: ³ÂÃ÷¼Æ
 143      =2  ** ÈÕ¡¡ÆÚ: 2002Äê10ÔÂ26ÈÕ
 144      =2  **-------------------------------------------------------------------------------------------------------
 145      =2  ** ÐÞ¸ÄÈË:
 146      =2  ** ÈÕ¡¡ÆÚ:
 147      =2  **-------------------------------------------------------------------------------------------------------
 148      =2  ********************************************************************************************************/
 149      =2  #endif
 150      =2  /*********************************************************************************************************
 151      =2  **                            End Of File
 152      =2  ********************************************************************************************************/
  70      =1  #include "..\os\OS_SEM.h" 
   1      =2  /*********************************************************************************************************
   2      =2  **                                                             Small RTOS(51)
   3      =2  **                                   The Real-Time Kernel(For Keil c51)
   4      =2  **
   5      =2  **                                  (c) Copyright 2002-2003, chenmingji
   6      =2  **                                           All Rights Reserved
   7      =2  **
   8      =2  **                                                  V1.20.0
   9      =2  **
  10      =2  **
  11      =2  **--------------ÎÄ¼þÐÅÏ¢--------------------------------------------------------------------------------
  12      =2  **ÎÄ   ¼þ   Ãû: OS_sem.h
  13      =2  **´´   ½¨   ÈË: ³ÂÃ÷¼Æ
  14      =2  **×îºóÐÞ¸ÄÈÕÆÚ:  2002Äê12ÔÂ2ÈÕ
  15      =2  ** Ãè¡¡Êö: Small RTOS(51)ÐÅºÅÁ¿Í·ÎÄ¼þ£¬¶¨ÒåÒ»Ð©ºêºÍÉùÃ÷Ò»Ð©º¯Êý
  16      =2  **
  17      =2  **--------------ÀúÊ·°æ±¾ÐÅÏ¢----------------------------------------------------------------------------
  18      =2  ** ´´½¨ÈË: ³ÂÃ÷¼Æ
  19      =2  ** °æ  ±¾: V1.10~V1.12.0
  20      =2  ** ÈÕ¡¡ÆÚ: 2002Äê9ÔÂ1ÈÕ~2002Äê12ÔÂ30ÈÕ
  21      =2  ** Ãè¡¡Êö: ÍêÉÆÐÅºÅÁ¿´úÂë
  22      =2  **
  23      =2  **------------------------------------------------------------------------------------------------------
  24      =2  ** ÐÞ¸ÄÈË: ³ÂÃ÷¼Æ
  25      =2  ** °æ  ±¾: V1.20.0
  26      =2  ** ÈÕ¡¡ÆÚ: 2003Äê8ÔÂ3ÈÕ
  27      =2  ** Ãè¡¡Êö: É¾³ýOSInt*º¯Êý£¬¸ù¾ÝÐÂ°æ±¾ÒªÇó¸Ä±äÒ»Ð©´úÂë
  28      =2  **
  29      =2  **--------------µ±Ç°°æ±¾ÐÞ¶©-----------------------------------------------------------------------------
  30      =2  ** ÐÞ¸ÄÈË:
  31      =2  ** ÈÕ¡¡ÆÚ:
  32      =2  ** Ãè¡¡Êö:
  33      =2  **
  34      =2  **------------------------------------------------------------------------------------------------------
  35      =2  ********************************************************************************************************/
  36      =2  
  37      =2  
  38      =2  #ifndef NOT_OK
           =2 #define NOT_OK      255                                 /* ²ÎÊý´íÎó                                     */
           =2 #endif
  41      =2  
  42      =2  #define OS_SEM_NOT_OK 4                                 /* ÎÞÐÅºÅ                                       */
  43      =2  #define OS_SEM_TMO    2                                 /* ³¬Ê±µ½                                       */
  44      =2  #define OS_SEM_OK     1                                 /* ²Ù×÷³É¹¦                                     */
  45      =2  
  46      =2  #ifndef IN_OS_SEM
  47      =2  extern uint8 OSSemCreate(uint8 Index,uint8 Data);
  48      =2  /*********************************************************************************************************
  49      =2  ** º¯ÊýÃû³Æ: OSSemCreate
  50      =2  ** ¹¦ÄÜÃèÊö: ³õÊ¼»¯ÏûÏ¢¶ÓÁÐ
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 32  

  51      =2  ** Êä¡¡Èë: Index:ÐÅºÅÁ¿Ë÷Òý
  52      =2  **         data:ÐÅºÅÁ¿³õÊ¼Öµ
  53      =2  ** Êä¡¡³ö: NOT_OK:Ã»ÓÐÕâ¸öÐÅºÅÁ¿
  54      =2  **         OS_SEM_OK:³É¹¦
  55      =2  ** È«¾Ö±äÁ¿: ÎÞ
  56      =2  ** µ÷ÓÃÄ£¿é: ÎÞ
  57      =2  ********************************************************************************************************/
  58      =2  extern uint8 OSSemPend(uint8 Index, uint8 Tick);
  59      =2  /*********************************************************************************************************
  60      =2  ** º¯ÊýÃû³Æ: OSSemPend
  61      =2  ** ¹¦ÄÜÃèÊö: µÈ´ýÒ»¸öÐÅºÅÁ¿
  62      =2  ** Êä¡¡Èë: Index:ÐÅºÅÁ¿Ë÷Òý
  63      =2  **         Tick:µÈ´ýÊ±¼ä
  64      =2  ** Êä¡¡³ö: NOT_OK:²ÎÊý´íÎó
  65      =2  **         OS_SEM_OK:µÃµ½ÐÅºÅÁ¿
  66      =2  **         OS_SEM_TMO:³¬Ê±µ½
  67      =2  **         OS_SEM_NOT_OK:Ã»ÓÐµÃµ½ÐÅºÅÁ¿
  68      =2  ** È«¾Ö±äÁ¿: ÎÞ
  69      =2  ** µ÷ÓÃÄ£¿é: OSRunningTaskID,OSClearSignal,OSSched,OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
  70      =2  ********************************************************************************************************/
  71      =2  extern uint8 OSSemAccept(uint8 Index);
  72      =2  /*********************************************************************************************************
  73      =2  ** º¯ÊýÃû³Æ: OSSemAccept
  74      =2  ** ¹¦ÄÜÃèÊö: ÎÞµÈ´ýÇëÇóÐÅºÅÁ¿
  75      =2  ** Êä¡¡Èë: Index:ÐÅºÅÁ¿Ë÷Òý
  76      =2  ** Êä¡¡³ö: NOT_OK:²ÎÊý´íÎó
  77      =2  **         OS_SEM_OK:µÃµ½ÐÅºÅÁ¿
  78      =2  **         OS_SEM_TMO:³¬Ê±µ½
  79      =2  **         OS_SEM_NOT_OK:Ã»ÓÐµÃµ½ÐÅºÅÁ¿
  80      =2  ** È«¾Ö±äÁ¿: ÎÞ
  81      =2  ** µ÷ÓÃÄ£¿é: OSClearSignal,OSSched,OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
  82      =2  ********************************************************************************************************/
  83      =2  
  84      =2  #define OSSemIntPost(Index) OSSemPost(Index)
  85      =2  
  86      =2  extern uint8 OSSemPost(uint8 Index);
  87      =2  /*********************************************************************************************************
  88      =2  ** º¯ÊýÃû³Æ: OSSemPost
  89      =2  ** ¹¦ÄÜÃèÊö: ·¢ËÍÒ»¸öÐÅºÅÁ¿
  90      =2  ** Êä¡¡Èë: Index:ÐÅºÅÁ¿Ë÷Òý
  91      =2  ** Êä¡¡³ö: NOT_OK:²ÎÊý´íÎó
  92      =2  **         OS_SEM_OK:·¢ËÍ³É¹¦
  93      =2  ** È«¾Ö±äÁ¿: ÎÞ
  94      =2  ** µ÷ÓÃÄ£¿é: OSSemIntPost,OSSched
  95      =2  ********************************************************************************************************/
  96      =2  extern uint8 OSSemQuery(uint8 Index);
  97      =2  /*********************************************************************************************************
  98      =2  ** º¯ÊýÃû³Æ: OSSemQuery
  99      =2  ** ¹¦ÄÜÃèÊö: ²éÑ¯ÐÅºÅÁ¿
 100      =2  ** Êä¡¡Èë: Index:ÐÅºÅÁ¿Ë÷Òý
 101      =2  ** Êä¡¡³ö: ÐÅºÅÁ¿µÄÖµ
 102      =2  ** È«¾Ö±äÁ¿: ÎÞ
 103      =2  ** µ÷ÓÃÄ£¿é: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
 104      =2  ********************************************************************************************************/
 105      =2  #endif
 106      =2  /*********************************************************************************************************
 107      =2  **                            End Of File
 108      =2  ********************************************************************************************************/
  71      =1  #include "SingleBus.h"
   1      =2  /*
   2      =2  **********************************Copyright (c) ****************************
   3      =2  *                                                       cwg
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 33  

   4      =2  *                              All Rights Reserved
   5      =2  *                                       QQ:7084394
   6      =2  *
   7      =2  *---------------------------------File Info---------------------------------
   8      =2  *File Name              :SingleBus.h
   9      =2  *Descriptor             :µ¥×ÜÏßÍ·ÎÄ¼þ
  10      =2  *Create By              :³ÂÎÀ¹ú
  11      =2  *Create Date            :2008-8-8
  12      =2  *Version                :V1.0
  13      =2  *Note                   :
  14      =2  *
  15      =2  *---------------------------------------------------------------------------
  16      =2  *Modified By            :
  17      =2  *Modified Date          :
  18      =2  *Version                :
  19      =2  *Note                   :
  20      =2  *
  21      =2  ****************************************************************************
  22      =2  */
  23      =2  //×ÜÏß0ºê¶¨Òå
  24      =2  #define         BUS0_FREQ_SIZE          7
  25      =2  #define         BUS0_FREQ_SIZE_HI       (BUS0_FREQ_SIZE << 4)
  26      =2  #define         BUS0_TX_Q_ZISE          (BUS0_FREQ_SIZE*20 + 1)
  27      =2  #define         DisableBus0RecInt()     {EX1 = 0;} 
  28      =2  #define         EnableBus0RecInt()      {IE1 = 0;EX1 = 1;}
  29      =2  #define         BUS0_SEND_CON           0x3c
  30      =2  #define         BUS0_CAN_SEND           0x0c 
  31      =2  #define         BUS0_ON_REC                     0x03
  32      =2  #define         BUS0_REQ_SEND           0x28
  33      =2  #define         BUS0_SEND_FINISH        0x0c 
  34      =2  #define         BUS0_ON_WORK            0x23
  35      =2  //µ¥×ÜÏß×Ô¶¯ÖØÔØÊ±¼ä
  36      =2  //#define               TIMER0_COUNT            ((256-(Fbus*9375/12/1000000))) 
  37      =2  
  38      =2  //300us
  39      =2  //#define TIMER0_H  0xfe
  40      =2  //#define TIMER0_L  0x34
  41      =2  
  42      =2  //100uS
  43      =2  #define TIMER0_H  0xff
  44      =2  #define TIMER0_L  0x67
  45      =2  
  46      =2  
  47      =2  /*Êý¾ÝÖ¡¸ñÊ½
  48      =2  ×Ö½Ú1£º·¢ËÍ·½ÇøµØÖ·£¨Ò»¸ö×Ö½Ú£©
  49      =2  ×Ö½Ú2£º·¢ËÍ·½·¿µØÖ·£¨Ò»¸ö×Ö½Ú£©
  50      =2  ×Ö½Ú3£º·¢ËÍ·½´²µØÖ·£¨Ò»¸ö×Ö½Ú£©
  51      =2  ×Ö½Ú4£ºÃüÁî´úÂë£¨Ò»¸ö×Ö½Ú£©
  52      =2  ×Ö½Ú5£º½ÓÊÕ·½ÇøµØÖ·£¨Ò»¸ö×Ö½Ú£©
  53      =2  ×Ö½Ú6£º½ÓÊÕ·½·¿µØÖ·£¨Ò»¸ö×Ö½Ú£©
  54      =2  ×Ö½Ú7£º½ÓÊÕ·½´²µØÖ·£¨Ò»¸ö×Ö½Ú£©
  55      =2  ×¢:Êý¾ÝèåÔÚ²»Í¬µÄÃüÁîÖÐ¿ÉÄÜÓÐ²»Í¬º¬Òå
  56      =2  */
  57      =2  /*µ¥×ÜÏßÐ­Òé
  58      =2    ÃüÁî´úÂë:Ò»×Ö½Ú
  59      =2    Êý¾Ý´úÂë:6×Ö½Ú(¸ù¾ÝÃüÁîµÄ²»Í¬Êý¾Ý¸ñÊ½)
  60      =2  */
  61      =2  typedef struct
  62      =2  {
  63      =2          uint8 bySndSecAddr;                     /*Ö÷¶¯·¢ËÍ·½ÇøµØÖ·*/
  64      =2          uint8 bySndRoomAddr;            /*Ö÷¶¯·¢ËÍ·½·¿µØÖ·*/
  65      =2          uint8 bySndBedAddr;                     /*Ö÷¶¯·¢ËÍ·½´²µØÖ·*/
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 34  

  66      =2          uint8 byCmd;                            /*ÃüÁî*/
  67      =2          uint8 byRecSecAddr;                     /*½ÓÊÕ·½ÇøµØÖ·*/
  68      =2          uint8 byRecRoomAddr;            /*½ÓÊÕ·½·¿µØÖ·*/
  69      =2          uint8 byRecBedAddr;                     /*½ÓÊÕ·½´²µØÖ·*/        
  70      =2  } STBusFreq, *pSTBusFreq;       
  71      =2  /*************************ÃüÁî¶¨Òå**********************/
  72      =2  #define CMD_QUEST                               0x01    /*²éÑ¯ÃüÁî*/
  73      =2  #define CMD_ANSWER                              0x02    /*Ó¦´ðÃüÁî*/
  74      =2  #define CMD_LANDING                             0x03    /*µÇ¼ÇÃüÁî*/                    /*ºóÃæÁ½¸ö×Ö½ÚÎªÓÅÏÈ¼¶ºÍ0x00*/
  75      =2  #define CMD_ENTER                               0x04    /*È·ÈÏÃüÁî*/                    /*Ö»ÄÜÎªÖ÷»ú¶Ô´Ó»ú·¢ËÍ*/
  76      =2  /*****************************************************************/
  77      =2  #define CMD_COMM_CALL                   0x05    /*ÆÕÍ¨ºô½ÐÃüÁî*/                /*ºóÃæÁ½¸ö×Ö½ÚÎªÓÅÏÈ¼¶ºÍÖ÷·½×´Ì¬*/
  78      =2  #define CMD_INFUSION_CALL               0x06    /*ÊäÒººô½ÐÃüÁî*/
  79      =2  #define CMD_SERVICE_CALL                0x07    /*·þÎñºô½ÐÃüÁî*/
  80      =2  #define CMD_EMERGENCY_CALL              0x08    /*½ô¼±ºô½ÐÃüÁî*/
  81      =2  #define CMD_HELP_CALL                   0x09    /*ÇóÔ®ºô½ÐÃüÁî*/                /* ±ØÐëµÃµ½Ö÷»úµÄÈ·ÈÏÃüÁî*/
  82      =2  #define CMD_INSPECTOR_CALL              0x0a    /*²é·¿ºô½ÐÃüÁî*/                /* ±ØÐëµÃµ½Ö÷»úµÄÈ·ÈÏÃüÁî*/
  83      =2  /*****************************************************************/
  84      =2  #define CMD_COMM_ANSWER                 0x0b    /*ÆÕÍ¨Ó¦´ðÃüÁî*/                
  85      =2  #define CMD_INFUSION_ANSWER             0x0c    /*´¦ÀíÊäÒºÃüÁî*/
  86      =2  #define CMD_SERVICE_ANSWER              0x0d    /*´¦Àí·þÎñÃüÁî*/
  87      =2  #define CMD_EMERGENCY_ANSWER    0x0e    /*´¦Àí½ô¼±ÃüÁî*/
  88      =2  #define CMD_HELP_ANSWER                 0x0f    /*´¦ÀíÇóÔ®ÃüÁî*/
  89      =2  /*****************************************************************/
  90      =2  #define CMD_INFUSION_CLEAR              0x10    /*Çå³ýÊäÒºÃüÁî*/                /* ¶ÔÓ¦µÄÇå³ýÃüÁî*/
  91      =2  #define CMD_SERVICE_CLEAR               0x11    /*Çå³ý·þÎñÃüÁî*/
  92      =2  #define CMD_EMERGENCY_CLEAR             0x12    /*Çå³ý½ô¼±ÃüÁî*/
  93      =2  #define CMD_HELP_CLEAR                  0x13    /*Çå³ýÇóÔ®ÃüÁî*/
  94      =2  /*****************************************************************/
  95      =2  #define CMD_BROADCAST1                  0x14    /*1Àà¹ã²¥ºô½ÐÃüÁî*/
  96      =2  #define CMD_BROADCAST2                  0x15    /*2Àà¹ã²¥ºô½ÐÃüÁî*/
  97      =2  #define CMD_CALL_LISTEN                 0x16    /*½ÓÌýºô½ÐÃüÁî*/
  98      =2  #define CMD_PRIORITY_SET                0x17    /*ÓÅÏÈ¼¶Ö¸¶¨ÃüÁî*/              /*ÏµÍ³ÃüÁî£ºµÚÒ»¸ö×Ö½Ú¸ß3Î»ÎªÓÅÏÈ¼¶£¬½ÓÊÕ·½µØÖ·*/
  99      =2  #define CMD_SYSTERM_RESET               0x18    /*ÏµÍ³¸´Î»ÃüÁî*/
 100      =2  /*****************************************************************/
 101      =2  #define CMD_DATA_SEND                   0x19    /*ÈÕÆÚ·¢ËÍÃüÁî*/                /*Ç°Á½¸ö×Ö½Ú£¬Äê£º4Î»BCDÂë£¬ºóÃæÁ½¸ö×Ö½Ú£ºÔÂºÍÈÕÆÚ£º4Î»BCDÂ
             -ë*/
 102      =2  #define CMD_TIME_SEND                   0x1a    /*Ê±¼ä·¢ËÍÃüÁî*/
 103      =2  #define CMD_SCHEDULE_SEND               0x1b    /*Ò»ÀÀ±í·¢ËÍÃüÁî*/
 104      =2  #define CMD_NUMBER_SET                  0x1c    /*ÐÞ¸Ä±àºÅÃüÁî*/                /*ÐÂµÄµØÖ·ÔÚÇ°2¸ö×Ö½Ú£¬±»ÐÞ¸ÄµØÖ·ÔÚºóÁ½¸ö×Ö½Ú*/
 105      =2  #define CMD_LAMP_CONTROL                0x1d    /*µÆ¿ØÃüÁî*/
 106      =2  /*****************************************************************/
 107      =2  #define CMD_CONTROL_SEND                0x1e    /*¿ØÖÆ×Ö´«µÝÃüÁî*/
 108      =2  #define CMD_FLOOR_SET                   0x1f    /*ÐÞ¸ÄÂ¥²ãºÅÃüÁî*/
 109      =2  #define CMD_BROADCAST3                  0x20    /*3Àà¹ã²¥ºô½ÐÃüÁî*/
 110      =2  #define CMD_INFUSION_ENTER              0x21    /*È·ÈÏÊäÒºÃüÁî*/
 111      =2  #define CMD_SERVICE_ENTER               0x22    /*È·ÈÏ·þÎñÃüÁî*/
 112      =2  #define CMD_HELP_ENTER                  0x23    /*È·ÈÏÇóÔ®ÃüÁî*/
 113      =2  #define CMD_EMERGENCY_ENTER             0x24    /*È·ÈÏ½ô¼±ÃüÁî*/
 114      =2  /*****************************************************************/
 115      =2  #define CMD_CLEAR_INSPERCTOR    0x25    /*Çå³ý²é·¿ÃüÁî*/
 116      =2  #define CMD_START_VOICE                 0x26    /*Æô¶¯²¥ÒôÃüÁî*/
 117      =2  #define CMD_STOP_VOICE                  0x27    /*Í£Ö¹²¥ÒôÃüÁî*/
 118      =2  #define CMD_MUSIC_PLAY                  0x28    /*±³¾°ÒôÀÖÃüÁî*/
 119      =2  #define CMD_REQUEST_INFO                0x29    /*ÇëÇó·¢ËÍÐÅÏ¢ÃüÁî*/
 120      =2  /*****************************************************************/
 121      =2  #define CMD_CHANNEL_CHANGE              0x2a    /*ÇÐ»»Í¨»°Í¨µÀ*/
 122      =2  #define CMD_CHANNEL_CLOSE               0x2b    /*¹Ø±ÕÍ¨»°Í¨µÀ*/
 123      =2  #define CMD_POWER_ON                    0x2c    /*ÉÏµç¸´Î»ÃüÁî*/
 124      =2  #define CMD_INSPERCTOR_ENTER    0x2d    /*È·ÈÏ²é·¿ÃüÁî*/
 125      =2  #define CMD_STOP_INDICATION             0x2e    /*ÖÕÖ¹ÐÅÏ¢Ö¸Ê¾*/
 126      =2  #define CMD_INFO_INDICATION             0x2f    /*ÐÅÏ¢Ö¸Ê¾ÃüÁî*/
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 35  

 127      =2  /*Ö÷¶¯ºô½Ð·½µØÖ·ÔÚÇ°Á½¸ö×Ö½Ú£¬ºóÃæÁ½¸ö×Ö½ÚÎªºô½ÐÀàÐÍ£º¸ß3Î»ÓÅÏÈ¼¶£¬µÍ5Î»ÎªÀà±ð*/
 128      =2  /*****************************************************************/
 129      =2  #define CMD_MUSIC                               0x30    /*ÒôÀÖÃüÁî*/
 130      =2  #define CMD_INCREACE_VOL                0x31    /*ÒôÁ¿Ôö¼ÓÃüÁî*/
 131      =2  #define CMD_DECREACE_VOL                0x32    /*ÒôÁ¿¼õÐ¡ÃüÁî*/
 132      =2  #define CMD_OPEN_LCD                    0x3e    /*´ò¿ªÏÔÊ¾ÃüÁî*/
 133      =2  #define CMD_CLOSE_LCD                   0x3f    /*¹Ø±ÕÏÔÊ¾ÃüÁî*/
 134      =2  /*****************************************************************/
 135      =2  #define CMD_OPEN_485BUS_OUT             0x40    /*´ò¿ª485Êä³ö*/
 136      =2  #define CMD_OPEN_485BUS_IN              0x41    /*´ò¿ª485ÊäÈëÃüÁî*/
 137      =2  #define CMD_CLOSE_485BUS                0x42    /*¹Ø±Õ485ÃüÁî*/
 138      =2  /*****************************************************************/
 139      =2  #define CMD_KEY_AVALID                  0x44    /*°´¼üÓÐÐ§ÃüÁî*/
 140      =2  #define CMD_KEY_INVALID                 0x45    /*°´¼üÊ§Ð§ÃüÁî*/
 141      =2  #define CMD_KEY_DOWN                    0x46    /*°´¼üÑ¹ÏÂÃüÁî*/
 142      =2  #define CMD_KEY_UP                              0x47    /*°´¼üÊÍ·ÅÃüÁî*/
 143      =2  #define CMD_ERROR_REPORT                0x48    /*¹ÊÕÏ±¨¸æÃüÁî*/
 144      =2  #define CMD_CLEAR_LCD                   0x49    /*Çå³ýÒº¾§ÐÅÏ¢ÃüÁî*/
 145      =2  #define CMD_RECEIVE_INFO                0x4a    /*ÊÕµ½ÐÅÏ¢ÃüÁî*/
 146      =2  #define CMD_SELECT_INFO                 0x4b    /*Ñ¡ÔñÐÅÏ¢ÃüÁî*/
 147      =2  #define CMD_NO_BUG                              0x4c    /*ÇëÎð´òÈÅÃüÁî*/
 148      =2  #define CMD_NO_BUG_AVALID               0x4d    /*ÇëÎð´òÈÅÓÐÐ§ÃüÁî*/
 149      =2  #define CMD_BUG_END                             0x4e    /*½áÊø´òÈÅÃüÁî*/
 150      =2  /*****************************************************************/
 151      =2  #define CMD_ONLINE_WRITE                0xf3    /*ÔÚÏßÐ´ÈëÃüÁî*/
 152      =2  #define CMD_ONLIEN_READ                 0xf4    /*ÔÚÏß¶Á³öÃüÁî*/
 153      =2  #define CMD_ONLINE_OUTPUT               0xf5    /*ÔÚÏßÊä³öÃüÁî*/
 154      =2  /*****************************************************************/
 155      =2  #define CMD_LED_OFFLINE_WRITE   0xf0    /*ledeepromÀëÏßÐ´ÈëÃüÁî*/
 156      =2  #define CMD_LED_OFFLINE_READ    0xf1    /*ledeepromÀëÏß¶Á³öÃüÁî*/
 157      =2  #define CMD_LED_OFFLINE_OUTPUT  0xf2    /*ledeepromÀëÏßÊä³öÃüÁî*/
 158      =2  /*****************************************************************/
 159      =2  #define CMD_EEPROM_OFFLINE_WR   0xfe    /*eepromÀëÏßÐ´ÈëÃüÁî*/
 160      =2  #define CMD_EEPROM_OFFLINE_RD   0xf1    /*eepromÀëÏß¶Á³öÃüÁî*/
 161      =2  #define CMD_EEPROM_OFFLINE_OUTT 0xf2    /*eepromÀëÏßÊä³öÃüÁî*/ 
 162      =2  /****************************************************************/        
 163      =2  #ifdef _IN_SINGLE_BUS_
           =2 //Éè±¸×´Ì¬¶¨Òå
           =2 uint8   bdata   byDevState1;
           =2 sbit    bLanding        =       byDevState1^0;                          //ÉÏµçµÇ¼Ç×´Ì¬  
           =2 #else
 168      =2  extern  uint8   byDevState1;
 169      =2  extern  bit             bLanding;
 170      =2  void SingleBusInit(void); 
 171      =2  void ReadParameter(void);       
 172      =2  void InitParameter(void);
 173      =2  void Bus0OutputData(uint8* pbyData);  
 174      =2  void MakeCH0TimerOut(uint8 byTimerOut, uint8 byTimerOutCount);
 175      =2  void Bus0RecDeal(void);
 176      =2  void Bus0SendDeal(void);
 177      =2  void Bus0Manage(void); 
 178      =2  void TimerOutDeal(void);
 179      =2  void TimerOutManager(void);
 180      =2  #endif
  72      =1  #include "Key.h"
   1      =2  /*
   2      =2  ************************Copyright(c)************************
   3      =2  *                                  ºþÄÏÒ»ÌØµç×Ó¹É·ÝÓÐÏÞ¹«Ë¾
   4      =2  *                               All Rights Reserved
   5      =2  *                                        
   6      =2  *
   7      =2  *-----------------------ÎÄ¼þÐÅÏ¢---------------------------
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 36  

   8      =2  *ÎÄ¼þÃû³Æ               :Key.h
   9      =2  *ÎÄ¼þÃèÊö               :°´¼üÇý¶¯³ÌÐòÍ·ÎÄ¼þ
  10      =2  *´´½¨ÈË                 :ÒüÔËÍ¬
  11      =2  *´´½¨ÈÕÆÚ               :2008-9-22
  12      =2  *°æ±¾ºÅ                 :V1.0
  13      =2  *×¢ÊÍ                   :²ÉÓÃ°´¼üÓëµÆÏÔÊ¾¿ØÖÆ¹²ÓÃÒ»¸öI/O¿ÚµÄ·½Ê½                                        
  14      =2  *----------------------------------------------------------
  15      =2  *ÐÞ¸ÄÈË                         :
  16      =2  *ÐÞ¸ÄÈÕÆÚ                       :
  17      =2  *°æ±¾ºÅ                 :
  18      =2  *×¢ÊÍ                   :
  19      =2  ***********************************************************
  20      =2  */
  21      =2  #ifndef KEY_H
  22      =2  #define KEY_H
  23      =2  
  24      =2  #define         KEY_DELAY                       100                                                     //ÉèÖÃ³¤°´¼üÊ±¼ä
  25      =2  //°´¼ü¶¨Òå
  26      =2  #define COPY_KEY_VAL                    0x01                                                    //Êý¾Ý¿½±´¼ü
  27      =2  #define NO_KEY_VAL                      0xff                                                            //ÎÞ¼ü°´ÏÂ
  28      =2  
  29      =2  #ifndef _IN_KEY_
  30      =2  #define _IN_KEY_
  31      =2  extern bit bPrgState;
  32      =2                                          
  33      =2  extern void SetLedState(uint8 byState);
  34      =2  extern void KeyDownDeal(uint8 byKey);
  35      =2  extern void KeyUpDeal(uint8 byKey);
  36      =2  extern void KeyAlwaysDeal(uint8 byKey);
  37      =2  extern void KeyManager(void);
  38      =2  
  39      =2  #endif
  40      =2  
  41      =2  #endif
  73      =1  #include "IAP.h"
   1      =2  /*
   2      =2  ************************Copyright(c)************************
   3      =2  *                                  ºþÄÏÒ»ÌØµç×Ó¹É·ÝÓÐÏÞ¹«Ë¾
   4      =2  *                               All Rights Reserved
   5      =2  *                                        
   6      =2  *
   7      =2  *-----------------------ÎÄ¼þÐÅÏ¢---------------------------
   8      =2  *ÎÄ¼þÃû³Æ               :IAP.h
   9      =2  *ÎÄ¼þÃèÊö               :Ð´FlashÇý¶¯Í·ÎÄ¼þ
  10      =2  *´´½¨ÈË                 :ÒüÔËÍ¬
  11      =2  *´´½¨ÈÕÆÚ               :2008-9-22
  12      =2  *°æ±¾ºÅ                 :V1.0
  13      =2  *×¢ÊÍ                   :²ÉÓÃSTCÏµÁÐCPU,¸ÃÀàÐÍCPU½«ÄÚ²¿Flash×÷
  14      =2                                       EEPromÊ¹ÓÃ,²Á³ýÐèÒÔÉÈÇøÎªµ¥Î»,ÔÚ½øÐÐ
  15      =2                                       IAP²Ù×÷¹ý³ÌÖÐ,CPU°´ÕÕÉè¶¨µÄÊ±¼ä¹ÒÆð,
  16      =2                                       ´ËÊ±CPU²»ÄÜ¹»½øÐÐÈÎºÎ¹¤×÷
  17      =2  *----------------------------------------------------------
  18      =2  *ÐÞ¸ÄÈË                         :
  19      =2  *ÐÞ¸ÄÈÕÆÚ                       :
  20      =2  *°æ±¾ºÅ                 :
  21      =2  *×¢ÊÍ                   :
  22      =2  ***********************************************************
  23      =2  */
  24      =2  #define         IAP_READ                        0x01                                            //IAP¶ÁÃüÁî
  25      =2  #define         IAP_WRITE                       0x02                                            //IAPÐ´ÃüÁî
  26      =2  #define         IAP_ERASE                       0x03                                            //IAP²Á³ýÃüÁî
  27      =2  #define         IAP_WAIT_TIME           0x02                                            //IAPµÈ´ýÊ±¼ä 20MÒÔÏÂ
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 37  

  28      =2  //#define               IAP_WAIT_TIME           0x03                                            //IAPµÈ´ýÊ±¼ä   12MÒÔÏÂ
  29      =2  
  30      =2  //#define       ISP_DATA        IAP_DATA        
  31      =2  //#define       ISP_CONTR       IAP_CONTR       
  32      =2  //#define       ISP_CMD         IAP_CMD         
  33      =2  //#define       ISP_ADDRH       IAP_ADDRH       
  34      =2  //#define       ISP_ADDRL       IAP_ADDRL       
  35      =2  //#define       ISP_TRIG        IAP_TRIG        
  36      =2  
  37      =2  
  38      =2  #ifndef _IN_IAP_
  39      =2  #define _IN_IAP_
  40      =2  void EnableIAP(uint8 byCmd);
  41      =2  void DisableIAP(void);
  42      =2  uint8 IapReadByte(uint16 uiAddr);
  43      =2  void IapWriteByte(uint16 uiAddr, uint8 byData);
  44      =2  void IapErase(uint16 uiAddr);
  45      =2  #endif
  74      =1  #include "VS10XX.h"
   1      =2  /** \file vs10xx.h
   2      =2   * Headers for interfacing with the mp3 player chip.
   3      =2   * Interfacing the New Way, not handling BSYNC -> not compatible with VS1001.
   4      =2   */
   5      =2  
   6      =2  
   7      =2  #ifndef VS10XX_H
   8      =2  #define VS10XX_H
   9      =2  
  10      =2  
  11      =2  /** VS10xx SCI Write Command byte is 0x02 */
  12      =2  #define VS_WRITE_COMMAND 0x02
  13      =2  
  14      =2  /** VS10xx SCI Read Command byte is 0x03 */
  15      =2  #define VS_READ_COMMAND 0x03
  16      =2  
  17      =2  
  18      =2  #define SPI_MODE        0x0   /**< VS10xx register */
  19      =2  #define SPI_STATUS      0x1   /**< VS10xx register */
  20      =2  #define SPI_BASS        0x2   /**< VS10xx register */
  21      =2  #define SPI_CLOCKF      0x3   /**< VS10xx register */
  22      =2  #define SPI_DECODE_TIME 0x4   /**< VS10xx register */
  23      =2  #define SPI_AUDATA      0x5   /**< VS10xx register */
  24      =2  #define SPI_WRAM        0x6   /**< VS10xx register */
  25      =2  #define SPI_WRAMADDR    0x7   /**< VS10xx register */
  26      =2  #define SPI_HDAT0       0x8   /**< VS10xx register */
  27      =2  #define SPI_HDAT1       0x9   /**< VS10xx register */
  28      =2  #define SPI_AIADDR      0xa   /**< VS10xx register */
  29      =2  #define SPI_VOL         0xb   /**< VS10xx register */
  30      =2  #define SPI_AICTRL0     0xc   /**< VS10xx register */
  31      =2  #define SPI_AICTRL1     0xd   /**< VS10xx register */
  32      =2  #define SPI_AICTRL2     0xe   /**< VS10xx register */
  33      =2  #define SPI_AICTRL3     0xf   /**< VS10xx register */
  34      =2  
  35      =2  #define SM_DIFF         0x01   /**< VS10xx register */
  36      =2  #define SM_JUMP         0x02   /**< VS10xx register */
  37      =2  #define SM_RESET        0x04   /**< VS10xx register */
  38      =2  #define SM_OUTOFWAV     0x08   /**< VS10xx register */
  39      =2  #define SM_PDOWN        0x10   /**< VS10xx register */
  40      =2  #define SM_TESTS        0x20   /**< VS10xx register */
  41      =2  #define SM_STREAM       0x40   /**< VS10xx register */
  42      =2  #define SM_PLUSV        0x80   /**< VS10xx register */
  43      =2  #define SM_DACT         0x100   /**< VS10xx register */
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 38  

  44      =2  #define SM_SDIORD       0x200   /**< VS10xx register */
  45      =2  #define SM_SDISHARE     0x400   /**< VS10xx register */
  46      =2  #define SM_SDINEW       0x800   /**< VS10xx register */
  47      =2  #define SM_ADPCM        0x1000   /**< VS10xx register */
  48      =2  #define SM_ADPCM_HP     0x2000   /**< VS10xx register */
  49      =2  
  50      =2  
  51      =2  
  52      =2  /** Put the MP3 player chip in reset */
  53      =2  #define Mp3PutInReset(){MP3_XRESET=0;}
  54      =2  
  55      =2  /** Release the MP3 player chip from reset */
  56      =2  #define Mp3ReleaseFromReset(){MP3_XRESET=1;}
  57      =2  
  58      =2  
  59      =2  /** Pull the VS10xx Control Chip Select line Low */
  60      =2  #define Mp3SelectControl(){MP3_XCS=0;}
  61      =2  
  62      =2  /** Pull the VS10xx Control Chip Select line High */
  63      =2  #define Mp3DeselectControl(){MP3_XCS=1;}
  64      =2  
  65      =2  /** Pull the VS10xx Data Chip Select line Low */
  66      =2  #define Mp3SelectData(){MP3_XDCS=0;}
  67      =2  
  68      =2  /** Pull the VS10xx Data Chip Select line High */
  69      =2  #define Mp3DeselectData(){MP3_XDCS=1;}
  70      =2  
  71      =2  
  72      =2  #ifndef _IN_VS10XX_
  73      =2  extern void Mp3WriteRegister(uint8 addressbyte,uint8 highbyte,uint8 lowbyte);
  74      =2  extern void Mp3SetVolume(uint8 leftchannel,uint8 rightchannel);
  75      =2  extern unsigned int Mp3ReadRegister (unsigned char addressbyte);
  76      =2  extern void VS1003Init(void);
  77      =2  extern void VsSineTest();
  78      =2  extern void VS1003SendDat(uint8 dat);
  79      =2  extern void VS1003FlushBuffer(void);
  80      =2  
  81      =2  
  82      =2  #endif
  83      =2  
  84      =2  #endif
  75      =1  #include "SPI.h"
   1      =2  /*
   2      =2  ************************Copyright(c)************************
   3      =2  *                                  ºþÄÏÒ»ÌØµç×Ó¹É·ÝÓÐÏÞ¹«Ë¾
   4      =2  *                               All Rights Reserved
   5      =2  *                                        
   6      =2  *
   7      =2  *-----------------------ÎÄ¼þÐÅÏ¢---------------------------
   8      =2  *ÎÄ¼þÃû³Æ               :SPI.h
   9      =2  *ÎÄ¼þÃèÊö               :SPI Çý¶¯³ÌÐòÍ·ÎÄ¼þ
  10      =2  *´´½¨ÈË                 :ÒüÔËÍ¬
  11      =2  *´´½¨ÈÕÆÚ               :2008-9-22
  12      =2  *°æ±¾ºÅ                 :V1.0
  13      =2  *×¢ÊÍ                   :                                       
  14      =2  *----------------------------------------------------------
  15      =2  *ÐÞ¸ÄÈË                         :
  16      =2  *ÐÞ¸ÄÈÕÆÚ                       :
  17      =2  *°æ±¾ºÅ                 :
  18      =2  *×¢ÊÍ                   :
  19      =2  ***********************************************************
  20      =2  */
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 39  

  21      =2  /* SPI macros */
  22      =2          
  23      =2          /** switch to fast SPI Clock */
  24      =2  #define SPISetFastClock(){SPCTL=0x71;}  /* 0x73 is much slower*/
  25      =2          
  26      =2          
  27      =2          /** SPI data return register */
  28      =2  #define SPI_RESULT_BYTE SPDAT
  29      =2  
  30      =2  #ifndef _IN_SPI_
  31      =2  #define _IN_SPI_
  32      =2  
  33      =2  extern void SpiInit(void);
  34      =2  extern uint8 SPI_WriteByte(unsigned char dat);
  35      =2  extern unsigned char SPIGetChar();
  36      =2  extern void SPI8Clocks(unsigned char nClocks);
  37      =2  
  38      =2  
  39      =2  #endif
  40      =2  
  76      =1  #include "SST25VF.h"
   1      =2  /*
   2      =2  ************************Copyright(c)************************
   3      =2  *                                  ºþÄÏÒ»ÌØµç×Ó¹É·ÝÓÐÏÞ¹«Ë¾
   4      =2  *                               All Rights Reserved
   5      =2  *                                        
   6      =2  *
   7      =2  *-----------------------ÎÄ¼þÐÅÏ¢---------------------------
   8      =2  *ÎÄ¼þÃû³Æ               :MB85RS256.h
   9      =2  *ÎÄ¼þÃèÊö               :MB85RS256Ìúµç´æ´¢Æ÷Í·ÎÄ¼þ
  10      =2  *´´½¨ÈË                 :ÒüÔËÍ¬
  11      =2  *´´½¨ÈÕÆÚ               :2008-9-22
  12      =2  *°æ±¾ºÅ                 :V1.0
  13      =2  *×¢ÊÍ                   :
  14      =2  *----------------------------------------------------------
  15      =2  *ÐÞ¸ÄÈË                         :
  16      =2  *ÐÞ¸ÄÈÕÆÚ                       :
  17      =2  *°æ±¾ºÅ                 :
  18      =2  *×¢ÊÍ                   :
  19      =2  ***********************************************************
  20      =2  */
  21      =2  
  22      =2  
  23      =2  /*#define WREN    0x06
  24      =2  #define WRITE   0x02
  25      =2  #define READ    0x03
  26      =2  #define RDSR    0x05
  27      =2  #define EWSR    0X50
  28      =2  #define WRSR    0x01
  29      =2  #define WRDI    0x04
  30      =2  #define SECTOR_ERASE  0X20
  31      =2  #define BLOCK_ERASE   0X52
  32      =2  #define CHIP_ERASE    0X60
  33      =2  #define AAI_WRITE         0XAF
  34      =2  #define READ_ID1      0X90
  35      =2  #define READ_ID2      0XAB*/
  36      =2  
  37      =2  
  38      =2  #ifndef _IN_SST25VF_
           =2 #define _IN_SST25VF_
           =2 
           =2 extern unsigned char xdata FRAM_BUFF[];
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 40  

           =2 
           =2 extern void SST25VF_Init();
           =2 extern void Send_Byte(unsigned char out);
           =2 extern unsigned char Get_Byte();
           =2 extern void Poll_SO();
           =2 extern void CE_High();
           =2 extern void CE_Low();
           =2 extern void Hold_Low();
           =2 extern void Unhold();
           =2 extern void WP_Low();
           =2 extern void UnWP();
           =2 extern unsigned char Read_Status_Register();
           =2 extern void EWSR();
           =2 extern void WRSR(byte);
           =2 extern void WREN();
           =2 extern void WRDI();
           =2 extern void EBSY();
           =2 extern void DBSY();
           =2 extern unsigned char Read_ID(ID_addr);
           =2 extern unsigned long Jedec_ID_Read(); 
           =2 extern unsigned char Read(unsigned long Dst);
           =2 extern void Read_Cont(unsigned long Dst, unsigned long no_bytes,uint8 *pBuffer);
           =2 extern unsigned char HighSpeed_Read(unsigned long Dst); 
           =2 extern void HighSpeed_Read_Cont(unsigned long Dst, unsigned long no_bytes,uint8 *pBuffer);
           =2 extern void Byte_Program(unsigned long Dst, unsigned char byte);
           =2 extern void Auto_Add_IncA(unsigned long Dst, unsigned char byte1, unsigned char byte2);
           =2 extern void Auto_Add_IncB(unsigned char byte1, unsigned char byte2);
           =2 extern void Auto_Add_IncA_EBSY(unsigned long Dst, unsigned char byte1, unsigned char byte2);
           =2 extern void Auto_Add_IncB_EBSY(unsigned char byte1, unsigned char byte2);
           =2 extern void Chip_Erase();
           =2 extern void Sector_Erase(unsigned long Dst);
           =2 extern void Block_Erase_32K(unsigned long Dst);
           =2 extern void Block_Erase_64K(unsigned long Dst);
           =2 extern void Wait_Busy();
           =2 extern void Wait_Busy_AAI();
           =2 extern void WREN_Check();
           =2 extern void WREN_AAI_Check();
           =2 
           =2 extern void Verify(unsigned char byte, unsigned char cor_byte);
           =2 extern void Byte_Write(unsigned long Dst, unsigned char byte);
           =2 extern void AAI_Write(unsigned long Dst, uint8 *p,uint8 no_bytes);
           =2 extern void Byte_Write1(unsigned long Dst, unsigned char byte);
           =2 extern void AAI_Write1(unsigned long Dst, uint8 *p,uint8 no_bytes);
           =2 extern void FRAM_TEST(void);
           =2 
           =2 
           =2 
           =2 #endif
  90      =2  
  77      =1  
  78      =1           
  79      =1  //Éè±¸ÅäÖÃ×Ö¶¨Òå
  80      =1  typedef struct
  81      =1  {
  82      =1          uint8   byInitFlag;                                                                     //³õÊ¼»¯²ÎÊý±êÖ¾
  83      =1          
  84      =1  } STEepromCfgData, *pSTEepromCfgData; 
  85      =1  //³¬Ê±¿ØÖÆ½á¹¹Ìå
  86      =1  typedef struct
  87      =1  {
  88      =1          uint8                           byTimerOutSet;                                          //Ò»´Î³¬Ê±Ê±¼äÉèÖÃ(20msµ¥Î»)
  89      =1          uint8                           byTimerOut;                                                     //Ò»´Î³¬Ê±Ê±¼ä(20msµ¥Î»)
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 41  

  90      =1          uint8                           byTimerOutCount;                                        //ÔÊÐí³¬Ê±´ÎÊý 
  91      =1  } STTimerOut, *pSTTimerOut;             
  92      =1  
  93      =1  //È«¾Ö¿ØÖÆ½á¹¹Ìå
  94      =1  typedef struct
  95      =1  {
  96      =1          uint8                           byChar1;                                                        //×Ö½ÚÊý¾Ý1     
  97      =1          uint16                          uiShortType;                                            //¶ÌÕûÐÍÊý¾Ý    
  98      =1          uint8                           xdata* pbyData;                                         //Êý¾ÝÖ¸Õë
  99      =1          STBusFreq                       stBusDealFreq;                                          //µ¥×ÜÏß´¦Àí½á¹¹Ìå
 100      =1          STTimerOut                      stCH0TimerOut;                                          //Éè±¸µ±Ç°×´Ì¬³¬Ê±¿ØÖÆ½á¹¹Ìå
 101      =1          STEepromCfgData         stEepromCfgData;                                        //ÏµÍ³ÅäÖÃ×Ö                    
 102      =1  } STLocalControl, *pSTLocalControl;             
 103      =1  
 104      =1  //5msPCAÖÐ¶Ï¼ÆÊ±´ÎÊý£¬Fosc=18.432MHz,·ÖÆµÏµÊýÎª2 
 105      =1  #define Fosc                            18432000
 106      =1  #define Fbus                            184320
 107      =1          
 108      =1                          
 109      =1  #define ISR_INC_COUNT           (Fosc/2/OS_TICKS_PER_SEC)
 110      =1  #define IAP_ADDR                        0x0000          //STC12C5624ÄÚµÄE2Ö»ÄÜÊÇÊý¾ÝE2
 111      =1  #define INIT_FLAG           0x5a
 112      =1  
 113      =1  
 114      =1  #ifndef _IN_MAIN_
 115      =1  extern void Send_Data(uint8 *Databuf,uint8 l);
 116      =1  extern void Send_Data_Byte(uint8 SndData);
 117      =1  extern void delay_nus(uint16 i);
 118      =1  extern void delay_nms(uint16 ms);
 119      =1  
 120      =1  
 121      =1  extern uint16   xdata uiIsrTimerCount ;                                 //ÏµÍ³Ê±ÖÓ¶¨Ê±Öµ
 122      =1  extern uint8    OS_Q_MEM_SEL    byMainCmdQ[];                                           //Ö÷Ïß³ÌÏûÏ¢¶ÓÁÐ
 123      =1  extern STLocalControl   xdata stLocalControl;                                           //È«¾Ö±äÁ¿½á¹¹Ìå
 124      =1  extern uint8    data volumn;
 125      =1  
 126      =1  extern void ConsoleWrite(char code *str);
 127      =1  
 128      =1  
 129      =1  #endif
  94                  
  95          
  96          unsigned char xdata FRAM_BUFF[100];
  97          
  98          
  99          
 100          /* Function Prototypes */
 101          
 102          void SST25VF_Init();
 103          void Send_Byte(unsigned char out);
 104          unsigned char Get_Byte();
 105          void Poll_SO();
 106          void CE_High();
 107          void CE_Low();
 108          void Hold_Low();
 109          void Unhold();
 110          void WP_Low();
 111          void UnWP();
 112          unsigned char Read_Status_Register();
 113          void EWSR();
 114          void WRSR(byte);
 115          void WREN();
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 42  

 116          void WRDI();
 117          void EBSY();
 118          void DBSY();
 119          unsigned char Read_ID(ID_addr);
 120          unsigned long Jedec_ID_Read(); 
 121          unsigned char Read(unsigned long Dst);
 122          void Read_Cont(unsigned long Dst, unsigned long no_bytes,uint8 *pBuffer);
 123          unsigned char HighSpeed_Read(unsigned long Dst); 
 124          void HighSpeed_Read_Cont(unsigned long Dst, unsigned long no_bytes,uint8 *pBuffer);
 125          void Byte_Program(unsigned long Dst, unsigned char byte);
 126          void Auto_Add_IncA(unsigned long Dst, unsigned char byte1, unsigned char byte2);
 127          void Auto_Add_IncB(unsigned char byte1, unsigned char byte2);
 128          void Auto_Add_IncA_EBSY(unsigned long Dst, unsigned char byte1, unsigned char byte2);
 129          void Auto_Add_IncB_EBSY(unsigned char byte1, unsigned char byte2);
 130          void Chip_Erase();
 131          void Sector_Erase(unsigned long Dst);
 132          void Block_Erase_32K(unsigned long Dst);
 133          void Block_Erase_64K(unsigned long Dst);
 134          void Wait_Busy();
 135          void Wait_Busy_AAI();
 136          void WREN_Check();
 137          void WREN_AAI_Check();
 138          
 139          void Verify(unsigned char byte, unsigned char cor_byte);
 140          void Byte_Write(unsigned long Dst, unsigned char byte);
 141          void AAI_Write(unsigned long Dst, uint8 *p,uint8 no_bytes);
 142          
 143          
 144          
 145          
 146          //unsigned char idata upper_128[128];           /* global array to store read data */
 147                                                                                          /* to upper RAM area from 80H - FFH */
 148          
 149          /************************************************************************/
 150          /* PROCEDURE: init                                                                                                              */
 151          /*                                                                                                                                              */
 152          /* This procedure initializes the SCK to low. Must be called prior to   */
 153          /* setting up mode 0.                                                                                                   */
 154          /*                                                                                                                                              */
 155          /* Input:                                                                                                                               */
 156          /*              None                                                                                                                    */
 157          /*                                                                                                                                              */
 158          /* Output:                                                                                                                              */
 159          /*              SCK                                                                                                                             */
 160          /************************************************************************/
 161          void SST25VF_Init()
 162          {
 163   1      //      SCLK = 0;       /* set clock to low initial state */
 164   1              
 165   1              Send_Data_Byte(Read_Status_Register());
 166   1              EWSR();
 167   1              delay_nms(1);
 168   1              WRSR(0x00);             //²»Ð´±£»¤
 169   1              delay_nms(1);
 170   1              Send_Data_Byte(Read_Status_Register()); 
 171   1      }
 172          
 173          /************************************************************************/
 174          /* PROCEDURE: Send_Byte                                                                                                 */
 175          /*                                                                                                                                              */
 176          /* This procedure outputs a byte shifting out 1-bit per clock rising    */
 177          /* edge on the the SI pin(LSB 1st).                                                                             */
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 43  

 178          /*                                                                                                                                              */
 179          /* Input:                                                                                                                               */
 180          /*              out                                                                                                                             */
 181          /*                                                                                                                                              */
 182          /* Output:                                                                                                                              */
 183          /*              SI                                                                                                                              */
 184          /************************************************************************/
 185          void Send_Byte(unsigned char out)
 186          {
 187   1              
 188   1              //unsigned char i = 0;
 189   1              //for (i = 0; i < 8; i++)
 190   1              //{
 191   1              //      
 192   1              //      if ((out & 0x80) == 0x80)       /* check if MSB is high */
 193   1              //              MOSI = 1;
 194   1              //      else
 195   1              //              MOSI = 0;                                       /* if not, set to low */
 196   1              //      SCLK = 1;                                       /* toggle clock high */
 197   1              //      out = (out << 1);                       /* shift 1 place for next bit */
 198   1              //      SCLK = 0;                                       /* toggle clock low */
 199   1              //}
 200   1              SPI_WriteByte(out);
 201   1      }
 202          
 203          /************************************************************************/
 204          /* PROCEDURE: Get_Byte                                                                                                  */
 205          /*                                                                                                                                              */
 206          /* This procedure inputs a byte shifting in 1-bit per clock falling             */
 207          /* edge on the SO pin(LSB 1st).                                                                                 */
 208          /*                                                                                                                                              */
 209          /* Input:                                                                                                                               */
 210          /*              SO                                                                                                                              */
 211          /*                                                                                                                                              */
 212          /* Output:                                                                                                                              */
 213          /*              None                                                                                                                    */
 214          /************************************************************************/
 215          unsigned char Get_Byte()
 216          {
 217   1              //unsigned char i = 0, in = 0, temp = 0;
 218   1              //for (i = 0; i < 8; i++)
 219   1              //{
 220   1              //      in = (in << 1);         /* shift 1 place to the left or shift in 0 */
 221   1              //      temp = MISO;                    /* save input */
 222   1              //      SCLK = 1;                       /* toggle clock high */
 223   1              //      if (temp == 1)                  /* check to see if bit is high */
 224   1              //              in = in | 0x01;         /* if high, make bit high */
 225   1      
 226   1              //      SCLK = 0;                       /* toggle clock low */
 227   1      
 228   1              //}
 229   1              //return in;
 230   1      
 231   1              uint8 xdata in;
 232   1              in=SPI_WriteByte(0x00); //ÊäÈë8¸öÊ±ÖÓ
 233   1              return in;
 234   1      }
 235          
 236          /************************************************************************/
 237          /* PROCEDURE: Poll_SO                                                                                                   */
 238          /*                                                                                                                                              */
 239          /* This procedure polls for the SO line during AAI programming                  */
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 44  

 240          /* waiting for SO to transition to 1 which will indicate AAI programming*/
 241          /* is completed                                                                                                                 */
 242          /*                                                                                                                                              */
 243          /* Input:                                                                                                                               */
 244          /*              SO                                                                                                                              */
 245          /*                                                                                                                                              */
 246          /* Output:                                                                                                                              */
 247          /*              None                                                                                                                    */
 248          /************************************************************************/
 249          void Poll_SO()
 250          {
 251   1              unsigned char xdata temp = 0;
 252   1              CE_Low();
 253   1              while (temp == 0x00)    /* waste time until not busy */
 254   1                      temp = MISO;
 255   1              CE_High();
 256   1      }
 257          
 258          /************************************************************************/
 259          /* PROCEDURE: CE_High                                                                                                   */
 260          /*                                                                                                                                              */
 261          /* This procedure set CE = High.                                                                                */
 262          /*                                                                                                                                              */
 263          /* Input:                                                                                                                               */
 264          /*              None                                                                                                                    */
 265          /*                                                                                                                                              */
 266          /* Output:                                                                                                                              */
 267          /*              CE                                                                                                                              */
 268          /*                                                                                                                                              */
 269          /************************************************************************/
 270          void CE_High() 
 271          {
 272   1              SST25VF_CS = 1;                         /* set CE high */
 273   1      }
 274          
 275          /************************************************************************/
 276          /* PROCEDURE: CE_Low                                                                                                    */
 277          /*                                                                                                                                              */
 278          /* This procedure drives the CE of the device to low.                                   */
 279          /*                                                                                                                                              */
 280          /* Input:                                                                                                                               */
 281          /*              None                                                                                                                    */
 282          /*                                                                                                                                              */
 283          /* Output:                                                                                                                              */
 284          /*              CE                                                                                                                              */
 285          /*                                                                                                                                              */
 286          /************************************************************************/
 287          void CE_Low() 
 288          {       
 289   1              SST25VF_CS = 0;                         /* clear CE low */
 290   1      }
 291          
 292          /************************************************************************/
 293          /* PROCEDURE: Hold()                                                                                                    */
 294          /*                                                                                                                                              */
 295          /* This procedure clears the Hold pin to low.                                                   */
 296          /*                                                                                                                                              */
 297          /* Input:                                                                                                                               */
 298          /*              None                                                                                                                    */
 299          /*                                                                                                                                              */
 300          /* Output:                                                                                                                              */
 301          /*              Hold                                                                                                                    */
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 45  

 302          /************************************************************************/
 303          void Hold_Low()
 304          {
 305   1      
 306   1      //      Hold = 0;                       /* clear Hold pin */
 307   1              
 308   1      }
 309          
 310          /************************************************************************/
 311          /* PROCEDURE: Unhold()                                                                                                  */
 312          /*                                                                                                                                              */
 313          /* This procedure sets the Hold pin to high.                                                    */
 314          /*                                                                                                                                              */
 315          /* Input:                                                                                                                               */
 316          /*              None                                                                                                                    */
 317          /*                                                                                                                                              */
 318          /* Output:                                                                                                                              */
 319          /*              Hold                                                                                                                    */
 320          /************************************************************************/
 321          void Unhold()
 322          {
 323   1      
 324   1      //      Hold = 1;                       /* set Hold pin */
 325   1              
 326   1      }
 327          
 328          /************************************************************************/
 329          /* PROCEDURE: WP()                                                                                                              */
 330          /*                                                                                                                                              */
 331          /* This procedure clears the WP pin to low.                                                             */
 332          /*                                                                                                                                              */
 333          /* Input:                                                                                                                               */
 334          /*              None                                                                                                                    */
 335          /*                                                                                                                                              */
 336          /* Output:                                                                                                                              */
 337          /*              WP                                                                                                                              */
 338          /************************************************************************/
 339          void WP_Low()
 340          {
 341   1      
 342   1      //      WP = 0;                         /* clear WP pin */
 343   1      
 344   1      }
 345          
 346          /************************************************************************/
 347          /* PROCEDURE: UnWP()                                                                                                    */
 348          /*                                                                                                                                              */
 349          /* This procedure sets the WP pin to high.                                                              */
 350          /*                                                                                                                                              */
 351          /* Input:                                                                                                                               */
 352          /*              None                                                                                                                    */
 353          /*                                                                                                                                              */
 354          /* Output:                                                                                                                              */
 355          /*              WP                                                                                                                              */
 356          /************************************************************************/
 357          void UnWP()
 358          {
 359   1      
 360   1      //      WP = 1;                         /* set WP pin */
 361   1      
 362   1      }
 363          
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 46  

 364          /************************************************************************/
 365          /* PROCEDURE: Read_Status_Register                                                                              */
 366          /*                                                                                                                                              */
 367          /* This procedure read the status register and returns the byte.                */
 368          /*                                                                                                                                              */
 369          /* Input:                                                                                                                               */
 370          /*              None                                                                                                                    */
 371          /*                                                                                                                                              */
 372          /* Returns:                                                                                                                             */
 373          /*              byte                                                                                                                    */
 374          /************************************************************************/
 375          unsigned char Read_Status_Register()
 376          {
 377   1              unsigned char xdata byte = 0;
 378   1              CE_Low();                               /* enable device */
 379   1              Send_Byte(0x05);                /* send RDSR command */
 380   1              byte = Get_Byte();              /* receive byte */
 381   1              CE_High();                              /* disable device */
 382   1              return byte;
 383   1      }
 384          
 385          /************************************************************************/
 386          /* PROCEDURE: EWSR                                                                                                              */
 387          /*                                                                                                                                              */
 388          /* This procedure Enables Write Status Register.                                                */
 389          /*                                                                                                                                              */
 390          /* Input:                                                                                                                               */
 391          /*              None                                                                                                                    */
 392          /*                                                                                                                                              */
 393          /* Returns:                                                                                                                             */
 394          /*              Nothing                                                                                                                 */
 395          /************************************************************************/
 396          void EWSR()
 397          {
 398   1              CE_Low();                               /* enable device */
 399   1              Send_Byte(0x50);                /* enable writing to the status register */
 400   1              CE_High();                              /* disable device */
 401   1      }
 402          
 403          /************************************************************************/
 404          /* PROCEDURE: WRSR                                                                                                              */
 405          /*                                                                                                                                              */
 406          /* This procedure writes a byte to the Status Register.                                 */
 407          /*                                                                                                                                              */
 408          /* Input:                                                                                                                               */
 409          /*              byte                                                                                                                    */
 410          /*                                                                                                                                              */
 411          /* Returns:                                                                                                                             */
 412          /*              Nothing                                                                                                                 */
 413          /************************************************************************/
 414          void WRSR(byte)
 415          {
 416   1              CE_Low();                               /* enable device */
 417   1              Send_Byte(0x01);                /* select write to status register */
 418   1              Send_Byte(byte);                /* data that will change the status of BPx 
 419   1                                                                 or BPL (only bits 2,3,4,5,7 can be written) */
 420   1              CE_High();                              /* disable the device */
 421   1      }
 422          
 423          /************************************************************************/
 424          /* PROCEDURE: WREN                                                                                                              */
 425          /*                                                                                                                                              */
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 47  

 426          /* This procedure enables the Write Enable Latch.  It can also be used  */
 427          /* to Enables Write Status Register.                                                                    */
 428          /*                                                                                                                                              */
 429          /* Input:                                                                                                                               */
 430          /*              None                                                                                                                    */
 431          /*                                                                                                                                              */
 432          /* Returns:                                                                                                                             */
 433          /*              Nothing                                                                                                                 */
 434          /************************************************************************/
 435          void WREN()
 436          {
 437   1              CE_Low();                               /* enable device */
 438   1              Send_Byte(0x06);                /* send WREN command */
 439   1              CE_High();                              /* disable device */
 440   1              Wait_Busy();
 441   1      //      WREN_Check();
 442   1      }
 443          
 444          /************************************************************************/
 445          /* PROCEDURE: WRDI                                                                                                              */
 446          /*                                                                                                                                              */
 447          /* This procedure disables the Write Enable Latch.                                              */
 448          /*                                                                                                                                              */
 449          /* Input:                                                                                                                               */
 450          /*              None                                                                                                                    */
 451          /*                                                                                                                                              */
 452          /* Returns:                                                                                                                             */
 453          /*              Nothing                                                                                                                 */
 454          /************************************************************************/
 455          void WRDI()
 456          {
 457   1              CE_Low();                               /* enable device */
 458   1              Send_Byte(0x04);                /* send WRDI command */
 459   1              CE_High();                              /* disable device */
 460   1      }
 461          
 462          /************************************************************************/
 463          /* PROCEDURE: EBSY                                                                                                              */
 464          /*                                                                                                                                              */
 465          /* This procedure enable SO to output RY/BY# status during AAI                  */
 466          /* programming.                                                                                                                 */
 467          /*                                                                                                                                              */
 468          /* Input:                                                                                                                               */
 469          /*              None                                                                                                                    */
 470          /*                                                                                                                                              */
 471          /* Returns:                                                                                                                             */
 472          /*              Nothing                                                                                                                 */
 473          /************************************************************************/
 474          void EBSY()
 475          {
 476   1              CE_Low();                               /* enable device */
 477   1              Send_Byte(0x70);                /* send EBSY command */
 478   1              CE_High();                              /* disable device */
 479   1      }
 480          
 481          /************************************************************************/
 482          /* PROCEDURE: DBSY                                                                                                              */
 483          /*                                                                                                                                              */
 484          /* This procedure disable SO as output RY/BY# status signal during AAI  */
 485          /* programming.                                                                                                                 */
 486          /*                                                                                                                                              */
 487          /* Input:                                                                                                                               */
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 48  

 488          /*              None                                                                                                                    */
 489          /*                                                                                                                                              */
 490          /* Returns:                                                                                                                             */
 491          /*              Nothing                                                                                                                 */
 492          /************************************************************************/
 493          void DBSY()
 494          {
 495   1              CE_Low();                               /* enable device */
 496   1              Send_Byte(0x80);                /* send DBSY command */
 497   1              CE_High();                              /* disable device */
 498   1      }       
 499          
 500          /************************************************************************/
 501          /* PROCEDURE: Read_ID                                                                                                   */
 502          /*                                                                                                                                              */
 503          /* This procedure Reads the manufacturer's ID and device ID.  It will   */
 504          /* use 90h or ABh as the command to read the ID (90h in this sample).   */
 505          /* It is up to the user to give the last byte ID_addr to determine      */
 506          /* whether the device outputs manufacturer's ID first, or device ID     */
 507          /* first.  Please see the product datasheet for details.  Returns ID in */
 508          /* variable byte.                                                                                                               */
 509          /*                                                                                                                                              */
 510          /* Input:                                                                                                                               */
 511          /*              ID_addr                                                                                                                 */
 512          /*                                                                                                                                              */
 513          /* Returns:                                                                                                                             */
 514          /*              byte:   ID1(Manufacture's ID = BFh or Device ID = 8Dh)                  */
 515          /*                                                                                                                                              */
 516          /************************************************************************/
 517          unsigned char Read_ID(ID_addr)
 518          {
 519   1              unsigned char xdata byte;
 520   1              CE_Low();                               /* enable device */
 521   1              Send_Byte(0x90);                /* send read ID command (90h or ABh) */
 522   1          Send_Byte(0x00);            /* send address */
 523   1              Send_Byte(0x00);                /* send address */
 524   1              Send_Byte(ID_addr);             /* send address - either 00H or 01H */
 525   1              byte = Get_Byte();              /* receive byte */
 526   1              CE_High();                              /* disable device */
 527   1              return byte;
 528   1      }
 529          
 530          /************************************************************************/
 531          /* PROCEDURE: Jedec_ID_Read                                                                                             */
 532          /*                                                                                                                                              */
 533          /* This procedure Reads the manufacturer's ID (BFh), memory type (25h)  */
 534          /* and device ID (8Dh).  It will use 9Fh as the JEDEC ID command.       */
 535          /* Please see the product datasheet for details.                                                */
 536          /*                                                                                                                                              */
 537          /* Input:                                                                                                                               */
 538          /*              None                                                                                                                    */
 539          /*                                                                                                                                              */
 540          /* Returns:                                                                                                                             */
 541          /*              IDs_Read:ID1(Manufacture's ID = BFh, Memory Type (25h),                 */
 542          /*               and Device ID (8Dh)                                                                                    */
 543          /*                                                                                                                                              */
 544          /************************************************************************/
 545          unsigned long Jedec_ID_Read() 
 546          {
 547   1              unsigned long xdata temp;
 548   1              
 549   1              temp = 0;
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 49  

 550   1      
 551   1              CE_Low();                                /* enable device */
 552   1              Send_Byte(0x9F);                 /* send JEDEC ID command (9Fh) */
 553   1          temp = (temp | Get_Byte()) << 8;     /* receive byte */
 554   1              temp = (temp | Get_Byte()) << 8;        
 555   1              temp = (temp | Get_Byte());      /* temp value = 0xBF258D */
 556   1              CE_High();                              /* disable device */
 557   1      
 558   1              return temp;
 559   1      }
 560          
 561          /************************************************************************/
 562          /* PROCEDURE:   Read                                                                                                    */
 563          /*                                                                                                                                              */              
 564          /* This procedure reads one address of the device.  It will return the  */
 565          /* byte read in variable byte.                                                                                  */
 566          /*                                                                                                                                              */
 567          /*                                                                                                                                              */
 568          /*                                                                                                                                              */
 569          /* Input:                                                                                                                               */
 570          /*              Dst:    Destination Address 000000H - 07FFFFH                                   */
 571          /*          SST25VF020:Dst:     Destination Address 000000H - 03FFFFH                   */           
 572          /*                                                                                                                                      */
 573          /*                                                                                                                                              */
 574          /* Returns:                                                                                                                             */
 575          /*              byte                                                                                                                    */
 576          /*                                                                                                                                              */
 577          /************************************************************************/
 578          unsigned char Read(unsigned long Dst) 
 579          {
 580   1              unsigned char xdata byte = 0;   
 581   1      
 582   1              CE_Low();                               /* enable device */
 583   1              Send_Byte(0x03);                /* read command */
 584   1              Send_Byte(((Dst & 0xFFFFFF) >> 16));    /* send 3 address bytes */
 585   1              Send_Byte(((Dst & 0xFFFF) >> 8));
 586   1              Send_Byte(Dst & 0xFF);
 587   1              byte = Get_Byte();
 588   1              CE_High();                              /* disable device */
 589   1              return byte;                    /* return one byte read */
 590   1      }
 591          
 592          /************************************************************************/
 593          /* PROCEDURE:   Read_Cont                                                                                               */
 594          /*                                                                                                                                              */              
 595          /* This procedure reads multiple addresses of the device and stores             */
 596          /* data into 128 byte buffer. Maximum byte that can be read is 128 bytes*/
 597          /*                                                                                                                                              */
 598          /* Input:                                                                                                                               */
 599          /*              Dst:            Destination Address 000000H - 07FFFFH                           */
 600          /*          SST25VF020:Dst:     Destination Address 000000H - 03FFFFH                   */
 601          /*      no_bytes        Number of bytes to read (max = 128)                                     */
 602          /*                                                                                                                                              */
 603          /* Returns:                                                                                                                             */
 604          /*              Nothing                                                                                                                 */
 605          /*                                                                                                                                              */
 606          /************************************************************************/
 607          void Read_Cont(unsigned long Dst, unsigned long no_bytes,uint8 *pBuffer)
 608          {
 609   1              unsigned long xdata i = 0;
 610   1              CE_Low();                                       /* enable device */
 611   1              Send_Byte(0x03);                        /* read command */
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 50  

 612   1              Send_Byte(((Dst & 0xFFFFFF) >> 16));    /* send 3 address bytes */
 613   1              Send_Byte(((Dst & 0xFFFF) >> 8));
 614   1              Send_Byte(Dst & 0xFF);
 615   1              for (i = 0; i < no_bytes; i++)          /* read until no_bytes is reached */
 616   1              {
 617   2                      pBuffer[i] = Get_Byte();        /* receive byte and store at address 80H - FFH */
 618   2              }
 619   1              CE_High();                                      /* disable device */
 620   1      
 621   1      }
 622          
 623          /************************************************************************/
 624          /* PROCEDURE:   HighSpeed_Read                                                                                  */
 625          /*                                                                                                                                              */              
 626          /* This procedure reads one address of the device.  It will return the  */
 627          /* byte read in variable byte.                                                                                  */
 628          /*                                                                                                                                              */
 629          /*                                                                                                                                              */
 630          /*                                                                                                                                              */
 631          /* Input:                                                                                                                               */
 632          /*              Dst:    Destination Address 000000H - 07FFFFH                                   */
 633          /*          SST25VF020:Dst:     Destination Address 000000H - 03FFFFH                   */
 634          /*                                                                                                                                      */
 635          /*                                                                                                                                              */
 636          /* Returns:                                                                                                                             */
 637          /*              byte                                                                                                                    */
 638          /*                                                                                                                                              */
 639          /************************************************************************/
 640          unsigned char HighSpeed_Read(unsigned long Dst) 
 641          {
 642   1              unsigned char xdata byte = 0;   
 643   1      
 644   1              CE_Low();                               /* enable device */
 645   1              Send_Byte(0x0B);                /* read command */
 646   1              Send_Byte(((Dst & 0xFFFFFF) >> 16));    /* send 3 address bytes */
 647   1              Send_Byte(((Dst & 0xFFFF) >> 8));
 648   1              Send_Byte(Dst & 0xFF);
 649   1              Send_Byte(0xFF);                /*dummy byte*/
 650   1              byte = Get_Byte();
 651   1              CE_High();                              /* disable device */
 652   1              return byte;                    /* return one byte read */
 653   1      }
 654          
 655          /************************************************************************/
 656          /* PROCEDURE:   HighSpeed_Read_Cont                                                                             */
 657          /*                                                                                                                                              */              
 658          /* This procedure reads multiple addresses of the device and stores             */
 659          /* data into 128 byte buffer. Maximum byte that can be read is 128 bytes*/
 660          /*                                                                                                                                              */
 661          /* Input:                                                                                                                               */
 662          /*              Dst:            Destination Address 000000H - 07FFFFH                           */
 663          /*      no_bytes        Number of bytes to read (max = 128)                                     */
 664          /*                                                                                                                                              */
 665          /* Returns:                                                                                                                             */
 666          /*              Nothing                                                                                                                 */
 667          /*                                                                                                                                              */
 668          /************************************************************************/
 669          void HighSpeed_Read_Cont(unsigned long Dst, unsigned long no_bytes,uint8 *pBuffer)
 670          {
 671   1              unsigned long xdata i = 0;
 672   1              CE_Low();                                       /* enable device */
 673   1              Send_Byte(0x0B);                        /* read command */
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 51  

 674   1              Send_Byte(((Dst & 0xFFFFFF) >> 16));    /* send 3 address bytes */
 675   1              Send_Byte(((Dst & 0xFFFF) >> 8));
 676   1              Send_Byte(Dst & 0xFF);
 677   1              Send_Byte(0xFF);                        /*dummy byte*/
 678   1              for (i = 0; i < no_bytes; i++)          /* read until no_bytes is reached */
 679   1              {
 680   2                      pBuffer[i] = Get_Byte();        /* receive byte and store at address 80H - FFH */
 681   2              }
 682   1              CE_High();                                      /* disable device */
 683   1      }
 684          
 685          /************************************************************************/
 686          /* PROCEDURE:   Byte_Program                                                                                    */
 687          /*                                                                                                                                              */
 688          /* This procedure programs one address of the device.                                   */
 689          /* Assumption:  Address being programmed is already erased and is NOT   */
 690          /*                              block protected.                                                                                */
 691          /*                                                                                                                                              */
 692          /*                                                                                                                                              */
 693          /*                                                                                                                                              */
 694          /* Input:                                                                                                                               */
 695          /*              Dst:            Destination Address 000000H - 07FFFFH                           */
 696          /*              byte:           byte to be programmed                                                           */
 697          /*                                                                                                                                      */
 698          /*                                                                                                                                              */
 699          /* Returns:                                                                                                                             */
 700          /*              Nothing                                                                                                                 */
 701          /*                                                                                                                                              */
 702          /************************************************************************/
 703          void Byte_Program(unsigned long Dst, unsigned char byte)
 704          {
 705   1              CE_Low();                                       /* enable device */
 706   1              Send_Byte(0x02);                        /* send Byte Program command */
 707   1              Send_Byte(((Dst & 0xFFFFFF) >> 16));    /* send 3 address bytes */
 708   1              Send_Byte(((Dst & 0xFFFF) >> 8));
 709   1              Send_Byte(Dst & 0xFF);
 710   1              Send_Byte(byte);                        /* send byte to be programmed */
 711   1              CE_High();                                      /* disable device */
 712   1      }
 713          
 714          /************************************************************************/
 715          /* PROCEDURE:   Auto_Add_IncA                                                                                   */
 716          /*                                                                                                                                              */
 717          /* This procedure programs consecutive addresses of 2 bytes of data into*/
 718          /* the device:  1st data byte will be programmed into the initial               */
 719          /* address [A23-A1] and with A0 = 0.  The 2nd data byte will be be              */
 720          /* programmed into initial address [A23-A1] and with A0  = 1.  This             */
 721          /* is used to to start the AAI process.  It should be followed by               */
 722          /* Auto_Add_IncB.                                                                                                               */
 723          /* Assumption:  Address being programmed is already erased and is NOT   */
 724          /*                              block protected.                                                                                */
 725          /*                                                                                                                                              */
 726          /*                                                                                                                                              */
 727          /* Note: Only RDSR command can be executed once in AAI mode with SO     */
 728          /*       disable to output RY/BY# status.  Use WRDI to exit AAI mode            */
 729          /*       unless AAI is programming the last address or last address of          */
 730          /*       unprotected block, which automatically exits AAI mode.                         */
 731          /*                                                                                                                                              */
 732          /* Input:                                                                                                                               */
 733          /*              Dst:            Destination Address 000000H - 07FFFFH                           */
 734          /*          SST25VF020:Dst:     Destination Address 000000H - 03FFFFH                   */
 735          /*              byte1:          1st byte to be programmed                                                       */
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 52  

 736          /*      byte1:          2nd byte to be programmed                                                       */
 737          /*                                                                                                                                              */
 738          /* Returns:                                                                                                                             */
 739          /*              Nothing                                                                                                                 */
 740          /*                                                                                                                                              */
 741          /************************************************************************/
 742          void Auto_Add_IncA(unsigned long Dst, unsigned char byte1, unsigned char byte2)
 743          {
 744   1              CE_Low();                                       /* enable device */
 745   1              Send_Byte(0xAD);                        /* send AAI command */
 746   1              Send_Byte(((Dst & 0xFFFFFF) >> 16));    /* send 3 address bytes */
 747   1              Send_Byte(((Dst & 0xFFFF) >> 8));
 748   1              Send_Byte(Dst & 0xFF);
 749   1              Send_Byte(byte1);                       /* send 1st byte to be programmed */    
 750   1              Send_Byte(byte2);                       /* send 2nd byte to be programmed */
 751   1              CE_High();                                      /* disable device */
 752   1      }
 753          
 754          /************************************************************************/
 755          /* PROCEDURE:   Auto_Add_IncB                                                                                   */
 756          /*                                                                                                                                              */
 757          /* This procedure programs consecutive addresses of 2 bytes of data into*/
 758          /* the device:  1st data byte will be programmed into the initial               */
 759          /* address [A23-A1] and with A0 = 0.  The 2nd data byte will be be              */
 760          /* programmed into initial address [A23-A1] and with A0  = 1.    This   */
 761          /* is used after Auto_Address_IncA.                                                                             */
 762          /* Assumption:  Address being programmed is already erased and is NOT   */
 763          /*                              block protected.                                                                                */
 764          /*                                                                                                                                              */
 765          /* Note: Only WRDI and AAI command can be executed once in AAI mode     */
 766          /*       with SO enabled as RY/BY# status.  When the device is busy             */
 767          /*       asserting CE# will output the status of RY/BY# on SO.  Use WRDI        */
 768          /*       to exit AAI mode unless AAI is programming the last address or         */
 769          /*       last address of unprotected block, which automatically exits           */
 770          /*       AAI mode.                                                                                                                      */
 771          /*                                                                                                                                              */
 772          /* Input:                                                                                                                               */
 773          /*                                                                                                                                              */
 774          /*              byte1:          1st byte to be programmed                                                       */
 775          /*              byte2:          2nd byte to be programmed                                                       */
 776          /*                                                                                                                                      */
 777          /*                                                                                                                                              */
 778          /* Returns:                                                                                                                             */
 779          /*              Nothing                                                                                                                 */
 780          /*                                                                                                                                              */
 781          /************************************************************************/
 782          void Auto_Add_IncB(unsigned char byte1, unsigned char byte2)
 783          {
 784   1              CE_Low();                                       /* enable device */
 785   1              Send_Byte(0xAD);                        /* send AAI command */
 786   1              Send_Byte(byte1);                       /* send 1st byte to be programmed */
 787   1              Send_Byte(byte2);                       /* send 2nd byte to be programmed */
 788   1              CE_High();                                      /* disable device */
 789   1      }       
 790          
 791          /************************************************************************/
 792          /* PROCEDURE:   Auto_Add_IncA_EBSY                                                                              */
 793          /*                                                                                                                                              */
 794          /* This procedure is the same as procedure Auto_Add_IncA except that it */
 795          /* uses EBSY and Poll_SO functions to check for RY/BY. It programs              */
 796          /* consecutive addresses of the device.  The 1st data byte will be              */
 797          /* programmed into the initial address [A23-A1] and with A0 = 0.  The   */
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 53  

 798          /* 2nd data byte will be programmed into initial address [A23-A1] and   */
 799          /* with A0  = 1.  This is used to to start the AAI process.  It should  */
 800          /* be followed by Auto_Add_IncB_EBSY.                                                                   */
 801          /* Assumption:  Address being programmed is already erased and is NOT   */
 802          /*                              block protected.                                                                                */
 803          /*                                                                                                                                              */
 804          /*                                                                                                                                              */
 805          /* Note: Only WRDI and AAI command can be executed once in AAI mode     */
 806          /*       with SO enabled as RY/BY# status.  When the device is busy                     */
 807          /*       asserting CE# will output the status of RY/BY# on SO.  Use WRDI        */
 808          /*       to exit AAI mode unless AAI is programming the last address or         */
 809          /*       last address of unprotected block, which automatically exits           */
 810          /*       AAI mode.                                                                                                                      */
 811          /*                                                                                                                                              */
 812          /* Input:                                                                                                                               */
 813          /*              Dst:            Destination Address 000000H - 07FFFFH                           */
 814          /*              byte1:          1st byte to be programmed                                                       */
 815          /*      byte1:          2nd byte to be programmed                                                       */
 816          /*                                                                                                                                              */
 817          /* Returns:                                                                                                                             */
 818          /*              Nothing                                                                                                                 */
 819          /*                                                                                                                                              */
 820          /************************************************************************/
 821          void Auto_Add_IncA_EBSY(unsigned long Dst, unsigned char byte1, unsigned char byte2)
 822          {
 823   1              EBSY();                                 /* enable RY/BY# status for SO in AAI */        
 824   1      
 825   1              CE_Low();                               /* enable device */
 826   1              Send_Byte(0xAD);                        /* send AAI command */
 827   1              Send_Byte(((Dst & 0xFFFFFF) >> 16));    /* send 3 address bytes */
 828   1              Send_Byte(((Dst & 0xFFFF) >> 8));
 829   1              Send_Byte(Dst & 0xFF);
 830   1              Send_Byte(byte1);                       /* send 1st byte to be programmed */    
 831   1              Send_Byte(byte2);                       /* send 2nd byte to be programmed */
 832   1              CE_High();                              /* disable device */
 833   1              
 834   1              Poll_SO();                              /* polls RY/BY# using SO line */
 835   1      
 836   1      }
 837          
 838          /************************************************************************/
 839          /* PROCEDURE:   Auto_Add_IncB_EBSY                                                                              */
 840          /*                                                                                                                                              */
 841          /* This procedure is the same as Auto_Add_IncB excpet that it uses              */
 842          /* Poll_SO to poll for RY/BY#.  It demonstrate on how to use DBSY after */
 843          /* AAI programmming is completed.  It programs consecutive addresses of */
 844          /* the device.  The 1st data byte will be programmed into the initial   */
 845          /* address [A23-A1] and with A0 = 0.  The 2nd data byte will be                 */
 846          /* programmed into initial address [A23-A1] and with A0  = 1.  This is  */
 847          /* used after Auto_Address_IncA.                                                                                */
 848          /* Assumption:  Address being programmed is already erased and is NOT   */
 849          /*                              block protected.                                                                                */
 850          /*                                                                                                                                              */
 851          /* Note: Only WRDI and AAI command can be executed once in AAI mode     */
 852          /*       with SO enabled as RY/BY# status.  When the device is busy             */
 853          /*       asserting CE# will output the status of RY/BY# on SO.  Use WRDI        */
 854          /*       to exit AAI mode unless AAI is programming the last address or         */
 855          /*       last address of unprotected block, which automatically exits           */
 856          /*       AAI mode.                                                                                                                      */
 857          /*                                                                                                                                              */
 858          /* Input:                                                                                                                               */
 859          /*                                                                                                                                              */
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 54  

 860          /*              byte1:          1st byte to be programmed                                                       */
 861          /*              byte2:          2nd byte to be programmed                                                       */
 862          /*                                                                                                                                      */
 863          /*                                                                                                                                              */
 864          /* Returns:                                                                                                                             */
 865          /*              Nothing                                                                                                                 */
 866          /*                                                                                                                                              */
 867          /************************************************************************/
 868          void Auto_Add_IncB_EBSY(unsigned char byte1, unsigned char byte2)
 869          {
 870   1              CE_Low();                                       /* enable device */
 871   1              Send_Byte(0xAD);                        /* send AAI command */
 872   1              Send_Byte(byte1);                       /* send 1st byte to be programmed */
 873   1              Send_Byte(byte2);                       /* send 2nd byte to be programmed */
 874   1              CE_High();                                      /* disable device */
 875   1      
 876   1              Poll_SO();                                      /* polls RY/BY# using SO line */
 877   1              
 878   1              WRDI();                                         /* Exit AAI before executing DBSY */
 879   1              DBSY();                                         /* disable SO as RY/BY# output if in AAI */
 880   1      }       
 881          
 882          /************************************************************************/
 883          /* PROCEDURE: Chip_Erase                                                                                                */
 884          /*                                                                                                                                              */
 885          /* This procedure erases the entire Chip.                                                               */
 886          /*                                                                                                                                              */
 887          /* Input:                                                                                                                               */
 888          /*              None                                                                                                                    */
 889          /*                                                                                                                                              */
 890          /* Returns:                                                                                                                             */
 891          /*              Nothing                                                                                                                 */
 892          /************************************************************************/
 893          void Chip_Erase()
 894          {                                               
 895   1              CE_Low();                                       /* enable device */
 896   1      //      Send_Byte(0x60);                        /* send Chip Erase command (60h or C7h) */
 897   1              Send_Byte(0xc7);                        /* send Chip Erase command (60h or C7h) */
 898   1              CE_High();                                      /* disable device */
 899   1      }
 900          
 901          /************************************************************************/
 902          /* PROCEDURE: Sector_Erase                                                                                              */
 903          /*                                                                                                                                              */
 904          /* This procedure Sector Erases the Chip.                                                               */
 905          /*                                                                                                                                              */
 906          /* Input:                                                                                                                               */
 907          /*              Dst:            Destination Address 000000H - 07FFFFH                           */
 908          /*                                                                                                                                              */
 909          /* Returns:                                                                                                                             */
 910          /*              Nothing                                                                                                                 */
 911          /************************************************************************/
 912          void Sector_Erase(unsigned long Dst)
 913          {
 914   1      
 915   1      
 916   1              CE_Low();                                       /* enable device */
 917   1              Send_Byte(0x20);                        /* send Sector Erase command */
 918   1              Send_Byte(((Dst & 0xFFFFFF) >> 16));    /* send 3 address bytes */
 919   1              Send_Byte(((Dst & 0xFFFF) >> 8));
 920   1              Send_Byte(Dst & 0xFF);
 921   1              CE_High();                                      /* disable device */
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 55  

 922   1      }
 923          
 924          /************************************************************************/
 925          /* PROCEDURE: Block_Erase_32K                                                                                   */
 926          /*                                                                                                                                              */
 927          /* This procedure Block Erases 32 KByte of the Chip.                                    */
 928          /*                                                                                                                                              */
 929          /* Input:                                                                                                                               */
 930          /*              Dst:            Destination Address 000000H - 07FFFFH                           */
 931          /*                                                                                                                                              */
 932          /* Returns:                                                                                                                             */
 933          /*              Nothing                                                                                                                 */
 934          /************************************************************************/
 935          void Block_Erase_32K(unsigned long Dst)
 936          {
 937   1              CE_Low();                                       /* enable device */
 938   1              Send_Byte(0x52);                        /* send 32 KByte Block Erase command */
 939   1              Send_Byte(((Dst & 0xFFFFFF) >> 16));    /* send 3 address bytes */
 940   1              Send_Byte(((Dst & 0xFFFF) >> 8));
 941   1              Send_Byte(Dst & 0xFF);
 942   1              CE_High();                                      /* disable device */
 943   1      }       
 944          
 945          /************************************************************************/
 946          /* PROCEDURE: Block_Erase_64K                                                                                   */
 947          /*                                                                                                                                              */
 948          /* This procedure Block Erases 64 KByte of the Chip.                                    */
 949          /*                                                                                                                                              */
 950          /* Input:                                                                                                                               */
 951          /*              Dst:            Destination Address 000000H - 07FFFFH                           */
 952          /*                                                                                                                                              */
 953          /* Returns:                                                                                                                             */
 954          /*              Nothing                                                                                                                 */
 955          /************************************************************************/
 956          void Block_Erase_64K(unsigned long Dst)
 957          {
 958   1              CE_Low();                                       /* enable device */
 959   1              Send_Byte(0xD8);                        /* send 64KByte Block Erase command */
 960   1              Send_Byte(((Dst & 0xFFFFFF) >> 16));    /* send 3 address bytes */
 961   1              Send_Byte(((Dst & 0xFFFF) >> 8));
 962   1              Send_Byte(Dst & 0xFF);
 963   1              CE_High();                                      /* disable device */
 964   1      }
 965          
 966          /************************************************************************/
 967          /* PROCEDURE: Wait_Busy                                                                                                 */
 968          /*                                                                                                                                              */
 969          /* This procedure waits until device is no longer busy (can be used by  */
 970          /* Byte-Program, Sector-Erase, Block-Erase, Chip-Erase).                                */
 971          /*                                                                                                                                              */
 972          /* Input:                                                                                                                               */
 973          /*              None                                                                                                                    */
 974          /*                                                                                                                                              */
 975          /* Returns:                                                                                                                             */
 976          /*              Nothing                                                                                                                 */
 977          /************************************************************************/
 978          void Wait_Busy()
 979          {
 980   1      while ((Read_Status_Register()&0x01) == 0x01)   /* waste time until not busy */
 981   1              {
 982   2                      delay_nus(10);
 983   2              }
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 56  

 984   1      
 985   1      }
 986          
 987          /************************************************************************/
 988          /* PROCEDURE: Wait_Busy_AAI                                                                                             */
 989          /*                                                                                                                                              */
 990          /* This procedure waits until device is no longer busy for AAI mode.    */
 991          /*                                                                                                                                              */
 992          /* Input:                                                                                                                               */
 993          /*              None                                                                                                                    */
 994          /*                                                                                                                                              */
 995          /* Returns:                                                                                                                             */
 996          /*              Nothing                                                                                                                 */
 997          /************************************************************************/
 998          void Wait_Busy_AAI()
 999          {
1000   1      while ((Read_Status_Register()&0X40) == 0x40)   /* waste time until not busy */
1001   1              {
1002   2                      delay_nms(1);
1003   2              }
1004   1      }
1005          
1006          /************************************************************************/
1007          /* PROCEDURE: WREN_Check                                                                                                */
1008          /*                                                                                                                                              */
1009          /* This procedure checks to see if WEL bit set before program/erase.    */
1010          /*                                                                                                                                              */
1011          /* Input:                                                                                                                               */
1012          /*              None                                                                                                                    */
1013          /*                                                                                                                                              */
1014          /* Returns:                                                                                                                             */
1015          /*              Nothing                                                                                                                 */
1016          /************************************************************************/
1017          void WREN_Check()
1018          {
1019   1              unsigned char xdata byte;
1020   1              byte = Read_Status_Register();  /* read the status register */
1021   1              if ((byte & 0x02)!= 0x02)                               /* verify that WEL bit is set */
1022   1              {
1023   2                      while(1) ;
1024   2                              /* add source code or statements for this file */
1025   2                              /* to compile                                  */
1026   2                              /* i.e. option: insert a display to view error on LED? */
1027   2              }
1028   1      }
1029          
1030          /************************************************************************/
1031          /* PROCEDURE: WREN_AAI_Check                                                                                    */
1032          /*                                                                                                                                              */
1033          /* This procedure checks for AAI and WEL bit once in AAI mode.                  */
1034          /*                                                                                                                                              */
1035          /* Input:                                                                                                                               */
1036          /*              None                                                                                                                    */
1037          /*                                                                                                                                              */
1038          /* Returns:                                                                                                                             */
1039          /*              Nothing                                                                                                                 */
1040          /************************************************************************/
1041          void WREN_AAI_Check()
1042          {
1043   1              unsigned char xdata byte;
1044   1              byte = Read_Status_Register();  /* read the status register */
1045   1              if ((byte&0x42) != 0x42)                                /* verify that AAI and WEL bit is set */
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 57  

1046   1              {
1047   2                      while(1);               
1048   2                              /* add source code or statements for this file */
1049   2                              /* to compile                                  */
1050   2                              /* i.e. option: insert a display to view error on LED? */
1051   2              }
1052   1      }
1053          
1054          /************************************************************************/
1055          /* PROCEDURE: Verify                                                                                                    */
1056          /*                                                                                                                                              */
1057          /* This procedure checks to see if the correct byte has be read.                */
1058          /*                                                                                                                                              */
1059          /* Input:                                                                                                                               */
1060          /*              byte:           byte read                                                                                       */
1061          /*              cor_byte:       correct_byte that should be read                                        */
1062          /*                                                                                                                                              */
1063          /* Returns:                                                                                                                             */
1064          /*              Nothing                                                                                                                 */
1065          /************************************************************************/
1066          void Verify(unsigned char byte, unsigned char cor_byte)
1067          {
1068   1              if (byte != cor_byte)
1069   1              {
1070   2                      while(1)  ;
1071   2                              /* add source code or statement for this file */
1072   2                              /* to compile                                  */
1073   2                              /* i.e. option: insert a display to view error on LED? */
1074   2              }
1075   1      }
1076          
1077          
1078          
1079          void Byte_Write(unsigned long Dst, unsigned char byte)
1080          {
1081   1              WREN();
1082   1              Sector_Erase(Dst);
1083   1              Wait_Busy();
1084   1      //      delay_nms(25);
1085   1      
1086   1              WREN();
1087   1              Byte_Program(Dst,byte);
1088   1              Wait_Busy();
1089   1      //      delay_nus(20);
1090   1      }
1091          
1092          
1093          //SST25VF032
1094          void AAI_Write(unsigned long Dst, uint8 *p,uint8 no_bytes)
1095          {
1096   1              WREN();
1097   1              Sector_Erase(Dst);
1098   1      //      delay_nms(25);
1099   1              Wait_Busy();
1100   1      
1101   1      
1102   1              
1103   1              WREN();
1104   1              Auto_Add_IncA_EBSY(Dst,*p,*(p+1));
1105   1      
1106   1              no_bytes -=2;
1107   1              p +=2;
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 58  

1108   1      
1109   1              for(;no_bytes>2;)
1110   1              {
1111   2                      CE_Low();                                       
1112   2                      Send_Byte(0xAD);                        
1113   2                      Send_Byte(*p);                  
1114   2                      Send_Byte(*(p+1));                      
1115   2                      CE_High();                                      
1116   2                      
1117   2                      Poll_SO();                                      
1118   2                      no_bytes -=2;
1119   2                      p +=2;
1120   2      
1121   2              }
1122   1              
1123   1              Auto_Add_IncB_EBSY(*p,*(p+1));
1124   1      
1125   1      }
1126          
1127          
1128          
1129          //SST25VF020 SST25VF040 
1130          /*void AAI_Write(unsigned long Dst, uint8 *p,uint8 no_bytes)
1131          {
1132                  WREN();
1133                  Sector_Erase(Dst);
1134          //      delay_nms(25);
1135                  Wait_Busy();
1136          
1137          
1138                  
1139                  WREN(); 
1140                  CE_Low();                               //enable device
1141                  Send_Byte(0xAF);                        //send AAI command 
1142                  Send_Byte(((Dst & 0xFFFFFF) >> 16));    //send 3 address bytes 
1143                  Send_Byte(((Dst & 0xFFFF) >> 8));
1144                  Send_Byte(Dst & 0xFF);
1145                  Send_Byte(*p);                  //send 1st byte to be programmed 
1146                  CE_High();                              // disable device 
1147                  
1148          //      delay_nus(30);                  //ÑÓÊ±30us
1149                  Wait_Busy();
1150          
1151                  no_bytes--;
1152                  p ++;
1153          
1154                  for(;no_bytes>0;)
1155                  {
1156                          CE_Low();                                       //enable device 
1157                          Send_Byte(0xAf);                        //send AAI command 
1158                          Send_Byte(*p);                  //send 1st byte to be programmed 
1159                          CE_High();                                      // disable device 
1160                          //delay_nus(30);                        //ÑÓÊ±30us
1161                          Wait_Busy();
1162          
1163                          no_bytes -=1;
1164                          p +=1;
1165          
1166                  }
1167                  
1168                  
1169                  WRDI();                                         //Exit AAI before executing DBSY 
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 59  

1170          //      delay_nus(30);                          //ÑÓÊ±30us
1171                  Wait_Busy();
1172                  
1173          }
1174          */      
1175          
1176          //Ô­ÒÑÕû¸öÉÈÇø²Á³ý,²»ÔÙÌ½³ý
1177          void Byte_Write1(unsigned long Dst, unsigned char byte)
1178          {
1179   1              WREN();
1180   1              Byte_Program(Dst,byte);
1181   1              Wait_Busy();
1182   1      //      delay_nus(20);
1183   1      }
1184          
1185          
1186          
1187          
1188          //SST25VF032
1189          //Ô­ÒÑÕû¸öÉÈÇø²Á³ý,²»ÔÙÌ½³ý
1190          void AAI_Write1(unsigned long Dst, uint8 *p,uint8 no_bytes)
1191          {
1192   1      
1193   1              WREN();
1194   1              Auto_Add_IncA_EBSY(Dst,*p,*(p+1));
1195   1      
1196   1              no_bytes -=2;
1197   1              p +=2;
1198   1      
1199   1              for(;no_bytes>2;)
1200   1              {
1201   2                      CE_Low();                                       
1202   2                      Send_Byte(0xAD);                        
1203   2                      Send_Byte(*p);                  
1204   2                      Send_Byte(*(p+1));                      
1205   2                      CE_High();                                      
1206   2                      
1207   2                      Poll_SO();                                      
1208   2                      no_bytes -=2;
1209   2                      p +=2;
1210   2      
1211   2              }
1212   1              
1213   1              Auto_Add_IncB_EBSY(*p,*(p+1));
1214   1      
1215   1      }
1216          
1217          
1218          
1219          ////SST25VF020 SST25VF040
1220          /*void AAI_Write1(unsigned long Dst, uint8 *p,uint8 no_bytes)
1221          {       
1222                  WREN(); 
1223                  CE_Low();                               // enable device 
1224                  Send_Byte(0xAF);                        //send AAI command 
1225                  Send_Byte(((Dst & 0xFFFFFF) >> 16));    //send 3 address bytes 
1226                  Send_Byte(((Dst & 0xFFFF) >> 8));
1227                  Send_Byte(Dst & 0xFF);
1228                  Send_Byte(*p);                  //send 1st byte to be programmed        
1229                  CE_High();                              //disable device 
1230                  
1231          //      delay_nus(30);                  //ÑÓÊ±30us
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 60  

1232                  Wait_Busy();
1233          
1234                  no_bytes--;
1235                  p ++;
1236          
1237                  for(;no_bytes>0;)
1238                  {
1239                          CE_Low();                                       // enable device 
1240                          Send_Byte(0xAf);                        // send AAI command 
1241                          Send_Byte(*p);                  //send 1st byte to be programmed 
1242                          CE_High();                                      //disable device 
1243          //              delay_nus(30);                  //ÑÓÊ±30us
1244                          Wait_Busy();
1245          
1246                          no_bytes -=1;
1247                          p +=1;
1248          
1249                  }
1250                  
1251                  
1252                  WRDI();                                         // Exit AAI before executing DBSY 
1253          //      delay_nus(30);                          //ÑÓÊ±30us
1254                  Wait_Busy();
1255                  
1256          }
1257          
1258          /**********************************************************
1259          *º¯ÊýÃû³Æ                       :FRAM_TEST      
1260          *º¯ÊýÃèÊö               :´æ´¢Ð¾Æ¬²âÊÔ²Ù×÷
1261          *ÊäÈë²ÎÊý               :
1262          *·µ»ØÖµ                         :       
1263          *È«¾Ö±äÁ¿                       :
1264          *µ÷ÓÃÄ£¿é                       :
1265          ***********************************************************
1266          *´´½¨ÈË                 :ÒüÔËÍ¬
1267          *´´½¨ÈÕÆÚ                       :2008-9-22
1268          ***********************************************************
1269          *ÐÞ¸ÄÈË                         :
1270          *ÐÞ¸ÄÈÕÆÚ               :
1271          *×¢ÊÍ                   :
1272          **********************************************************/
1273          void FRAM_TEST(void)
1274          {
1275   1               unsigned char xdata i;
1276   1      
1277   1               FRAM_BUFF[0]=0x11;
1278   1               FRAM_BUFF[1]=0x22;
1279   1               FRAM_BUFF[2]=0x33;
1280   1               FRAM_BUFF[3]=0x44;
1281   1               FRAM_BUFF[4]=0x55;
1282   1               FRAM_BUFF[5]=0x66;     
1283   1      
1284   1               FRAM_BUFF[6]=0x77;
1285   1               FRAM_BUFF[7]=0x88;
1286   1               FRAM_BUFF[8]=0x99;
1287   1               FRAM_BUFF[9]=0xaa;
1288   1               FRAM_BUFF[10]=0xbb;
1289   1      
1290   1               
1291   1      /*       Byte_Write(0x000000,FRAM_BUFF[0]);
1292   1               AAI_Write1(0x000002,&(FRAM_BUFF[1]),10);
1293   1               
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 61  

1294   1               for(i=0;i<20;i++) FRAM_BUFF[i]=0;
1295   1               delay_nms(10);
1296   1      
1297   1               FRAM_BUFF[0]=Read(0x000000);
1298   1               Read_Cont(0x000002,10,&(FRAM_BUFF[1]));
1299   1               delay_nms(10);
1300   1               Send_Data(FRAM_BUFF,11);
1301   1      */       
1302   1      
1303   1      
1304   1              //SST25VF032   ²âÊÔ´æ´¢Êý¾Ý×î¶àÖ»µ½0x7fff0
1305   1               AAI_Write1(0x7fff1,&(FRAM_BUFF[0]),11);
1306   1               
1307   1               for(i=0;i<20;i++) FRAM_BUFF[i]=0;
1308   1               delay_nms(10);
1309   1      
1310   1               Read_Cont(0x7fff1,11,&(FRAM_BUFF[0]));
1311   1               delay_nms(10);
1312   1               Send_Data(FRAM_BUFF,11);
1313   1      
1314   1      /*      Byte_Write(0x7fff0,0x11);
1315   1              delay_nms(1);
1316   1              Send_Data_Byte(Read(0x7fff0));  
1317   1      
1318   1              Byte_Write(0x7fffe,0x11);
1319   1              delay_nms(1);
1320   1              Send_Data_Byte(Read(0x7fffe));  
1321   1      
1322   1              Byte_Write(0x100000,0x22);
1323   1              delay_nms(1);
1324   1              Send_Data_Byte(Read(0x100000)); 
1325   1      
1326   1      
1327   1              Byte_Write(0x300000,0xbb);
1328   1              delay_nms(1);
1329   1              Send_Data_Byte(Read(0x300000));*/
1330   1      
1331   1      /*       Read_Cont(0x000002,20,FRAM_BUFF);       
1332   1               Send_Data(FRAM_BUFF,20);
1333   1      */
1334   1      }
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 62  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION SST25VF_Init (BEGIN)
                                           ; SOURCE LINE # 161
                                           ; SOURCE LINE # 162
                                           ; SOURCE LINE # 165
0000 120000      R     LCALL   Read_Status_Register
0003 120000      E     LCALL   _Send_Data_Byte
                                           ; SOURCE LINE # 166
0006 120000      R     LCALL   EWSR
                                           ; SOURCE LINE # 167
0009 7F01              MOV     R7,#01H
000B 7E00              MOV     R6,#00H
000D 120000      E     LCALL   _delay_nms
                                           ; SOURCE LINE # 168
0010 E4                CLR     A
0011 FF                MOV     R7,A
0012 FE                MOV     R6,A
0013 120000      R     LCALL   _WRSR
                                           ; SOURCE LINE # 169
0016 7F01              MOV     R7,#01H
0018 7E00              MOV     R6,#00H
001A 120000      E     LCALL   _delay_nms
                                           ; SOURCE LINE # 170
001D 120000      R     LCALL   Read_Status_Register
0020 020000      E     LJMP    _Send_Data_Byte
             ; FUNCTION SST25VF_Init (END)

             ; FUNCTION L?0074 (BEGIN)
0000         L?0075:
0000 A3                INC     DPTR
0001 E0                MOVX    A,@DPTR
0002 FD                MOV     R5,A
0003 A3                INC     DPTR
0004 E0                MOVX    A,@DPTR
0005 FE                MOV     R6,A
0006 A3                INC     DPTR
0007 E0                MOVX    A,@DPTR
0008 FF                MOV     R7,A
0009 E4                CLR     A
000A 7810              MOV     R0,#010H
000C         L?0076:
000C FC                MOV     R4,A
000D 120000      E     LCALL   ?C?ULSHR
             ; FUNCTION _Send_Byte (BEGIN)
                                           ; SOURCE LINE # 185
;---- Variable 'out' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 186
                                           ; SOURCE LINE # 200
0010 020000      E     LJMP    _SPI_WriteByte
             ; FUNCTION _Send_Byte (END)

             ; FUNCTION L?0078 (BEGIN)
0000 900000      R     MOV     DPTR,#temp
0003 E0                MOVX    A,@DPTR
0004 F8                MOV     R0,A
0005 A3                INC     DPTR
0006 E0                MOVX    A,@DPTR
0007 F9                MOV     R1,A
0008 A3                INC     DPTR
0009 E0                MOVX    A,@DPTR
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 63  

000A FA                MOV     R2,A
000B A3                INC     DPTR
000C E0                MOVX    A,@DPTR
000D 4F                ORL     A,R7
000E FF                MOV     R7,A
000F EA                MOV     A,R2
0010 FE                MOV     R6,A
0011 E9                MOV     A,R1
0012 FD                MOV     R5,A
0013 E8                MOV     A,R0
0014 FC                MOV     R4,A
0015 7808              MOV     R0,#08H
0017 120000      E     LCALL   ?C?LSHL
001A 900000      R     MOV     DPTR,#temp
001D 120000      E     LCALL   ?C?LSTXDATA
             ; FUNCTION Get_Byte (BEGIN)
                                           ; SOURCE LINE # 215
                                           ; SOURCE LINE # 216
                                           ; SOURCE LINE # 232
0020 E4                CLR     A
0021 FF                MOV     R7,A
0022 120000      E     LCALL   _SPI_WriteByte
;---- Variable 'in' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 233
                                           ; SOURCE LINE # 234
0025         ?C0003:
0025 22                RET     
             ; FUNCTION Get_Byte (END)

             ; FUNCTION L?0083 (BEGIN)
0000 120000      R     LCALL   CE_High
             ; FUNCTION Poll_SO (BEGIN)
                                           ; SOURCE LINE # 249
                                           ; SOURCE LINE # 250
                                           ; SOURCE LINE # 251
0003 E4                CLR     A
0004 900000      R     MOV     DPTR,#temp
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 252
0008 120000      R     LCALL   CE_Low
000B         ?C0004:
                                           ; SOURCE LINE # 253
000B 900000      R     MOV     DPTR,#temp
000E E0                MOVX    A,@DPTR
000F 7006              JNZ     ?C0005
                                           ; SOURCE LINE # 254
0011 A296              MOV     C,MISO
0013 33                RLC     A
0014 F0                MOVX    @DPTR,A
0015 80F4              SJMP    ?C0004
0017         ?C0005:
                                           ; SOURCE LINE # 255
0017 020000      R     LJMP    CE_High
             ; FUNCTION Poll_SO (END)

             ; FUNCTION CE_High (BEGIN)
                                           ; SOURCE LINE # 270
                                           ; SOURCE LINE # 271
                                           ; SOURCE LINE # 272
0000 D294              SETB    SST25VF_CS
                                           ; SOURCE LINE # 273
0002 22                RET     
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 64  

             ; FUNCTION CE_High (END)

             ; FUNCTION L?0080 (BEGIN)
0000 120000      E     LCALL   ?C?LSTXDATA
             ; FUNCTION CE_Low (BEGIN)
                                           ; SOURCE LINE # 287
                                           ; SOURCE LINE # 288
                                           ; SOURCE LINE # 289
0003 C294              CLR     SST25VF_CS
                                           ; SOURCE LINE # 290
0005 22                RET     
             ; FUNCTION CE_Low (END)

             ; FUNCTION Hold_Low (BEGIN)
                                           ; SOURCE LINE # 303
                                           ; SOURCE LINE # 304
                                           ; SOURCE LINE # 308
0000 22                RET     
             ; FUNCTION Hold_Low (END)

             ; FUNCTION Unhold (BEGIN)
                                           ; SOURCE LINE # 321
                                           ; SOURCE LINE # 322
                                           ; SOURCE LINE # 326
0000 22                RET     
             ; FUNCTION Unhold (END)

             ; FUNCTION WP_Low (BEGIN)
                                           ; SOURCE LINE # 339
                                           ; SOURCE LINE # 340
                                           ; SOURCE LINE # 344
0000 22                RET     
             ; FUNCTION WP_Low (END)

             ; FUNCTION UnWP (BEGIN)
                                           ; SOURCE LINE # 357
                                           ; SOURCE LINE # 358
                                           ; SOURCE LINE # 362
0000 22                RET     
             ; FUNCTION UnWP (END)

             ; FUNCTION Read_Status_Register (BEGIN)
                                           ; SOURCE LINE # 375
                                           ; SOURCE LINE # 376
                                           ; SOURCE LINE # 377
;---- Variable 'byte' assigned to Register 'R7' ----
0000 E4                CLR     A
0001 FF                MOV     R7,A
                                           ; SOURCE LINE # 378
0002 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 379
0005 7F05              MOV     R7,#05H
0007 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 380
000A 120000      R     LCALL   Get_Byte
                                           ; SOURCE LINE # 381
000D 120000      R     LCALL   CE_High
                                           ; SOURCE LINE # 382
                                           ; SOURCE LINE # 383
0010         ?C0013:
0010 22                RET     
             ; FUNCTION Read_Status_Register (END)
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 65  


             ; FUNCTION EWSR (BEGIN)
                                           ; SOURCE LINE # 396
                                           ; SOURCE LINE # 397
                                           ; SOURCE LINE # 398
0000 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 399
0003 7F50              MOV     R7,#050H
0005 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 400
0008 020000      R     LJMP    CE_High
             ; FUNCTION EWSR (END)

             ; FUNCTION _WRSR (BEGIN)
                                           ; SOURCE LINE # 414
0000 900000      R     MOV     DPTR,#byte
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 415
                                           ; SOURCE LINE # 416
0008 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 417
000B 7F01              MOV     R7,#01H
000D 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 418
0010 900000      R     MOV     DPTR,#byte
0013 A3                INC     DPTR
0014 E0                MOVX    A,@DPTR
0015 FF                MOV     R7,A
0016 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 420
0019 020000      R     LJMP    CE_High
             ; FUNCTION _WRSR (END)

             ; FUNCTION L?0082 (BEGIN)
0000 EB                MOV     A,R3
0001 F0                MOVX    @DPTR,A
0002 A3                INC     DPTR
0003 EA                MOV     A,R2
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 E9                MOV     A,R1
0007 F0                MOVX    @DPTR,A
             ; FUNCTION WREN (BEGIN)
                                           ; SOURCE LINE # 435
                                           ; SOURCE LINE # 436
                                           ; SOURCE LINE # 437
0008 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 438
000B 7F06              MOV     R7,#06H
000D 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 439
0010 120000      R     LCALL   CE_High
                                           ; SOURCE LINE # 440
0013 020000      R     LJMP    Wait_Busy
             ; FUNCTION WREN (END)

             ; FUNCTION WRDI (BEGIN)
                                           ; SOURCE LINE # 455
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 66  

                                           ; SOURCE LINE # 456
                                           ; SOURCE LINE # 457
0000 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 458
0003 7F04              MOV     R7,#04H
0005 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 459
0008 020000      R     LJMP    CE_High
             ; FUNCTION WRDI (END)

             ; FUNCTION EBSY (BEGIN)
                                           ; SOURCE LINE # 474
                                           ; SOURCE LINE # 475
                                           ; SOURCE LINE # 476
0000 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 477
0003 7F70              MOV     R7,#070H
0005 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 478
0008 020000      R     LJMP    CE_High
             ; FUNCTION EBSY (END)

             ; FUNCTION DBSY (BEGIN)
                                           ; SOURCE LINE # 493
                                           ; SOURCE LINE # 494
                                           ; SOURCE LINE # 495
0000 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 496
0003 7F80              MOV     R7,#080H
0005 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 497
0008 020000      R     LJMP    CE_High
             ; FUNCTION DBSY (END)

             ; FUNCTION _Read_ID (BEGIN)
                                           ; SOURCE LINE # 517
0000 900000      R     MOV     DPTR,#ID_addr
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 518
                                           ; SOURCE LINE # 520
0008 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 521
000B 7F90              MOV     R7,#090H
000D 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 522
0010 E4                CLR     A
0011 FF                MOV     R7,A
0012 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 523
0015 E4                CLR     A
0016 FF                MOV     R7,A
0017 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 524
001A 900000      R     MOV     DPTR,#ID_addr
001D A3                INC     DPTR
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 120000      R     LCALL   _Send_Byte
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 67  

                                           ; SOURCE LINE # 525
0023 120000      R     LCALL   Get_Byte
;---- Variable 'byte' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 526
0026 120000      R     LCALL   CE_High
                                           ; SOURCE LINE # 527
                                           ; SOURCE LINE # 528
0029         ?C0020:
0029 22                RET     
             ; FUNCTION _Read_ID (END)

             ; FUNCTION Jedec_ID_Read (BEGIN)
                                           ; SOURCE LINE # 545
                                           ; SOURCE LINE # 546
                                           ; SOURCE LINE # 549
0000 900000      R     MOV     DPTR,#temp
0003 120000      E     LCALL   ?C?LSTKXDATA
0006 00                DB      00H
0007 00                DB      00H
0008 00                DB      00H
0009 00                DB      00H
                                           ; SOURCE LINE # 551
000A 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 552
000D 7F9F              MOV     R7,#09FH
000F 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 553
0012 120000      R     LCALL   Get_Byte
                                           ; SOURCE LINE # 554
0015 120000      R     LCALL   L?0078
                                           ; SOURCE LINE # 555
0018 120000      R     LCALL   L?0078
001B 900000      R     MOV     DPTR,#temp
001E E0                MOVX    A,@DPTR
001F F8                MOV     R0,A
0020 A3                INC     DPTR
0021 E0                MOVX    A,@DPTR
0022 F9                MOV     R1,A
0023 A3                INC     DPTR
0024 E0                MOVX    A,@DPTR
0025 FA                MOV     R2,A
0026 A3                INC     DPTR
0027 E0                MOVX    A,@DPTR
0028 4F                ORL     A,R7
0029 FF                MOV     R7,A
002A EA                MOV     A,R2
002B FE                MOV     R6,A
002C E9                MOV     A,R1
002D FD                MOV     R5,A
002E E8                MOV     A,R0
002F FC                MOV     R4,A
0030 900000      R     MOV     DPTR,#temp
0033 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 556
0036 120000      R     LCALL   CE_High
                                           ; SOURCE LINE # 558
0039 900000      R     MOV     DPTR,#temp
003C E0                MOVX    A,@DPTR
003D FC                MOV     R4,A
003E A3                INC     DPTR
003F E0                MOVX    A,@DPTR
0040 FD                MOV     R5,A
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 68  

0041 A3                INC     DPTR
0042 E0                MOVX    A,@DPTR
0043 FE                MOV     R6,A
0044 A3                INC     DPTR
0045 E0                MOVX    A,@DPTR
0046 FF                MOV     R7,A
                                           ; SOURCE LINE # 559
0047         ?C0021:
0047 22                RET     
             ; FUNCTION Jedec_ID_Read (END)

             ; FUNCTION _Read (BEGIN)
                                           ; SOURCE LINE # 578
0000 900000      R     MOV     DPTR,#Dst
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 579
                                           ; SOURCE LINE # 580
;---- Variable 'byte' assigned to Register 'R7' ----
0006 E4                CLR     A
0007 FF                MOV     R7,A
                                           ; SOURCE LINE # 582
0008 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 583
000B 7F03              MOV     R7,#03H
000D 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 584
0010 900000      R     MOV     DPTR,#Dst
0013 120000      R     LCALL   L?0074
                                           ; SOURCE LINE # 585
0016 900000      R     MOV     DPTR,#Dst
0019 A3                INC     DPTR
001A A3                INC     DPTR
001B E0                MOVX    A,@DPTR
001C FE                MOV     R6,A
001D A3                INC     DPTR
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 E4                CLR     A
0021 FD                MOV     R5,A
0022 7808              MOV     R0,#08H
0024 120000      R     LCALL   L?0076
                                           ; SOURCE LINE # 586
0027 900000      R     MOV     DPTR,#Dst
002A E0                MOVX    A,@DPTR
002B FC                MOV     R4,A
002C A3                INC     DPTR
002D E0                MOVX    A,@DPTR
002E FD                MOV     R5,A
002F A3                INC     DPTR
0030 E0                MOVX    A,@DPTR
0031 FE                MOV     R6,A
0032 A3                INC     DPTR
0033 E0                MOVX    A,@DPTR
0034 FF                MOV     R7,A
0035 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 587
0038 120000      R     LCALL   Get_Byte
                                           ; SOURCE LINE # 588
003B 120000      R     LCALL   CE_High
                                           ; SOURCE LINE # 589
                                           ; SOURCE LINE # 590
003E         ?C0022:
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 69  

003E 22                RET     
             ; FUNCTION _Read (END)

             ; FUNCTION _Read_Cont (BEGIN)
                                           ; SOURCE LINE # 607
0000 900000      R     MOV     DPTR,#Dst
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 608
                                           ; SOURCE LINE # 609
0006 900000      R     MOV     DPTR,#i
0009 120000      E     LCALL   ?C?LSTKXDATA
000C 00                DB      00H
000D 00                DB      00H
000E 00                DB      00H
000F 00                DB      00H
                                           ; SOURCE LINE # 610
0010 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 611
0013 7F03              MOV     R7,#03H
0015 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 612
0018 900000      R     MOV     DPTR,#Dst
001B 120000      R     LCALL   L?0074
                                           ; SOURCE LINE # 613
001E 900000      R     MOV     DPTR,#Dst
0021 A3                INC     DPTR
0022 A3                INC     DPTR
0023 E0                MOVX    A,@DPTR
0024 FE                MOV     R6,A
0025 A3                INC     DPTR
0026 E0                MOVX    A,@DPTR
0027 FF                MOV     R7,A
0028 E4                CLR     A
0029 FD                MOV     R5,A
002A FC                MOV     R4,A
002B 7808              MOV     R0,#08H
002D 120000      E     LCALL   ?C?ULSHR
0030 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 614
0033 900000      R     MOV     DPTR,#Dst
0036 E0                MOVX    A,@DPTR
0037 FC                MOV     R4,A
0038 A3                INC     DPTR
0039 E0                MOVX    A,@DPTR
003A FD                MOV     R5,A
003B A3                INC     DPTR
003C E0                MOVX    A,@DPTR
003D FE                MOV     R6,A
003E A3                INC     DPTR
003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
0041 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 615
0044 900000      R     MOV     DPTR,#i
0047 120000      E     LCALL   ?C?LSTKXDATA
004A 00                DB      00H
004B 00                DB      00H
004C 00                DB      00H
004D 00                DB      00H
004E         ?C0023:
004E 900000      R     MOV     DPTR,#no_bytes
0051 E0                MOVX    A,@DPTR
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 70  

0052 FC                MOV     R4,A
0053 A3                INC     DPTR
0054 E0                MOVX    A,@DPTR
0055 FD                MOV     R5,A
0056 A3                INC     DPTR
0057 E0                MOVX    A,@DPTR
0058 FE                MOV     R6,A
0059 A3                INC     DPTR
005A E0                MOVX    A,@DPTR
005B FF                MOV     R7,A
005C 900000      R     MOV     DPTR,#i
005F E0                MOVX    A,@DPTR
0060 F8                MOV     R0,A
0061 A3                INC     DPTR
0062 E0                MOVX    A,@DPTR
0063 F9                MOV     R1,A
0064 A3                INC     DPTR
0065 E0                MOVX    A,@DPTR
0066 FA                MOV     R2,A
0067 A3                INC     DPTR
0068 E0                MOVX    A,@DPTR
0069 FB                MOV     R3,A
006A C3                CLR     C
006B 120000      E     LCALL   ?C?ULCMP
006E 5044              JNC     ?C0024
                                           ; SOURCE LINE # 616
                                           ; SOURCE LINE # 617
0070 120000      R     LCALL   Get_Byte
0073 C007              PUSH    AR7
0075 900000      R     MOV     DPTR,#i
0078 A3                INC     DPTR
0079 A3                INC     DPTR
007A E0                MOVX    A,@DPTR
007B FE                MOV     R6,A
007C A3                INC     DPTR
007D E0                MOVX    A,@DPTR
007E FF                MOV     R7,A
007F 900000      R     MOV     DPTR,#pBuffer
0082 E0                MOVX    A,@DPTR
0083 FB                MOV     R3,A
0084 A3                INC     DPTR
0085 E0                MOVX    A,@DPTR
0086 FA                MOV     R2,A
0087 A3                INC     DPTR
0088 E0                MOVX    A,@DPTR
0089 F9                MOV     R1,A
008A 8F82              MOV     DPL,R7
008C 8E83              MOV     DPH,R6
008E D0E0              POP     ACC
0090 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 618
0093 900000      R     MOV     DPTR,#i
0096 E0                MOVX    A,@DPTR
0097 FC                MOV     R4,A
0098 A3                INC     DPTR
0099 E0                MOVX    A,@DPTR
009A FD                MOV     R5,A
009B A3                INC     DPTR
009C E0                MOVX    A,@DPTR
009D FE                MOV     R6,A
009E A3                INC     DPTR
009F E0                MOVX    A,@DPTR
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 71  

00A0 2401              ADD     A,#01H
00A2 FF                MOV     R7,A
00A3 E4                CLR     A
00A4 3E                ADDC    A,R6
00A5 FE                MOV     R6,A
00A6 E4                CLR     A
00A7 3D                ADDC    A,R5
00A8 FD                MOV     R5,A
00A9 E4                CLR     A
00AA 3C                ADDC    A,R4
00AB FC                MOV     R4,A
00AC 900000      R     MOV     DPTR,#i
00AF 120000      E     LCALL   ?C?LSTXDATA
00B2 809A              SJMP    ?C0023
00B4         ?C0024:
                                           ; SOURCE LINE # 619
00B4 020000      R     LJMP    CE_High
             ; FUNCTION _Read_Cont (END)

             ; FUNCTION _HighSpeed_Read (BEGIN)
                                           ; SOURCE LINE # 640
0000 900000      R     MOV     DPTR,#Dst
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 641
                                           ; SOURCE LINE # 642
;---- Variable 'byte' assigned to Register 'R7' ----
0006 E4                CLR     A
0007 FF                MOV     R7,A
                                           ; SOURCE LINE # 644
0008 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 645
000B 7F0B              MOV     R7,#0BH
000D 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 646
0010 900000      R     MOV     DPTR,#Dst
0013 120000      R     LCALL   L?0075
                                           ; SOURCE LINE # 647
0016 900000      R     MOV     DPTR,#Dst
0019 A3                INC     DPTR
001A A3                INC     DPTR
001B E0                MOVX    A,@DPTR
001C FE                MOV     R6,A
001D A3                INC     DPTR
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 E4                CLR     A
0021 FD                MOV     R5,A
0022 FC                MOV     R4,A
0023 7808              MOV     R0,#08H
0025 120000      E     LCALL   ?C?ULSHR
0028 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 648
002B 900000      R     MOV     DPTR,#Dst
002E E0                MOVX    A,@DPTR
002F FC                MOV     R4,A
0030 A3                INC     DPTR
0031 E0                MOVX    A,@DPTR
0032 FD                MOV     R5,A
0033 A3                INC     DPTR
0034 E0                MOVX    A,@DPTR
0035 FE                MOV     R6,A
0036 A3                INC     DPTR
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 72  

0037 E0                MOVX    A,@DPTR
0038 FF                MOV     R7,A
0039 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 649
003C 7FFF              MOV     R7,#0FFH
003E 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 650
0041 120000      R     LCALL   Get_Byte
                                           ; SOURCE LINE # 651
0044 120000      R     LCALL   CE_High
                                           ; SOURCE LINE # 652
                                           ; SOURCE LINE # 653
0047         ?C0027:
0047 22                RET     
             ; FUNCTION _HighSpeed_Read (END)

             ; FUNCTION _HighSpeed_Read_Cont (BEGIN)
                                           ; SOURCE LINE # 669
0000 900000      R     MOV     DPTR,#Dst
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 670
                                           ; SOURCE LINE # 671
0006 900000      R     MOV     DPTR,#i
0009 120000      E     LCALL   ?C?LSTKXDATA
000C 00                DB      00H
000D 00                DB      00H
000E 00                DB      00H
000F 00                DB      00H
                                           ; SOURCE LINE # 672
0010 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 673
0013 7F0B              MOV     R7,#0BH
0015 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 674
0018 900000      R     MOV     DPTR,#Dst
001B 120000      R     LCALL   L?0075
                                           ; SOURCE LINE # 675
001E 900000      R     MOV     DPTR,#Dst
0021 A3                INC     DPTR
0022 A3                INC     DPTR
0023 E0                MOVX    A,@DPTR
0024 FE                MOV     R6,A
0025 A3                INC     DPTR
0026 E0                MOVX    A,@DPTR
0027 FF                MOV     R7,A
0028 E4                CLR     A
0029 FD                MOV     R5,A
002A FC                MOV     R4,A
002B 7808              MOV     R0,#08H
002D 120000      E     LCALL   ?C?ULSHR
0030 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 676
0033 900000      R     MOV     DPTR,#Dst
0036 E0                MOVX    A,@DPTR
0037 FC                MOV     R4,A
0038 A3                INC     DPTR
0039 E0                MOVX    A,@DPTR
003A FD                MOV     R5,A
003B A3                INC     DPTR
003C E0                MOVX    A,@DPTR
003D FE                MOV     R6,A
003E A3                INC     DPTR
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 73  

003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
0041 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 677
0044 7FFF              MOV     R7,#0FFH
0046 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 678
0049 900000      R     MOV     DPTR,#i
004C 120000      E     LCALL   ?C?LSTKXDATA
004F 00                DB      00H
0050 00                DB      00H
0051 00                DB      00H
0052 00                DB      00H
0053         ?C0028:
0053 900000      R     MOV     DPTR,#no_bytes
0056 E0                MOVX    A,@DPTR
0057 FC                MOV     R4,A
0058 A3                INC     DPTR
0059 E0                MOVX    A,@DPTR
005A FD                MOV     R5,A
005B A3                INC     DPTR
005C E0                MOVX    A,@DPTR
005D FE                MOV     R6,A
005E A3                INC     DPTR
005F E0                MOVX    A,@DPTR
0060 FF                MOV     R7,A
0061 900000      R     MOV     DPTR,#i
0064 E0                MOVX    A,@DPTR
0065 F8                MOV     R0,A
0066 A3                INC     DPTR
0067 E0                MOVX    A,@DPTR
0068 F9                MOV     R1,A
0069 A3                INC     DPTR
006A E0                MOVX    A,@DPTR
006B FA                MOV     R2,A
006C A3                INC     DPTR
006D E0                MOVX    A,@DPTR
006E FB                MOV     R3,A
006F C3                CLR     C
0070 120000      E     LCALL   ?C?ULCMP
0073 5044              JNC     ?C0029
                                           ; SOURCE LINE # 679
                                           ; SOURCE LINE # 680
0075 120000      R     LCALL   Get_Byte
0078 C007              PUSH    AR7
007A 900000      R     MOV     DPTR,#i
007D A3                INC     DPTR
007E A3                INC     DPTR
007F E0                MOVX    A,@DPTR
0080 FE                MOV     R6,A
0081 A3                INC     DPTR
0082 E0                MOVX    A,@DPTR
0083 FF                MOV     R7,A
0084 900000      R     MOV     DPTR,#pBuffer
0087 E0                MOVX    A,@DPTR
0088 FB                MOV     R3,A
0089 A3                INC     DPTR
008A E0                MOVX    A,@DPTR
008B FA                MOV     R2,A
008C A3                INC     DPTR
008D E0                MOVX    A,@DPTR
008E F9                MOV     R1,A
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 74  

008F 8F82              MOV     DPL,R7
0091 8E83              MOV     DPH,R6
0093 D0E0              POP     ACC
0095 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 681
0098 900000      R     MOV     DPTR,#i
009B E0                MOVX    A,@DPTR
009C FC                MOV     R4,A
009D A3                INC     DPTR
009E E0                MOVX    A,@DPTR
009F FD                MOV     R5,A
00A0 A3                INC     DPTR
00A1 E0                MOVX    A,@DPTR
00A2 FE                MOV     R6,A
00A3 A3                INC     DPTR
00A4 E0                MOVX    A,@DPTR
00A5 2401              ADD     A,#01H
00A7 FF                MOV     R7,A
00A8 E4                CLR     A
00A9 3E                ADDC    A,R6
00AA FE                MOV     R6,A
00AB E4                CLR     A
00AC 3D                ADDC    A,R5
00AD FD                MOV     R5,A
00AE E4                CLR     A
00AF 3C                ADDC    A,R4
00B0 FC                MOV     R4,A
00B1 900000      R     MOV     DPTR,#i
00B4 120000      E     LCALL   ?C?LSTXDATA
00B7 809A              SJMP    ?C0028
00B9         ?C0029:
                                           ; SOURCE LINE # 682
00B9 020000      R     LJMP    CE_High
             ; FUNCTION _HighSpeed_Read_Cont (END)

             ; FUNCTION L?0079 (BEGIN)
0000 E0                MOVX    A,@DPTR
0001 FC                MOV     R4,A
0002 A3                INC     DPTR
0003 E0                MOVX    A,@DPTR
0004 FD                MOV     R5,A
0005 A3                INC     DPTR
0006 E0                MOVX    A,@DPTR
0007 FE                MOV     R6,A
0008 A3                INC     DPTR
0009 E0                MOVX    A,@DPTR
000A FF                MOV     R7,A
000B A3                INC     DPTR
000C E0                MOVX    A,@DPTR
000D 900000      R     MOV     DPTR,#?_Byte_Program?BYTE+04H
0010 F0                MOVX    @DPTR,A
             ; FUNCTION _Byte_Program (BEGIN)
                                           ; SOURCE LINE # 703
0011 900000      R     MOV     DPTR,#Dst
                                           ; SOURCE LINE # 704
                                           ; SOURCE LINE # 705
0014 120000      R     LCALL   L?0080
                                           ; SOURCE LINE # 706
0017 7F02              MOV     R7,#02H
0019 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 707
001C 900000      R     MOV     DPTR,#Dst
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 75  

001F 120000      R     LCALL   L?0075
                                           ; SOURCE LINE # 708
0022 900000      R     MOV     DPTR,#Dst
0025 A3                INC     DPTR
0026 A3                INC     DPTR
0027 E0                MOVX    A,@DPTR
0028 FE                MOV     R6,A
0029 A3                INC     DPTR
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C E4                CLR     A
002D FD                MOV     R5,A
002E FC                MOV     R4,A
002F 7808              MOV     R0,#08H
0031 120000      E     LCALL   ?C?ULSHR
0034 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 709
0037 900000      R     MOV     DPTR,#Dst
003A E0                MOVX    A,@DPTR
003B FC                MOV     R4,A
003C A3                INC     DPTR
003D E0                MOVX    A,@DPTR
003E FD                MOV     R5,A
003F A3                INC     DPTR
0040 E0                MOVX    A,@DPTR
0041 FE                MOV     R6,A
0042 A3                INC     DPTR
0043 E0                MOVX    A,@DPTR
0044 FF                MOV     R7,A
0045 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 710
0048 900000      R     MOV     DPTR,#byte
004B E0                MOVX    A,@DPTR
004C FF                MOV     R7,A
004D 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 711
0050 020000      R     LJMP    CE_High
             ; FUNCTION _Byte_Program (END)

             ; FUNCTION _Auto_Add_IncA (BEGIN)
                                           ; SOURCE LINE # 742
0000 900000      R     MOV     DPTR,#Dst
                                           ; SOURCE LINE # 743
                                           ; SOURCE LINE # 744
0003 120000      R     LCALL   L?0080
                                           ; SOURCE LINE # 745
0006 7FAD              MOV     R7,#0ADH
0008 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 746
000B 900000      R     MOV     DPTR,#Dst
000E 120000      R     LCALL   L?0075
                                           ; SOURCE LINE # 747
0011 900000      R     MOV     DPTR,#Dst
0014 A3                INC     DPTR
0015 A3                INC     DPTR
0016 E0                MOVX    A,@DPTR
0017 FE                MOV     R6,A
0018 A3                INC     DPTR
0019 E0                MOVX    A,@DPTR
001A FF                MOV     R7,A
001B E4                CLR     A
001C FD                MOV     R5,A
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 76  

001D FC                MOV     R4,A
001E 7808              MOV     R0,#08H
0020 120000      E     LCALL   ?C?ULSHR
0023 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 748
0026 900000      R     MOV     DPTR,#Dst
0029 E0                MOVX    A,@DPTR
002A FC                MOV     R4,A
002B A3                INC     DPTR
002C E0                MOVX    A,@DPTR
002D FD                MOV     R5,A
002E A3                INC     DPTR
002F E0                MOVX    A,@DPTR
0030 FE                MOV     R6,A
0031 A3                INC     DPTR
0032 E0                MOVX    A,@DPTR
0033 FF                MOV     R7,A
0034 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 749
0037 900000      R     MOV     DPTR,#byte1
003A E0                MOVX    A,@DPTR
003B FF                MOV     R7,A
003C 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 750
003F 900000      R     MOV     DPTR,#byte2
0042 E0                MOVX    A,@DPTR
0043 FF                MOV     R7,A
0044 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 751
0047 020000      R     LJMP    CE_High
             ; FUNCTION _Auto_Add_IncA (END)

             ; FUNCTION _Auto_Add_IncB (BEGIN)
                                           ; SOURCE LINE # 782
0000 900000      R     MOV     DPTR,#byte1
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 783
                                           ; SOURCE LINE # 784
0008 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 785
000B 7FAD              MOV     R7,#0ADH
000D 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 786
0010 900000      R     MOV     DPTR,#byte1
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 787
0018 900000      R     MOV     DPTR,#byte2
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 788
0020 020000      R     LJMP    CE_High
             ; FUNCTION _Auto_Add_IncB (END)

             ; FUNCTION L?0077 (BEGIN)
0000 E0                MOVX    A,@DPTR
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 77  

0001 FC                MOV     R4,A
0002 A3                INC     DPTR
0003 E0                MOVX    A,@DPTR
0004 FD                MOV     R5,A
0005 A3                INC     DPTR
0006 E0                MOVX    A,@DPTR
0007 FE                MOV     R6,A
0008 A3                INC     DPTR
0009 E0                MOVX    A,@DPTR
000A FF                MOV     R7,A
000B A3                INC     DPTR
000C E0                MOVX    A,@DPTR
000D FB                MOV     R3,A
000E A3                INC     DPTR
000F E0                MOVX    A,@DPTR
0010 FA                MOV     R2,A
0011 A3                INC     DPTR
0012 E0                MOVX    A,@DPTR
0013 F9                MOV     R1,A
0014 120000      E     LCALL   ?C?CLDPTR
0017 900000      R     MOV     DPTR,#?_Auto_Add_IncA_EBSY?BYTE+04H
001A F0                MOVX    @DPTR,A
001B 900001            MOV     DPTR,#01H
001E 120000      E     LCALL   ?C?CLDOPTR
0021 900000      R     MOV     DPTR,#?_Auto_Add_IncA_EBSY?BYTE+05H
0024 F0                MOVX    @DPTR,A
             ; FUNCTION _Auto_Add_IncA_EBSY (BEGIN)
                                           ; SOURCE LINE # 821
0025 900000      R     MOV     DPTR,#Dst
0028 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 822
                                           ; SOURCE LINE # 823
002B 120000      R     LCALL   EBSY
                                           ; SOURCE LINE # 825
002E 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 826
0031 7FAD              MOV     R7,#0ADH
0033 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 827
0036 900000      R     MOV     DPTR,#Dst
0039 120000      R     LCALL   L?0075
                                           ; SOURCE LINE # 828
003C 900000      R     MOV     DPTR,#Dst
003F A3                INC     DPTR
0040 A3                INC     DPTR
0041 E0                MOVX    A,@DPTR
0042 FE                MOV     R6,A
0043 A3                INC     DPTR
0044 E0                MOVX    A,@DPTR
0045 FF                MOV     R7,A
0046 E4                CLR     A
0047 FD                MOV     R5,A
0048 FC                MOV     R4,A
0049 7808              MOV     R0,#08H
004B 120000      E     LCALL   ?C?ULSHR
004E 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 829
0051 900000      R     MOV     DPTR,#Dst
0054 E0                MOVX    A,@DPTR
0055 FC                MOV     R4,A
0056 A3                INC     DPTR
0057 E0                MOVX    A,@DPTR
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 78  

0058 FD                MOV     R5,A
0059 A3                INC     DPTR
005A E0                MOVX    A,@DPTR
005B FE                MOV     R6,A
005C A3                INC     DPTR
005D E0                MOVX    A,@DPTR
005E FF                MOV     R7,A
005F 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 830
0062 900000      R     MOV     DPTR,#byte1
0065 E0                MOVX    A,@DPTR
0066 FF                MOV     R7,A
0067 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 831
006A 900000      R     MOV     DPTR,#byte2
006D E0                MOVX    A,@DPTR
006E FF                MOV     R7,A
006F 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 832
0072 120000      R     LCALL   CE_High
                                           ; SOURCE LINE # 834
0075 020000      R     LJMP    Poll_SO
             ; FUNCTION _Auto_Add_IncA_EBSY (END)

             ; FUNCTION _Auto_Add_IncB_EBSY (BEGIN)
                                           ; SOURCE LINE # 868
0000 900000      R     MOV     DPTR,#byte1
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 869
                                           ; SOURCE LINE # 870
0008 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 871
000B 7FAD              MOV     R7,#0ADH
000D 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 872
0010 900000      R     MOV     DPTR,#byte1
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 873
0018 900000      R     MOV     DPTR,#byte2
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 874
                                           ; SOURCE LINE # 876
0020 120000      R     LCALL   L?0083
                                           ; SOURCE LINE # 878
0023 120000      R     LCALL   WRDI
                                           ; SOURCE LINE # 879
0026 020000      R     LJMP    DBSY
             ; FUNCTION _Auto_Add_IncB_EBSY (END)

             ; FUNCTION Chip_Erase (BEGIN)
                                           ; SOURCE LINE # 893
                                           ; SOURCE LINE # 894
                                           ; SOURCE LINE # 895
0000 120000      R     LCALL   CE_Low
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 79  

                                           ; SOURCE LINE # 897
0003 7FC7              MOV     R7,#0C7H
0005 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 898
0008 020000      R     LJMP    CE_High
             ; FUNCTION Chip_Erase (END)

             ; FUNCTION L?0081 (BEGIN)
0000 E0                MOVX    A,@DPTR
0001 FC                MOV     R4,A
0002 A3                INC     DPTR
0003 E0                MOVX    A,@DPTR
0004 FD                MOV     R5,A
0005 A3                INC     DPTR
0006 E0                MOVX    A,@DPTR
0007 FE                MOV     R6,A
0008 A3                INC     DPTR
0009 E0                MOVX    A,@DPTR
000A FF                MOV     R7,A
             ; FUNCTION _Sector_Erase (BEGIN)
                                           ; SOURCE LINE # 912
000B 900000      R     MOV     DPTR,#Dst
000E 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 913
                                           ; SOURCE LINE # 916
0011 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 917
0014 7F20              MOV     R7,#020H
0016 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 918
0019 900000      R     MOV     DPTR,#Dst
001C 120000      R     LCALL   L?0075
                                           ; SOURCE LINE # 919
001F 900000      R     MOV     DPTR,#Dst
0022 A3                INC     DPTR
0023 A3                INC     DPTR
0024 E0                MOVX    A,@DPTR
0025 FE                MOV     R6,A
0026 A3                INC     DPTR
0027 E0                MOVX    A,@DPTR
0028 FF                MOV     R7,A
0029 E4                CLR     A
002A FD                MOV     R5,A
002B FC                MOV     R4,A
002C 7808              MOV     R0,#08H
002E 120000      E     LCALL   ?C?ULSHR
0031 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 920
0034 900000      R     MOV     DPTR,#Dst
0037 E0                MOVX    A,@DPTR
0038 FC                MOV     R4,A
0039 A3                INC     DPTR
003A E0                MOVX    A,@DPTR
003B FD                MOV     R5,A
003C A3                INC     DPTR
003D E0                MOVX    A,@DPTR
003E FE                MOV     R6,A
003F A3                INC     DPTR
0040 E0                MOVX    A,@DPTR
0041 FF                MOV     R7,A
0042 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 921
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 80  

0045 020000      R     LJMP    CE_High
             ; FUNCTION _Sector_Erase (END)

             ; FUNCTION _Block_Erase_32K (BEGIN)
                                           ; SOURCE LINE # 935
0000 900000      R     MOV     DPTR,#Dst
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 936
                                           ; SOURCE LINE # 937
0006 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 938
0009 7F52              MOV     R7,#052H
000B 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 939
000E 900000      R     MOV     DPTR,#Dst
0011 120000      R     LCALL   L?0075
                                           ; SOURCE LINE # 940
0014 900000      R     MOV     DPTR,#Dst
0017 A3                INC     DPTR
0018 A3                INC     DPTR
0019 E0                MOVX    A,@DPTR
001A FE                MOV     R6,A
001B A3                INC     DPTR
001C E0                MOVX    A,@DPTR
001D FF                MOV     R7,A
001E E4                CLR     A
001F FD                MOV     R5,A
0020 FC                MOV     R4,A
0021 7808              MOV     R0,#08H
0023 120000      E     LCALL   ?C?ULSHR
0026 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 941
0029 900000      R     MOV     DPTR,#Dst
002C E0                MOVX    A,@DPTR
002D FC                MOV     R4,A
002E A3                INC     DPTR
002F E0                MOVX    A,@DPTR
0030 FD                MOV     R5,A
0031 A3                INC     DPTR
0032 E0                MOVX    A,@DPTR
0033 FE                MOV     R6,A
0034 A3                INC     DPTR
0035 E0                MOVX    A,@DPTR
0036 FF                MOV     R7,A
0037 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 942
003A 020000      R     LJMP    CE_High
             ; FUNCTION _Block_Erase_32K (END)

             ; FUNCTION _Block_Erase_64K (BEGIN)
                                           ; SOURCE LINE # 956
0000 900000      R     MOV     DPTR,#Dst
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 957
                                           ; SOURCE LINE # 958
0006 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 959
0009 7FD8              MOV     R7,#0D8H
000B 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 960
000E 900000      R     MOV     DPTR,#Dst
0011 120000      R     LCALL   L?0075
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 81  

                                           ; SOURCE LINE # 961
0014 900000      R     MOV     DPTR,#Dst
0017 A3                INC     DPTR
0018 A3                INC     DPTR
0019 E0                MOVX    A,@DPTR
001A FE                MOV     R6,A
001B A3                INC     DPTR
001C E0                MOVX    A,@DPTR
001D FF                MOV     R7,A
001E E4                CLR     A
001F FD                MOV     R5,A
0020 FC                MOV     R4,A
0021 7808              MOV     R0,#08H
0023 120000      E     LCALL   ?C?ULSHR
0026 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 962
0029 900000      R     MOV     DPTR,#Dst
002C E0                MOVX    A,@DPTR
002D FC                MOV     R4,A
002E A3                INC     DPTR
002F E0                MOVX    A,@DPTR
0030 FD                MOV     R5,A
0031 A3                INC     DPTR
0032 E0                MOVX    A,@DPTR
0033 FE                MOV     R6,A
0034 A3                INC     DPTR
0035 E0                MOVX    A,@DPTR
0036 FF                MOV     R7,A
0037 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 963
003A 020000      R     LJMP    CE_High
             ; FUNCTION _Block_Erase_64K (END)

             ; FUNCTION Wait_Busy (BEGIN)
                                           ; SOURCE LINE # 978
                                           ; SOURCE LINE # 979
0000         ?C0041:
                                           ; SOURCE LINE # 980
0000 120000      R     LCALL   Read_Status_Register
0003 EF                MOV     A,R7
0004 30E009            JNB     ACC.0,?C0043
                                           ; SOURCE LINE # 981
                                           ; SOURCE LINE # 982
0007 7F0A              MOV     R7,#0AH
0009 7E00              MOV     R6,#00H
000B 120000      E     LCALL   _delay_nus
                                           ; SOURCE LINE # 983
000E 80F0              SJMP    ?C0041
                                           ; SOURCE LINE # 985
0010         ?C0043:
0010 22                RET     
             ; FUNCTION Wait_Busy (END)

             ; FUNCTION Wait_Busy_AAI (BEGIN)
                                           ; SOURCE LINE # 998
                                           ; SOURCE LINE # 999
0000         ?C0044:
                                           ; SOURCE LINE # 1000
0000 120000      R     LCALL   Read_Status_Register
0003 EF                MOV     A,R7
0004 30E609            JNB     ACC.6,?C0046
                                           ; SOURCE LINE # 1001
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 82  

                                           ; SOURCE LINE # 1002
0007 7F01              MOV     R7,#01H
0009 7E00              MOV     R6,#00H
000B 120000      E     LCALL   _delay_nms
                                           ; SOURCE LINE # 1003
000E 80F0              SJMP    ?C0044
                                           ; SOURCE LINE # 1004
0010         ?C0046:
0010 22                RET     
             ; FUNCTION Wait_Busy_AAI (END)

             ; FUNCTION WREN_Check (BEGIN)
                                           ; SOURCE LINE # 1017
                                           ; SOURCE LINE # 1018
                                           ; SOURCE LINE # 1020
0000 120000      R     LCALL   Read_Status_Register
;---- Variable 'byte' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1021
0003 EF                MOV     A,R7
0004 20E102            JB      ACC.1,?C0050
                                           ; SOURCE LINE # 1022
0007         ?C0048:
                                           ; SOURCE LINE # 1023
0007 80FE              SJMP    ?C0048
                                           ; SOURCE LINE # 1027
                                           ; SOURCE LINE # 1028
0009         ?C0050:
0009 22                RET     
             ; FUNCTION WREN_Check (END)

             ; FUNCTION WREN_AAI_Check (BEGIN)
                                           ; SOURCE LINE # 1041
                                           ; SOURCE LINE # 1042
                                           ; SOURCE LINE # 1044
0000 120000      R     LCALL   Read_Status_Register
;---- Variable 'byte' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1045
0003 EF                MOV     A,R7
0004 5442              ANL     A,#042H
0006 6442              XRL     A,#042H
0008 6002              JZ      ?C0054
                                           ; SOURCE LINE # 1046
000A         ?C0052:
                                           ; SOURCE LINE # 1047
000A 80FE              SJMP    ?C0052
                                           ; SOURCE LINE # 1051
                                           ; SOURCE LINE # 1052
000C         ?C0054:
000C 22                RET     
             ; FUNCTION WREN_AAI_Check (END)

             ; FUNCTION _Verify (BEGIN)
                                           ; SOURCE LINE # 1066
;---- Variable 'cor_byte' assigned to Register 'R5' ----
;---- Variable 'byte' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1067
                                           ; SOURCE LINE # 1068
0000 EF                MOV     A,R7
0001 6D                XRL     A,R5
0002 6002              JZ      ?C0058
                                           ; SOURCE LINE # 1069
0004         ?C0056:
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 83  

                                           ; SOURCE LINE # 1070
0004 80FE              SJMP    ?C0056
                                           ; SOURCE LINE # 1074
                                           ; SOURCE LINE # 1075
0006         ?C0058:
0006 22                RET     
             ; FUNCTION _Verify (END)

             ; FUNCTION _Byte_Write (BEGIN)
                                           ; SOURCE LINE # 1079
0000 900000      R     MOV     DPTR,#Dst
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1080
                                           ; SOURCE LINE # 1081
0006 120000      R     LCALL   WREN
                                           ; SOURCE LINE # 1082
0009 900000      R     MOV     DPTR,#Dst
000C 120000      R     LCALL   L?0081
                                           ; SOURCE LINE # 1083
000F 120000      R     LCALL   Wait_Busy
                                           ; SOURCE LINE # 1086
0012 120000      R     LCALL   WREN
                                           ; SOURCE LINE # 1087
0015 900000      R     MOV     DPTR,#Dst
0018 120000      R     LCALL   L?0079
                                           ; SOURCE LINE # 1088
001B 020000      R     LJMP    Wait_Busy
             ; FUNCTION _Byte_Write (END)

             ; FUNCTION _AAI_Write (BEGIN)
                                           ; SOURCE LINE # 1094
0000 900000      R     MOV     DPTR,#Dst
0003 120000      E     LCALL   ?C?LSTXDATA
0006 900000      R     MOV     DPTR,#p
                                           ; SOURCE LINE # 1095
                                           ; SOURCE LINE # 1096
0009 120000      R     LCALL   L?0082
                                           ; SOURCE LINE # 1097
000C 900000      R     MOV     DPTR,#Dst
000F 120000      R     LCALL   L?0081
                                           ; SOURCE LINE # 1099
0012 120000      R     LCALL   Wait_Busy
                                           ; SOURCE LINE # 1103
0015 120000      R     LCALL   WREN
                                           ; SOURCE LINE # 1104
0018 900000      R     MOV     DPTR,#Dst
001B 120000      R     LCALL   L?0077
                                           ; SOURCE LINE # 1106
                                           ; SOURCE LINE # 1107
                                           ; SOURCE LINE # 1109
001E 803B              SJMP    ?C0072
0020         ?C0060:
0020 900000      R     MOV     DPTR,#no_bytes
0023 E0                MOVX    A,@DPTR
0024 D3                SETB    C
0025 9402              SUBB    A,#02H
0027 4045              JC      ?C0061
                                           ; SOURCE LINE # 1110
                                           ; SOURCE LINE # 1111
0029 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 1112
002C 7FAD              MOV     R7,#0ADH
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 84  

002E 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 1113
0031 900000      R     MOV     DPTR,#p
0034 E0                MOVX    A,@DPTR
0035 FB                MOV     R3,A
0036 A3                INC     DPTR
0037 E0                MOVX    A,@DPTR
0038 FA                MOV     R2,A
0039 A3                INC     DPTR
003A E0                MOVX    A,@DPTR
003B F9                MOV     R1,A
003C 120000      E     LCALL   ?C?CLDPTR
003F FF                MOV     R7,A
0040 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 1114
0043 900000      R     MOV     DPTR,#p
0046 E0                MOVX    A,@DPTR
0047 FB                MOV     R3,A
0048 A3                INC     DPTR
0049 E0                MOVX    A,@DPTR
004A FA                MOV     R2,A
004B A3                INC     DPTR
004C E0                MOVX    A,@DPTR
004D F9                MOV     R1,A
004E 900001            MOV     DPTR,#01H
0051 120000      E     LCALL   ?C?CLDOPTR
0054 FF                MOV     R7,A
0055 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 1115
                                           ; SOURCE LINE # 1117
0058 120000      R     LCALL   L?0083
                                           ; SOURCE LINE # 1118
005B         ?C0072:
005B 900000      R     MOV     DPTR,#no_bytes
005E E0                MOVX    A,@DPTR
005F 24FE              ADD     A,#0FEH
0061 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1119
0062 900000      R     MOV     DPTR,#p+01H
0065 E4                CLR     A
0066 75F002            MOV     B,#02H
0069 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 1121
006C 80B2              SJMP    ?C0060
006E         ?C0061:
                                           ; SOURCE LINE # 1123
006E 900000      R     MOV     DPTR,#p
0071 E0                MOVX    A,@DPTR
0072 FB                MOV     R3,A
0073 A3                INC     DPTR
0074 E0                MOVX    A,@DPTR
0075 FA                MOV     R2,A
0076 A3                INC     DPTR
0077 E0                MOVX    A,@DPTR
0078 F9                MOV     R1,A
0079 120000      E     LCALL   ?C?CLDPTR
007C FF                MOV     R7,A
007D 900001            MOV     DPTR,#01H
0080 120000      E     LCALL   ?C?CLDOPTR
0083 FD                MOV     R5,A
0084 020000      R     LJMP    _Auto_Add_IncB_EBSY
             ; FUNCTION _AAI_Write (END)
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 85  


             ; FUNCTION _Byte_Write1 (BEGIN)
                                           ; SOURCE LINE # 1177
0000 900000      R     MOV     DPTR,#Dst
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1178
                                           ; SOURCE LINE # 1179
0006 120000      R     LCALL   WREN
                                           ; SOURCE LINE # 1180
0009 900000      R     MOV     DPTR,#Dst
000C 120000      R     LCALL   L?0079
                                           ; SOURCE LINE # 1181
000F 020000      R     LJMP    Wait_Busy
             ; FUNCTION _Byte_Write1 (END)

             ; FUNCTION _AAI_Write1 (BEGIN)
                                           ; SOURCE LINE # 1190
0000 900000      R     MOV     DPTR,#Dst
0003 120000      E     LCALL   ?C?LSTXDATA
0006 900000      R     MOV     DPTR,#p
                                           ; SOURCE LINE # 1191
                                           ; SOURCE LINE # 1193
0009 120000      R     LCALL   L?0082
                                           ; SOURCE LINE # 1194
000C 900000      R     MOV     DPTR,#Dst
000F 120000      R     LCALL   L?0077
                                           ; SOURCE LINE # 1196
                                           ; SOURCE LINE # 1197
                                           ; SOURCE LINE # 1199
0012 803E              SJMP    ?C0073
0014         ?C0064:
0014 900000      R     MOV     DPTR,#no_bytes
0017 E0                MOVX    A,@DPTR
0018 D3                SETB    C
0019 9402              SUBB    A,#02H
001B 4048              JC      ?C0065
                                           ; SOURCE LINE # 1200
                                           ; SOURCE LINE # 1201
001D 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 1202
0020 7FAD              MOV     R7,#0ADH
0022 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 1203
0025 900000      R     MOV     DPTR,#p
0028 E0                MOVX    A,@DPTR
0029 FB                MOV     R3,A
002A A3                INC     DPTR
002B E0                MOVX    A,@DPTR
002C FA                MOV     R2,A
002D A3                INC     DPTR
002E E0                MOVX    A,@DPTR
002F F9                MOV     R1,A
0030 120000      E     LCALL   ?C?CLDPTR
0033 FF                MOV     R7,A
0034 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 1204
0037 900000      R     MOV     DPTR,#p
003A E0                MOVX    A,@DPTR
003B FB                MOV     R3,A
003C A3                INC     DPTR
003D E0                MOVX    A,@DPTR
003E FA                MOV     R2,A
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 86  

003F A3                INC     DPTR
0040 E0                MOVX    A,@DPTR
0041 F9                MOV     R1,A
0042 900001            MOV     DPTR,#01H
0045 120000      E     LCALL   ?C?CLDOPTR
0048 FF                MOV     R7,A
0049 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 1205
004C 120000      R     LCALL   CE_High
                                           ; SOURCE LINE # 1207
004F 120000      R     LCALL   Poll_SO
                                           ; SOURCE LINE # 1208
0052         ?C0073:
0052 900000      R     MOV     DPTR,#no_bytes
0055 E0                MOVX    A,@DPTR
0056 24FE              ADD     A,#0FEH
0058 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1209
0059 900000      R     MOV     DPTR,#p+01H
005C E4                CLR     A
005D 75F002            MOV     B,#02H
0060 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 1211
0063 80AF              SJMP    ?C0064
0065         ?C0065:
                                           ; SOURCE LINE # 1213
0065 900000      R     MOV     DPTR,#p
0068 E0                MOVX    A,@DPTR
0069 FB                MOV     R3,A
006A A3                INC     DPTR
006B E0                MOVX    A,@DPTR
006C FA                MOV     R2,A
006D A3                INC     DPTR
006E E0                MOVX    A,@DPTR
006F F9                MOV     R1,A
0070 120000      E     LCALL   ?C?CLDPTR
0073 FF                MOV     R7,A
0074 900001            MOV     DPTR,#01H
0077 120000      E     LCALL   ?C?CLDOPTR
007A FD                MOV     R5,A
007B 020000      R     LJMP    _Auto_Add_IncB_EBSY
             ; FUNCTION _AAI_Write1 (END)

             ; FUNCTION FRAM_TEST (BEGIN)
                                           ; SOURCE LINE # 1273
                                           ; SOURCE LINE # 1274
                                           ; SOURCE LINE # 1277
0000 900000      R     MOV     DPTR,#FRAM_BUFF
0003 7411              MOV     A,#011H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1278
0006 A3                INC     DPTR
0007 7422              MOV     A,#022H
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1279
000A A3                INC     DPTR
000B 7433              MOV     A,#033H
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1280
000E A3                INC     DPTR
000F 7444              MOV     A,#044H
0011 F0                MOVX    @DPTR,A
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 87  

                                           ; SOURCE LINE # 1281
0012 A3                INC     DPTR
0013 7455              MOV     A,#055H
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1282
0016 A3                INC     DPTR
0017 7466              MOV     A,#066H
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1284
001A A3                INC     DPTR
001B 7477              MOV     A,#077H
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1285
001E A3                INC     DPTR
001F 7488              MOV     A,#088H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1286
0022 A3                INC     DPTR
0023 7499              MOV     A,#099H
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1287
0026 A3                INC     DPTR
0027 74AA              MOV     A,#0AAH
0029 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1288
002A A3                INC     DPTR
002B 74BB              MOV     A,#0BBH
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1305
002E 7B01              MOV     R3,#01H
0030 7A00        R     MOV     R2,#HIGH FRAM_BUFF
0032 7900        R     MOV     R1,#LOW FRAM_BUFF
0034 900000      R     MOV     DPTR,#?_AAI_Write1?BYTE+07H
0037 740B              MOV     A,#0BH
0039 F0                MOVX    @DPTR,A
003A 7FF1              MOV     R7,#0F1H
003C 7EFF              MOV     R6,#0FFH
003E 7D07              MOV     R5,#07H
0040 7C00              MOV     R4,#00H
0042 120000      R     LCALL   _AAI_Write1
                                           ; SOURCE LINE # 1307
;---- Variable 'i' assigned to Register 'R7' ----
0045         ?C0067:
0045 7F14              MOV     R7,#014H
0047 900000      R     MOV     DPTR,#FRAM_BUFF
004A E4                CLR     A
004B         ?C0071:
004B F0                MOVX    @DPTR,A
004C A3                INC     DPTR
004D DFFC              DJNZ    R7,?C0071
004F         ?C0068:
                                           ; SOURCE LINE # 1308
004F 7F0A              MOV     R7,#0AH
0051 7E00              MOV     R6,#00H
0053 120000      E     LCALL   _delay_nms
                                           ; SOURCE LINE # 1310
0056 900000      R     MOV     DPTR,#?_Read_Cont?BYTE+04H
0059 120000      E     LCALL   ?C?LSTKXDATA
005C 00                DB      00H
005D 00                DB      00H
005E 00                DB      00H
005F 0B                DB      0BH
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 88  

0060 900000      R     MOV     DPTR,#?_Read_Cont?BYTE+08H
0063 7401              MOV     A,#01H
0065 F0                MOVX    @DPTR,A
0066 A3                INC     DPTR
0067 7400        R     MOV     A,#HIGH FRAM_BUFF
0069 F0                MOVX    @DPTR,A
006A A3                INC     DPTR
006B 7400        R     MOV     A,#LOW FRAM_BUFF
006D F0                MOVX    @DPTR,A
006E 7FF1              MOV     R7,#0F1H
0070 7EFF              MOV     R6,#0FFH
0072 7D07              MOV     R5,#07H
0074 7C00              MOV     R4,#00H
0076 120000      R     LCALL   _Read_Cont
                                           ; SOURCE LINE # 1311
0079 7F0A              MOV     R7,#0AH
007B 7E00              MOV     R6,#00H
007D 120000      E     LCALL   _delay_nms
                                           ; SOURCE LINE # 1312
0080 7B01              MOV     R3,#01H
0082 7A00        R     MOV     R2,#HIGH FRAM_BUFF
0084 7900        R     MOV     R1,#LOW FRAM_BUFF
0086 7D0B              MOV     R5,#0BH
0088 020000      E     LJMP    _Send_Data
             ; FUNCTION FRAM_TEST (END)

C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 89  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


WREN_Check . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  byte . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
P0 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0080H  1
P1 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0090H  1
P2 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A0H  1
_Send_Byte . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0010H  -----
  out. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
P3 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B0H  1
_Byte_Write. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  byte . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0004H  1
int8 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
IE . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
Read_Status_Register . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  byte . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
pSTEepromCfgData . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
Get_Byte . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0020H  -----
  in . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
IP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
CE_Low . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0003H  -----
Poll_SO. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0003H  -----
  temp . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
Wait_Busy. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Hold_Low . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
STEepromCfgData. . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  1
  byInitFlag . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
CCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
uint32 . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
Jedec_ID_Read. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  temp . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
uint16 . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
WREN_AAI_Check . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  byte . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
FRAM_BUFF. . . . . . . . . . . . . . .  PUBLIC   XDATA  ARRAY    0000H  100
int32. . . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
DBSY . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
EBSY . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
int16. . . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
SCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
TCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
_Byte_Write1 . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  byte . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0004H  1
WRDI . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
MISO . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
_AAI_Write . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  p. . . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0004H  3
  no_bytes . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0007H  1
WP_Low . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
WREN . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0008H  -----
EWSR . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_delay_nms . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Auto_Add_IncA . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  byte1. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0004H  1
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 90  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  byte2. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0005H  1
_Auto_Add_IncB . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  byte1. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  byte2. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
_Sector_Erase. . . . . . . . . . . . .  PUBLIC   CODE   PROC     000BH  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
ACC. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E0H  1
FRAM_TEST. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
Wait_Busy_AAI. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_delay_nus . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_HighSpeed_Read_Cont . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  no_bytes . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0004H  4
  pBuffer. . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0008H  3
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   000BH  4
_WRSR. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  byte . . . . . . . . . . . . . . . .  AUTO     XDATA  INT      0000H  2
_Block_Erase_32K . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
_Byte_Program. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0011H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  byte . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0004H  1
_HighSpeed_Read. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  byte . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
pSTBusFreq . . . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
_Block_Erase_64K . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
pSTTimerOut. . . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
_Auto_Add_IncA_EBSY. . . . . . . . . .  PUBLIC   CODE   PROC     0025H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  byte1. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0004H  1
  byte2. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0005H  1
Chip_Erase . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_Auto_Add_IncB_EBSY. . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  byte1. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  byte2. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
_Send_Data_Byte. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
STBusFreq. . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  7
  bySndSecAddr . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  bySndRoomAddr. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  bySndBedAddr . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  byCmd. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  byRecSecAddr . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  byRecRoomAddr. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  byRecBedAddr . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
STTimerOut . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  byTimerOutSet. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  byTimerOut . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  byTimerOutCount. . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
_Send_Data . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
CE_High. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_AAI_Write1. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  p. . . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0004H  3
  no_bytes . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0007H  1
C51 COMPILER V8.08   SST25VF040_2005                                                       04/19/2012 15:50:52 PAGE 91  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_Read_ID . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ID_addr. . . . . . . . . . . . . . .  AUTO     XDATA  INT      0000H  2
  byte . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
UnWP . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Unhold . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
pSTLocalControl. . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
_SPI_WriteByte . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Read_Cont . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  no_bytes . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0004H  4
  pBuffer. . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0008H  3
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   000BH  4
SST25VF_Init . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
SST25VF_CS . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
_Verify. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  byte . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  cor_byte . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
uint8. . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
PSW. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D0H  1
STLocalControl . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  16
  byChar1. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  uiShortType. . . . . . . . . . . . .  MEMBER   -----  U_INT    0001H  2
  pbyData. . . . . . . . . . . . . . .  MEMBER   -----  PTR      0003H  2
  stBusDealFreq. . . . . . . . . . . .  MEMBER   -----  STRUCT   0005H  7
  stCH0TimerOut. . . . . . . . . . . .  MEMBER   -----  STRUCT   000CH  3
  stEepromCfgData. . . . . . . . . . .  MEMBER   -----  STRUCT   000FH  1
_Read. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  byte . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1932    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    100     106
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
