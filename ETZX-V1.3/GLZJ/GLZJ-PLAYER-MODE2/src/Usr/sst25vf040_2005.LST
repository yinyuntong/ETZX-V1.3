C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 1   


C51 COMPILER V8.08, COMPILATION OF MODULE SST25VF040_2005
OBJECT MODULE PLACED IN sst25vf040_2005.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE sst25vf040_2005.C LARGE BROWSE DEBUG OBJECTEXTEND CODE LISTINCLUDE SYMBOLS

line level    source

   1          /*Software Driver
   2          
   3          SST25VF040B 4 Mbit(512K x 8) Serial Flash Memory
   4          
   5          November 4th, 2005, Rev. 1.0
   6          
   7          ABOUT THE SOFTWARE
   8          This application note provides software driver examples for SST25VF040B,
   9          Serial Flash. Extensive comments are included in each routine to describe 
  10          the function of each routine.  The interface coding uses polling method 
  11          rather than the SPI protocol to interface with these serial devices.  The
  12          functions are differentiated below in terms of the communication protocols
  13          (uses Mode 0) and specific device operation instructions. This code has been 
  14          designed to compile using the Keil compiler.
  15          
  16          
  17          ABOUT THE SST25VF040B
  18          
  19          Companion product datasheets for the SST25VF040B should be reviewed in 
  20          conjunction with this application note for a complete understanding 
  21          of the device.
  22          
  23          
  24          Device Communication Protocol(pinout related) functions:
  25          
  26          Functions                               Function
  27          ------------------------------------------------------------------
  28          init                                    Initializes clock to set up mode 0.
  29          Send_Byte                               Sends one byte using SI pin to send and 
  30                                                          shift out 1-bit per clock rising edge
  31          Get_Byte                                Receives one byte using SO pin to receive and shift 
  32                                                          in 1-bit per clock falling edge
  33          Poll_SO                                 Used in the polling for RY/BY# of SO during AAI programming
  34          CE_High                                 Sets Chip Enable pin of the serial flash to high
  35          CE_Low                                  Clears Chip Enable of the serial flash to low
  36          Hold_Low                                Clears Hold pin to make serial flash hold
  37          Unhold                                  Unholds the serial flash
  38          WP_Low                                  Clears WP pin to make serial flash write protected
  39          UnWP                                    Disables write protection pin
  40          
  41          Note:  The pin names of the SST25VF040B are used in this application note. The associated test code
  42          will not compile unless these pinouts (SCK, SI, SO, SO, CE, WP, Hold) are pre-defined on your
  43          software which should reflect your hardware interfaced.          
  44          
  45          
  46          Device Operation Instruction functions:
  47          
  48          Functions                               Function
  49          ------------------------------------------------------------------
  50          Read_Status_Register    Reads the status register of the serial flash
  51          EWSR                                    Enables the Write Status Register
  52          WRSR                                    Performs a write to the status register
  53          WREN                                    Write enables the serial flash
  54          WRDI                                    Write disables the serial flash
  55          EBSY                                    Enable SO to output RY/BY# status during AAI programming
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 2   

  56          DBSY                                    Disable SO to output RY/BY# status during AAI programming
  57          Read_ID                                 Reads the manufacturer ID and device ID
  58          Jedec_ID_Read                   Reads the Jedec ID
  59          Read                                    Reads one byte from the serial flash and returns byte(max of 25 MHz CLK frequency)
  60          Read_Cont                               Reads multiple bytes(max of 25 MHz CLK frequency)
  61          HighSpeed_Read                  Reads one byte from the serial flash and returns byte(max of 50 MHz CLK frequency)
  62          HighSpeed_Read_Cont             Reads multiple bytes(max of 50 MHz CLK frequency)
  63          Byte_Program                    Program one byte to the serial flash
  64          Auto_Add_IncA                   Initial Auto Address Increment process
  65          Auto_Add_IncB                   Successive Auto_Address_Increment process after AAI initiation
  66          Auto_Add_IncA_EBSY              Initial Auto Address Increment process with EBSY
  67          Auto_Add_IncB_EBSY              Successive Auto_Address_Increment process after AAI initiation with EBSY and WRDI/DBSY
  68          Chip_Erase                              Erases entire serial flash
  69          Sector_Erase                    Erases one sector (4 KB) of the serial flash
  70          Block_Erase_32K                 Erases 32 KByte block memory of the serial flash
  71          Block_Erase_64K                 Erases 64 KByte block memory of the serial flash
  72          Wait_Busy                               Polls status register until busy bit is low
  73          Wait_Busy_AAI                   Polls status register until busy bit is low for AAI programming
  74          WREN_Check                              Checks to see if WEL is set
  75          WREN_AAI_Check                  Checks to see if WEL and AAI mode is set
  76          
  77          */
  78          
  79                                                                               
  80          /*"C" LANGUAGE DRIVERS */
  81          
  82          /********************************************************************/
  83          /* Copyright Silicon Storage Technology, Inc. (SST), 1994-2005      */
  84          /* Example "C" language Driver of SST25VF040B Serial Flash                      */
  85          /* Conrado Canio, Silicon Storage Technology, Inc.                  */
  86          /*                                                                  */
  87          /* Revision 1.0, November 4th, 2005                                                                     */   
  88          /*                                                                  */
  89          /*                                                                                                                                      */
  90          /********************************************************************/
  91          
  92          #define _IN_SST25VF_
  93          #include "config.h"
   1      =1  /*
   2      =1  ************************Copyright(c)************************
   3      =1  *                                  ºþÄÏÎõÍú´ï¿Æ¼¼ÓÐÏÞ¹«Ë¾
   4      =1  *                               All Rights Reserved
   5      =1  *                                        
   6      =1  *
   7      =1  *-----------------------ÎÄ¼þÐÅÏ¢---------------------------
   8      =1  *ÎÄ¼þÃû³Æ               :config.h
   9      =1  *ÎÄ¼þÃèÊö               :ÅäÖÃÍ·ÎÄ¼þ
  10      =1  *´´½¨ÈË                 :³ÂÎÀ¹ú
  11      =1  *´´½¨ÈÕÆÚ               :2008-9-22
  12      =1  *°æ±¾ºÅ                 :V1.0
  13      =1  *×¢ÊÍ                   :                                       
  14      =1  *----------------------------------------------------------
  15      =1  *ÐÞ¸ÄÈË                         :
  16      =1  *ÐÞ¸ÄÈÕÆÚ                       :
  17      =1  *°æ±¾ºÅ                 :
  18      =1  *×¢ÊÍ                   :
  19      =1  ***********************************************************
  20      =1  */
  21      =1  //ÏµÍ³Í·ÎÄ¼þ
  22      =1  #pragma REGPARMS          
  23      =1  #include <intrins.h>
   1      =2  /*--------------------------------------------------------------------------
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 3   

   2      =2  INTRINS.H
   3      =2  
   4      =2  Intrinsic functions for C51.
   5      =2  Copyright (c) 1988-2004 Keil Elektronik GmbH and Keil Software, Inc.
   6      =2  All rights reserved.
   7      =2  --------------------------------------------------------------------------*/
   8      =2  
   9      =2  #ifndef __INTRINS_H__
  10      =2  #define __INTRINS_H__
  11      =2  
  12      =2  extern void          _nop_     (void);
  13      =2  extern bit           _testbit_ (bit);
  14      =2  extern unsigned char _cror_    (unsigned char, unsigned char);
  15      =2  extern unsigned int  _iror_    (unsigned int,  unsigned char);
  16      =2  extern unsigned long _lror_    (unsigned long, unsigned char);
  17      =2  extern unsigned char _crol_    (unsigned char, unsigned char);
  18      =2  extern unsigned int  _irol_    (unsigned int,  unsigned char);
  19      =2  extern unsigned long _lrol_    (unsigned long, unsigned char);
  20      =2  extern unsigned char _chkfloat_(float);
  21      =2  extern void          _push_    (unsigned char _sfr);
  22      =2  extern void          _pop_     (unsigned char _sfr);
  23      =2  
  24      =2  #endif
  25      =2  
  24      =1  #include <absacc.h>
   1      =2  /*--------------------------------------------------------------------------
   2      =2  ABSACC.H
   3      =2  
   4      =2  Direct access to 8051, extended 8051 and Philips 80C51MX memory areas.
   5      =2  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =2  All rights reserved.
   7      =2  --------------------------------------------------------------------------*/
   8      =2  
   9      =2  #ifndef __ABSACC_H__
  10      =2  #define __ABSACC_H__
  11      =2  
  12      =2  #define CBYTE ((unsigned char volatile code  *) 0)
  13      =2  #define DBYTE ((unsigned char volatile data  *) 0)
  14      =2  #define PBYTE ((unsigned char volatile pdata *) 0)
  15      =2  #define XBYTE ((unsigned char volatile xdata *) 0)
  16      =2  
  17      =2  #define CWORD ((unsigned int volatile code  *) 0)
  18      =2  #define DWORD ((unsigned int volatile data  *) 0)
  19      =2  #define PWORD ((unsigned int volatile pdata *) 0)
  20      =2  #define XWORD ((unsigned int volatile xdata *) 0)
  21      =2  
  22      =2  
  23      =2  #ifdef __CX51__
           =2 #define FVAR(object, addr)   (*((object volatile far *) (addr)))
           =2 #define FARRAY(object, base) ((object volatile far *) (base))
           =2 #define FCVAR(object, addr)   (*((object const far *) (addr)))
           =2 #define FCARRAY(object, base) ((object const far *) (base))
           =2 #else
  29      =2  #define FVAR(object, addr)    (*((object volatile far *) ((addr)+0x10000L)))
  30      =2  #define FCVAR(object, addr)   (*((object const far *) ((addr)+0x810000L)))
  31      =2  #define FARRAY(object, base)  ((object volatile far *) ((base)+0x10000L))
  32      =2  #define FCARRAY(object, base) ((object const far *) ((base)+0x810000L))
  33      =2  #endif
  34      =2  
  35      =2  #endif
  25      =1  #include <stdio.h>
   1      =2  /*--------------------------------------------------------------------------
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 4   

   2      =2  STDIO.H
   3      =2  
   4      =2  Prototypes for standard I/O functions.
   5      =2  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =2  All rights reserved.
   7      =2  --------------------------------------------------------------------------*/
   8      =2  
   9      =2  #ifndef __STDIO_H__
  10      =2  #define __STDIO_H__
  11      =2  
  12      =2  #ifndef EOF
  13      =2   #define EOF -1
  14      =2  #endif
  15      =2  
  16      =2  #ifndef NULL
  17      =2   #define NULL ((void *) 0)
  18      =2  #endif
  19      =2  
  20      =2  #ifndef _SIZE_T
  21      =2   #define _SIZE_T
  22      =2   typedef unsigned int size_t;
  23      =2  #endif
  24      =2  
  25      =2  #pragma SAVE
  26      =2  #pragma REGPARMS
  27      =2  extern char _getkey (void);
  28      =2  extern char getchar (void);
  29      =2  extern char ungetchar (char);
  30      =2  extern char putchar (char);
  31      =2  extern int printf   (const char *, ...);
  32      =2  extern int sprintf  (char *, const char *, ...);
  33      =2  extern int vprintf  (const char *, char *);
  34      =2  extern int vsprintf (char *, const char *, char *);
  35      =2  extern char *gets (char *, int n);
  36      =2  extern int scanf (const char *, ...);
  37      =2  extern int sscanf (char *, const char *, ...);
  38      =2  extern int puts (const char *);
  39      =2  
  40      =2  #pragma RESTORE
  41      =2  
  42      =2  #endif
  43      =2  
  26      =1  #include <string.h>
   1      =2  /*--------------------------------------------------------------------------
   2      =2  STRING.H
   3      =2  
   4      =2  String functions.
   5      =2  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =2  All rights reserved.
   7      =2  --------------------------------------------------------------------------*/
   8      =2  
   9      =2  #ifndef __STRING_H__
  10      =2  #define __STRING_H__
  11      =2  
  12      =2  #ifndef _SIZE_T
           =2  #define _SIZE_T
           =2  typedef unsigned int size_t;
           =2 #endif
  16      =2  
  17      =2  #ifndef NULL
           =2  #define NULL ((void *) 0L)
           =2 #endif
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 5   

  20      =2  
  21      =2  #pragma SAVE
  22      =2  #pragma REGPARMS
  23      =2  extern char *strcat (char *s1, char *s2);
  24      =2  extern char *strncat (char *s1, char *s2, int n);
  25      =2  
  26      =2  extern char strcmp (char *s1, char *s2);
  27      =2  extern char strncmp (char *s1, char *s2, int n);
  28      =2  
  29      =2  extern char *strcpy (char *s1, char *s2);
  30      =2  extern char *strncpy (char *s1, char *s2, int n);
  31      =2  
  32      =2  extern int strlen (char *);
  33      =2  
  34      =2  extern char *strchr (const char *s, char c);
  35      =2  extern int strpos (const char *s, char c);
  36      =2  extern char *strrchr (const char *s, char c);
  37      =2  extern int strrpos (const char *s, char c);
  38      =2  
  39      =2  extern int strspn (char *s, char *set);
  40      =2  extern int strcspn (char *s, char *set);
  41      =2  extern char *strpbrk (char *s, char *set);
  42      =2  extern char *strrpbrk (char *s, char *set);
  43      =2  extern char *strstr  (char *s, char *sub);
  44      =2  extern char *strtok  (char *str, const char *set);
  45      =2  
  46      =2  extern char memcmp (void *s1, void *s2, int n);
  47      =2  extern void *memcpy (void *s1, void *s2, int n);
  48      =2  extern void *memchr (void *s, char val, int n);
  49      =2  extern void *memccpy (void *s1, void *s2, char val, int n);
  50      =2  extern void *memmove (void *s1, void *s2, int n);
  51      =2  extern void *memset  (void *s, char val, int n);
  52      =2  #pragma RESTORE
  53      =2  
  54      =2  #endif
  27      =1  #include <math.h> 
   1      =2  /*--------------------------------------------------------------------------
   2      =2  MATH.H
   3      =2  
   4      =2  Prototypes for mathematic functions.
   5      =2  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =2  All rights reserved.
   7      =2  --------------------------------------------------------------------------*/
   8      =2  
   9      =2  #ifndef __MATH_H__
  10      =2  #define __MATH_H__
  11      =2  
  12      =2  #pragma SAVE
  13      =2  #pragma REGPARMS
  14      =2  extern char  cabs  (char  val);
  15      =2  extern int    abs  (int   val);
  16      =2  extern long  labs  (long  val);
  17      =2  extern float fabs  (float val);
  18      =2  extern float sqrt  (float val);
  19      =2  extern float exp   (float val);
  20      =2  extern float log   (float val);
  21      =2  extern float log10 (float val);
  22      =2  extern float sin   (float val);
  23      =2  extern float cos   (float val);
  24      =2  extern float tan   (float val);
  25      =2  extern float asin  (float val);
  26      =2  extern float acos  (float val);
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 6   

  27      =2  extern float atan  (float val);
  28      =2  extern float sinh  (float val);
  29      =2  extern float cosh  (float val);
  30      =2  extern float tanh  (float val);
  31      =2  extern float atan2 (float y, float x);
  32      =2  
  33      =2  extern float ceil  (float val);
  34      =2  extern float floor (float val);
  35      =2  extern float modf  (float val, float *n);
  36      =2  extern float fmod  (float x, float y);
  37      =2  extern float pow   (float x, float y);
  38      =2  
  39      =2  #pragma RESTORE
  40      =2  
  41      =2  #endif
  28      =1  #include "STC12C56.H"
   1      =2  /*------------------------------------------------*/
   2      =2  /* --- ºê¾§¿Æ¼¼ STCMCU ---------------------------*/
   3      =2  /* --- Mobile: (86)13922805190 -------------------*/
   4      =2  /* --- Fax: 86-755-82944243 ----------------------*/
   5      =2  /* --- Tel: 86-755-82948412 ----------------------*/
   6      =2  /* --- Web: www.STCMCU.com -----------------------*/
   7      =2  /* ÊÊÓÃÓÚ: STC12C56xx    STC12LE56xx  ------------*/
   8      =2  /* ------- STC12C56xxAD  STC12LE56xxAD  ----------*/
   9      =2  /*------------------------------------------------*/
  10      =2  
  11      =2  #ifndef __STC12C56_H__
  12      =2  #define __STC12C56_H__
  13      =2  
  14      =2  //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -//////
  15      =2  
  16      =2  sfr  PSW        =   0xd0;       //³ÌÐò×´Ì¬×Ö            Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
  17      =2                                  //Î»ÃèÊö                CY      AC      F0      RS1     RS0     OV      F1
             -      P
  18      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
  19      =2  
  20      =2  sbit CY         =   PSW^7;      //½øÎ»±êÖ¾
  21      =2  sbit AC         =   PSW^6;      //¸¨Öú½øÎ»±êÖ¾
  22      =2  sbit F0         =   PSW^5;      //ÓÃ»§±êÖ¾
  23      =2  sbit RS1        =   PSW^4;      //¼Ä´æÆ÷×éÑ¡ÔñÎ»1
  24      =2  sbit RS0        =   PSW^3;      //¼Ä´æÆ÷×éÑ¡ÔñÎ»0
  25      =2  sbit OV         =   PSW^2;      //Òç³ö±êÖ¾
  26      =2  sbit P          =   PSW^0;      //ACCµÄÅ¼Ð£ÑéÎ»
  27      =2  
  28      =2  /////////////////////////////////
  29      =2  
  30      =2  sfr  ACC        =   0xe0;       //ÀÛ¼ÓÆ÷                Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
  31      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
  32      =2  
  33      =2  sbit ACC7       =   ACC^7;      //ÀÛ¼ÓÆ÷µÚ7Î»
  34      =2  sbit ACC6       =   ACC^6;      //ÀÛ¼ÓÆ÷µÚ6Î»
  35      =2  sbit ACC5       =   ACC^5;      //ÀÛ¼ÓÆ÷µÚ5Î»
  36      =2  sbit ACC4       =   ACC^4;      //ÀÛ¼ÓÆ÷µÚ4Î»
  37      =2  sbit ACC3       =   ACC^3;      //ÀÛ¼ÓÆ÷µÚ3Î»
  38      =2  sbit ACC2       =   ACC^2;      //ÀÛ¼ÓÆ÷µÚ2Î»
  39      =2  sbit ACC1       =   ACC^1;      //ÀÛ¼ÓÆ÷µÚ1Î»
  40      =2  sbit ACC0       =   ACC^0;      //ÀÛ¼ÓÆ÷µÚ0Î»
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 7   

  41      =2  
  42      =2  /////////////////////////////////
  43      =2  
  44      =2  sfr  B          =   0xf0;       //B¼Ä´æÆ÷               Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
  45      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
  46      =2  
  47      =2  /////////////////////////////////
  48      =2  
  49      =2  sfr  SP         =   0x81;       //¶ÑÕ»Ö¸Õë              Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
  50      =2                                  //³õÊ¼Öµ=0000,0111      0       0       0       0       0       1       1 
             -      1
  51      =2  
  52      =2  /////////////////////////////////
  53      =2  
  54      =2  sfr  DPL        =   0x82;       //Êý¾ÝÖ¸ÕëµÍ×Ö½Ú        Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
  55      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
  56      =2  
  57      =2  /////////////////////////////////
  58      =2  
  59      =2  sfr  DPH        =   0x83;       //Êý¾ÝÖ¸Õë¸ß×Ö½Ú        Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
  60      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
  61      =2  
  62      =2  //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -//////
  63      =2  
  64      =2  sfr  PCON       =   0x87;       //µçÔ´¿ØÖÆ¼Ä´æÆ÷        Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
  65      =2                                  //Î»ÃèÊö                SMOD    SMOD0   LVDF    POF     GF1     GF0     PD
             -      IDL
  66      =2                                  //³õÊ¼Öµ=0011,0000      0       0       1       1       0       0       0 
             -      0
  67      =2  
  68      =2  #define SMOD        0x80        //´®¿Ú²¨ÌØÂÊ±¶ËÙÎ»,ÖÃ1¿ÉÊ¹²¨ÌØÂÊ¿ì1±¶
  69      =2  #define SMOD0       0x40        //FE/SM0Ñ¡ÔñÎ»,0:SCON.7ÎªSM0 1:SCON.7ÎªFE
  70      =2  #define LVDF        0x20        //µÍÑ¹¼ì²âÖÐ¶ÏÇëÇóÎ»,ÓÉÓ²¼þÖÃ1,ÐèÓÉÈí¼þÇå0
  71      =2  #define POF         0x10        //ÉÏµç¸´Î»±êÖ¾Î»,ÉÏµçÊ±ÓÉÓ²¼þÖÃ1,ÐèÓÉÈí¼þÇå0
  72      =2  #define GF1         0x08        //Í¨ÓÃ±êÖ¾Î»1
  73      =2  #define GF0         0x04        //Í¨ÓÃ±êÖ¾Î»0
  74      =2  #define PD          0x02        //µôµç¿ØÖÆÎ»,Ð´1¿ÉÒÔÊ¹MCU½øÈëPowerDownÄ£Ê½
  75      =2  #define IDL         0x01        //¿ÕÏÐ¿ØÖÆÎ»,Ð´1¿ÉÒÔÊ¹MCU½øÈëIdleÄ£Ê½
  76      =2  
  77      =2  /////////////////////////////////
  78      =2  
  79      =2  sfr  WAKE_CLKO  =   0x8f;       //µôµç»½ÐÑ/Ê±ÖÓÊä³ö¿ØÖÆ Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
  80      =2                                  //Î»ÃèÊö          PCAWAKEUP RXDPINIE T1PINIE T0PINIE    -       -      T1V
             -LKO  T0CLKO
  81      =2                                  //³õÊ¼Öµ=0000,xx00      0       0       0       0       x       x       0 
             -      0
  82      =2  
  83      =2  #define PCAWAKEUP   0x80        //ÔÊÐíPCAµÄÉÏÉýÑØ/ÏÂ½µÑØÖÐ¶Ï»½ÐÑµôµçMCU
  84      =2  #define RXD_PIN_IE  0x40        //ÔÊÐíRXD(P3.0)ÏÂ½µÑØÖÃÎ»RIÖÐ¶ÏÊ±»½ÐÑµôµçMCU(±ØÐë´ò¿ªÏàÓ¦ÖÐ¶Ï)
  85      =2  #define T1_PIN_IE   0x20        //ÔÊÐíT1(P3.5)ÏÂ½µÑØÖÃÎ»T1ÖÐ¶ÏÊ±»½ÐÑµôµçMCU(±ØÐë´ò¿ªÏàÓ¦ÖÐ¶Ï)
  86      =2  #define T0_PIN_IE   0x10        //ÔÊÐíT0(P3.4)ÏÂ½µÑØÖÃÎ»T0ÖÐ¶ÏÊ±»½ÐÑµôµçMCU(±ØÐë´ò¿ªÏàÓ¦ÖÐ¶Ï)
  87      =2  #define T1CLKOEN    0x02        //´ò¿ªP3.5½ÅµÄ¶¨Ê±Æ÷1Ê±ÖÓÒç³öÂö³å,Êä³öµÄÊ±ÖÓÆµÂÊÎª1/2±¶µÄT1Òç³öÂÊ
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 8   

  88      =2  #define T0CLKOEN    0x01        //´ò¿ªP3.4½ÅµÄ¶¨Ê±Æ÷0Ê±ÖÓÒç³öÂö³å,Êä³öµÄÊ±ÖÓÆµÂÊÎª1/2±¶µÄT0Òç³öÂÊ
  89      =2  
  90      =2  /////////////////////////////////
  91      =2  
  92      =2  sfr  CLK_DIV    =   0xc7;       //Ê±ÖÓ·ÖÆµ¼Ä´æÆ÷        Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
  93      =2                                  //Î»ÃèÊö                -       -       -       -       -       CLKS2   CL
             -KS1   CLKS0
  94      =2                                  //³õÊ¼Öµ=xxxx,x000      x       x       x       x       x       0       0 
             -      0
  95      =2  
  96      =2  #define FOSCD1      0x00        //ÏµÍ³Ê±ÖÓÎªFosc
  97      =2  #define FOSCD2      0x01        //ÏµÍ³Ê±ÖÓÎªFosc/2
  98      =2  #define FOSCD4      0x02        //ÏµÍ³Ê±ÖÓÎªFosc/4
  99      =2  #define FOSCD8      0x03        //ÏµÍ³Ê±ÖÓÎªFosc/8
 100      =2  #define FOSCD16     0x04        //ÏµÍ³Ê±ÖÓÎªFosc/16
 101      =2  #define FOSCD32     0x05        //ÏµÍ³Ê±ÖÓÎªFosc/32
 102      =2  #define FOSCD64     0x06        //ÏµÍ³Ê±ÖÓÎªFosc/64
 103      =2  #define FOSCD128    0x07        //ÏµÍ³Ê±ÖÓÎªFosc/128
 104      =2  
 105      =2  /////////////////////////////////
 106      =2  
 107      =2  sfr  WDT_CONTR  =   0xe1;       //¿´ÃÅ¹·¶¨Ê±Æ÷¿ØÖÆÆ÷    Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 108      =2                                  //Î»ÃèÊö             WDT_FLAG   -       EN_WDT  CLR_WDT IDL_WDT PS2     PS
             -1     PS0
 109      =2                                  //³õÊ¼Öµ=0x00,0000      0       x       0       0       0       0       0 
             -      0
 110      =2  
 111      =2  #define WDT_FLAG    0x80        //¿´ÃÅ¹·¸´Î»±êÖ¾,µ±¿´ÃÅ¹·Òç³ö²úÉú¸´Î»ºó,Ó²¼þ×Ô¶¯ÖÃ1,ÐèÒªÓÉÈí¼þÇå0
 112      =2  #define EN_WDT      0x20        //Èí¼þÊ¹ÄÜ¿´ÃÅ¹·,´ò¿ªºó²»ÄÜÓÃÈí¼þµÄ·½Ê½¹Ø±Õ
 113      =2  #define CLR_WDT     0x10        //Çå¿´ÃÅ¹·¶¨Ê±Æ÷
 114      =2  #define IDLE_WDT    0x08        //IDLEÄ£Ê½ÏÂ,¿´ÃÅ¹·¶¨Ê±Æ÷ÊÇ·ñ¼ÌÐø¼ÆÊ±
 115      =2  
 116      =2  //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -//////
 117      =2  
 118      =2  sfr  AUXR       =   0x8e;       //¸¨Öú¼Ä´æÆ÷            Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 119      =2                                  //Î»ÃèÊö                T0x12   T1x12   UM0x6   EADCI   ESPI    ELVDI   - 
             -      -
 120      =2                                  //³õÊ¼Öµ=0000,00xx      0       0       0       0       0       0       x 
             -      x
 121      =2  
 122      =2  #define T0x12       0x80        //¶¨Ê±Æ÷0Ê±ÖÓ¿ØÖÆ,0:Fosc/12(´«Í³µÄ12·ÖÆµ) 1:Fosc/1(1TÄ£Ê½,²»·ÖÆµ,¼´12±¶ÓÚ´
             -«Í³ËÙ¶È)
 123      =2  #define T1x12       0x40        //¶¨Ê±Æ÷1Ê±ÖÓ¿ØÖÆ,0:Fosc/12(´«Í³µÄ12·ÖÆµ) 1:Fosc/1(1TÄ£Ê½,²»·ÖÆµ,¼´12±¶ÓÚ´
             -«Í³ËÙ¶È)
 124      =2  #define UR0x6       0x20        //´®¿ÚÄ£Ê½0µÄÊ±ÖÓ¿ØÖÆ,0:Fosc/12(´«Í³µÄ12·ÖÆµ) 1:Fosc/2(2·ÖÆµ,,¼´6±¶ÓÚ´«Í³Ë
             -Ù¶È)
 125      =2  #define EADCI       0x10        //Ê¹ÄÜADCÖÐ¶ÏÎ»
 126      =2  #define ESPI        0x08        //Ê¹ÄÜSPIÖÐ¶ÏÎ»
 127      =2  #define ELVDI       0x04        //Ê¹ÄÜLVDÖÐ¶ÏÎ»
 128      =2  
 129      =2  //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -//////
 130      =2  
 131      =2  sfr  P0         =   0x80;       //I/O¶Ë¿Ú0              Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 132      =2                                  //Î»ÃèÊö                -       -       -       -       P0.3    P0.2    P0
             -.1    P0.0
 133      =2                                  //³õÊ¼Öµ=xxxx,1111      x       x       x       x       1       1       1 
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 9   

             -      1
 134      =2  
 135      =2  sbit P03        =   P0^3;       //I/O¿ÚP0.3
 136      =2  sbit P02        =   P0^2;       //I/O¿ÚP0.2
 137      =2  sbit P01        =   P0^1;       //I/O¿ÚP0.1
 138      =2  sbit P00        =   P0^0;       //I/O¿ÚP0.0
 139      =2  
 140      =2  /////////////////////////////////
 141      =2  
 142      =2  sfr  P1         =   0x90;       //I/O¶Ë¿Ú0              Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 143      =2                                  //Î»ÃèÊö                P1.7    P1.6    P1.5    P1.4    P1.3    P1.2    P1
             -.1    P1.0
 144      =2                                  //³õÊ¼Öµ=1111,1111      1       1       1       1       1       1       1 
             -      1
 145      =2  
 146      =2  sbit P17        =   P1^7;       //I/O¿ÚP1.7
 147      =2  sbit P16        =   P1^6;       //I/O¿ÚP1.6
 148      =2  sbit P15        =   P1^5;       //I/O¿ÚP1.5
 149      =2  sbit P14        =   P1^4;       //I/O¿ÚP1.4
 150      =2  sbit P13        =   P1^3;       //I/O¿ÚP1.3
 151      =2  sbit P12        =   P1^2;       //I/O¿ÚP1.2
 152      =2  sbit P11        =   P1^1;       //I/O¿ÚP1.1
 153      =2  sbit P10        =   P1^0;       //I/O¿ÚP1.0
 154      =2  
 155      =2  sbit ADCIN7     =   P1^7;       //ADCÍ¨µÀ7µÄÄ£ÄâÐÅºÅÊäÈë½Å
 156      =2  sbit ADCIN6     =   P1^6;       //ADCÍ¨µÀ6µÄÄ£ÄâÐÅºÅÊäÈë½Å
 157      =2  sbit ADCIN5     =   P1^5;       //ADCÍ¨µÀ5µÄÄ£ÄâÐÅºÅÊäÈë½Å
 158      =2  sbit ADCIN4     =   P1^4;       //ADCÍ¨µÀ4µÄÄ£ÄâÐÅºÅÊäÈë½Å
 159      =2  sbit ADCIN3     =   P1^3;       //ADCÍ¨µÀ3µÄÄ£ÄâÐÅºÅÊäÈë½Å
 160      =2  sbit ADCIN2     =   P1^2;       //ADCÍ¨µÀ2µÄÄ£ÄâÐÅºÅÊäÈë½Å
 161      =2  sbit ADCIN1     =   P1^1;       //ADCÍ¨µÀ1µÄÄ£ÄâÐÅºÅÊäÈë½Å
 162      =2  sbit ADCIN0     =   P1^0;       //ADCÍ¨µÀ0µÄÄ£ÄâÐÅºÅÊäÈë½Å
 163      =2  
 164      =2  sbit SPISCLK    =   P1^7;       //SPI×ÜÏßµÄÊ±ÖÓ½Å
 165      =2  sbit SPIMISO    =   P1^6;       //SPI×ÜÏßµÄÖ÷³ö´ÓÈë½Å
 166      =2  sbit SPIMOSI    =   P1^5;       //SPI×ÜÏßµÄÖ÷Èë´Ó³ö½Å
 167      =2  sbit SPISS      =   P1^4;       //SPI×ÜÏßµÄ´Ó»úÑ¡Ôñ½Å
 168      =2  
 169      =2  sbit T1CLKO     =   P1^1;       //¶¨Ê±Æ÷1Ê±ÖÓÒç³öÂö³åÊä³ö½Å
 170      =2  sbit T0CLKO     =   P1^0;       //¶¨Ê±Æ÷0Ê±ÖÓÒç³öÂö³åÊä³ö½Å
 171      =2  
 172      =2  /////////////////////////////////
 173      =2  
 174      =2  sfr  P2         =   0xa0;       //I/O¶Ë¿Ú2              Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 175      =2                                  //Î»ÃèÊö                P2.7    P2.6    P2.5    P2.4    P2.3    P2.2    P2
             -.1    P2.0
 176      =2                                  //³õÊ¼Öµ=1111,1111      1       1       1       1       1       1       1 
             -      1
 177      =2  
 178      =2  sbit P27        =   P2^7;       //I/O¿ÚP2.7
 179      =2  sbit P26        =   P2^6;       //I/O¿ÚP2.6
 180      =2  sbit P25        =   P2^5;       //I/O¿ÚP2.5
 181      =2  sbit P24        =   P2^4;       //I/O¿ÚP2.4
 182      =2  sbit P23        =   P2^3;       //I/O¿ÚP2.3
 183      =2  sbit P22        =   P2^2;       //I/O¿ÚP2.2
 184      =2  sbit P21        =   P2^1;       //I/O¿ÚP2.1
 185      =2  sbit P20        =   P2^0;       //I/O¿ÚP2.0
 186      =2  
 187      =2  sbit CEX3       =   P2^4;       //±È½Ï/²¶»ñ/PWM3Íâ²¿Òý½Å
 188      =2  sbit CEX2       =   P2^0;       //±È½Ï/²¶»ñ/PWM2Íâ²¿Òý½Å
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 10  

 189      =2  
 190      =2  /////////////////////////////////
 191      =2  
 192      =2  sfr  P3         =   0xb0;       //I/O¶Ë¿Ú3              Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 193      =2                                  //Î»ÃèÊö                P3.7    -       P3.5    P3.4    P3.3    P3.2    P3
             -.1    P3.0
 194      =2                                  //³õÊ¼Öµ=1x11,1111      1       x       1       1       1       1       1 
             -      1
 195      =2  
 196      =2  sbit P37        =   P3^7;       //I/O¿ÚP3.7
 197      =2  sbit P35        =   P3^5;       //I/O¿ÚP3.5
 198      =2  sbit P34        =   P3^4;       //I/O¿ÚP3.4
 199      =2  sbit P33        =   P3^3;       //I/O¿ÚP3.3
 200      =2  sbit P32        =   P3^2;       //I/O¿ÚP3.2
 201      =2  sbit P31        =   P3^1;       //I/O¿ÚP3.1
 202      =2  sbit P30        =   P3^0;       //I/O¿ÚP3.0
 203      =2  
 204      =2  sbit RXD        =   P3^0;       //´®¿Ú1µÄÊý¾Ý½ÓÊÕ¿Ú
 205      =2  sbit TXD        =   P3^1;       //´®¿Ú1µÄÊý¾Ý·¢ËÍ¿Ú
 206      =2  sbit INT0       =   P3^2;       //Íâ²¿ÖÐ¶Ï0µÄÐÅºÅÊäÈë¿Ú
 207      =2  sbit INT1       =   P3^3;       //Íâ²¿ÖÐ¶Ï1µÄÐÅºÅÊä³ö¿Ú
 208      =2  sbit T0         =   P3^4;       //¶¨Ê±Æ÷0µÄÍâ²¿ÐÅºÅÊäÈë¿Ú
 209      =2  sbit T1         =   P3^5;       //¶¨Ê±Æ÷1µÄÍâ²¿ÐÅºÅÊäÈë¿Ú
 210      =2  
 211      =2  sbit CEX0       =   P3^7;       //±È½Ï/²¶»ñ/PWM0Íâ²¿Òý½Å
 212      =2  sbit CEX1       =   P3^5;       //±È½Ï/²¶»ñ/PWM1Íâ²¿Òý½Å
 213      =2  sbit ECI        =   P3^4;       //±È½Ï/²¶»ñ/PWMÄ£¿éµÄÍâ²¿Ê±ÖÓÊäÈë½Å(×î´óÖµÎªFosc/2)
 214      =2  
 215      =2  /////////////////////////////////
 216      =2  
 217      =2  sfr  P1M0       =   0x91;       //I/O¿Ú1Ä£Ê½¿ØÖÆÆ÷1     Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 218      =2                                  //³õ/Ê¼Öµ=0000,0000     0       0       0       0       0       0       0 
             -      0
 219      =2  
 220      =2  /////////////////////////////////
 221      =2  
 222      =2  sfr  P1M1       =   0x92;       //I/O¿Ú1Ä£Ê½¿ØÖÆÆ÷0     Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 223      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 224      =2  
 225      =2  /////////////////////////////////
 226      =2  
 227      =2  sfr  P0M0       =   0x93;       //I/O¿Ú0Ä£Ê½¿ØÖÆÆ÷1     Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 228      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 229      =2  
 230      =2  /////////////////////////////////
 231      =2  
 232      =2  sfr  P0M1       =   0x94;       //I/O¿Ú0Ä£Ê½¿ØÖÆÆ÷0     Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 233      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 234      =2  
 235      =2  /////////////////////////////////
 236      =2  
 237      =2  sfr  P2M0       =   0x95;       //I/O¿Ú2Ä£Ê½¿ØÖÆÆ÷1     Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 238      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 11  

             -      0
 239      =2  
 240      =2  /////////////////////////////////
 241      =2  
 242      =2  sfr  P2M1       =   0x96;       //I/O¿Ú2Ä£Ê½¿ØÖÆÆ÷0     Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 243      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 244      =2  
 245      =2  /////////////////////////////////
 246      =2  
 247      =2  sfr  P3M0       =   0xb1;       //I/O¿Ú3Ä£Ê½¿ØÖÆÆ÷1     Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 248      =2                                  //³õ/Ê¼Öµ=0000,0000     0       0       0       0       0       0       0 
             -      0
 249      =2  
 250      =2  /////////////////////////////////
 251      =2  
 252      =2  sfr  P3M1       =   0xb2;       //I/O¿Ú3Ä£Ê½¿ØÖÆÆ÷0     Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 253      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 254      =2  
 255      =2  /////////////////////////////////
 256      =2  
 257      =2  // PxM0 PxM1
 258      =2  //  0    0     ×¼Ë«Ïò¿Ú
 259      =2  //  0    1     Ç¿ÍÆÍìÊä³ö
 260      =2  //  1    0     ¸ß×èÊäÈëÌ¬
 261      =2  //  1    1     ¿ªÂ©Êä³ö
 262      =2  
 263      =2  //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -//////
 264      =2  
 265      =2  sfr  IE         =   0xa8;       //ÖÐ¶ÏÊ¹ÄÜ¼Ä´æÆ÷        Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 266      =2                                  //Î»ÃèÊö                EA   EPCA_LVD EADC_SPI  ES      ET1     EX1     ET
             -0     EX0
 267      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 268      =2  
 269      =2  sbit EA         =   IE^7;       //×ÜÖÐ¶Ï¿ª¹Ø
 270      =2  sbit EPCA_LVD   =   IE^6;       //PCAºÍLVD×ÜÖÐ¶ÏÊ¹ÄÜÎ»,Òª´ò¿ªPCA/LVDÖÐ¶Ï,»¹ÐèÒªÊ¹ÄÜCCAPMn.ECCFn/AUXR.ELVDI
 271      =2  sbit EADC_SPI   =   IE^5;       //ADCºÍSPI×ÜÖÐ¶ÏÊ¹ÄÜÎ»,Òª´ò¿ªADC/SPIÖÐ¶Ï,»¹ÐèÒªÊ¹ÄÜAUXR.EADCI/AUXR.ESPII
 272      =2  sbit ES         =   IE^4;       //´®¿ÚÖÐ¶ÏÊ¹ÄÜÎ»
 273      =2  sbit ET1        =   IE^3;       //¶¨Ê±Æ÷1ÖÐ¶ÏÊ¹ÄÜÎ»
 274      =2  sbit EX1        =   IE^2;       //Íâ²¿ÖÐ¶Ï1ÖÐ¶ÏÊ¹ÄÜÎ»
 275      =2  sbit ET0        =   IE^1;       //¶¨Ê±Æ÷0ÖÐ¶ÏÊ¹ÄÜÎ»
 276      =2  sbit EX0        =   IE^0;       //Íâ²¿ÖÐ¶Ï0ÖÐ¶ÏÊ¹ÄÜÎ»
 277      =2  
 278      =2  /////////////////////////////////
 279      =2  
 280      =2  #define X0_INTNO    0           //Íâ²¿ÖÐ¶Ï0ÖÐ¶ÏºÅ,Èë¿ÚµØÖ·Îª0003H
 281      =2  #define T0_INTNO    1           //¶¨Ê±Æ÷0ÖÐ¶ÏºÅ,Èë¿ÚµØÖ·Îª000BH
 282      =2  #define X1_INTNO    2           //Íâ²¿ÖÐ¶Ï1ÖÐ¶ÏºÅ,Èë¿ÚµØÖ·Îª0013H
 283      =2  #define T1_INTNO    3           //¶¨Ê±Æ÷1ÖÐ¶ÏºÅ,Èë¿ÚµØÖ·Îª001BH
 284      =2  #define UART_INTNO  4           //´®¿ÚÖÐ¶ÏºÅ,Èë¿ÚµØÖ·Îª0023H
 285      =2  #define ADC_SPI_INTNO   5       //SPI/ADCÖÐ¶ÏºÅ,Èë¿ÚµØÖ·Îª002BH
 286      =2  #define PCA_LVD_INTNO   6       //PCA/LVDÖÐ¶ÏºÅ,Èë¿ÚµØÖ·Îª0033H
 287      =2  
 288      =2  /////////////////////////////////
 289      =2  
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 12  

 290      =2  sfr  IPH        =   0xb7;       //ÖÐ¶ÏÓÅÏÈ¼¶¼Ä´æÆ÷¸ßÎ»  Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 291      =2                                  //Î»ÃèÊö                -    PCA_LVDH PADC_SPIH PSH     PT1H    PX1H    PT
             -0H    PX0H
 292      =2                                  //³õÊ¼Öµ=x000,0000      x       0       0       0       0       0       0 
             -      0
 293      =2  
 294      =2  #define PPCA_LVDH   0x40        //PCA/LVDÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆ¸ßÎ»
 295      =2  #define PADC_SPIH   0x20        //ADC/SPIÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆ¸ßÎ»
 296      =2  #define PSH         0x10        //´®¿ÚÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆ¸ßÎ»
 297      =2  #define PT1H        0x08        //¶¨Ê±Æ÷1ÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆ¸ßÎ»
 298      =2  #define PX1H        0x04        //Íâ²¿ÖÐ¶Ï1ÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆ¸ßÎ»
 299      =2  #define PT0H        0x02        //¶¨Ê±Æ÷0ÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆ¸ßÎ»
 300      =2  #define PX0H        0x01        //Íâ²¿ÖÐ¶Ï0ÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆ¸ßÎ»
 301      =2  
 302      =2  /////////////////////////////////
 303      =2  
 304      =2  sfr  IP         =   0xb8;       //ÖÐ¶ÏÓÅÏÈ¼¶¼Ä´æÆ÷      Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 305      =2                                  //Î»ÃèÊö                -    PPCA_LVD PADC_SPI  PS      PT1     PX1     PT
             -0     PX0
 306      =2                                  //³õÊ¼Öµ=x000,0000      x       0       0       0       0       0       0 
             -      0
 307      =2  
 308      =2  sbit PPCA_LVD   =   IP^6;       //PCA/LVDÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆµÍÎ»
 309      =2  sbit PADC_SPI   =   IP^5;       //ADC/SPIÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆµÍÎ»
 310      =2  sbit PS         =   IP^4;       //´®¿ÚÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆµÍÎ»
 311      =2  sbit PT1        =   IP^3;       //¶¨Ê±Æ÷1ÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆµÍÎ»
 312      =2  sbit PX1        =   IP^2;       //Íâ²¿ÖÐ¶Ï1ÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆµÍÎ»
 313      =2  sbit PT0        =   IP^1;       //¶¨Ê±Æ÷0ÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆµÍÎ»
 314      =2  sbit PX0        =   IP^0;       //Íâ²¿ÖÐ¶Ï0ÖÐ¶ÏÓÅÏÈ¼¶¿ØÖÆµÍÎ»
 315      =2  
 316      =2  //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -//////
 317      =2  
 318      =2  sfr  TCON       =   0x88;       //¶¨Ê±Æ÷0/1¿ØÖÆ¼Ä´æÆ÷   Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 319      =2                                  //Î»ÃèÊö                TF1     TR1     TF0     TR0     IE1     IT1     IE
             -0     IT0
 320      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 321      =2  
 322      =2  sbit TF1        = TCON^7;       //¶¨Ê±Æ÷1Òç³ö±êÖ¾,ÓÉÓ²¼þÖÃ1,¿ÉÓÉÈí¼þÇå0»òÕßÔÚÖÐ¶Ï´¦Àí³ÌÐòÍê³ÉºóÓÉÓ²¼þ×Ô¶¯Ç
             -å0
 323      =2  sbit TR1        = TCON^6;       //¶¨Ê±Æ÷1µÄÆô¶¯¿ØÖÆÎ»,1:Æô¶¯¶¨Ê±Æ÷ 0:Í£Ö¹¶¨Ê±Æ÷
 324      =2  sbit TF0        = TCON^5;       //¶¨Ê±Æ÷0Òç³ö±êÖ¾,ÓÉÓ²¼þÖÃ1,¿ÉÓÉÈí¼þÇå0»òÕßÔÚÖÐ¶Ï´¦Àí³ÌÐòÍê³ÉºóÓÉÓ²¼þ×Ô¶¯Ç
             -å0
 325      =2  sbit TR0        = TCON^4;       //¶¨Ê±Æ÷0µÄÆô¶¯¿ØÖÆÎ»,1:Æô¶¯¶¨Ê±Æ÷ 0:Í£Ö¹¶¨Ê±Æ÷
 326      =2  sbit IE1        = TCON^3;       //Íâ²¿ÖÐ¶Ï1µÄÖÐ¶ÏÇëÇóÎ»,ÓÉÓ²¼þÖÃ1,¿ÉÓÉÈí¼þÇå0»òÕßÔÚÖÐ¶Ï´¦Àí³ÌÐòÍê³ÉºóÓÉÓ²¼
             -þ×Ô¶¯Çå0
 327      =2  sbit IT1        = TCON^2;       //Íâ²¿ÖÐ¶Ï1µÄ´¥·¢ÀàÐÍ,0:µÍµçÆ½´¥·¢Íâ²¿ÖÐ¶Ï 1:ÏÂ½µÑØ´¥·¢Íâ²¿ÖÐ¶Ï
 328      =2  sbit IE0        = TCON^1;       //Íâ²¿ÖÐ¶Ï0µÄÖÐ¶ÏÇëÇóÎ»,ÓÉÓ²¼þÖÃ1,¿ÉÓÉÈí¼þÇå0»òÕßÔÚÖÐ¶Ï´¦Àí³ÌÐòÍê³ÉºóÓÉÓ²¼
             -þ×Ô¶¯Çå0
 329      =2  sbit IT0        = TCON^0;       //Íâ²¿ÖÐ¶Ï0µÄ´¥·¢ÀàÐÍ,0:µÍµçÆ½´¥·¢Íâ²¿ÖÐ¶Ï 1:ÏÂ½µÑØ´¥·¢Íâ²¿ÖÐ¶Ï
 330      =2  
 331      =2  /////////////////////////////////
 332      =2  
 333      =2  sfr  TMOD       =   0x89;       //¶¨Ê±Æ÷0/1Ä£Ê½¼Ä´æÆ÷   Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 334      =2                                  //Î»ÃèÊö                GATE    C/T#    M1      M0      GATE    C/T#    M1
             -      M0
 335      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 13  

             -      0
 336      =2  
 337      =2  #define GATE1       0x80        //¶¨Ê±Æ÷1Æô¶¯¿ØÖÆÎ»,0:TR1Îª1Ê±Æô¶¯¶¨Ê±Æ÷1 1:TR1Îª1ÇÒINT1Îª¸ßµçÆ½Ê±²ÅÆô¶¯¶¨
             -Ê±Æ÷1
 338      =2  #define C_T1        0x40        //¶¨Ê±Æ÷/¼ÆÊýÆ÷Ñ¡ÔñÎ»,0:¶¨Ê±Æ÷(Ê±ÖÓÔ´ÎªÄÚ²¿Ê±ÖÓ) 1:¼ÆÊýÆ÷(Ê±ÖÓÔ´ÎªT1Òý½ÅµÄ
             -Íâ²¿Ê±ÖÓ)
 339      =2  #define T1_M0       0x00        //¶¨Ê±Æ÷1²Ù×÷Ä£Ê½0:13Î»¶¨Ê±Æ÷
 340      =2  #define T1_M1       0x10        //¶¨Ê±Æ÷1²Ù×÷Ä£Ê½1:16Î»¶¨Ê±Æ÷
 341      =2  #define T1_M2       0x20        //¶¨Ê±Æ÷1²Ù×÷Ä£Ê½2:8Î»×Ô¶¯ÖØÔØ¶¨Ê±Æ÷
 342      =2  #define T1_M3       0x30        //¶¨Ê±Æ÷1²Ù×÷Ä£Ê½3:¶¨Ê±Æ÷1Í£Ö¹
 343      =2  #define GATE0       0x08        //¶¨Ê±Æ÷1Æô¶¯¿ØÖÆÎ»,0:TR0Îª1Ê±Æô¶¯¶¨Ê±Æ÷1 1:TR0Îª1ÇÒINT0Îª¸ßµçÆ½Ê±²ÅÆô¶¯¶¨
             -Ê±Æ÷0
 344      =2  #define C_T0        0x04        //¶¨Ê±Æ÷/¼ÆÊýÆ÷Ñ¡ÔñÎ»,0:¶¨Ê±Æ÷(Ê±ÖÓÔ´ÎªÄÚ²¿Ê±ÖÓ) 1:¼ÆÊýÆ÷(Ê±ÖÓÔ´ÎªT0Òý½ÅµÄ
             -Íâ²¿Ê±ÖÓ)
 345      =2  #define T0_M0       0x00        //¶¨Ê±Æ÷0²Ù×÷Ä£Ê½0:13Î»¶¨Ê±Æ÷
 346      =2  #define T0_M1       0x01        //¶¨Ê±Æ÷0²Ù×÷Ä£Ê½1:16Î»¶¨Ê±Æ÷
 347      =2  #define T0_M2       0x02        //¶¨Ê±Æ÷0²Ù×÷Ä£Ê½2:8Î»×Ô¶¯ÖØÔØ¶¨Ê±Æ÷
 348      =2  #define T0_M3       0x03        //¶¨Ê±Æ÷0²Ù×÷Ä£Ê½3:TL0ºÍTH0ÎªÁ½×é¶ÀÁ¢8Î»¶¨Ê±Æ÷
 349      =2  
 350      =2  /////////////////////////////////
 351      =2  
 352      =2  sfr  TL0        = 0x8a;         //¶¨Ê±Æ÷0µÄµÍ8Î»¼ÆÊýÖµ  Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 353      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 354      =2  
 355      =2  /////////////////////////////////
 356      =2  
 357      =2  sfr  TL1        = 0x8b;         //¶¨Ê±Æ÷1µÄµÍ8Î»¼ÆÊýÖµ  Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 358      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 359      =2  
 360      =2  /////////////////////////////////
 361      =2  
 362      =2  sfr  TH0        = 0x8c;         //¶¨Ê±Æ÷0µÄ¸ß8Î»¼ÆÊýÖµ  Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 363      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 364      =2  
 365      =2  /////////////////////////////////
 366      =2  
 367      =2  sfr  TH1        = 0x8d;         //¶¨Ê±Æ÷1µÄ¸ß8Î»¼ÆÊýÖµ  Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 368      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 369      =2  
 370      =2  //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -//////
 371      =2  
 372      =2  sfr  SCON       =   0x98;       //´®¿Ú¿ØÖÆ¼Ä´æÆ÷        Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 373      =2                                  //Î»ÃèÊö                SM0/FE  SM1     SM2     REN     TB8     RB8     TI
             -      Ri
 374      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 375      =2  
 376      =2  sbit FE         =   SCON^7;     //Ö¡´íÎó¼ì²âÎ»,µ±´®¿ÚÄ£¿éÔÚ½ÓÊÕÊý¾ÝÊ±Ã»ÓÐ¼ì²âµ½ÕýÈ·µÄÍ£Ö¹Î»Ê±,FE±»Ó²¼þÖÃ1,
             -ÐèÒªÓÉÈí¼þÀ´Çå0(µ±SMOD0Îª1Ê±,FEÓÐÐ§)
 377      =2  sbit SM0        =   SCON^7;     //´®¿ÚÄ£Ê½ÉèÖÃÎ»
 378      =2  sbit SM1        =   SCON^6;     //SM0/SM1=0/0:ÒÆÎ»¼Ä´æÆ÷ 0/1:8Î»¿É±ä²¨ÌØÂÊ 1/0:9Î»¹Ì¶¨²¨ÌØÂÊ 1/1:9Î»¿É±ä²¨
             -ÌØÂÊ
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 14  

 379      =2  sbit SM2        =   SCON^5;     //×Ô¶¯µØÖ·Ê¶±ðÊ¹ÄÜÎ»
 380      =2  sbit REN        =   SCON^4;     //Ê¹ÄÜ´®¿Ú½ÓÊÕÄ£¿é
 381      =2  sbit TB8        =   SCON^3;     //·¢ËÍµÄµÚ9Î»Êý¾Ý
 382      =2  sbit RB8        =   SCON^2;     //½ÓÊÕµÄµÚ9Î»Êý¾Ý
 383      =2  sbit TI         =   SCON^1;     //·¢ËÍÍê³ÉÖÐ¶Ï±êÖ¾
 384      =2  sbit RI         =   SCON^0;     //½ÓÊÕÍê³ÉÖÐ¶Ï±êÖ¾
 385      =2  
 386      =2  /////////////////////////////////
 387      =2  
 388      =2  sfr  SBUF       =   0x99;       //´®¿Ú½ÓÊÕ/·¢ËÍÊý¾Ý     Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 389      =2                                  //³õÊ¼Öµ=xxxx,xxxx      x       x       x       x       x       x       x 
             -      x
 390      =2  
 391      =2  /////////////////////////////////
 392      =2  
 393      =2  sfr  SADDR      =   0xa9;       //´®¿ÚÉè±¸´ÓµØÖ·¼Ä´æÆ÷  Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 394      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 395      =2  
 396      =2  /////////////////////////////////
 397      =2  
 398      =2  sfr  SADEN      =   0xb9;       //´®¿ÚÉè±¸´ÓµØÖ·ÆÁ±ÎÎ»  Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 399      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 400      =2  
 401      =2  //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -//////
 402      =2  
 403      =2  sfr  ADC_CONTR  =   0xc5;       //ADC¿ØÖÆ¼Ä´æÆ÷         Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 404      =2                                  //Î»ÃèÊö            ADC_POWER  SPEED1 SPEED0 ADC_FLAG ADC_START CHS2    CH
             -S1    CHS0
 405      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 406      =2  
 407      =2  #define ADC_POWER   0x80        //ADCÄ£¿éµçÔ´¿ØÖÆÎ»
 408      =2  #define ADC_SPEEDLL 0x00        //Ã¿´Î×ª»»ÐèÒª1080¸öÊ±ÖÓÖÜÆÚ
 409      =2  #define ADC_SPEEDL  0x20        //Ã¿´Î×ª»»ÐèÒª810¸öÊ±ÖÓÖÜÆÚ
 410      =2  #define ADC_SPEEDH  0x40        //Ã¿´Î×ª»»ÐèÒª540¸öÊ±ÖÓÖÜÆÚ
 411      =2  #define ADC_SPEEDHH 0x60        //Ã¿´Î×ª»»ÐèÒª270¸öÊ±ÖÓÖÜÆÚ
 412      =2  #define ADC_FLAG    0x10        //ADC×ª»»Íê³É±êÖ¾
 413      =2  #define ADC_START   0x08        //ADC¿ªÊ¼×ª»»¿ØÖÆÎ»
 414      =2  #define ADC_CHS2    0x04        //ADCÍ¨µÀÑ¡ÔñÎ»2
 415      =2  #define ADC_CHS1    0x02        //ADCÍ¨µÀÑ¡ÔñÎ»1
 416      =2  #define ADC_CHS0    0x01        //ADCÍ¨µÀÑ¡ÔñÎ»0
 417      =2  
 418      =2  /////////////////////////////////
 419      =2  
 420      =2  sfr  ADC_DATA   =   0xc6;       //ADC½á¹û¸ß×Ö½Ú         Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 421      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 422      =2  
 423      =2  /////////////////////////////////
 424      =2  
 425      =2  sfr  ADC_LOW2   =   0xbe;       //ADC½á¹ûµÍ×Ö½Ú         Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 426      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 15  

 427      =2  
 428      =2  //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -//////
 429      =2  
 430      =2  sfr  ISP_DATA   =   0xe2;       //ISPÊý¾Ý¼Ä´æÆ÷         Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 431      =2                                  //³õÊ¼Öµ=1111,1111      1       1       1       1       1       1       1 
             -      1
 432      =2  
 433      =2  /////////////////////////////////
 434      =2  
 435      =2  sfr  ISP_ADDRH  =   0xe3;       //ISPµØÖ·¸ßÎ»¼Ä´æÆ÷     Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 436      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 437      =2  
 438      =2  /////////////////////////////////
 439      =2  
 440      =2  sfr  ISP_ADDRL  =   0xe4;       //ISPµØÖ·µÍÎ»¼Ä´æÆ÷     Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 441      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 442      =2  
 443      =2  /////////////////////////////////
 444      =2  
 445      =2  sfr  ISP_CMD    =   0xe5;       //ISPÃüÁî¼Ä´æÆ÷         Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 446      =2                                  //³õÊ¼Öµ=xxxx,xx00      x       x       x       x       x       x       0 
             -      0
 447      =2  
 448      =2  #define ISP_IDLE    0x00        //ISP´ý»úÃüÁî
 449      =2  #define ISP_READ    0x01        //ISP¶Á×Ö½ÚÊý¾ÝÃüÁî
 450      =2  #define ISP_PROGRAM 0x02        //ISP×Ö½Ú±à³ÌÃüÁî
 451      =2  #define ISP_ERASE   0x03        //ISPÉÈÇø²Á³ýÃüÁî(Ã¿ÉÈÇø512×Ö½Ú))
 452      =2  
 453      =2  /////////////////////////////////
 454      =2  
 455      =2  sfr  ISP_TRIG   =   0xe6;       //ISPÃüÁî´¥·¢¼Ä´æÆ÷     Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 456      =2                                  //³õÊ¼Öµ=xxxx,xxxx      x       x       x       x       x       x       x 
             -      x
 457      =2  
 458      =2  #define ISP_TRIG0   0x46        //ISP¹¦ÄÜ´¥·¢ÃüÁî1
 459      =2  #define ISP_TRIG1   0xb9        //ISP¹¦ÄÜ´¥·¢ÃüÁî2
 460      =2  
 461      =2  /////////////////////////////////
 462      =2  
 463      =2  sfr  ISP_CONTR  =   0xe7;       //ISP¿ØÖÆ¼Ä´æÆ÷         Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 464      =2                                  //Î»ÃèÊö                ISPEN   SWBS    SWRST   CMD_FAIL -      WT2     WT
             -1     WT0
 465      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 466      =2  
 467      =2  #define ISPEN       0x80        //ISPÊ¹ÄÜ¿ª¹Ø
 468      =2  #define SWBS        0x40        //ÈíÆô¶¯Ñ¡Ôñ,0:´ÓÓÃ»§APÆô¶¯ 1:´ÓISPÆô¶¯
 469      =2  #define SWRST       0x20        //´¥·¢Èí¼þ¸´Î»
 470      =2  #define CMD_FAIL    0x10        //ISPÃüÁîÊ§°Ü±êÖ¾
 471      =2  
 472      =2  //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -//////
 473      =2  
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 16  

 474      =2  sfr  SPSTAT     =   0x84;       //SPI×´Ì¬¼Ä´æÆ÷         Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 475      =2                                  //Î»ÃèÊö                SPIF    WCOL    -       -       -       -       - 
             -      -
 476      =2                                  //³õÊ¼Öµ=11xx,xxxx      1       1       x       x       x       x       x 
             -      x
 477      =2  
 478      =2  #define SPIF        0x80        //SPI´«ÊäÍê³É±êÖ¾,µ±SPIÖÐ¶ÏÊ¹ÄÜÊ±»á´¥·¢SPIÖÐ¶ÏÇëÇó,ÐèÒªÓÃÈí¼þÏò´ËÎ»Ð´"1"À´
             -Çå0
 479      =2  #define WCOL        0x40        //SPIÐ´³åÍ»±êÖ¾,ÐèÒªÓÃÈí¼þÏò´ËÎ»Ð´"1"À´Çå0
 480      =2  
 481      =2  /////////////////////////////////
 482      =2  
 483      =2  sfr  SPCTL      =   0x85;       //SPI¿ØÖÆ¼Ä´æÆ÷         Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 484      =2                                  //Î»ÃèÊö                SSIG    SPEN    DORD    MSTR    CPOL    CPHA    SP
             -R1    SPR0
 485      =2                                  //³õÊ¼Öµ=0000,0100      0       0       0       0       0       1       0 
             -      0
 486      =2  
 487      =2  #define SSIG        0x80        //SSºöÂÔÎ»,1:ÓÉMSTRÈ·¶¨Ö÷/´Ó 0:ÓÉSS½ÅÈ·¶¨Ö÷/´Ó
 488      =2  #define SPEN        0x40        //SPIÄ£¿éÊ¹ÄÜÎ»
 489      =2  #define DORD        0x20        //SPIÊý¾ÝË³Ðò,1:LSB(ÏÈÊÕ/·¢×îµÍÎ») 0:MSB(ÏÈÊÕ/·¢×î¸ßÎ»)
 490      =2  #define MSTR        0x10        //Ö÷/´ÓÄ£Ê½Ñ¡ÔñÎ»
 491      =2  #define CPOL        0x08        //SPIÊ±ÖÓ¼«ÐÔ
 492      =2  #define CPHA        0x04        //SPIÏàÎ»Ñ¡Ôñ
 493      =2  #define SPSPEEDHH   0x00        //×î¿ìµÄËÙ¶È,CPU_CLK/4
 494      =2  #define SPSPEEDH    0x01        //×î¿ìµÄËÙ¶È,CPU_CLK/16
 495      =2  #define SPSPEEDL    0x02        //×î¿ìµÄËÙ¶È,CPU_CLK/64
 496      =2  #define SPSPEEDLL   0x03        //×î¿ìµÄËÙ¶È,CPU_CLK/128
 497      =2  
 498      =2  /////////////////////////////////
 499      =2  
 500      =2  sfr  SPDAT      =   0x86;       //SPIÊý¾Ý¼Ä´æÆ÷         Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 501      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 502      =2  
 503      =2  //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -//////
 504      =2  
 505      =2  sfr  CCON       =   0xd8;       //PCA¿ØÖÆ¼Ä´æÆ÷         Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 506      =2                                  //Î»ÃèÊö                CF      CR      -       -       CCF3    CCF2    CC
             -F1    CCF0
 507      =2                                  //³õÊ¼Öµ=00xx,0000      0       0       x       x       0       0       0 
             -      0
 508      =2  
 509      =2  sbit CF         =   CCON^7;     //PCA¼ÆÊýÆ÷Òç³ö±êÖ¾,µ±PCAÖÐ¶ÏÊ¹ÄÜÊ±»á´¥·¢PCAÖÐ¶ÏÇëÇó,ÐèÒªÓÃÈí¼þÇå0
 510      =2  sbit CR         =   CCON^6;     //PCA¼ÆÊýÆ÷Æô¶¯¿ØÖÆÎ»,Ð´"1"Æô¶¯¶«¼ÆÊýÆ÷
 511      =2  sbit CCF3       =   CCON^3;     //PCAÄ£¿é3ÖÐ¶Ï±êÖ¾,ÐèÒªÓÃÈí¼þÇå0
 512      =2  sbit CCF2       =   CCON^2;     //PCAÄ£¿é2ÖÐ¶Ï±êÖ¾,ÐèÒªÓÃÈí¼þÇå0
 513      =2  sbit CCF1       =   CCON^1;     //PCAÄ£¿é1ÖÐ¶Ï±êÖ¾,ÐèÒªÓÃÈí¼þÇå0
 514      =2  sbit CCF0       =   CCON^0;     //PCAÄ£¿é0ÖÐ¶Ï±êÖ¾,ÐèÒªÓÃÈí¼þÇå0
 515      =2  
 516      =2  /////////////////////////////////
 517      =2  
 518      =2  sfr  CMOD       =   0xd9;       //PCAÄ£Ê½¼Ä´æÆ÷         Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 519      =2                                  //Î»ÃèÊö                CIDL    -       -       -       CPS2    CPS1    CP
             -S0    ECF
 520      =2                                  //³õÊ¼Öµ=0xxx,0000      0       x       x       x       0       0       0 
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 17  

             -      0
 521      =2  
 522      =2  #define CIDL        0x80        //¼ÆÊ±Æ÷ÕóÁÐ¿ÕÏÐ¿ØÖÆ,0:¿ÕÏÐÄ£Ê½ÏÂPCA¼ÌÐø¹¤×÷ 1:¿ÕÏÐÄ£Ê½ÏÂPCAÍ£Ö¹¹¤×÷
 523      =2  #define PCACLK0     0x00        //Fosc/12
 524      =2  #define PCACLK1     0x02        //Fosc/2
 525      =2  #define PCACLK2     0x04        //¶¨Ê±Æ÷0µÄÒç³öÂÊ
 526      =2  #define PCACLK3     0x06        //ECIÍâ²¿Ê±ÖÓ
 527      =2  #define PCACLK4     0x08        //Fosc/1
 528      =2  #define PCACLK5     0x0a        //Fosc/4
 529      =2  #define PCACLK6     0x0c        //Fosc/6
 530      =2  #define PCACLK7     0x0e        //Fosc/8
 531      =2  #define ECF         0x01        //PCA¼ÆÊýÆ÷Òç³öÖÐ¶ÏÔÊÐíÎ»
 532      =2  
 533      =2  /////////////////////////////////
 534      =2  
 535      =2  sfr  CCAPM0     =   0xda;       //PCAÄ£¿é0Ä£Ê½¼Ä´æÆ÷    Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 536      =2                                  //Î»ÃèÊö                -       ECOM0   CAPP0   CAPN0   MAT0    TOG0    PW
             -M0    ECCF0
 537      =2                                  //³õÊ¼Öµ=x000,0000      x       0       0       0       0       0       0 
             -      0
 538      =2  
 539      =2  #define PCA0_ECOM   0x40        //Ê¹ÄÜ±È½ÏÆ÷0
 540      =2  #define PCA0_CAPP   0x20        //Ê¹ÄÜPCAÄ£¿é0µÄÉÏÉýÑØ²¶»ñ
 541      =2  #define PCA0_CAPN   0x10        //Ê¹ÄÜPCAÄ£¿é0µÄÏÂ½µÑØ²¶»ñ
 542      =2  #define PCA0_MAT    0x08        //Æ¥ÅäÊ¹ÄÜ,µ±PCAµÄ¼ÆÊýÖµÓëÄ£¿é0Éè¶¨µÄÖµÏàÆ¥ÅäÊ±,ÖÃCCON.CCF0
 543      =2  #define PCA0_TOG    0x04        //·­×ª¿ØÖÆÎ»,µ±PCAµÄ¼ÆÊýÖµÓëÄ£¿é0Éè¶¨µÄÖµÏàÆ¥ÅäÊ±,·­×ªCEX0µÄµçÆ½
 544      =2  #define PCA0_PWM    0x02        //Âö¿íµ÷ÖÆÄ£Ê½,Ê¹ÄÜCEX0ÎªÂö¿íµ÷ÖÆÊä³ö¿Ú
 545      =2  #define PCA0_ECCF   0x01        //Ê¹ÄÜCCF0ÖÐ¶Ï
 546      =2  
 547      =2  /////////////////////////////////
 548      =2  
 549      =2  sfr  CCAPM1     =   0xdb;       //PCAÄ£¿é1Ä£Ê½¼Ä´æÆ÷    Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 550      =2                                  //Î»ÃèÊö                -       ECOM1   CAPP1   CAPN1   MAT1    TOG1    PW
             -M1    ECCF1
 551      =2                                  //³õÊ¼Öµ=x000,0000      x       0       0       0       0       0       0 
             -      0
 552      =2  
 553      =2  #define PCA1_ECOM   0x40        //Ê¹ÄÜ±È½ÏÆ÷1
 554      =2  #define PCA1_CAPP   0x20        //Ê¹ÄÜPCAÄ£¿é1µÄÉÏÉýÑØ²¶»ñ
 555      =2  #define PCA1_CAPN   0x10        //Ê¹ÄÜPCAÄ£¿é1µÄÏÂ½µÑØ²¶»ñ
 556      =2  #define PCA1_MAT    0x08        //Æ¥ÅäÊ¹ÄÜ,µ±PCAµÄ¼ÆÊýÖµÓëÄ£¿é1Éè¶¨µÄÖµÏàÆ¥ÅäÊ±,ÖÃCCON.CCF1
 557      =2  #define PCA1_TOG    0x04        //·­×ª¿ØÖÆÎ»,µ±PCAµÄ¼ÆÊýÖµÓëÄ£¿é1Éè¶¨µÄÖµÏàÆ¥ÅäÊ±,·­×ªCEX1µÄµçÆ½
 558      =2  #define PCA1_PWM    0x02        //Âö¿íµ÷ÖÆÄ£Ê½,Ê¹ÄÜCEX1ÎªÂö¿íµ÷ÖÆÊä³ö¿Ú
 559      =2  #define PCA1_ECCF   0x01        //Ê¹ÄÜCCF1ÖÐ¶Ï
 560      =2  
 561      =2  /////////////////////////////////
 562      =2  
 563      =2  sfr  CCAPM2     =   0xdc;       //PCAÄ£¿é2Ä£Ê½¼Ä´æÆ÷    Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 564      =2                                  //Î»ÃèÊö                -       ECOM2   CAPP2   CAPN2   MAT2    TOG2    PW
             -M2    ECCF2
 565      =2                                  //³õÊ¼Öµ=x000,0000      x       0       0       0       0       0       0 
             -      0
 566      =2  
 567      =2  #define PCA2_ECOM   0x40        //Ê¹ÄÜ±È½ÏÆ÷2
 568      =2  #define PCA2_CAPP   0x20        //Ê¹ÄÜPCAÄ£¿é2µÄÉÏÉýÑØ²¶»ñ
 569      =2  #define PCA2_CAPN   0x10        //Ê¹ÄÜPCAÄ£¿é2µÄÏÂ½µÑØ²¶»ñ
 570      =2  #define PCA2_MAT    0x08        //Æ¥ÅäÊ¹ÄÜ,µ±PCAµÄ¼ÆÊýÖµÓëÄ£¿é2Éè¶¨µÄÖµÏàÆ¥ÅäÊ±,ÖÃCCON.CCF2
 571      =2  #define PCA2_TOG    0x04        //·­×ª¿ØÖÆÎ»,µ±PCAµÄ¼ÆÊýÖµÓëÄ£¿é2Éè¶¨µÄÖµÏàÆ¥ÅäÊ±,·­×ªCEX2µÄµçÆ½
 572      =2  #define PCA2_PWM    0x02        //Âö¿íµ÷ÖÆÄ£Ê½,Ê¹ÄÜCEX2ÎªÂö¿íµ÷ÖÆÊä³ö¿Ú
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 18  

 573      =2  #define PCA2_ECCF   0x01        //Ê¹ÄÜCCF2ÖÐ¶Ï
 574      =2  
 575      =2  /////////////////////////////////
 576      =2  
 577      =2  sfr  CCAPM3     =   0xdd;       //PCAÄ£¿é3Ä£Ê½¼Ä´æÆ÷    Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 578      =2                                  //Î»ÃèÊö                -       ECOM3   CAPP3   CAPN3   MAT3    TOG3    PW
             -M3    ECCF3
 579      =2                                  //³õÊ¼Öµ=x000,0000      x       0       0       0       0       0       0 
             -      0
 580      =2  
 581      =2  #define PCA3_ECOM   0x40        //Ê¹ÄÜ±È½ÏÆ÷3
 582      =2  #define PCA3_CAPP   0x20        //Ê¹ÄÜPCAÄ£¿é3µÄÉÏÉýÑØ²¶»ñ
 583      =2  #define PCA3_CAPN   0x10        //Ê¹ÄÜPCAÄ£¿é3µÄÏÂ½µÑØ²¶»ñ
 584      =2  #define PCA3_MAT    0x08        //Æ¥ÅäÊ¹ÄÜ,µ±PCAµÄ¼ÆÊýÖµÓëÄ£¿é3Éè¶¨µÄÖµÏàÆ¥ÅäÊ±,ÖÃCCON.CCF3
 585      =2  #define PCA3_TOG    0x04        //·­×ª¿ØÖÆÎ»,µ±PCAµÄ¼ÆÊýÖµÓëÄ£¿é3Éè¶¨µÄÖµÏàÆ¥ÅäÊ±,·­×ªCEX3µÄµçÆ½
 586      =2  #define PCA3_PWM    0x02        //Âö¿íµ÷ÖÆÄ£Ê½,Ê¹ÄÜCEX3ÎªÂö¿íµ÷ÖÆÊä³ö¿Ú
 587      =2  #define PCA3_ECCF   0x01        //Ê¹ÄÜCCF3ÖÐ¶Ï
 588      =2  
 589      =2  /////////////////////////////////
 590      =2  
 591      =2  //CCAPM0   -   ECOM CAPP CAPN MAT  TOG  PWM  CCF
 592      =2  // 00H     0    0    0    0    0    0    0    0     ÎÞ²Ù×÷,´ý»ú×´Ì¬
 593      =2  // 42H     0    1    0    0    0    0    1    0     8Î»PWMÊä³ö,ÎÞÖÐ¶Ï
 594      =2  // 63H     0    1    1    0    0    0    1    1     8Î»PWMÊä³ö,²úÉúCEX0ÉÏÉýÑØÖÐ¶Ï
 595      =2  // 53H     0    1    0    1    0    0    1    1     8Î»PWMÊä³ö,²úÉúCEX0ÏÂ½µÑØÖÐ¶Ï
 596      =2  // 73H     0    1    1    1    0    0    1    1     8Î»PWMÊä³ö,²úÉúCEX0Ìø±äÖÐ¶Ï
 597      =2  // 20H     0    x    1    0    0    0    0    0     16Î»²¶»ñÄ£Ê½,CEX0ÉÏÉýÑØ´¥·¢²¶»ñ
 598      =2  // 10H     0    x    0    1    0    0    0    0     16Î»²¶»ñÄ£Ê½,CEX0ÏÂ½µÑØ´¥·¢²¶»ñ
 599      =2  // 30H     0    x    1    1    0    0    0    0     16Î»²¶»ñÄ£Ê½,CEX0Ìø±ä´¥·¢²¶»ñ
 600      =2  // 48H     0    1    0    0    1    0    0    0     16Î»Èí¼þ¶¨Ê±Æ÷
 601      =2  // 4CH     0    1    0    0    1    1    0    0     16Î»¸ßËÙÂö³åÊä³ö
 602      =2  
 603      =2  /////////////////////////////////
 604      =2  
 605      =2  sfr  CL         =   0xe9;       //PCA¼ÆÊýÆ÷µÍ8Î»        Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 606      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 607      =2  
 608      =2  /////////////////////////////////
 609      =2  
 610      =2  sfr  CH         =   0xf9;       //PCA¼ÆÊýÆ÷¸ß8Î»        Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 611      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 612      =2  
 613      =2  /////////////////////////////////
 614      =2  
 615      =2  sfr  CCAP0L     =   0xea;       //PCAÄ£¿é0¼Ä´æÆ÷µÍ8Î»   Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 616      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 617      =2  
 618      =2  /////////////////////////////////
 619      =2  
 620      =2  sfr  CCAP1L     =   0xeb;       //PCAÄ£¿é1¼Ä´æÆ÷µÍ8Î»   Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 621      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 622      =2  
 623      =2  /////////////////////////////////
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 19  

 624      =2  
 625      =2  sfr  CCAP2L     =   0xec;       //PCAÄ£¿é2¼Ä´æÆ÷µÍ8Î»   Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 626      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 627      =2  
 628      =2  /////////////////////////////////
 629      =2  
 630      =2  sfr  CCAP3L     =   0xed;       //PCAÄ£¿é3¼Ä´æÆ÷µÍ8Î»   Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 631      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 632      =2  
 633      =2  /////////////////////////////////
 634      =2  
 635      =2  sfr  CCAP0H     =   0xfa;       //PCAÄ£¿é0¼Ä´æÆ÷¸ß8Î»   Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 636      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 637      =2  
 638      =2  /////////////////////////////////
 639      =2  
 640      =2  sfr  CCAP1H     =   0xfb;       //PCAÄ£¿é1¼Ä´æÆ÷¸ß8Î»   Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 641      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 642      =2  
 643      =2  /////////////////////////////////
 644      =2  
 645      =2  sfr  CCAP2H     =   0xfc;       //PCAÄ£¿é2¼Ä´æÆ÷¸ß8Î»   Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 646      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 647      =2  
 648      =2  /////////////////////////////////
 649      =2  
 650      =2  sfr  CCAP3H     =   0xfd;       //PCAÄ£¿é3¼Ä´æÆ÷¸ß8Î»   Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 651      =2                                  //³õÊ¼Öµ=0000,0000      0       0       0       0       0       0       0 
             -      0
 652      =2  
 653      =2  /////////////////////////////////
 654      =2  
 655      =2  sfr  PCA_PWM0   =   0xf2;       //PCA0Ä£Ê½PWM¸¨Öú¼Ä´æÆ÷ Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 656      =2                                  //Î»ÃèÊö                -       -       -       -       -       -       EP
             -C0H   EPC0L
 657      =2                                  //³õÊ¼Öµ=xxxx,xx00      x       x       x       x       x       x       0 
             -      0
 658      =2  
 659      =2  /////////////////////////////////
 660      =2  
 661      =2  sfr  PCA_PWM1   =   0xf3;       //PCA1Ä£Ê½PWM¸¨Öú¼Ä´æÆ÷ Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 662      =2                                  //Î»ÃèÊö                -       -       -       -       -       -       EP
             -C1H   EPC1L
 663      =2                                  //³õÊ¼Öµ=xxxx,xx00      x       x       x       x       x       x       0 
             -      0
 664      =2  
 665      =2  /////////////////////////////////
 666      =2  
 667      =2  sfr  PCA_PWM2   =   0xf4;       //PCA2Ä£Ê½PWM¸¨Öú¼Ä´æÆ÷ Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 20  

             -t1    Bit0
 668      =2                                  //Î»ÃèÊö                -       -       -       -       -       -       EP
             -C2H   EPC2L
 669      =2                                  //³õÊ¼Öµ=xxxx,xx00      x       x       x       x       x       x       0 
             -      0
 670      =2  
 671      =2  /////////////////////////////////
 672      =2  
 673      =2  sfr  PCA_PWM3   =   0xf5;       //PCA3Ä£Ê½PWM¸¨Öú¼Ä´æÆ÷ Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bi
             -t1    Bit0
 674      =2                                  //Î»ÃèÊö                -       -       -       -       -       -       EP
             -C3H   EPC3L
 675      =2                                  //³õÊ¼Öµ=xxxx,xx00      x       x       x       x       x       x       0 
             -      0
 676      =2  
 677      =2  //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -//////
 678      =2  
 679      =2  #endif
  29      =1  
  30      =1  #define const code 
  31      =1  #ifndef TRUE
  32      =1  #define TRUE  1
  33      =1  #endif 
  34      =1  #ifndef FALSE
  35      =1  #define FALSE 0
  36      =1  #endif
  37      =1  
  38      =1  #define true 1
  39      =1  
  40      =1  #define SPK_ROOM 0
  41      =1  
  42      =1  #define ADD_FJ_ADDR 250
  43      =1  #define MOVE_FJ_ADDR 251
  44      =1  
  45      =1  
  46      =1  #define Bin(b7,b6,b5,b4,b3,b2,b1,b0)    ((b7<<7)|(b6<<6)|(b5<<5)|(b4<<4)|(b3<<3)|(b2<<2)|(b1<<1)|(b0<<0))
  47      =1  
  48      =1  //Ö÷Ïß³ÌÃüÁî
  49      =1  #define BUS0_REC                0x20                                                            //×ÜÏß0½ÓÊÕÍê³É
  50      =1  #define BUS0_SND                0x40                                                            //×ÜÏß0·¢ËÍÍê³É  
  51      =1  #define KEY_DOWN                0x60                                                            //°´¼ü°´ÏÂ
  52      =1  #define KEY_ALWAYS              0x70
  53      =1  #define KEY_UP                  0x80                                                            //°´¼üµ¯Æð
  54      =1  #define TIMER_OUT               0xa0                                                            //³¬Ê±ÃüÁî      
  55      =1  //°´¼ü¶¨Òå      
  56      =1  #define NO_KEY                  0xff                                                            //ÎÞ¼ü°´ÏÂ      
  57      =1  
  58      =1  sbit    MP3_DREQ        =       P3^2;
  59      =1  sbit    KEY_COPY        =       P3^5;
  60      =1  sbit    MP3_XDCS        =       P3^7;
  61      =1  
  62      =1  sbit    PRG_STATE       =       P1^0;
  63      =1  sbit    MP3_XRESET      =       P1^1;
  64      =1  sbit    MP3_XCS         =       P1^2;
  65      =1  sbit    TER_CS          =       P1^3;
  66      =1  sbit    SST25VF_CS              =       P1^4;
  67      =1  sbit    MOSI            =       P1^5;
  68      =1  sbit    MISO            =       P1^6;
  69      =1  sbit    SCLK            =       P1^7;
  70      =1  
  71      =1  
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 21  

  72      =1  //°üº¬Í·ÎÄ¼þ
  73      =1  #include "OS_CFG.H"
   1      =2  /*********************************************************************************************************
   2      =2  **                                                             Small RTOS(51)
   3      =2  **                                   The Real-Time Kernel(For Keil c51)
   4      =2  **
   5      =2  **                                  (c) Copyright 2002-2002, chenmingji
   6      =2  **                                           All Rights Reserved
   7      =2  **
   8      =2  **                                                  V1.20.0
   9      =2  **
  10      =2  **
  11      =2  **--------------ÎÄ¼þÐÅÏ¢--------------------------------------------------------------------------------
  12      =2  **ÎÄ   ¼þ   Ãû: OS_CFG.H
  13      =2  **´´   ½¨   ÈË: ³ÂÃ÷¼Æ
  14      =2  **×îºóÐÞ¸ÄÈÕÆÚ: 2002Äê12ÔÂ30ÈÕ
  15      =2  **Ãè¡¡      Êö: ex1µÄÏµÍ³ÅäÖÃÎÄ¼þ
  16      =2  **
  17      =2  **--------------ÀúÊ·°æ±¾ÐÅÏ¢----------------------------------------------------------------------------
  18      =2  ** ´´½¨ÈË: ³ÂÃ÷¼Æ
  19      =2  ** °æ  ±¾: V0.50
  20      =2  ** ÈÕ¡¡ÆÚ: 2002Äê2ÔÂ22ÈÕ
  21      =2  ** Ãè¡¡Êö: Ô­Ê¼°æ±¾
  22      =2  **
  23      =2  **------------------------------------------------------------------------------------------------------
  24      =2  ** ÐÞ¸ÄÈË: ³ÂÃ÷¼Æ
  25      =2  ** °æ  ±¾: V1.00
  26      =2  ** ÈÕ¡¡ÆÚ: 2002Äê6ÔÂ20ÈÕ
  27      =2  ** Ãè¡¡Êö: Ê¹ÓÃ»§¿ÉÒÔ½øÐÐ¸ü¶àµÄÅäÖÃ
  28      =2  **
  29      =2  **------------------------------------------------------------------------------------------------------
  30      =2  ** ÐÞ¸ÄÈË: ³ÂÃ÷¼Æ
  31      =2  ** °æ  ±¾: V1.10~1.12.1
  32      =2  ** ÈÕ¡¡ÆÚ: 2002Äê9ÔÂ1ÈÕ~2002Äê12ÔÂ2ÈÕ
  33      =2  ** Ãè¡¡Êö: ¸ù¾ÝÐÂ°æ±¾ÐèÒª¸ü¸ÄÒ»Ð©¶¨Òå
  34      =2  **
  35      =2  **------------------------------------------------------------------------------------------------------
  36      =2  ** ÐÞ¸ÄÈË: ³ÂÃ÷¼Æ
  37      =2  ** °æ  ±¾: V1.20.0
  38      =2  ** ÈÕ¡¡ÆÚ: 2003Äê8ÔÂ3ÈÕ
  39      =2  ** Ãè¡¡Êö: ¸ù¾ÝÐÂ°æ±¾ÐèÒªÔö¼ÓÅäÖÃOSWait_EN£»
  40      =2  **         ¼õÉÙÒ»Ð©¹ØÓÚÖÐ¶ÏÇ¶Ì×µÄÅäÖÃ
  41      =2  **
  42      =2  **--------------µ±Ç°°æ±¾ÐÞ¶©------------------------------------------------------------------------------
  43      =2  ** ÐÞ¸ÄÈË: 
  44      =2  ** ÈÕ¡¡ÆÚ:
  45      =2  ** Ãè¡¡Êö:
  46      =2  **
  47      =2  **------------------------------------------------------------------------------------------------------
  48      =2  ********************************************************************************************************/
  49      =2  
  50      =2  #define OS_MAX_TASKS            5           /* ×î´óÈÎÎñÊý1~16                                           */
  51      =2  #define OS_TICKS_PER_SEC        200         /* ÉùÃ÷1ÃëÏµÍ³ÏµÍ³½ÚÅÄÊý                                    */
  52      =2  #define EN_USER_TICK_TIMER      1           /* ½ûÖ¹(0)»òÔÊÐí(1)ÏµÍ³¶¨Ê±ÖÐ¶Ïµ÷ÓÃÓÃ»§º¯ÊýUserTickTimer()  */
  53      =2  #define EN_TIMER_SHARING        1           /* ½ûÖ¹(0)»òÔÊÐí(1)¶¨Ê±Æ÷ÖÐ¶Ïµ÷ÓÃOSTimeTick()               */
  54      =2  #define TICK_TIMER_SHARING      0           /* ¶¨Òå½øÈë¶àÉÙ´ÎÓ²¼þÖÐ¶ÏÎªÒ»´ÎÏµÍ³¶¨Ê±Æ÷ÈíÖÐ¶Ï             */
  55      =2  #define OSWait_EN               1           /* ½ûÖ¹(0)»òÔÊÐí(1)µ÷ÓÃ¼æÈÝº¯ÊýOSWait  */
  56      =2  
  57      =2  
  58      =2  #define EN_OS_Q                 1           /* ½ûÖ¹(0)»òÔÊÐí(1)ÏûÏ¢¶ÓÁÐ                                 */
  59      =2  #define EN_OS_Q_CHK             0           /* ½ûÖ¹(0)»òÔÊÐí(1)Ð£ÑéÏûÏ¢¶ÓÁÐÖ¸Õë                         */
  60      =2  #define OS_Q_MEM_SEL            idata       /* ÏûÏ¢¶ÓÁÐ´æ´¢¿Õ¼äÑ¡Ôñ£¬keil c51ÓÐÓÃ£¬±ØÐëÎªidata¡¢xdata   */
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 22  

  61      =2                                              /* ²»ÊÇkeil c51Ê±Ëü±ØÐëÎª¿Õ¸ñ                               */
  62      =2  #define EN_OS_Q_PENT            1           /* ½ûÖ¹(0)»òÔÊÐí(1)µÈ´ý¶ÓÁÐÖÐµÄÏûÏ¢                         */
  63      =2  #define EN_OS_Q_ACCEPT          0           /* ½ûÖ¹(0)»òÔÊÐí(1)ÎÞµÈ´ýµÄ´Ó¶ÓÁÐÖÐÈ¡µÃÏûÏ¢                 */
  64      =2  #define EN_OS_Q_POST            1           /* ½ûÖ¹(0)»òÔÊÐí(1)FIFO·½Ê½Ïò¶ÔÁÐ·¢ËÍÏûÏ¢                   */
  65      =2  #define EN_OS_Q_POST_FRONT      0           /* ½ûÖ¹(0)»òÔÊÐí(1)LIFO·½Ê½Ïò¶ÔÁÐ·¢ËÍÏûÏ¢                   */
  66      =2  #define EN_OS_Q_NMsgs           0           /* ½ûÖ¹(0)»òÔÊÐí(1)È¡µÃ¶ÓÁÐÖÐÏûÏ¢Êý                         */
  67      =2  #define EN_OS_Q_SIZE            0           /* ½ûÖ¹(0)»òÔÊÐí(1)È¡µÃ¶ÓÁÐ×ÜÈÝÁ¿                           */
  68      =2  #define EN_OS_Q_FLUSH           0           /* ½ûÖ¹(0)»òÔÊÐí(1)Çå¿Õ¶ÓÁÐ                                 */
  69      =2  
  70      =2  #define EN_OS_SEM               0           /* ½ûÖ¹(0)»òÔÊÐí(1)ÐÅºÅÁ¿                                   */
  71      =2  #define EN_OS_SEM_CHK           0           /* ½ûÖ¹(0)»òÔÊÐí(1)Ð£ÑéÐÅºÅÁ¿Ë÷Òý                           */
  72      =2  #define OS_SEM_MEM_SEL          idata       /* ÐÅºÅÁ¿´¢¿Õ¼äÑ¡Ôñ£¬keil c51ÓÐÓÃ£¬±ØÐëÎªidata¡¢xdata       */
  73      =2                                              /* ²»ÊÇkeil c51Ê±Ëü±ØÐëÎª¿Õ¸ñ                               */
  74      =2  #define OS_MAX_SEMS             0           /* ×î´óÐÅºÅÁ¿ÊýÄ¿                                           */
  75      =2  #define EN_OS_SEM_PENT          1           /* ½ûÖ¹(0)»òÔÊÐí(1)µÈ´ýÐÅºÅÁ¿                               */
  76      =2  #define EN_OS_SEM_ACCEPT        1           /* ½ûÖ¹(0)»òÔÊÐí(1)ÎÞµÈ´ýÇëÇóÐÅºÅÁ¿                         */
  77      =2  #define EN_OS_SEM_POST          1           /* ½ûÖ¹(0)»òÔÊÐí(1)ÖÐ·¢ËÍÐÅºÅÁ¿                             */
  78      =2  #define EN_OS_SEM_QUERY         1           /* ½ûÖ¹(0)»òÔÊÐí(1)²éÑ¯ÐÅºÅÁ¿                               */
  79      =2  
  80      =2  #define EN_OS_MEM               0           /* ½ûÖ¹(0)»òÔÊÐí(1)¶¯Ì¬ÄÚ´æ·ÖÅä                             */
  81      =2  #define EN_OS_MEM_FREE          0           /* ½ûÖ¹(0)»òÔÊÐí(1)ÊÍ·Å¶¯Ì¬·ÖÅäµÄÄÚ´æ                        *
             -/
  82      =2  #define EN_OS_MEM_CHK           1           /* ½ûÖ¹(0)»òÔÊÐí(1)ÄÚ´æ»ØÊÕÊ±ÑéÖ¤ÄÚ´æ¿éÊÇ·ñÓÐÐ§               
             -*/
  83      =2  #define EN_UserMemChkErr        0           /* ½ûÖ¹(0)»òÔÊÐí(1)ÄÚ´æ»ØÊÕÑéÖ¤³ö´íµ÷ÓÃÓÃ»§º¯ÊýUserMemChkErr  
             - */
  84      =2  
  85      =2  #if EN_TIMER_SHARING == 0
           =2 #define TIME_ISR_TASK_ID     COMM_TASK_ID   /* ¶¨ÒåÏµÍ³¶¨Ê±Æ÷ÈíÖÐ¶Ï´¥·¢µÄÈÎÎñID                         */
           =2 #endif
  88      =2  
  89      =2  #ifdef IN_OS_CPU_C 
           =2 #if EN_USER_TICK_TIMER > 0      
           =2 //extern void UserTickTimer(void);            /* ÏµÍ³¶¨Ê±ÖÐ¶ÏÖÐµ÷ÓÃµÄÓÃ»§º¯Êý                             
             -   
           =2 //#define UserTickTimer()       {uiIsrTimerCount+=ISR_INC_COUNT;CCAP0L = (uint8)uiIsrTimerCount;CCAP0H = (uint8
             -)(uiIsrTimerCount>>8);CCF0=0;WDT_CONTR = 0x3a;}   /* ÏµÍ³¶¨Ê±ÖÐ¶ÏÖÐµ÷ÓÃµÄÓÃ»§º¯                                                                */
           =2 
           =2 #endif
           =2 #endif
  96      =2  /*********************************************************************************************************
  97      =2  **                            End Of File
  98      =2  ********************************************************************************************************/
  74      =1  #include "OS_CPU.H"
   1      =2  /*********************************************************************************************************
   2      =2  **                                                             Small RTOS 51
   3      =2  **                                   The Real-Time Kernel For Keil c51
   4      =2  **
   5      =2  **                                  (c) Copyright 2002-2003, chenmingji
   6      =2  **                                           All Rights Reserved
   7      =2  **
   8      =2  **                                                  V1.20.0
   9      =2  **
  10      =2  **
  11      =2  **--------------ÎÄ¼þÐÅÏ¢--------------------------------------------------------------------------------
  12      =2  **ÎÄ   ¼þ   Ãû: OS_CPU.h
  13      =2  **´´   ½¨   ÈË: ³ÂÃ÷¼Æ
  14      =2  **×îºóÐÞ¸ÄÈÕÆÚ:  2003Äê8ÔÂ17ÈÕ
  15      =2  **Ãè¡¡      Êö: Small RTOS 51ÓëCPU(¼È8051ÏµÁÐ)Ïà¹ØµÄCÓïÑÔÍ·ÎÄ¼þ,¶¨ÒåÒ»Ð©ÓëCPUÏà¹ØµÄºê¡£
  16      =2  **
  17      =2  **--------------ÀúÊ·°æ±¾ÐÅÏ¢----------------------------------------------------------------------------
  18      =2  ** ´´½¨ÈË: ³ÂÃ÷¼Æ
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 23  

  19      =2  ** °æ  ±¾: V0.50
  20      =2  ** ÈÕ¡¡ÆÚ: 2002Äê2ÔÂ22ÈÕ
  21      =2  ** Ãè¡¡Êö: Ô­Ê¼°æ±¾
  22      =2  **
  23      =2  **------------------------------------------------------------------------------------------------------
  24      =2  ** ÐÞ¸ÄÈË: ³ÂÃ÷¼Æ
  25      =2  ** °æ  ±¾: V1.00
  26      =2  ** ÈÕ¡¡ÆÚ: 2002Äê6ÔÂ20ÈÕ
  27      =2  ** Ãè¡¡Êö: ÎÞ±ä»¯
  28      =2  **
  29      =2  **------------------------------------------------------------------------------------------------------
  30      =2  ** ÐÞ¸ÄÈË: ³ÂÃ÷¼Æ
  31      =2  ** °æ  ±¾: V1.10~1.12.1
  32      =2  ** ÈÕ¡¡ÆÚ: 2002Äê9ÔÂ1ÈÕ~2002Äê12ÔÂ2ÈÕ
  33      =2  ** Ãè¡¡Êö: ¸ù¾ÝÐÂ°æ±¾ÐèÒªÔö¼ÓÒ»Ð©ºê¶¨Òå
  34      =2  **
  35      =2  **------------------------------------------------------------------------------------------------------
  36      =2  ** ÐÞ¸ÄÈË: ³ÂÃ÷¼Æ
  37      =2  ** °æ  ±¾: V1.20.0
  38      =2  ** ÈÕ¡¡ÆÚ: 2003Äê8ÔÂ17ÈÕ
  39      =2  ** Ãè¡¡Êö: ¸ù¾ÝÐÂ°æ±¾ÐèÒªÔö¼ÓEN_REENTRANT
  40      =2  **
  41      =2  **--------------µ±Ç°°æ±¾ÐÞ¶©------------------------------------------------------------------------------
  42      =2  ** ÐÞ¸ÄÈË: 
  43      =2  ** ÈÕ¡¡ÆÚ:
  44      =2  ** Ãè¡¡Êö:
  45      =2  **
  46      =2  **------------------------------------------------------------------------------------------------------
  47      =2  ********************************************************************************************************/
  48      =2  #define EN_SP2        0                                         /* ½ûÖ¹(0)»òÔÊÐí(1)Èí·ÇÆÁ±ÎÖÐ¶Ï           
             -    */
  49      =2  #define EN_REENTRANT  0                                         /* ½ûÖ¹(0)»òÔÊÐí(1)¹ÜÀíÖØÈëÕ»             
             -    */
  50      =2  
  51      =2  #ifdef __C51__
  52      =2  
  53      =2  //#define idata                                   /* ·Çkeil c51Ê±±ØÐë¼ÓÖ¹ÕâÒ»¾ä                           
             -    */
  54      =2  //#define data                                    /* ·Çkeil c51Ê±±ØÐë¼ÓÖ¹ÕâÒ»¾ä                           
             -    */
  55      =2  //#define xdata                                   /* ·Çkeil c51Ê±±ØÐë¼ÓÖ¹ÕâÒ»¾ä                           
             -    */
  56      =2  //#define reentrant                               /* ·Çkeil c51Ê±±ØÐë¼ÓÖ¹ÕâÒ»¾ä                           
             -    */
  57      =2  //#define small                                   /* ·Çkeil c51Ê±±ØÐë¼ÓÖ¹ÕâÒ»¾ä                           
             -    */
  58      =2  //#define code                                    /* ·Çkeil c51Ê±±ØÐë¼ÓÖ¹ÕâÒ»¾ä                           
             -    */
  59      =2  
  60      =2  typedef unsigned char  uint8;                                   /* ¶¨Òå¿ÉÒÆÖ²µÄÎÞ·ûºÅ8Î»ÕûÊý¹Ø¼ü×Ö        
             -    */
  61      =2  typedef signed   char  int8;                                    /* ¶¨Òå¿ÉÒÆÖ²µÄÓÐ·ûºÅ8Î»ÕûÊý¹Ø¼ü×Ö        
             -    */
  62      =2  typedef unsigned int   uint16;                                  /* ¶¨Òå¿ÉÒÆÖ²µÄÎÞ·ûºÅ16Î»ÕûÊý¹Ø¼ü×Ö       
             -    */
  63      =2  typedef signed   int   int16;                                   /* ¶¨Òå¿ÉÒÆÖ²µÄÓÐ·ûºÅ16Î»ÕûÊý¹Ø¼ü×Ö       
             -    */
  64      =2  typedef unsigned long  uint32;                                  /* ¶¨Òå¿ÉÒÆÖ²µÄÎÞ·ûºÅ32Î»ÕûÊý¹Ø¼ü×Ö       
             -    */
  65      =2  typedef signed   long  int32;                                   /* ¶¨Òå¿ÉÒÆÖ²µÄÓÐ·ûºÅ32Î»ÕûÊý¹Ø¼ü×Ö       
             -    */
  66      =2  
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 24  

  67      =2  extern void OSCPUInit(void) small;
  68      =2  extern void OSTaskStkInit(void (code * task)(void), void xdata *ptos, uint8 TaskID);
  69      =2  extern void OSTaskStkDel(uint8 TaskID) small;
  70      =2  
  71      =2  #ifndef NULL
           =2 #define NULL 0
           =2 #endif
  74      =2  
  75      =2  #define  OS_INT_ENTER() OSIntNesting++, EA = 1
  76      =2  
  77      =2  #define  OS_ENTER_CRITICAL()  EA = 0,Os_Enter_Sum++             /* ½ûÖ¹ÖÐ¶Ï                                     */      
  78      =2  #define  OS_EXIT_CRITICAL()   if (--Os_Enter_Sum==0) EA = 1  /* ÔÊÐíÖÐ¶Ï                                        
             -*/         
  79      =2  
  80      =2  #define  HIGH_BYTE  0                                           /* uint16µÄ¸ßÎ»×Ö½Ú                       
             -       */
  81      =2  #define  LOW_BYTE   1                                           /* uint16µÄµÍÎ»×Ö½Ú                       
             -       */
  82      =2  
  83      =2  #define  OS_TASK_SW()         OSCtxSw()                         /* ÈÎÎñÇÐ»»º¯Êý                           
             -       */
  84      =2  
  85      =2  
  86      =2  #define  IDATA_RAM_SIZE  0x100                                  /* idata´óÐ¡                              
             -      */
  87      =2  
  88      =2  extern void OSCtxSw(void);
  89      =2  extern void OSIntCtxSw(void);
  90      =2  #ifndef IN_OS_CPU_C
  91      =2  extern void OSStartHighRdy(void)  small;
  92      =2  #endif
  93      =2  
  94      =2  #define  Sp2Space       8                                       /* ¸ß¼¶ÖÐ¶Ï£¨Èí·ÇÆÁ±ÎÖÐ¶Ï£©¶ÑÕ»´óÐ¡ EN_SP2
             -Îª0Ê±ÎÞÐ§*/
  95      =2  
  96      =2  #define OS_TIME_ISR     6                                       /* ÏµÍ³¶¨Ê±Æ÷Ê¹ÓÃµÄÖÐ¶Ï                   
             -      */
  97      =2  
  98      =2  #endif
  99      =2  
 100      =2  
 101      =2  
 102      =2  #ifndef __C51__   
           =2 SET_EA   MACRO
           =2              SETB     EA
           =2          ENDM
           =2          
           =2 #endif
 108      =2  
 109      =2  /*********************************************************************************************************
 110      =2  **                            End Of File
 111      =2  ********************************************************************************************************/
  75      =1  #include "..\os\OS.H"
   1      =2  /*********************************************************************************************************
   2      =2  **                                                             Small RTOS(51)
   3      =2  **                                   The Real-Time Kernel(For Keil c51)
   4      =2  **
   5      =2  **                                  (c) Copyright 2002-2003, chenmingji
   6      =2  **                                           All Rights Reserved
   7      =2  **
   8      =2  **                                                  V1.20.0
   9      =2  **
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 25  

  10      =2  **
  11      =2  **--------------ÎÄ¼þÐÅÏ¢--------------------------------------------------------------------------------
  12      =2  **ÎÄ   ¼þ   Ãû: OS.h
  13      =2  **´´   ½¨   ÈË: ³ÂÃ÷¼Æ
  14      =2  **×îºóÐÞ¸ÄÈÕÆÚ:  2003Äê8ÔÂ17ÈÕ
  15      =2  **Ãè¡¡     Êö: Small RTOS(51) CÓïÑÔÍ·ÎÄ¼þ,¶¨ÒåÒ»Ð©ºêºÍÉùÃ÷Ò»Ð©º¯ÊýºÍ±äÁ¿
  16      =2  **
  17      =2  **--------------ÀúÊ·°æ±¾ÐÅÏ¢----------------------------------------------------------------------------
  18      =2  ** ´´½¨ÈË: ³ÂÃ÷¼Æ
  19      =2  ** °æ  ±¾: V0.50~V1.00
  20      =2  ** ÈÕ¡¡ÆÚ: 2002Äê2ÔÂ22ÈÕ~2002Äê6ÔÂ20ÈÕ
  21      =2  ** Ãè¡¡Êö: »ù±¾Íê³ÉSmall RTOSºË
  22      =2  **
  23      =2  **------------------------------------------------------------------------------------------------------
  24      =2  ** ÐÞ¸ÄÈË: ³ÂÃ÷¼Æ
  25      =2  ** °æ  ±¾: V1.10~V1.21
  26      =2  ** ÈÕ¡¡ÆÚ: 2002Äê9ÔÂ1ÈÕ~2003Äê1ÔÂ23ÈÕ
  27      =2  ** Ãè¡¡Êö: ÍêÉÆSmall RTOS
  28      =2  **
  29      =2  **------------------------------------------------------------------------------------------------------
  30      =2  ** ÐÞ¸ÄÈË: ³ÂÃ÷¼Æ
  31      =2  ** °æ  ±¾: V1.20.0
  32      =2  ** ÈÕ¡¡ÆÚ: 2003Äê8ÔÂ17ÈÕ
  33      =2  ** Ãè¡¡Êö: Ôö¼ÓÖ§³ÖÈÎÎñ¶¯Ì¬½¨Á¢ºÍÉ¾³ý£¬º¯Êý¹¦ÄÜÏòÒ»°ãµÄRTOS¿¿Æë
  34      =2  **--------------µ±Ç°°æ±¾ÐÞ¶©------------------------------------------------------------------------------
  35      =2  ** ÐÞ¸ÄÈË: 
  36      =2  ** ÈÕ¡¡ÆÚ:
  37      =2  ** Ãè¡¡Êö:
  38      =2  **
  39      =2  **------------------------------------------------------------------------------------------------------
  40      =2  ********************************************************************************************************/
  41      =2  
  42      =2  #define  OS_VERSION    120                              /* ÏµÍ³°æ±¾ºÅ                                   */
  43      =2  
  44      =2  #define  OSVersion()     OS_VERSION                     /* ·µ»ØÏµÍ³°æ±¾                                 */
  45      =2  #define  OSRunningTaskID() OSTaskID                     /* ·µ»Øµ±Ç°ÈÎÎñID                               */
             - 
  46      =2  
  47      =2  #define K_SIG      1                                    /* µÈ´ýÐÅºÅ                                     */
  48      =2  #define K_TMO      2                                    /* µÈ´ý³¬Ê±                                     */
  49      =2  
  50      =2  #define NOT_OK     255                                  /* ²ÎÊý´íÎó                                     */
  51      =2  #define TMO_EVENT  8                                    /* ³¬Ê±µ½                                       */
  52      =2  #define SIG_EVENT  4                                    /* ÓÐÐÅºÅ                                       */
  53      =2  
  54      =2   
  55      =2  #ifndef IN_OS_CORE
  56      =2  
  57      =2  /* ¼æÈÝV1.21.1°æ±¾µÄºê */
  58      =2  #define OSSendSignal(a)     OSTaskResume((a))
  59      =2  #define OSIntSendSignal(a)  OSTaskResume((a))
  60      =2  #define OSClearSignal(a)    OS_TaskSuspend((a))
  61      =2  #define OSTaskCreate(a, b, c) _OSTaskCreate((c),(a),(b))
  62      =2  
  63      =2  
  64      =2  extern uint8 data OSWaitTick[];
  65      =2  extern uint8 code OSMapTbl[];
  66      =2  extern uint8 data Os_Enter_Sum;
  67      =2  extern uint8 data OSTaskID;
  68      =2  extern uint8 data OSNextTaskID;
  69      =2  extern uint8 data OSIntNesting;
  70      =2  
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 26  

  71      =2  
  72      =2  extern void OSInit(void) small;
  73      =2  /*********************************************************************************************************
  74      =2  ** º¯ÊýÃû³Æ: OSInit
  75      =2  ** ¹¦ÄÜÃèÊö: ÏµÍ³±äÁ¿³õÊ¼»¯
  76      =2  ** Êä¡¡Èë: ÎÞ
  77      =2  ** Êä¡¡³ö: ÎÞ
  78      =2  ** È«¾Ö±äÁ¿: 
  79      =2  ** µ÷ÓÃÄ£¿é: OSCPUInit
  80      =2  ********************************************************************************************************/
  81      =2  
  82      =2  extern void OSStart(void);
  83      =2  /*********************************************************************************************************
  84      =2  ** º¯ÊýÃû³Æ: OSStart
  85      =2  ** ¹¦ÄÜÃèÊö: Æô¶¯¶àÈÎÎñ»·¾³
  86      =2  ** Êä¡¡Èë: ÎÞ
  87      =2  ** Êä¡¡³ö : ÎÞ
  88      =2  ** È«¾Ö±äÁ¿: ÎÞ
  89      =2  ** µ÷ÓÃÄ£¿é: OSFindNextRunningTask,OSStartHighRdy
  90      =2  ********************************************************************************************************/
  91      =2  
  92      =2  extern uint8 _OSTaskCreate(uint8 TaskID, void (code * task)(void), void xdata *ptos) small;
  93      =2  /*********************************************************************************************************
  94      =2  ** º¯ÊýÃû³Æ: _OSTaskCreate
  95      =2  ** ¹¦ÄÜÃèÊö: ´´½¨ÈÎÎñ
  96      =2  ** Êä¡¡Èë: TaskID:ÈÎÎñID
  97      =2  **         task  :ÈÎÎñµØÖ·
  98      =2  **         ptos  :ÈÎÎñ¶ÑÕ»£¬ÔÚ51ÖÐÎªÖØÈëÕ»
  99      =2  ** Êä¡¡³ö: ÎÞ
 100      =2  ** È«¾Ö±äÁ¿: 
 101      =2  ** µ÷ÓÃÄ£¿é: ÎÞ
 102      =2  ********************************************************************************************************/
 103      =2  
 104      =2  extern uint8 OSTaskDel(uint8 TaskID) small;
 105      =2  /*********************************************************************************************************
 106      =2  ** º¯ÊýÃû³Æ: OSTaskDel
 107      =2  ** ¹¦ÄÜÃèÊö: ´´½¨ÈÎÎñ
 108      =2  ** Êä¡¡Èë: TaskID:ÈÎÎñID
 109      =2  ** Êä¡¡³ö: ÎÞ
 110      =2  ** È«¾Ö±äÁ¿: 
 111      =2  ** µ÷ÓÃÄ£¿é: ÎÞ
 112      =2  ********************************************************************************************************/
 113      =2         
 114      =2  extern void OSTaskResume(uint8 TaskID) small;
 115      =2  /*********************************************************************************************************
 116      =2  ** º¯ÊýÃû³Æ: OSTaskResume
 117      =2  ** ¹¦ÄÜÃèÊö: ÖÐ»Ö¸´ÈÎÎñ
 118      =2  ** Êä¡¡Èë: TaskID : ÈÎÎñID
 119      =2  ** Êä¡¡³ö: ÎÞ
 120      =2  ** È«¾Ö±äÁ¿: ÎÞ
 121      =2  ** µ÷ÓÃÄ£¿é: OSSched
 122      =2  ********************************************************************************************************/
 123      =2  
 124      =2  extern void OS_TaskSuspend(uint8 TaskID)    small;
 125      =2  /*********************************************************************************************************
 126      =2  ** º¯ÊýÃû³Æ: OS_TaskSuspend
 127      =2  ** ¹¦ÄÜÃèÊö: Ê¹Ö¸¶¨ÈÎÎñÐÝÃß£¬µ«²»½øÐÐÈÎÎñÇÐ»»
 128      =2  ** Êä¡¡Èë: TaskID : ÈÎÎñID
 129      =2  ** Êä¡¡³ö: ÎÞ
 130      =2  ** È«¾Ö±äÁ¿: OSWaitTick
 131      =2  ** µ÷ÓÃÄ£¿é: ÎÞ
 132      =2  **
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 27  

 133      =2  ** ×÷¡¡Õß: ³ÂÃ÷¼Æ
 134      =2  ** ÈÕ¡¡ÆÚ: 2002Äê6ÔÂ20ÈÕ
 135      =2  **-------------------------------------------------------------------------------------------------------
 136      =2  ** ÐÞ¸ÄÈË:
 137      =2  ** ÈÕ¡¡ÆÚ:
 138      =2  **-------------------------------------------------------------------------------------------------------
 139      =2  ********************************************************************************************************/
 140      =2  
 141      =2  extern void OSTaskSuspend(uint8 TaskID)    small;
 142      =2  /*********************************************************************************************************
 143      =2  ** º¯ÊýÃû³Æ: OSTaskSuspend
 144      =2  ** ¹¦ÄÜÃèÊö: Ê¹Ö¸¶¨ÈÎÎñÐÝÃß
 145      =2  ** Êä¡¡Èë: TaskID : ÈÎÎñID
 146      =2  ** Êä¡¡³ö: ÎÞ
 147      =2  ** È«¾Ö±äÁ¿: Îå
 148      =2  ** µ÷ÓÃÄ£¿é: OS_TaskSuspend
 149      =2  **
 150      =2  ** ×÷¡¡Õß: ³ÂÃ÷¼Æ
 151      =2  ** ÈÕ¡¡ÆÚ: 2002Äê6ÔÂ20ÈÕ
 152      =2  **-------------------------------------------------------------------------------------------------------
 153      =2  ** ÐÞ¸ÄÈË:
 154      =2  ** ÈÕ¡¡ÆÚ:
 155      =2  **-------------------------------------------------------------------------------------------------------
 156      =2  ********************************************************************************************************/
 157      =2  
 158      =2  extern void OSTimeDly(uint8 ticks)     small;
 159      =2  /*********************************************************************************************************
 160      =2  ** º¯ÊýÃû³Æ: OSTimeDly
 161      =2  ** ¹¦ÄÜÃèÊö: ÏµÍ³µÈ´ýº¯Êý,ÈÎÎñµ÷ÓÃ´Ëº¯Êý¿ÉÒÔµÈ´ýÒ»¶¨Ê±¼ä
 162      =2  ** Êä¡¡Èë:  ticks : µÈ´ý³¬Ê±Ê±µÄÏµÍ³àÖàªÊý
 163      =2  ** Êä¡¡³ö : ÎÞ
 164      =2  **
 165      =2  ** È«¾Ö±äÁ¿: OSWaitTick
 166      =2  ** µ÷ÓÃÄ£¿é: OSIntTaskResume,OSSched
 167      =2  ********************************************************************************************************/
 168      =2  
 169      =2  extern void OSTimeDlyResume(uint8 TaskID)    small;
 170      =2  /*********************************************************************************************************
 171      =2  ** º¯ÊýÃû³Æ: OSTimeDlyResume
 172      =2  ** ¹¦ÄÜÃèÊö: ÈÃ´¦ÔÚÑÓÊ±ÆÚµÄÈÎÎñ½áÊøÑÓÊ±
 173      =2  ** Êä¡¡Èë:  TaskID : ÈÎÎñID
 174      =2  ** Êä¡¡³ö : ÎÞ
 175      =2  ** È«¾Ö±äÁ¿: OSWaitTick
 176      =2  ** µ÷ÓÃÄ£¿é: OSTaskResume
 177      =2  ********************************************************************************************************/
 178      =2  
 179      =2  extern void  OSTimeTick (void)  small;
 180      =2  /*********************************************************************************************************
 181      =2  ** º¯ÊýÃû³Æ: OSTimeTick
 182      =2  ** ¹¦ÄÜÃèÊö: ÏµÍ³Ê±ÖÓ´¦Àíº¯Êý,´¦Àí¸÷¸öÈÎÎñµÄÑÓÊ±
 183      =2  ** Êä¡¡Èë: ÎÞ
 184      =2  ** Êä¡¡³ö: ÎÞ
 185      =2  ** È«¾Ö±äÁ¿: OSWaitTick
 186      =2  ** µ÷ÓÃÄ£¿é: OSIntSendSignal
 187      =2  ********************************************************************************************************/
 188      =2  
 189      =2  extern uint8 OSWait (uint8 typ, uint8 ticks)    small;
 190      =2  /*********************************************************************************************************
 191      =2  ** º¯ÊýÃû³Æ: OSWait
 192      =2  ** ¹¦ÄÜÃèÊö: ÏµÍ³µÈ´ýº¯Êý,ÈÎÎñµ÷ÓÃ´Ëº¯Êý¿ÉÒÔµÈ´ýÒ»¶¨Ê±¼ä»òÐÅºÅ
 193      =2  ** Êä¡¡Èë: typ: µÈ´ýÊÂ¼þÀàÐÍ,Ä¿Ç°¿ÉÒÔÈ¡ÒÔÏÂÖµ,»òÊÇÆäÖÐÈÎÒâ¸öÖµµÄ°´Î»»ò
 194      =2  **             K_SIG: µÈ´ýÐÅºÅ
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 28  

 195      =2  **             K_TMO: µÈ´ý³¬Ê±
 196      =2  **        ticks : µÈ´ý³¬Ê±Ê±µÄÏµÍ³àÖàªÊý
 197      =2  ** Êä¡¡³ö : NOT_OK : ²ÎÊý´íÎó
 198      =2  **         TMO_EVENT : ³¬Ê±µ½
 199      =2  **         SIG_EVENT : ÓÐÐÅºÅ
 200      =2  ** È«¾Ö±äÁ¿: OSWaitTick
 201      =2  ** µ÷ÓÃÄ£¿é: OSTaskSuspend,OSTimeDly,OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
 202      =2  ********************************************************************************************************/
 203      =2  
 204      =2  extern uint8 OSIntExit (void)    small;
 205      =2  /*********************************************************************************************************
 206      =2  ** º¯ÊýÃû³Æ: OSIntExit
 207      =2  ** ¹¦ÄÜÃèÊö: ÖÐ¶ÏÍË³ö´¦Àíº¯Êý,ÔÚ´Ë½øÐÐÖÐ¶ÏºóµÄÈÎÎñÇÐ»»
 208      =2  ** Êä¡¡Èë: ÎÞ
 209      =2  ** Êä¡¡³ö: 0:ÎÞÐèÈÎÎñÇÐ»»
 210      =2  **         1:ÐèÒªÈÎÎñÇÐ»»
 211      =2  ** È«¾Ö±äÁ¿: OSIntNesting,OSNextTaskID
 212      =2  ** µ÷ÓÃÄ£¿é: OSIntCtxSw
 213      =2  ********************************************************************************************************/
 214      =2  
 215      =2  extern void OSSched (void)  small;
 216      =2  /*********************************************************************************************************
 217      =2  ** º¯ÊýÃû³Æ: OSSched
 218      =2  ** ¹¦ÄÜÃèÊö: ·ÇÖÐ¶ÏµÄÈÎÎñÇÐ»»º¯Êý
 219      =2  ** Êä¡¡Èë: ÎÞ
 220      =2  ** Êä¡¡³ö: ÎÞ
 221      =2  ** È«¾Ö±äÁ¿: OSIntNesting,OSNextTaskID
 222      =2  ** µ÷ÓÃÄ£¿é: OS_TASK_SW
 223      =2  ********************************************************************************************************/
 224      =2  
 225      =2  extern void OSFindNextRunningTask(void) small;
 226      =2  /*********************************************************************************************************
 227      =2  ** º¯ÊýÃû³Æ: OSFindNextRunningTask
 228      =2  ** ¹¦ÄÜÃèÊö: ²éÕÒÏÂÒ»¸öÓÅÏÈ¼¶×î¸ßµÄ¾ÍÐ÷ÈÎÎñ
 229      =2  ** Êä¡¡Èë: ÎÞ
 230      =2  ** Êä¡¡³ö: OSNextTaskID:´æ´¢²éÕÒ½á¹û
 231      =2  ** È«¾Ö±äÁ¿: OSTaskRuning,OSTaskCreated
 232      =2  ** µ÷ÓÃÄ£¿é: ÎÞ
 233      =2  **
 234      =2  ** ×÷¡¡Õß: ³ÂÃ÷¼Æ
 235      =2  ** ÈÕ¡¡ÆÚ: 2002Äê6ÔÂ20ÈÕ
 236      =2  **-------------------------------------------------------------------------------------------------------
 237      =2  ** ÐÞ¸ÄÈË:
 238      =2  ** ÈÕ¡¡ÆÚ:
 239      =2  **-------------------------------------------------------------------------------------------------------
 240      =2  ********************************************************************************************************/
 241      =2  #endif
 242      =2  
 243      =2  /*********************************************************************************************************
 244      =2  **                            End Of File
 245      =2  ********************************************************************************************************/
  76      =1  #include "..\os\OS_Q.h"
   1      =2  /*********************************************************************************************************
   2      =2  **                                                             Small RTOS(51)
   3      =2  **                                   The Real-Time Kernel(For Keil c51)
   4      =2  **
   5      =2  **                                  (c) Copyright 2002-2003, chenmingji
   6      =2  **                                           All Rights Reserved
   7      =2  **
   8      =2  **                                                  V1.20.0
   9      =2  **
  10      =2  **
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 29  

  11      =2  **--------------ÎÄ¼þÐÅÏ¢--------------------------------------------------------------------------------
  12      =2  **ÎÄ   ¼þ   Ãû: OS_Q.h
  13      =2  **´´   ½¨   ÈË: ³ÂÃ÷¼Æ
  14      =2  **×îºóÐÞ¸ÄÈÕÆÚ:  2003Äê8ÔÂ3ÈÕ
  15      =2  ** Ãè¡¡Êö: Small RTOS(51)ÏûÏ¢¶ÓÁÐÍ·ÎÄ¼þ£¬¶¨ÒåÒ»Ð©ºêºÍÉùÃ÷Ò»Ð©º¯Êý
  16      =2  **
  17      =2  **--------------ÀúÊ·°æ±¾ÐÅÏ¢----------------------------------------------------------------------------
  18      =2  ** ´´½¨ÈË: ³ÂÃ÷¼Æ
  19      =2  ** °æ  ±¾: V1.10~V1.12.0
  20      =2  ** ÈÕ¡¡ÆÚ: 2002Äê6ÔÂ20ÈÕ~2002Äê12ÔÂ30ÈÕ
  21      =2  ** Ãè¡¡Êö: ÍêÉÆÏûÏ¢¶ÓÁÐ´úÂë
  22      =2  **
  23      =2  **------------------------------------------------------------------------------------------------------
  24      =2  ** ÐÞ¸ÄÈË: ³ÂÃ÷¼Æ
  25      =2  ** °æ  ±¾: V1.20.0
  26      =2  ** ÈÕ¡¡ÆÚ: 2003Äê8ÔÂ3ÈÕ
  27      =2  ** Ãè¡¡Êö: É¾³ýOSInt*º¯Êý£¬¸ù¾ÝÐÂ°æ±¾ÒªÇó¸Ä±äÒ»Ð©´úÂë
  28      =2  **
  29      =2  **--------------µ±Ç°°æ±¾ÐÞ¶©-----------------------------------------------------------------------------
  30      =2  ** ÐÞ¸ÄÈË:
  31      =2  ** ÈÕ¡¡ÆÚ:
  32      =2  ** Ãè¡¡Êö:
  33      =2  **
  34      =2  **------------------------------------------------------------------------------------------------------
  35      =2  ********************************************************************************************************/
  36      =2  
  37      =2  
  38      =2  #ifndef NOT_OK
           =2 #define NOT_OK      255                                 /* ²ÎÊý´íÎó                                     */
           =2 #endif
  41      =2  
  42      =2  #define OS_Q_FULL   8                                   /* ¶ÓÁÐÂú                                       */
  43      =2  #define OS_Q_NOT_OK 4                                   /* ÎÞÏûÏ¢                                       */
  44      =2  #define OS_Q_TMO    2                                   /* ³¬Ê±µ½                                       */
  45      =2  #define OS_Q_OK     1                                   /* ²Ù×÷³É¹¦                                     */
  46      =2  
  47      =2  #ifndef IN_OS_Q
  48      =2  extern uint8 OSQCreate(uint8 OS_Q_MEM_SEL *Buf, uint8 SizeOfBuf);
  49      =2  /*********************************************************************************************************
  50      =2  ** º¯ÊýÃû³Æ: OSQCreate
  51      =2  ** ¹¦ÄÜÃèÊö: ³õÊ¼»¯ÏûÏ¢¶ÓÁÐ
  52      =2  ** Êä¡¡Èë: Buf:Îª¶ÓÁÐ·ÖÅäµÄ´æ´¢¿Õ¼äµØÖ·
  53      =2  **         SizeOfBuf:Îª¶ÓÁÐ·ÖÅäµÄ´æ´¢¿Õ¼ä´óÐ¡
  54      =2  ** Êä¡¡³ö: NOT_OK:²ÎÊý´íÎó
  55      =2  **         OS_Q_OK:³É¹¦
  56      =2  ** È«¾Ö±äÁ¿: ÎÞ
  57      =2  ** µ÷ÓÃÄ£¿é: ÎÞ
  58      =2  ********************************************************************************************************/
  59      =2  extern uint8 OSQPend(uint8 data *Ret, uint8 OS_Q_MEM_SEL *Buf, uint8 Tick);
  60      =2  /*********************************************************************************************************
  61      =2  ** º¯ÊýÃû³Æ: OSQPend
  62      =2  ** ¹¦ÄÜÃèÊö: µÈ´ýÏûÏ¢¶ÓÁÐÖÐµÄÏûÏ¢
  63      =2  ** Êä¡¡Èë: Ret:·µ»ØµÄÏûÏ¢
  64      =2  **         Buf:Ö¸Ïò¶ÓÁÐµÄÖ¸Õë
  65      =2  **         Tick:µÈ´ýÊ±¼ä
  66      =2  ** Êä¡¡³ö: NOT_OK:²ÎÊý´íÎó
  67      =2  **         OS_Q_OK:ÊÕµ½ÏûÏ¢
  68      =2  **         OS_Q_TMO:³¬Ê±µ½
  69      =2  **         OS_Q_NOT_OK:ÎÞÏûÏ¢
  70      =2  ** È«¾Ö±äÁ¿: ÎÞ
  71      =2  ** µ÷ÓÃÄ£¿é: OSRunningTaskID,OSClearSignal,OSSched,OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
  72      =2  ********************************************************************************************************/
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 30  

  73      =2  extern uint8 OSQAccept(uint8 data *Ret, uint8 OS_Q_MEM_SEL *Buf);
  74      =2  /*********************************************************************************************************
  75      =2  ** º¯ÊýÃû³Æ: OSQAccept
  76      =2  ** ¹¦ÄÜÃèÊö: ÎÞµÈ´ý´ÓÏûÏ¢¶ÓÁÐÖÐÈ¡µÃÏûÏ¢
  77      =2  ** Êä¡¡Èë: Ret:·µ»ØµÄÏûÏ¢
  78      =2  **         Buf:Ö¸Ïò¶ÓÁÐµÄÖ¸Õë
  79      =2  ** Êä¡¡³ö: NOT_OK:²ÎÊý´íÎó
  80      =2  **         OS_Q_OK:ÊÕµ½ÏûÏ¢
  81      =2  **         OS_Q_TMO:³¬Ê±µ½
  82      =2  **         OS_Q_NOT_OK:ÎÞÏûÏ¢
  83      =2  ** È«¾Ö±äÁ¿: ÎÞ
  84      =2  ** µ÷ÓÃÄ£¿é: OSClearSignal,OSSched,OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
  85      =2  ********************************************************************************************************/
  86      =2  extern uint8 OSQPost(uint8 OS_Q_MEM_SEL *Buf, uint8 Data);
  87      =2  /*********************************************************************************************************
  88      =2  ** º¯ÊýÃû³Æ: OSQPost
  89      =2  ** ¹¦ÄÜÃèÊö: FIFO·½Ê½·¢ËÍÏûÏ¢
  90      =2  ** Êä¡¡Èë: Buf:Ö¸Ïò¶ÓÁÐµÄÖ¸Õë
  91      =2  **         Data:ÏûÏ¢Êý¾Ý
  92      =2  ** Êä¡¡³ö: OS_Q_FULL:¶ÓÁÐÂú
  93      =2  **         OS_Q_OK:·¢ËÍ³É¹¦
  94      =2  ** È«¾Ö±äÁ¿: ÎÞ
  95      =2  ** µ÷ÓÃÄ£¿é: OSQIntPost,OSSched
  96      =2  ********************************************************************************************************/
  97      =2  extern uint8 OSQPostFront(uint8 OS_Q_MEM_SEL *Buf, uint8 Data);
  98      =2  /*********************************************************************************************************
  99      =2  ** º¯ÊýÃû³Æ: OSQPostFront
 100      =2  ** ¹¦ÄÜÃèÊö: LIFO·½Ê½·¢ËÍÏûÏ¢
 101      =2  ** Êä¡¡Èë: Buf:Ö¸Ïò¶ÓÁÐµÄÖ¸Õë
 102      =2  **         Data:ÏûÏ¢Êý¾Ý
 103      =2  ** Êä¡¡³ö: OS_Q_FULL:¶ÓÁÐÂú
 104      =2  **         OS_Q_OK:·¢ËÍ³É¹¦
 105      =2  ** È«¾Ö±äÁ¿: ÎÞ
 106      =2  ** µ÷ÓÃÄ£¿é: OSQIntPostFront,OSSched
 107      =2  ********************************************************************************************************/
 108      =2  /* ¼æÈÝV1.12.1µÄºê */
 109      =2  #define OSQIntPost(Buf, Data) OSQPost(Buf, Data)
 110      =2  #define OSQIntPostFront(Buf, Data) OSQPostFront(Buf, Data)
 111      =2  
 112      =2  extern uint8 OSQNMsgs(uint8 OS_Q_MEM_SEL *Buf);
 113      =2  /*********************************************************************************************************
 114      =2  ** º¯ÊýÃû³Æ: OSQNMsgs
 115      =2  ** ¹¦ÄÜÃèÊö: È¡µÃÏûÏ¢¶ÓÁÐÖÐÏûÏ¢Êý
 116      =2  ** Êä¡¡Èë: Buf:Ö¸Ïò¶ÓÁÐµÄÖ¸Õë
 117      =2  ** Êä¡¡³ö: ÏûÏ¢Êý
 118      =2  ** È«¾Ö±äÁ¿: ÎÞ
 119      =2  ** µ÷ÓÃÄ£¿é: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
 120      =2  ********************************************************************************************************/
 121      =2  extern uint8 OSQSize(uint8 OS_Q_MEM_SEL *Buf);
 122      =2  /*********************************************************************************************************
 123      =2  ** º¯ÊýÃû³Æ: OSQSize
 124      =2  ** ¹¦ÄÜÃèÊö: È¡µÃÏûÏ¢¶ÓÁÐ×ÜÈÝÁ¿
 125      =2  ** Êä¡¡Èë: Buf:Ö¸Ïò¶ÓÁÐµÄÖ¸Õë
 126      =2  ** Êä¡¡³ö: ÏûÏ¢¶ÓÁÐ×ÜÈÝÁ¿
 127      =2  ** È«¾Ö±äÁ¿: ÎÞ
 128      =2  ** µ÷ÓÃÄ£¿é: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
 129      =2  ********************************************************************************************************/
 130      =2  extern void OSQFlush (uint8 OS_Q_MEM_SEL *Buf);
 131      =2  /*********************************************************************************************************
 132      =2  ** º¯ÊýÃû³Æ: OSQFlush
 133      =2  ** ¹¦ÄÜÃèÊö: Çå¿Õ¶ÓÁÐ
 134      =2  ** Êä¡¡Èë: Buf:Ö¸Ïò¶ÓÁÐµÄÖ¸Õë
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 31  

 135      =2  ** Êä¡¡³ö: ÎÞ
 136      =2  ** È«¾Ö±äÁ¿: ÎÞ
 137      =2  ** µ÷ÓÃÄ£¿é: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
 138      =2  **
 139      =2  ** ×÷¡¡Õß: ³ÂÃ÷¼Æ
 140      =2  ** ÈÕ¡¡ÆÚ: 2002Äê9ÔÂ1ÈÕ
 141      =2  **-------------------------------------------------------------------------------------------------------
 142      =2  ** ÐÞ¸ÄÈË: ³ÂÃ÷¼Æ
 143      =2  ** ÈÕ¡¡ÆÚ: 2002Äê10ÔÂ26ÈÕ
 144      =2  **-------------------------------------------------------------------------------------------------------
 145      =2  ** ÐÞ¸ÄÈË:
 146      =2  ** ÈÕ¡¡ÆÚ:
 147      =2  **-------------------------------------------------------------------------------------------------------
 148      =2  ********************************************************************************************************/
 149      =2  #endif
 150      =2  /*********************************************************************************************************
 151      =2  **                            End Of File
 152      =2  ********************************************************************************************************/
  77      =1  #include "..\os\OS_SEM.h" 
   1      =2  /*********************************************************************************************************
   2      =2  **                                                             Small RTOS(51)
   3      =2  **                                   The Real-Time Kernel(For Keil c51)
   4      =2  **
   5      =2  **                                  (c) Copyright 2002-2003, chenmingji
   6      =2  **                                           All Rights Reserved
   7      =2  **
   8      =2  **                                                  V1.20.0
   9      =2  **
  10      =2  **
  11      =2  **--------------ÎÄ¼þÐÅÏ¢--------------------------------------------------------------------------------
  12      =2  **ÎÄ   ¼þ   Ãû: OS_sem.h
  13      =2  **´´   ½¨   ÈË: ³ÂÃ÷¼Æ
  14      =2  **×îºóÐÞ¸ÄÈÕÆÚ:  2002Äê12ÔÂ2ÈÕ
  15      =2  ** Ãè¡¡Êö: Small RTOS(51)ÐÅºÅÁ¿Í·ÎÄ¼þ£¬¶¨ÒåÒ»Ð©ºêºÍÉùÃ÷Ò»Ð©º¯Êý
  16      =2  **
  17      =2  **--------------ÀúÊ·°æ±¾ÐÅÏ¢----------------------------------------------------------------------------
  18      =2  ** ´´½¨ÈË: ³ÂÃ÷¼Æ
  19      =2  ** °æ  ±¾: V1.10~V1.12.0
  20      =2  ** ÈÕ¡¡ÆÚ: 2002Äê9ÔÂ1ÈÕ~2002Äê12ÔÂ30ÈÕ
  21      =2  ** Ãè¡¡Êö: ÍêÉÆÐÅºÅÁ¿´úÂë
  22      =2  **
  23      =2  **------------------------------------------------------------------------------------------------------
  24      =2  ** ÐÞ¸ÄÈË: ³ÂÃ÷¼Æ
  25      =2  ** °æ  ±¾: V1.20.0
  26      =2  ** ÈÕ¡¡ÆÚ: 2003Äê8ÔÂ3ÈÕ
  27      =2  ** Ãè¡¡Êö: É¾³ýOSInt*º¯Êý£¬¸ù¾ÝÐÂ°æ±¾ÒªÇó¸Ä±äÒ»Ð©´úÂë
  28      =2  **
  29      =2  **--------------µ±Ç°°æ±¾ÐÞ¶©-----------------------------------------------------------------------------
  30      =2  ** ÐÞ¸ÄÈË:
  31      =2  ** ÈÕ¡¡ÆÚ:
  32      =2  ** Ãè¡¡Êö:
  33      =2  **
  34      =2  **------------------------------------------------------------------------------------------------------
  35      =2  ********************************************************************************************************/
  36      =2  
  37      =2  
  38      =2  #ifndef NOT_OK
           =2 #define NOT_OK      255                                 /* ²ÎÊý´íÎó                                     */
           =2 #endif
  41      =2  
  42      =2  #define OS_SEM_NOT_OK 4                                 /* ÎÞÐÅºÅ                                       */
  43      =2  #define OS_SEM_TMO    2                                 /* ³¬Ê±µ½                                       */
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 32  

  44      =2  #define OS_SEM_OK     1                                 /* ²Ù×÷³É¹¦                                     */
  45      =2  
  46      =2  #ifndef IN_OS_SEM
  47      =2  extern uint8 OSSemCreate(uint8 Index,uint8 Data);
  48      =2  /*********************************************************************************************************
  49      =2  ** º¯ÊýÃû³Æ: OSSemCreate
  50      =2  ** ¹¦ÄÜÃèÊö: ³õÊ¼»¯ÏûÏ¢¶ÓÁÐ
  51      =2  ** Êä¡¡Èë: Index:ÐÅºÅÁ¿Ë÷Òý
  52      =2  **         data:ÐÅºÅÁ¿³õÊ¼Öµ
  53      =2  ** Êä¡¡³ö: NOT_OK:Ã»ÓÐÕâ¸öÐÅºÅÁ¿
  54      =2  **         OS_SEM_OK:³É¹¦
  55      =2  ** È«¾Ö±äÁ¿: ÎÞ
  56      =2  ** µ÷ÓÃÄ£¿é: ÎÞ
  57      =2  ********************************************************************************************************/
  58      =2  extern uint8 OSSemPend(uint8 Index, uint8 Tick);
  59      =2  /*********************************************************************************************************
  60      =2  ** º¯ÊýÃû³Æ: OSSemPend
  61      =2  ** ¹¦ÄÜÃèÊö: µÈ´ýÒ»¸öÐÅºÅÁ¿
  62      =2  ** Êä¡¡Èë: Index:ÐÅºÅÁ¿Ë÷Òý
  63      =2  **         Tick:µÈ´ýÊ±¼ä
  64      =2  ** Êä¡¡³ö: NOT_OK:²ÎÊý´íÎó
  65      =2  **         OS_SEM_OK:µÃµ½ÐÅºÅÁ¿
  66      =2  **         OS_SEM_TMO:³¬Ê±µ½
  67      =2  **         OS_SEM_NOT_OK:Ã»ÓÐµÃµ½ÐÅºÅÁ¿
  68      =2  ** È«¾Ö±äÁ¿: ÎÞ
  69      =2  ** µ÷ÓÃÄ£¿é: OSRunningTaskID,OSClearSignal,OSSched,OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
  70      =2  ********************************************************************************************************/
  71      =2  extern uint8 OSSemAccept(uint8 Index);
  72      =2  /*********************************************************************************************************
  73      =2  ** º¯ÊýÃû³Æ: OSSemAccept
  74      =2  ** ¹¦ÄÜÃèÊö: ÎÞµÈ´ýÇëÇóÐÅºÅÁ¿
  75      =2  ** Êä¡¡Èë: Index:ÐÅºÅÁ¿Ë÷Òý
  76      =2  ** Êä¡¡³ö: NOT_OK:²ÎÊý´íÎó
  77      =2  **         OS_SEM_OK:µÃµ½ÐÅºÅÁ¿
  78      =2  **         OS_SEM_TMO:³¬Ê±µ½
  79      =2  **         OS_SEM_NOT_OK:Ã»ÓÐµÃµ½ÐÅºÅÁ¿
  80      =2  ** È«¾Ö±äÁ¿: ÎÞ
  81      =2  ** µ÷ÓÃÄ£¿é: OSClearSignal,OSSched,OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
  82      =2  ********************************************************************************************************/
  83      =2  
  84      =2  #define OSSemIntPost(Index) OSSemPost(Index)
  85      =2  
  86      =2  extern uint8 OSSemPost(uint8 Index);
  87      =2  /*********************************************************************************************************
  88      =2  ** º¯ÊýÃû³Æ: OSSemPost
  89      =2  ** ¹¦ÄÜÃèÊö: ·¢ËÍÒ»¸öÐÅºÅÁ¿
  90      =2  ** Êä¡¡Èë: Index:ÐÅºÅÁ¿Ë÷Òý
  91      =2  ** Êä¡¡³ö: NOT_OK:²ÎÊý´íÎó
  92      =2  **         OS_SEM_OK:·¢ËÍ³É¹¦
  93      =2  ** È«¾Ö±äÁ¿: ÎÞ
  94      =2  ** µ÷ÓÃÄ£¿é: OSSemIntPost,OSSched
  95      =2  ********************************************************************************************************/
  96      =2  extern uint8 OSSemQuery(uint8 Index);
  97      =2  /*********************************************************************************************************
  98      =2  ** º¯ÊýÃû³Æ: OSSemQuery
  99      =2  ** ¹¦ÄÜÃèÊö: ²éÑ¯ÐÅºÅÁ¿
 100      =2  ** Êä¡¡Èë: Index:ÐÅºÅÁ¿Ë÷Òý
 101      =2  ** Êä¡¡³ö: ÐÅºÅÁ¿µÄÖµ
 102      =2  ** È«¾Ö±äÁ¿: ÎÞ
 103      =2  ** µ÷ÓÃÄ£¿é: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
 104      =2  ********************************************************************************************************/
 105      =2  #endif
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 33  

 106      =2  /*********************************************************************************************************
 107      =2  **                            End Of File
 108      =2  ********************************************************************************************************/
  78      =1  #include "SingleBus.h"
   1      =2  /*
   2      =2  **********************************Copyright (c) ****************************
   3      =2  *                                                       cwg
   4      =2  *                              All Rights Reserved
   5      =2  *                                       QQ:7084394
   6      =2  *
   7      =2  *---------------------------------File Info---------------------------------
   8      =2  *File Name              :SingleBus.h
   9      =2  *Descriptor             :µ¥×ÜÏßÍ·ÎÄ¼þ
  10      =2  *Create By              :³ÂÎÀ¹ú
  11      =2  *Create Date            :2008-8-8
  12      =2  *Version                :V1.0
  13      =2  *Note                   :
  14      =2  *
  15      =2  *---------------------------------------------------------------------------
  16      =2  *Modified By            :
  17      =2  *Modified Date          :
  18      =2  *Version                :
  19      =2  *Note                   :
  20      =2  *
  21      =2  ****************************************************************************
  22      =2  */
  23      =2  //×ÜÏß0ºê¶¨Òå
  24      =2  #define         BUS0_FREQ_SIZE          7
  25      =2  #define         BUS0_FREQ_SIZE_HI       (BUS0_FREQ_SIZE << 4)
  26      =2  #define         BUS0_TX_Q_ZISE          (BUS0_FREQ_SIZE*20 + 1)
  27      =2  #define         DisableBus0RecInt()     {EX1 = 0;} 
  28      =2  #define         EnableBus0RecInt()      {IE1 = 0;EX1 = 1;}
  29      =2  #define         BUS0_SEND_CON           0x3c
  30      =2  #define         BUS0_CAN_SEND           0x0c 
  31      =2  #define         BUS0_ON_REC                     0x03
  32      =2  #define         BUS0_REQ_SEND           0x28
  33      =2  #define         BUS0_SEND_FINISH        0x0c 
  34      =2  #define         BUS0_ON_WORK            0x23
  35      =2  //µ¥×ÜÏß×Ô¶¯ÖØÔØÊ±¼ä
  36      =2  //#define               TIMER0_COUNT            ((256-(Fbus*9375/12/1000000))) 
  37      =2  
  38      =2  //300us
  39      =2  //#define TIMER0_H  0xfe
  40      =2  //#define TIMER0_L  0x34
  41      =2  
  42      =2  //100uS
  43      =2  #define TIMER0_H  0xff
  44      =2  #define TIMER0_L  0x67
  45      =2  
  46      =2  
  47      =2  /*Êý¾ÝÖ¡¸ñÊ½
  48      =2  ×Ö½Ú1£º·¢ËÍ·½ÇøµØÖ·£¨Ò»¸ö×Ö½Ú£©
  49      =2  ×Ö½Ú2£º·¢ËÍ·½·¿µØÖ·£¨Ò»¸ö×Ö½Ú£©
  50      =2  ×Ö½Ú3£º·¢ËÍ·½´²µØÖ·£¨Ò»¸ö×Ö½Ú£©
  51      =2  ×Ö½Ú4£ºÃüÁî´úÂë£¨Ò»¸ö×Ö½Ú£©
  52      =2  ×Ö½Ú5£º½ÓÊÕ·½ÇøµØÖ·£¨Ò»¸ö×Ö½Ú£©
  53      =2  ×Ö½Ú6£º½ÓÊÕ·½·¿µØÖ·£¨Ò»¸ö×Ö½Ú£©
  54      =2  ×Ö½Ú7£º½ÓÊÕ·½´²µØÖ·£¨Ò»¸ö×Ö½Ú£©
  55      =2  ×¢:Êý¾ÝèåÔÚ²»Í¬µÄÃüÁîÖÐ¿ÉÄÜÓÐ²»Í¬º¬Òå
  56      =2  */
  57      =2  /*µ¥×ÜÏßÐ­Òé
  58      =2    ÃüÁî´úÂë:Ò»×Ö½Ú
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 34  

  59      =2    Êý¾Ý´úÂë:6×Ö½Ú(¸ù¾ÝÃüÁîµÄ²»Í¬Êý¾Ý¸ñÊ½)
  60      =2  */
  61      =2  typedef struct
  62      =2  {
  63      =2          uint8 bySndSecAddr;                     /*Ö÷¶¯·¢ËÍ·½ÇøµØÖ·*/
  64      =2          uint8 bySndRoomAddr;            /*Ö÷¶¯·¢ËÍ·½·¿µØÖ·*/
  65      =2          uint8 bySndBedAddr;                     /*Ö÷¶¯·¢ËÍ·½´²µØÖ·*/
  66      =2          uint8 byCmd;                            /*ÃüÁî*/
  67      =2          uint8 byRecSecAddr;                     /*½ÓÊÕ·½ÇøµØÖ·*/
  68      =2          uint8 byRecRoomAddr;            /*½ÓÊÕ·½·¿µØÖ·*/
  69      =2          uint8 byRecBedAddr;                     /*½ÓÊÕ·½´²µØÖ·*/        
  70      =2  } STBusFreq, *pSTBusFreq;       
  71      =2  /*************************ÃüÁî¶¨Òå**********************/
  72      =2  #define CMD_QUEST                               0x01    /*²éÑ¯ÃüÁî*/
  73      =2  #define CMD_ANSWER                              0x02    /*Ó¦´ðÃüÁî*/
  74      =2  #define CMD_LANDING                             0x03    /*µÇ¼ÇÃüÁî*/                    /*ºóÃæÁ½¸ö×Ö½ÚÎªÓÅÏÈ¼¶ºÍ0x00*/
  75      =2  #define CMD_ENTER                               0x04    /*È·ÈÏÃüÁî*/                    /*Ö»ÄÜÎªÖ÷»ú¶Ô´Ó»ú·¢ËÍ*/
  76      =2  /*****************************************************************/
  77      =2  #define CMD_COMM_CALL                   0x05    /*ÆÕÍ¨ºô½ÐÃüÁî*/                /*ºóÃæÁ½¸ö×Ö½ÚÎªÓÅÏÈ¼¶ºÍÖ÷·½×´Ì¬*/
  78      =2  #define CMD_INFUSION_CALL               0x06    /*ÊäÒººô½ÐÃüÁî*/
  79      =2  #define CMD_SERVICE_CALL                0x07    /*·þÎñºô½ÐÃüÁî*/
  80      =2  #define CMD_EMERGENCY_CALL              0x08    /*½ô¼±ºô½ÐÃüÁî*/
  81      =2  #define CMD_HELP_CALL                   0x09    /*ÇóÔ®ºô½ÐÃüÁî*/                /* ±ØÐëµÃµ½Ö÷»úµÄÈ·ÈÏÃüÁî*/
  82      =2  #define CMD_INSPECTOR_CALL              0x0a    /*²é·¿ºô½ÐÃüÁî*/                /* ±ØÐëµÃµ½Ö÷»úµÄÈ·ÈÏÃüÁî*/
  83      =2  /*****************************************************************/
  84      =2  #define CMD_COMM_ANSWER                 0x0b    /*ÆÕÍ¨Ó¦´ðÃüÁî*/                
  85      =2  #define CMD_INFUSION_ANSWER             0x0c    /*´¦ÀíÊäÒºÃüÁî*/
  86      =2  #define CMD_SERVICE_ANSWER              0x0d    /*´¦Àí·þÎñÃüÁî*/
  87      =2  #define CMD_EMERGENCY_ANSWER    0x0e    /*´¦Àí½ô¼±ÃüÁî*/
  88      =2  #define CMD_HELP_ANSWER                 0x0f    /*´¦ÀíÇóÔ®ÃüÁî*/
  89      =2  /*****************************************************************/
  90      =2  #define CMD_INFUSION_CLEAR              0x10    /*Çå³ýÊäÒºÃüÁî*/                /* ¶ÔÓ¦µÄÇå³ýÃüÁî*/
  91      =2  #define CMD_SERVICE_CLEAR               0x11    /*Çå³ý·þÎñÃüÁî*/
  92      =2  #define CMD_EMERGENCY_CLEAR             0x12    /*Çå³ý½ô¼±ÃüÁî*/
  93      =2  #define CMD_HELP_CLEAR                  0x13    /*Çå³ýÇóÔ®ÃüÁî*/
  94      =2  /*****************************************************************/
  95      =2  #define CMD_BROADCAST1                  0x14    /*1Àà¹ã²¥ºô½ÐÃüÁî*/
  96      =2  #define CMD_BROADCAST2                  0x15    /*2Àà¹ã²¥ºô½ÐÃüÁî*/
  97      =2  #define CMD_CALL_LISTEN                 0x16    /*½ÓÌýºô½ÐÃüÁî*/
  98      =2  #define CMD_PRIORITY_SET                0x17    /*ÓÅÏÈ¼¶Ö¸¶¨ÃüÁî*/              /*ÏµÍ³ÃüÁî£ºµÚÒ»¸ö×Ö½Ú¸ß3Î»ÎªÓÅÏÈ¼¶£¬½ÓÊÕ·½µØÖ·*/
  99      =2  #define CMD_SYSTERM_RESET               0x18    /*ÏµÍ³¸´Î»ÃüÁî*/
 100      =2  /*****************************************************************/
 101      =2  #define CMD_DATA_SEND                   0x19    /*ÈÕÆÚ·¢ËÍÃüÁî*/                /*Ç°Á½¸ö×Ö½Ú£¬Äê£º4Î»BCDÂë£¬ºóÃæÁ½¸ö×Ö½Ú£ºÔÂºÍÈÕÆÚ£º4Î»BCDÂ
             -ë*/
 102      =2  #define CMD_TIME_SEND                   0x1a    /*Ê±¼ä·¢ËÍÃüÁî*/
 103      =2  #define CMD_SCHEDULE_SEND               0x1b    /*Ò»ÀÀ±í·¢ËÍÃüÁî*/
 104      =2  #define CMD_NUMBER_SET                  0x1c    /*ÐÞ¸Ä±àºÅÃüÁî*/                /*ÐÂµÄµØÖ·ÔÚÇ°2¸ö×Ö½Ú£¬±»ÐÞ¸ÄµØÖ·ÔÚºóÁ½¸ö×Ö½Ú*/
 105      =2  #define CMD_LAMP_CONTROL                0x1d    /*µÆ¿ØÃüÁî*/
 106      =2  /*****************************************************************/
 107      =2  #define CMD_CONTROL_SEND                0x1e    /*¿ØÖÆ×Ö´«µÝÃüÁî*/
 108      =2  #define CMD_FLOOR_SET                   0x1f    /*ÐÞ¸ÄÂ¥²ãºÅÃüÁî*/
 109      =2  #define CMD_BROADCAST3                  0x20    /*3Àà¹ã²¥ºô½ÐÃüÁî*/
 110      =2  #define CMD_INFUSION_ENTER              0x21    /*È·ÈÏÊäÒºÃüÁî*/
 111      =2  #define CMD_SERVICE_ENTER               0x22    /*È·ÈÏ·þÎñÃüÁî*/
 112      =2  #define CMD_HELP_ENTER                  0x23    /*È·ÈÏÇóÔ®ÃüÁî*/
 113      =2  #define CMD_EMERGENCY_ENTER             0x24    /*È·ÈÏ½ô¼±ÃüÁî*/
 114      =2  /*****************************************************************/
 115      =2  #define CMD_CLEAR_INSPERCTOR    0x25    /*Çå³ý²é·¿ÃüÁî*/
 116      =2  #define CMD_START_VOICE                 0x26    /*Æô¶¯²¥ÒôÃüÁî*/
 117      =2  #define CMD_STOP_VOICE                  0x27    /*Í£Ö¹²¥ÒôÃüÁî*/
 118      =2  #define CMD_MUSIC_PLAY                  0x28    /*±³¾°ÒôÀÖÃüÁî*/
 119      =2  #define CMD_REQUEST_INFO                0x29    /*ÇëÇó·¢ËÍÐÅÏ¢ÃüÁî*/
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 35  

 120      =2  /*****************************************************************/
 121      =2  #define CMD_CHANNEL_CHANGE              0x2a    /*ÇÐ»»Í¨»°Í¨µÀ*/
 122      =2  #define CMD_CHANNEL_CLOSE               0x2b    /*¹Ø±ÕÍ¨»°Í¨µÀ*/
 123      =2  #define CMD_POWER_ON                    0x2c    /*ÉÏµç¸´Î»ÃüÁî*/
 124      =2  #define CMD_INSPERCTOR_ENTER    0x2d    /*È·ÈÏ²é·¿ÃüÁî*/
 125      =2  #define CMD_STOP_INDICATION             0x2e    /*ÖÕÖ¹ÐÅÏ¢Ö¸Ê¾*/
 126      =2  #define CMD_INFO_INDICATION             0x2f    /*ÐÅÏ¢Ö¸Ê¾ÃüÁî*/
 127      =2  /*Ö÷¶¯ºô½Ð·½µØÖ·ÔÚÇ°Á½¸ö×Ö½Ú£¬ºóÃæÁ½¸ö×Ö½ÚÎªºô½ÐÀàÐÍ£º¸ß3Î»ÓÅÏÈ¼¶£¬µÍ5Î»ÎªÀà±ð*/
 128      =2  /*****************************************************************/
 129      =2  #define CMD_MUSIC                               0x30    /*ÒôÀÖÃüÁî*/
 130      =2  #define CMD_INCREACE_VOL                0x31    /*ÒôÁ¿Ôö¼ÓÃüÁî*/
 131      =2  #define CMD_DECREACE_VOL                0x32    /*ÒôÁ¿¼õÐ¡ÃüÁî*/
 132      =2  #define CMD_OPEN_LCD                    0x3e    /*´ò¿ªÏÔÊ¾ÃüÁî*/
 133      =2  #define CMD_CLOSE_LCD                   0x3f    /*¹Ø±ÕÏÔÊ¾ÃüÁî*/
 134      =2  /*****************************************************************/
 135      =2  #define CMD_OPEN_485BUS_OUT             0x40    /*´ò¿ª485Êä³ö*/
 136      =2  #define CMD_OPEN_485BUS_IN              0x41    /*´ò¿ª485ÊäÈëÃüÁî*/
 137      =2  #define CMD_CLOSE_485BUS                0x42    /*¹Ø±Õ485ÃüÁî*/
 138      =2  /*****************************************************************/
 139      =2  #define CMD_KEY_AVALID                  0x44    /*°´¼üÓÐÐ§ÃüÁî*/
 140      =2  #define CMD_KEY_INVALID                 0x45    /*°´¼üÊ§Ð§ÃüÁî*/
 141      =2  #define CMD_KEY_DOWN                    0x46    /*°´¼üÑ¹ÏÂÃüÁî*/
 142      =2  #define CMD_KEY_UP                              0x47    /*°´¼üÊÍ·ÅÃüÁî*/
 143      =2  #define CMD_ERROR_REPORT                0x48    /*¹ÊÕÏ±¨¸æÃüÁî*/
 144      =2  #define CMD_CLEAR_LCD                   0x49    /*Çå³ýÒº¾§ÐÅÏ¢ÃüÁî*/
 145      =2  #define CMD_RECEIVE_INFO                0x4a    /*ÊÕµ½ÐÅÏ¢ÃüÁî*/
 146      =2  #define CMD_SELECT_INFO                 0x4b    /*Ñ¡ÔñÐÅÏ¢ÃüÁî*/
 147      =2  #define CMD_NO_BUG                              0x4c    /*ÇëÎð´òÈÅÃüÁî*/
 148      =2  #define CMD_NO_BUG_AVALID               0x4d    /*ÇëÎð´òÈÅÓÐÐ§ÃüÁî*/
 149      =2  #define CMD_BUG_END                             0x4e    /*½áÊø´òÈÅÃüÁî*/
 150      =2  
 151      =2  
 152      =2  #define  CMD_STOP_VOICE_PLAY    0x90    //ÓïÒô±¨ºÅ½áÊøÃüÁî
 153      =2  
 154      =2  
 155      =2  #define CMD_VOICE_MAINTAIN      0x98    //ÏµÍ³Î¬»¤ÓïÒô   SndSecAddr  0x01:¿ªÊ¼²¥·Å   0X00:½áÊø²¥·Å
 156      =2  #define CMD_VOICE_WAITE                 0X99    //¡°ÇëÉÔºò£¬»¤Ê¿ÂíÉÏ¾ÍÀ´¡±ÓïÒô  0x01:¿ªÊ¼²¥·Å  0X00:½áÊø²¥·Å
 157      =2  
 158      =2  /*****************************************************************/  
 159      =2  #ifdef _IN_SINGLE_BUS_
           =2 //Éè±¸×´Ì¬¶¨Òå
           =2 uint8   bdata   byDevState1;
           =2 sbit    bLanding        =       byDevState1^0;                          //ÉÏµçµÇ¼Ç×´Ì¬  
           =2 #else
 164      =2  extern  uint8   byDevState1;
 165      =2  extern  bit             bLanding;
 166      =2  extern bit bPlayVoiceMaintain;
 167      =2  extern bit bPlayVoiceWait;
 168      =2  
 169      =2  
 170      =2  void SingleBusInit(void); 
 171      =2  void ReadParameter(void);       
 172      =2  void InitParameter(void);
 173      =2  void Bus0OutputData(uint8* pbyData);  
 174      =2  void MakeCH0TimerOut(uint8 byTimerOut, uint8 byTimerOutCount);
 175      =2  void Bus0RecDeal(void);
 176      =2  void Bus0SendDeal(void);
 177      =2  void Bus0Manage(void); 
 178      =2  void TimerOutDeal(void);
 179      =2  void TimerOutManager(void);
 180      =2  #endif
  79      =1  #include "Key.h"
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 36  

   1      =2  /*
   2      =2  ************************Copyright(c)************************
   3      =2  *                                  ºþÄÏÒ»ÌØµç×Ó¹É·ÝÓÐÏÞ¹«Ë¾
   4      =2  *                               All Rights Reserved
   5      =2  *                                        
   6      =2  *
   7      =2  *-----------------------ÎÄ¼þÐÅÏ¢---------------------------
   8      =2  *ÎÄ¼þÃû³Æ               :Key.h
   9      =2  *ÎÄ¼þÃèÊö               :°´¼üÇý¶¯³ÌÐòÍ·ÎÄ¼þ
  10      =2  *´´½¨ÈË                 :ÒüÔËÍ¬
  11      =2  *´´½¨ÈÕÆÚ               :2008-9-22
  12      =2  *°æ±¾ºÅ                 :V1.0
  13      =2  *×¢ÊÍ                   :²ÉÓÃ°´¼üÓëµÆÏÔÊ¾¿ØÖÆ¹²ÓÃÒ»¸öI/O¿ÚµÄ·½Ê½                                        
  14      =2  *----------------------------------------------------------
  15      =2  *ÐÞ¸ÄÈË                         :
  16      =2  *ÐÞ¸ÄÈÕÆÚ                       :
  17      =2  *°æ±¾ºÅ                 :
  18      =2  *×¢ÊÍ                   :
  19      =2  ***********************************************************
  20      =2  */
  21      =2  #ifndef KEY_H
  22      =2  #define KEY_H
  23      =2  
  24      =2  #define         KEY_DELAY                       100                                                     //ÉèÖÃ³¤°´¼üÊ±¼ä
  25      =2  //°´¼ü¶¨Òå
  26      =2  #define COPY_KEY_VAL                    0x01                                                    //Êý¾Ý¿½±´¼ü
  27      =2  #define NO_KEY_VAL                      0xff                                                            //ÎÞ¼ü°´ÏÂ
  28      =2  
  29      =2  #ifndef _IN_KEY_
  30      =2  #define _IN_KEY_
  31      =2  extern bit bPrgState;
  32      =2                                          
  33      =2  extern void SetLedState(uint8 byState);
  34      =2  extern void KeyDownDeal(uint8 byKey);
  35      =2  extern void KeyUpDeal(uint8 byKey);
  36      =2  extern void KeyAlwaysDeal(uint8 byKey);
  37      =2  extern void KeyManager(void);
  38      =2  
  39      =2  #endif
  40      =2  
  41      =2  #endif
  80      =1  #include "IAP.h"
   1      =2  /*
   2      =2  ************************Copyright(c)************************
   3      =2  *                                  ºþÄÏÒ»ÌØµç×Ó¹É·ÝÓÐÏÞ¹«Ë¾
   4      =2  *                               All Rights Reserved
   5      =2  *                                        
   6      =2  *
   7      =2  *-----------------------ÎÄ¼þÐÅÏ¢---------------------------
   8      =2  *ÎÄ¼þÃû³Æ               :IAP.h
   9      =2  *ÎÄ¼þÃèÊö               :Ð´FlashÇý¶¯Í·ÎÄ¼þ
  10      =2  *´´½¨ÈË                 :ÒüÔËÍ¬
  11      =2  *´´½¨ÈÕÆÚ               :2008-9-22
  12      =2  *°æ±¾ºÅ                 :V1.0
  13      =2  *×¢ÊÍ                   :²ÉÓÃSTCÏµÁÐCPU,¸ÃÀàÐÍCPU½«ÄÚ²¿Flash×÷
  14      =2                                       EEPromÊ¹ÓÃ,²Á³ýÐèÒÔÉÈÇøÎªµ¥Î»,ÔÚ½øÐÐ
  15      =2                                       IAP²Ù×÷¹ý³ÌÖÐ,CPU°´ÕÕÉè¶¨µÄÊ±¼ä¹ÒÆð,
  16      =2                                       ´ËÊ±CPU²»ÄÜ¹»½øÐÐÈÎºÎ¹¤×÷
  17      =2  *----------------------------------------------------------
  18      =2  *ÐÞ¸ÄÈË                         :
  19      =2  *ÐÞ¸ÄÈÕÆÚ                       :
  20      =2  *°æ±¾ºÅ                 :
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 37  

  21      =2  *×¢ÊÍ                   :
  22      =2  ***********************************************************
  23      =2  */
  24      =2  #define         IAP_READ                        0x01                                            //IAP¶ÁÃüÁî
  25      =2  #define         IAP_WRITE                       0x02                                            //IAPÐ´ÃüÁî
  26      =2  #define         IAP_ERASE                       0x03                                            //IAP²Á³ýÃüÁî
  27      =2  #define         IAP_WAIT_TIME           0x02                                            //IAPµÈ´ýÊ±¼ä 20MÒÔÏÂ
  28      =2  //#define               IAP_WAIT_TIME           0x03                                            //IAPµÈ´ýÊ±¼ä   12MÒÔÏÂ
  29      =2  
  30      =2  //#define       ISP_DATA        IAP_DATA        
  31      =2  //#define       ISP_CONTR       IAP_CONTR       
  32      =2  //#define       ISP_CMD         IAP_CMD         
  33      =2  //#define       ISP_ADDRH       IAP_ADDRH       
  34      =2  //#define       ISP_ADDRL       IAP_ADDRL       
  35      =2  //#define       ISP_TRIG        IAP_TRIG        
  36      =2  
  37      =2  
  38      =2  #ifndef _IN_IAP_
  39      =2  #define _IN_IAP_
  40      =2  void EnableIAP(uint8 byCmd);
  41      =2  void DisableIAP(void);
  42      =2  uint8 IapReadByte(uint16 uiAddr);
  43      =2  void IapWriteByte(uint16 uiAddr, uint8 byData);
  44      =2  void IapErase(uint16 uiAddr);
  45      =2  #endif
  81      =1  #include "VS10XX.h"
   1      =2  /** \file vs10xx.h
   2      =2   * Headers for interfacing with the mp3 player chip.
   3      =2   * Interfacing the New Way, not handling BSYNC -> not compatible with VS1001.
   4      =2   */
   5      =2  
   6      =2  
   7      =2  #ifndef VS10XX_H
   8      =2  #define VS10XX_H
   9      =2  
  10      =2  
  11      =2  /** VS10xx SCI Write Command byte is 0x02 */
  12      =2  #define VS_WRITE_COMMAND 0x02
  13      =2  
  14      =2  /** VS10xx SCI Read Command byte is 0x03 */
  15      =2  #define VS_READ_COMMAND 0x03
  16      =2  
  17      =2  
  18      =2  #define SPI_MODE        0x0   /**< VS10xx register */
  19      =2  #define SPI_STATUS      0x1   /**< VS10xx register */
  20      =2  #define SPI_BASS        0x2   /**< VS10xx register */
  21      =2  #define SPI_CLOCKF      0x3   /**< VS10xx register */
  22      =2  #define SPI_DECODE_TIME 0x4   /**< VS10xx register */
  23      =2  #define SPI_AUDATA      0x5   /**< VS10xx register */
  24      =2  #define SPI_WRAM        0x6   /**< VS10xx register */
  25      =2  #define SPI_WRAMADDR    0x7   /**< VS10xx register */
  26      =2  #define SPI_HDAT0       0x8   /**< VS10xx register */
  27      =2  #define SPI_HDAT1       0x9   /**< VS10xx register */
  28      =2  #define SPI_AIADDR      0xa   /**< VS10xx register */
  29      =2  #define SPI_VOL         0xb   /**< VS10xx register */
  30      =2  #define SPI_AICTRL0     0xc   /**< VS10xx register */
  31      =2  #define SPI_AICTRL1     0xd   /**< VS10xx register */
  32      =2  #define SPI_AICTRL2     0xe   /**< VS10xx register */
  33      =2  #define SPI_AICTRL3     0xf   /**< VS10xx register */
  34      =2  
  35      =2  #define SM_DIFF         0x01   /**< VS10xx register */
  36      =2  #define SM_JUMP         0x02   /**< VS10xx register */
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 38  

  37      =2  #define SM_RESET        0x04   /**< VS10xx register */
  38      =2  #define SM_OUTOFWAV     0x08   /**< VS10xx register */
  39      =2  #define SM_PDOWN        0x10   /**< VS10xx register */
  40      =2  #define SM_TESTS        0x20   /**< VS10xx register */
  41      =2  #define SM_STREAM       0x40   /**< VS10xx register */
  42      =2  #define SM_PLUSV        0x80   /**< VS10xx register */
  43      =2  #define SM_DACT         0x100   /**< VS10xx register */
  44      =2  #define SM_SDIORD       0x200   /**< VS10xx register */
  45      =2  #define SM_SDISHARE     0x400   /**< VS10xx register */
  46      =2  #define SM_SDINEW       0x800   /**< VS10xx register */
  47      =2  #define SM_ADPCM        0x1000   /**< VS10xx register */
  48      =2  #define SM_ADPCM_HP     0x2000   /**< VS10xx register */
  49      =2  
  50      =2  
  51      =2  
  52      =2  /** Put the MP3 player chip in reset */
  53      =2  #define Mp3PutInReset(){MP3_XRESET=0;}
  54      =2  
  55      =2  /** Release the MP3 player chip from reset */
  56      =2  #define Mp3ReleaseFromReset(){MP3_XRESET=1;}
  57      =2  
  58      =2  
  59      =2  /** Pull the VS10xx Control Chip Select line Low */
  60      =2  #define Mp3SelectControl(){MP3_XCS=0;}
  61      =2  
  62      =2  /** Pull the VS10xx Control Chip Select line High */
  63      =2  #define Mp3DeselectControl(){MP3_XCS=1;}
  64      =2  
  65      =2  /** Pull the VS10xx Data Chip Select line Low */
  66      =2  #define Mp3SelectData(){MP3_XDCS=0;}
  67      =2  
  68      =2  /** Pull the VS10xx Data Chip Select line High */
  69      =2  #define Mp3DeselectData(){MP3_XDCS=1;}
  70      =2  
  71      =2  
  72      =2  #ifndef _IN_VS10XX_
  73      =2  extern void Mp3WriteRegister(uint8 addressbyte,uint8 highbyte,uint8 lowbyte);
  74      =2  extern void Mp3SetVolume(uint8 leftchannel,uint8 rightchannel);
  75      =2  extern unsigned int Mp3ReadRegister (unsigned char addressbyte);
  76      =2  extern void VS1003Init(void);
  77      =2  extern void VsSineTest();
  78      =2  extern void VS1003SendDat(uint8 dat);
  79      =2  extern void VS1003FlushBuffer(void);
  80      =2  extern void Mp3SoftReset(void);
  81      =2  
  82      =2  #endif
  83      =2  
  84      =2  #endif
  82      =1  #include "SPI.h"
   1      =2  /*
   2      =2  ************************Copyright(c)************************
   3      =2  *                                  ºþÄÏÒ»ÌØµç×Ó¹É·ÝÓÐÏÞ¹«Ë¾
   4      =2  *                               All Rights Reserved
   5      =2  *                                        
   6      =2  *
   7      =2  *-----------------------ÎÄ¼þÐÅÏ¢---------------------------
   8      =2  *ÎÄ¼þÃû³Æ               :SPI.h
   9      =2  *ÎÄ¼þÃèÊö               :SPI Çý¶¯³ÌÐòÍ·ÎÄ¼þ
  10      =2  *´´½¨ÈË                 :ÒüÔËÍ¬
  11      =2  *´´½¨ÈÕÆÚ               :2008-9-22
  12      =2  *°æ±¾ºÅ                 :V1.0
  13      =2  *×¢ÊÍ                   :                                       
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 39  

  14      =2  *----------------------------------------------------------
  15      =2  *ÐÞ¸ÄÈË                         :
  16      =2  *ÐÞ¸ÄÈÕÆÚ                       :
  17      =2  *°æ±¾ºÅ                 :
  18      =2  *×¢ÊÍ                   :
  19      =2  ***********************************************************
  20      =2  */
  21      =2  /* SPI macros */
  22      =2          
  23      =2          /** switch to fast SPI Clock */
  24      =2  #define SPISetFastClock(){SPCTL=0x71;}  /* 0x73 is much slower*/
  25      =2          
  26      =2          
  27      =2          /** SPI data return register */
  28      =2  #define SPI_RESULT_BYTE SPDAT
  29      =2  
  30      =2  #ifndef _IN_SPI_
  31      =2  #define _IN_SPI_
  32      =2  
  33      =2  extern void SpiInit(void);
  34      =2  extern uint8 SPI_WriteByte(unsigned char dat);
  35      =2  extern unsigned char SPIGetChar();
  36      =2  extern void SPI8Clocks(unsigned char nClocks);
  37      =2  extern void Vs1003SpiInit(void);
  38      =2  
  39      =2  #endif
  40      =2  
  83      =1  #include "SST25VF.h"
   1      =2  /*
   2      =2  ************************Copyright(c)************************
   3      =2  *                                  ºþÄÏÒ»ÌØµç×Ó¹É·ÝÓÐÏÞ¹«Ë¾
   4      =2  *                               All Rights Reserved
   5      =2  *                                        
   6      =2  *
   7      =2  *-----------------------ÎÄ¼þÐÅÏ¢---------------------------
   8      =2  *ÎÄ¼þÃû³Æ               :MB85RS256.h
   9      =2  *ÎÄ¼þÃèÊö               :MB85RS256Ìúµç´æ´¢Æ÷Í·ÎÄ¼þ
  10      =2  *´´½¨ÈË                 :ÒüÔËÍ¬
  11      =2  *´´½¨ÈÕÆÚ               :2008-9-22
  12      =2  *°æ±¾ºÅ                 :V1.0
  13      =2  *×¢ÊÍ                   :
  14      =2  *----------------------------------------------------------
  15      =2  *ÐÞ¸ÄÈË                         :
  16      =2  *ÐÞ¸ÄÈÕÆÚ                       :
  17      =2  *°æ±¾ºÅ                 :
  18      =2  *×¢ÊÍ                   :
  19      =2  ***********************************************************
  20      =2  */
  21      =2  
  22      =2  
  23      =2  /*#define WREN    0x06
  24      =2  #define WRITE   0x02
  25      =2  #define READ    0x03
  26      =2  #define RDSR    0x05
  27      =2  #define EWSR    0X50
  28      =2  #define WRSR    0x01
  29      =2  #define WRDI    0x04
  30      =2  #define SECTOR_ERASE  0X20
  31      =2  #define BLOCK_ERASE   0X52
  32      =2  #define CHIP_ERASE    0X60
  33      =2  #define AAI_WRITE         0XAF
  34      =2  #define READ_ID1      0X90
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 40  

  35      =2  #define READ_ID2      0XAB*/
  36      =2  
  37      =2  
  38      =2  #ifndef _IN_SST25VF_
           =2 #define _IN_SST25VF_
           =2 
           =2 extern unsigned char xdata FRAM_BUFF[];
           =2 
           =2 extern void SST25VF_Init();
           =2 extern void Send_Byte(unsigned char out);
           =2 extern unsigned char Get_Byte();
           =2 extern void Poll_SO();
           =2 extern void CE_High();
           =2 extern void CE_Low();
           =2 extern void Hold_Low();
           =2 extern void Unhold();
           =2 extern void WP_Low();
           =2 extern void UnWP();
           =2 extern unsigned char Read_Status_Register();
           =2 extern void EWSR();
           =2 extern void WRSR(byte);
           =2 extern void WREN();
           =2 extern void WRDI();
           =2 extern void EBSY();
           =2 extern void DBSY();
           =2 extern unsigned char Read_ID(ID_addr);
           =2 extern unsigned long Jedec_ID_Read(); 
           =2 extern unsigned char Read(unsigned long Dst);
           =2 extern void Read_Cont(unsigned long Dst, unsigned long no_bytes,uint8 *pBuffer);
           =2 extern unsigned char HighSpeed_Read(unsigned long Dst); 
           =2 extern void HighSpeed_Read_Cont(unsigned long Dst, unsigned long no_bytes,uint8 *pBuffer);
           =2 extern void Byte_Program(unsigned long Dst, unsigned char byte);
           =2 extern void Auto_Add_IncA(unsigned long Dst, unsigned char byte1, unsigned char byte2);
           =2 extern void Auto_Add_IncB(unsigned char byte1, unsigned char byte2);
           =2 extern void Auto_Add_IncA_EBSY(unsigned long Dst, unsigned char byte1, unsigned char byte2);
           =2 extern void Auto_Add_IncB_EBSY(unsigned char byte1, unsigned char byte2);
           =2 extern void Chip_Erase();
           =2 extern void Sector_Erase(unsigned long Dst);
           =2 extern void Block_Erase_32K(unsigned long Dst);
           =2 extern void Block_Erase_64K(unsigned long Dst);
           =2 extern void Wait_Busy();
           =2 extern void Wait_Busy_AAI();
           =2 extern void WREN_Check();
           =2 extern void WREN_AAI_Check();
           =2 
           =2 extern void Verify(unsigned char byte, unsigned char cor_byte);
           =2 extern void Byte_Write(unsigned long Dst, unsigned char byte);
           =2 extern void AAI_Write(unsigned long Dst, uint8 *p,uint8 no_bytes);
           =2 extern void Byte_Write1(unsigned long Dst, unsigned char byte);
           =2 extern void AAI_Write1(unsigned long Dst, uint8 *p,uint8 no_bytes);
           =2 extern void FRAM_TEST(void);
           =2 
           =2 
           =2 
           =2 #endif
  90      =2  
  84      =1  #include "player.h"
   1      =2  
   2      =2  #ifndef PLAYER_H
   3      =2  #define PLAYER_H
   4      =2  
   5      =2  
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 41  

   6      =2  /*
   7      =2  0       0.mp3£º0x00000000
   8      =2  1       1.mp3£º0x000028c9
   9      =2  2       2.mp3£º0x00004f6e
  10      =2  3       3.mp3£º0x00007613
  11      =2  4       4.mp3£º0x00009e25
  12      =2  5       5.mp3£º0x0000c580
  13      =2  6       6.mp3£º0x0000ed92
  14      =2  7       7.mp3£º0x0001115b
  15      =2  8       8.mp3£º0x0001396d
  16      =2  9       9.mp3£º0x00015ded
  17      =2  10      ¹©Ñõ.mp3£º0x00018548
  18      =2  11  ¼Ó.mp3
  19      =2  12      Ê®.mp3£º0x0001f61c
  20      =2  13      ÎÀÉú¼ä.mp3£º0x00021e2e
  21      =2  14      ºÅ.mp3£º0x00024a89
  22      =2  15      ºô½Ð.mp3£º0x00025dd2
  23      =2  16      Íê±Ï.mp3£º0x000288c0
  24      =2  17      ´².mp3£º0x0002f994
  25      =2  18      ¿ªÊ¼.mp3£º0x00030e4b
  26      =2  19      ·¿.mp3£º0x00037f1f
  27      =2  20      °Ù.mp3£º0x00039c7a
  28      =2  21      ÊäÒº.mp3£º0x0003b131
  29      =2  22  ÇëÉÔºò.mp3
  30      =2  23  ÏµÍ³·þÎñ.mp3
  31      =2  */
  32      =2  
  33      =2  
  34      =2  #define ZERO_VOICE      0
  35      =2  #define ONE_VOICE       1
  36      =2  #define TOW_VOICE       2
  37      =2  #define THREE_VOICE     3
  38      =2  #define FOUR_VOICE      4
  39      =2  #define FIVE_VOICE      5
  40      =2  #define SIX_VOICE       6
  41      =2  #define SEVEN_VOICE     7
  42      =2  #define EIGHT_VOICE     8
  43      =2  #define NINE_VOICE      9
  44      =2  #define OX_SUPPLY_VOICE 10
  45      =2  #define ADD_VOICE       11
  46      =2  #define TEN_VOICE       12
  47      =2  #define TOILET_VOICE    13
  48      =2  #define NUM_VOICE       14
  49      =2  #define CALL_VOICE      15
  50      =2  #define END_VOICE       16
  51      =2  #define BED_VOICE       17
  52      =2  #define START_VOICE     18
  53      =2  #define ROOM_VOICE      19
  54      =2  #define HUNDRED_VOICE 20
  55      =2  #define INFUSION_VOICE 21
  56      =2  #define WAIT_VOICE   22
  57      =2  #define MAINTAIN_VOICE 23
  58      =2  
  59      =2  
  60      =2  
  61      =2  //ISD1700×´Ì¬¿ØÖÆ×Ö
  62      =2  #define         ISD_PLAYING             0x01                                                            //ÓïÒôÐ¾Æ¬ÕýÔÚ²¥Òô
  63      =2  #define         ISD_REPLAY              0x02                                                            //ÓïÒôÐ¾Æ¬ÖØ²¥Òô
  64      =2  #define         ISD_TIME_OVER   0x04                                                            //Ò»ÂÖ²¥ÒôÊ±¼äµ½ÁË
  65      =2  
  66      =2  #ifndef _IN_PLAYER_
  67      =2  extern uint32 code ulVoiceDataAddr[19][2];
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 42  

  68      =2  extern void SetPlay(uint8 byPos);
  69      =2  extern void PlayManager(void);
  70      =2  #endif
  71      =2  
  72      =2  #endif
  85      =1  
  86      =1           
  87      =1  //Éè±¸ÅäÖÃ×Ö¶¨Òå
  88      =1  typedef struct
  89      =1  {
  90      =1          uint8   byInitFlag;                                                                     //³õÊ¼»¯²ÎÊý±êÖ¾
  91      =1          
  92      =1  } STEepromCfgData, *pSTEepromCfgData;
  93      =1  
  94      =1  
  95      =1  #define         VOICE_DATA_SIZE         16
  96      =1  
  97      =1  //ÓïÒô±¨ºÅ¿ØÖÆÌå
  98      =1  typedef struct _STVoicePlay 
  99      =1  {
 100      =1      uint8  byVoiceData[VOICE_DATA_SIZE];                                        //ÐèÒª²¥·ÅµÄÓïÒôÊý¾Ý
 101      =1      uint8  byVoicePosition;                                                                     //²¥·ÅÓïÒôÎ»ÖÃ
 102      =1      uint8  byVoiceSize;                                                                         //ÐèÒª²¥·ÅµÄÓïÒô³¤¶È   
 103      =1      uint8  byVS1003State;
 104      =1          uint8  byVoiceTimes;                                                                    //ÓïÒô±¨ºÅµÄ±éÊý
 105      =1  } STVoicePlay, *pSTVoicePlay;
 106      =1  
 107      =1  //³¬Ê±¿ØÖÆ½á¹¹Ìå
 108      =1  typedef struct
 109      =1  {
 110      =1          uint8                           byTimerOutSet;                                          //Ò»´Î³¬Ê±Ê±¼äÉèÖÃ(20msµ¥Î»)
 111      =1          uint8                           byTimerOut;                                                     //Ò»´Î³¬Ê±Ê±¼ä(20msµ¥Î»)
 112      =1          uint8                           byTimerOutCount;                                        //ÔÊÐí³¬Ê±´ÎÊý 
 113      =1  } STTimerOut, *pSTTimerOut;             
 114      =1  
 115      =1  //ÐÅÏ¢Ö¸Ê¾·½½á¹¹Ìå
 116      =1  typedef struct _STIndicationData
 117      =1  {
 118      =1      uint8  byIndicationSecAddr;                                                         //Ö¸Ê¾·½ÇøµØÖ·
 119      =1      uint8  byIndicationRoomAddr;                                                        //Ö¸Ê¾·½·¿µØÖ·  
 120      =1      uint8  byIndicationBedAddr;                                                         //Ö¸Ê¾·½´²µØÖ· 
 121      =1      uint8  byCallCmd;                                                                           //Ö¸Ê¾µÄÃüÁî
 122      =1      uint8  byState;                                                                                     //¸Ãºô½ÐÐÅÏ¢µÄ×´Ì¬
 123      =1  } STIndicationData, *pSTIndicationData;
 124      =1  
 125      =1  
 126      =1  //È«¾Ö¿ØÖÆ½á¹¹Ìå
 127      =1  typedef struct
 128      =1  {
 129      =1          uint8                           byChar1;                                                        //×Ö½ÚÊý¾Ý1     
 130      =1          uint16                          uiShortType;                                            //¶ÌÕûÐÍÊý¾Ý    
 131      =1          uint8                           xdata* pbyData;                                         //Êý¾ÝÖ¸Õë
 132      =1          STBusFreq                       stBusDealFreq;                                          //µ¥×ÜÏß´¦Àí½á¹¹Ìå
 133      =1          STVoicePlay             stVoicePlay;                                            //ÓïÒô²¥·Å¿ØÖÆ  
 134      =1          STTimerOut                      stCH0TimerOut;                                          //Éè±¸µ±Ç°×´Ì¬³¬Ê±¿ØÖÆ½á¹¹Ìå
 135      =1          STEepromCfgData         stEepromCfgData;                                        //ÏµÍ³ÅäÖÃ×Ö                    
 136      =1  } STLocalControl, *pSTLocalControl;             
 137      =1  
 138      =1  //5msPCAÖÐ¶Ï¼ÆÊ±´ÎÊý£¬Fosc=18.432MHz,·ÖÆµÏµÊýÎª2 
 139      =1  #define Fosc                            18432000
 140      =1  #define Fbus                            184320
 141      =1          
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 43  

 142      =1                          
 143      =1  #define ISR_INC_COUNT           (Fosc/2/OS_TICKS_PER_SEC)
 144      =1  #define IAP_ADDR                        0x0000          //STC12C5624ÄÚµÄE2Ö»ÄÜÊÇÊý¾ÝE2
 145      =1  #define INIT_FLAG           0x5a
 146      =1  
 147      =1  
 148      =1  #ifndef _IN_MAIN_
 149      =1  extern void Send_Data(uint8 *Databuf,uint8 l);
 150      =1  extern void Send_Data_Byte(uint8 SndData);
 151      =1  extern void delay_nus(uint16 i);
 152      =1  extern void delay_nms(uint16 ms);
 153      =1  
 154      =1  
 155      =1  extern uint16   xdata uiIsrTimerCount ;                                 //ÏµÍ³Ê±ÖÓ¶¨Ê±Öµ
 156      =1  extern uint8    OS_Q_MEM_SEL    byMainCmdQ[];                                           //Ö÷Ïß³ÌÏûÏ¢¶ÓÁÐ
 157      =1  extern STLocalControl   xdata stLocalControl;                                           //È«¾Ö±äÁ¿½á¹¹Ìå
 158      =1  extern uint8    data volumn;
 159      =1  extern uint32   xdata SST25VFAddr;
 160      =1  extern int32  xdata VoiceDataLen;
 161      =1  extern uint8 xdata i;
 162      =1  
 163      =1  extern void ConsoleWrite(char code *str);
 164      =1  
 165      =1  
 166      =1  #endif
  94                  
  95          
  96          unsigned char xdata FRAM_BUFF[32];
  97          
  98          
  99          
 100          /* Function Prototypes */
 101          
 102          void SST25VF_Init();
 103          void Send_Byte(unsigned char out);
 104          unsigned char Get_Byte();
 105          void Poll_SO();
 106          void CE_High();
 107          void CE_Low();
 108          void Hold_Low();
 109          void Unhold();
 110          void WP_Low();
 111          void UnWP();
 112          unsigned char Read_Status_Register();
 113          void EWSR();
 114          void WRSR(byte);
 115          void WREN();
 116          void WRDI();
 117          void EBSY();
 118          void DBSY();
 119          unsigned char Read_ID(ID_addr);
 120          unsigned long Jedec_ID_Read(); 
 121          unsigned char Read(unsigned long Dst);
 122          void Read_Cont(unsigned long Dst, unsigned long no_bytes,uint8 *pBuffer);
 123          unsigned char HighSpeed_Read(unsigned long Dst); 
 124          void HighSpeed_Read_Cont(unsigned long Dst, unsigned long no_bytes,uint8 *pBuffer);
 125          void Byte_Program(unsigned long Dst, unsigned char byte);
 126          void Auto_Add_IncA(unsigned long Dst, unsigned char byte1, unsigned char byte2);
 127          void Auto_Add_IncB(unsigned char byte1, unsigned char byte2);
 128          void Auto_Add_IncA_EBSY(unsigned long Dst, unsigned char byte1, unsigned char byte2);
 129          void Auto_Add_IncB_EBSY(unsigned char byte1, unsigned char byte2);
 130          void Chip_Erase();
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 44  

 131          void Sector_Erase(unsigned long Dst);
 132          void Block_Erase_32K(unsigned long Dst);
 133          void Block_Erase_64K(unsigned long Dst);
 134          void Wait_Busy();
 135          void Wait_Busy_AAI();
 136          void WREN_Check();
 137          void WREN_AAI_Check();
 138          
 139          void Verify(unsigned char byte, unsigned char cor_byte);
 140          void Byte_Write(unsigned long Dst, unsigned char byte);
 141          void AAI_Write(unsigned long Dst, uint8 *p,uint8 no_bytes);
 142          
 143          
 144          
 145          
 146          //unsigned char idata upper_128[128];           /* global array to store read data */
 147                                                                                          /* to upper RAM area from 80H - FFH */
 148          
 149          /************************************************************************/
 150          /* PROCEDURE: init                                                                                                              */
 151          /*                                                                                                                                              */
 152          /* This procedure initializes the SCK to low. Must be called prior to   */
 153          /* setting up mode 0.                                                                                                   */
 154          /*                                                                                                                                              */
 155          /* Input:                                                                                                                               */
 156          /*              None                                                                                                                    */
 157          /*                                                                                                                                              */
 158          /* Output:                                                                                                                              */
 159          /*              SCK                                                                                                                             */
 160          /************************************************************************/
 161          void SST25VF_Init()
 162          {
 163   1      //      SCLK = 0;       /* set clock to low initial state */
 164   1              
 165   1      //      Send_Data_Byte(Read_Status_Register());
 166   1      
 167   1              EWSR();
 168   1              delay_nms(1);
 169   1              WRSR(0x00);             //²»Ð´±£»¤
 170   1              delay_nms(1);
 171   1      
 172   1      //      Send_Data_Byte(Read_Status_Register()); 
 173   1      }
 174          
 175          /************************************************************************/
 176          /* PROCEDURE: Send_Byte                                                                                                 */
 177          /*                                                                                                                                              */
 178          /* This procedure outputs a byte shifting out 1-bit per clock rising    */
 179          /* edge on the the SI pin(LSB 1st).                                                                             */
 180          /*                                                                                                                                              */
 181          /* Input:                                                                                                                               */
 182          /*              out                                                                                                                             */
 183          /*                                                                                                                                              */
 184          /* Output:                                                                                                                              */
 185          /*              SI                                                                                                                              */
 186          /************************************************************************/
 187          void Send_Byte(unsigned char out)
 188          {
 189   1              
 190   1              //unsigned char i = 0;
 191   1              //for (i = 0; i < 8; i++)
 192   1              //{
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 45  

 193   1              //      
 194   1              //      if ((out & 0x80) == 0x80)       /* check if MSB is high */
 195   1              //              MOSI = 1;
 196   1              //      else
 197   1              //              MOSI = 0;                                       /* if not, set to low */
 198   1              //      SCLK = 1;                                       /* toggle clock high */
 199   1              //      out = (out << 1);                       /* shift 1 place for next bit */
 200   1              //      SCLK = 0;                                       /* toggle clock low */
 201   1              //}
 202   1              SPI_WriteByte(out);
 203   1      }
 204          
 205          /************************************************************************/
 206          /* PROCEDURE: Get_Byte                                                                                                  */
 207          /*                                                                                                                                              */
 208          /* This procedure inputs a byte shifting in 1-bit per clock falling             */
 209          /* edge on the SO pin(LSB 1st).                                                                                 */
 210          /*                                                                                                                                              */
 211          /* Input:                                                                                                                               */
 212          /*              SO                                                                                                                              */
 213          /*                                                                                                                                              */
 214          /* Output:                                                                                                                              */
 215          /*              None                                                                                                                    */
 216          /************************************************************************/
 217          unsigned char Get_Byte()
 218          {
 219   1              //unsigned char i = 0, in = 0, temp = 0;
 220   1              //for (i = 0; i < 8; i++)
 221   1              //{
 222   1              //      in = (in << 1);         /* shift 1 place to the left or shift in 0 */
 223   1              //      temp = MISO;                    /* save input */
 224   1              //      SCLK = 1;                       /* toggle clock high */
 225   1              //      if (temp == 1)                  /* check to see if bit is high */
 226   1              //              in = in | 0x01;         /* if high, make bit high */
 227   1      
 228   1              //      SCLK = 0;                       /* toggle clock low */
 229   1      
 230   1              //}
 231   1              //return in;
 232   1      
 233   1              uint8 xdata in;
 234   1              in=SPI_WriteByte(0x00); //ÊäÈë8¸öÊ±ÖÓ
 235   1              return in;
 236   1      }
 237          
 238          /************************************************************************/
 239          /* PROCEDURE: Poll_SO                                                                                                   */
 240          /*                                                                                                                                              */
 241          /* This procedure polls for the SO line during AAI programming                  */
 242          /* waiting for SO to transition to 1 which will indicate AAI programming*/
 243          /* is completed                                                                                                                 */
 244          /*                                                                                                                                              */
 245          /* Input:                                                                                                                               */
 246          /*              SO                                                                                                                              */
 247          /*                                                                                                                                              */
 248          /* Output:                                                                                                                              */
 249          /*              None                                                                                                                    */
 250          /************************************************************************/
 251          void Poll_SO()
 252          {
 253   1              unsigned char xdata temp = 0;
 254   1              CE_Low();
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 46  

 255   1              while (temp == 0x00)    /* waste time until not busy */
 256   1                      temp = MISO;
 257   1              CE_High();
 258   1      }
 259          
 260          /************************************************************************/
 261          /* PROCEDURE: CE_High                                                                                                   */
 262          /*                                                                                                                                              */
 263          /* This procedure set CE = High.                                                                                */
 264          /*                                                                                                                                              */
 265          /* Input:                                                                                                                               */
 266          /*              None                                                                                                                    */
 267          /*                                                                                                                                              */
 268          /* Output:                                                                                                                              */
 269          /*              CE                                                                                                                              */
 270          /*                                                                                                                                              */
 271          /************************************************************************/
 272          void CE_High() 
 273          {
 274   1              SST25VF_CS = 1;                         /* set CE high */
 275   1      }
 276          
 277          /************************************************************************/
 278          /* PROCEDURE: CE_Low                                                                                                    */
 279          /*                                                                                                                                              */
 280          /* This procedure drives the CE of the device to low.                                   */
 281          /*                                                                                                                                              */
 282          /* Input:                                                                                                                               */
 283          /*              None                                                                                                                    */
 284          /*                                                                                                                                              */
 285          /* Output:                                                                                                                              */
 286          /*              CE                                                                                                                              */
 287          /*                                                                                                                                              */
 288          /************************************************************************/
 289          void CE_Low() 
 290          {       
 291   1              SST25VF_CS = 0;                         /* clear CE low */
 292   1      }
 293          
 294          /************************************************************************/
 295          /* PROCEDURE: Hold()                                                                                                    */
 296          /*                                                                                                                                              */
 297          /* This procedure clears the Hold pin to low.                                                   */
 298          /*                                                                                                                                              */
 299          /* Input:                                                                                                                               */
 300          /*              None                                                                                                                    */
 301          /*                                                                                                                                              */
 302          /* Output:                                                                                                                              */
 303          /*              Hold                                                                                                                    */
 304          /************************************************************************/
 305          void Hold_Low()
 306          {
 307   1      
 308   1      //      Hold = 0;                       /* clear Hold pin */
 309   1              
 310   1      }
 311          
 312          /************************************************************************/
 313          /* PROCEDURE: Unhold()                                                                                                  */
 314          /*                                                                                                                                              */
 315          /* This procedure sets the Hold pin to high.                                                    */
 316          /*                                                                                                                                              */
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 47  

 317          /* Input:                                                                                                                               */
 318          /*              None                                                                                                                    */
 319          /*                                                                                                                                              */
 320          /* Output:                                                                                                                              */
 321          /*              Hold                                                                                                                    */
 322          /************************************************************************/
 323          void Unhold()
 324          {
 325   1      
 326   1      //      Hold = 1;                       /* set Hold pin */
 327   1              
 328   1      }
 329          
 330          /************************************************************************/
 331          /* PROCEDURE: WP()                                                                                                              */
 332          /*                                                                                                                                              */
 333          /* This procedure clears the WP pin to low.                                                             */
 334          /*                                                                                                                                              */
 335          /* Input:                                                                                                                               */
 336          /*              None                                                                                                                    */
 337          /*                                                                                                                                              */
 338          /* Output:                                                                                                                              */
 339          /*              WP                                                                                                                              */
 340          /************************************************************************/
 341          void WP_Low()
 342          {
 343   1      
 344   1      //      WP = 0;                         /* clear WP pin */
 345   1      
 346   1      }
 347          
 348          /************************************************************************/
 349          /* PROCEDURE: UnWP()                                                                                                    */
 350          /*                                                                                                                                              */
 351          /* This procedure sets the WP pin to high.                                                              */
 352          /*                                                                                                                                              */
 353          /* Input:                                                                                                                               */
 354          /*              None                                                                                                                    */
 355          /*                                                                                                                                              */
 356          /* Output:                                                                                                                              */
 357          /*              WP                                                                                                                              */
 358          /************************************************************************/
 359          void UnWP()
 360          {
 361   1      
 362   1      //      WP = 1;                         /* set WP pin */
 363   1      
 364   1      }
 365          
 366          /************************************************************************/
 367          /* PROCEDURE: Read_Status_Register                                                                              */
 368          /*                                                                                                                                              */
 369          /* This procedure read the status register and returns the byte.                */
 370          /*                                                                                                                                              */
 371          /* Input:                                                                                                                               */
 372          /*              None                                                                                                                    */
 373          /*                                                                                                                                              */
 374          /* Returns:                                                                                                                             */
 375          /*              byte                                                                                                                    */
 376          /************************************************************************/
 377          unsigned char Read_Status_Register()
 378          {
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 48  

 379   1              unsigned char xdata byte = 0;
 380   1              CE_Low();                               /* enable device */
 381   1              Send_Byte(0x05);                /* send RDSR command */
 382   1              byte = Get_Byte();              /* receive byte */
 383   1              CE_High();                              /* disable device */
 384   1              return byte;
 385   1      }
 386          
 387          /************************************************************************/
 388          /* PROCEDURE: EWSR                                                                                                              */
 389          /*                                                                                                                                              */
 390          /* This procedure Enables Write Status Register.                                                */
 391          /*                                                                                                                                              */
 392          /* Input:                                                                                                                               */
 393          /*              None                                                                                                                    */
 394          /*                                                                                                                                              */
 395          /* Returns:                                                                                                                             */
 396          /*              Nothing                                                                                                                 */
 397          /************************************************************************/
 398          void EWSR()
 399          {
 400   1              CE_Low();                               /* enable device */
 401   1              Send_Byte(0x50);                /* enable writing to the status register */
 402   1              CE_High();                              /* disable device */
 403   1      }
 404          
 405          /************************************************************************/
 406          /* PROCEDURE: WRSR                                                                                                              */
 407          /*                                                                                                                                              */
 408          /* This procedure writes a byte to the Status Register.                                 */
 409          /*                                                                                                                                              */
 410          /* Input:                                                                                                                               */
 411          /*              byte                                                                                                                    */
 412          /*                                                                                                                                              */
 413          /* Returns:                                                                                                                             */
 414          /*              Nothing                                                                                                                 */
 415          /************************************************************************/
 416          void WRSR(byte)
 417          {
 418   1              CE_Low();                               /* enable device */
 419   1              Send_Byte(0x01);                /* select write to status register */
 420   1              Send_Byte(byte);                /* data that will change the status of BPx 
 421   1                                                                 or BPL (only bits 2,3,4,5,7 can be written) */
 422   1              CE_High();                              /* disable the device */
 423   1      }
 424          
 425          /************************************************************************/
 426          /* PROCEDURE: WREN                                                                                                              */
 427          /*                                                                                                                                              */
 428          /* This procedure enables the Write Enable Latch.  It can also be used  */
 429          /* to Enables Write Status Register.                                                                    */
 430          /*                                                                                                                                              */
 431          /* Input:                                                                                                                               */
 432          /*              None                                                                                                                    */
 433          /*                                                                                                                                              */
 434          /* Returns:                                                                                                                             */
 435          /*              Nothing                                                                                                                 */
 436          /************************************************************************/
 437          void WREN()
 438          {
 439   1              CE_Low();                               /* enable device */
 440   1              Send_Byte(0x06);                /* send WREN command */
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 49  

 441   1              CE_High();                              /* disable device */
 442   1              Wait_Busy();
 443   1      //      WREN_Check();
 444   1      }
 445          
 446          /************************************************************************/
 447          /* PROCEDURE: WRDI                                                                                                              */
 448          /*                                                                                                                                              */
 449          /* This procedure disables the Write Enable Latch.                                              */
 450          /*                                                                                                                                              */
 451          /* Input:                                                                                                                               */
 452          /*              None                                                                                                                    */
 453          /*                                                                                                                                              */
 454          /* Returns:                                                                                                                             */
 455          /*              Nothing                                                                                                                 */
 456          /************************************************************************/
 457          void WRDI()
 458          {
 459   1              CE_Low();                               /* enable device */
 460   1              Send_Byte(0x04);                /* send WRDI command */
 461   1              CE_High();                              /* disable device */
 462   1      }
 463          
 464          /************************************************************************/
 465          /* PROCEDURE: EBSY                                                                                                              */
 466          /*                                                                                                                                              */
 467          /* This procedure enable SO to output RY/BY# status during AAI                  */
 468          /* programming.                                                                                                                 */
 469          /*                                                                                                                                              */
 470          /* Input:                                                                                                                               */
 471          /*              None                                                                                                                    */
 472          /*                                                                                                                                              */
 473          /* Returns:                                                                                                                             */
 474          /*              Nothing                                                                                                                 */
 475          /************************************************************************/
 476          void EBSY()
 477          {
 478   1              CE_Low();                               /* enable device */
 479   1              Send_Byte(0x70);                /* send EBSY command */
 480   1              CE_High();                              /* disable device */
 481   1      }
 482          
 483          /************************************************************************/
 484          /* PROCEDURE: DBSY                                                                                                              */
 485          /*                                                                                                                                              */
 486          /* This procedure disable SO as output RY/BY# status signal during AAI  */
 487          /* programming.                                                                                                                 */
 488          /*                                                                                                                                              */
 489          /* Input:                                                                                                                               */
 490          /*              None                                                                                                                    */
 491          /*                                                                                                                                              */
 492          /* Returns:                                                                                                                             */
 493          /*              Nothing                                                                                                                 */
 494          /************************************************************************/
 495          void DBSY()
 496          {
 497   1              CE_Low();                               /* enable device */
 498   1              Send_Byte(0x80);                /* send DBSY command */
 499   1              CE_High();                              /* disable device */
 500   1      }       
 501          
 502          /************************************************************************/
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 50  

 503          /* PROCEDURE: Read_ID                                                                                                   */
 504          /*                                                                                                                                              */
 505          /* This procedure Reads the manufacturer's ID and device ID.  It will   */
 506          /* use 90h or ABh as the command to read the ID (90h in this sample).   */
 507          /* It is up to the user to give the last byte ID_addr to determine      */
 508          /* whether the device outputs manufacturer's ID first, or device ID     */
 509          /* first.  Please see the product datasheet for details.  Returns ID in */
 510          /* variable byte.                                                                                                               */
 511          /*                                                                                                                                              */
 512          /* Input:                                                                                                                               */
 513          /*              ID_addr                                                                                                                 */
 514          /*                                                                                                                                              */
 515          /* Returns:                                                                                                                             */
 516          /*              byte:   ID1(Manufacture's ID = BFh or Device ID = 8Dh)                  */
 517          /*                                                                                                                                              */
 518          /************************************************************************/
 519          unsigned char Read_ID(ID_addr)
 520          {
 521   1              unsigned char xdata byte;
 522   1              CE_Low();                               /* enable device */
 523   1              Send_Byte(0x90);                /* send read ID command (90h or ABh) */
 524   1          Send_Byte(0x00);            /* send address */
 525   1              Send_Byte(0x00);                /* send address */
 526   1              Send_Byte(ID_addr);             /* send address - either 00H or 01H */
 527   1              byte = Get_Byte();              /* receive byte */
 528   1              CE_High();                              /* disable device */
 529   1              return byte;
 530   1      }
 531          
 532          /************************************************************************/
 533          /* PROCEDURE: Jedec_ID_Read                                                                                             */
 534          /*                                                                                                                                              */
 535          /* This procedure Reads the manufacturer's ID (BFh), memory type (25h)  */
 536          /* and device ID (8Dh).  It will use 9Fh as the JEDEC ID command.       */
 537          /* Please see the product datasheet for details.                                                */
 538          /*                                                                                                                                              */
 539          /* Input:                                                                                                                               */
 540          /*              None                                                                                                                    */
 541          /*                                                                                                                                              */
 542          /* Returns:                                                                                                                             */
 543          /*              IDs_Read:ID1(Manufacture's ID = BFh, Memory Type (25h),                 */
 544          /*               and Device ID (8Dh)                                                                                    */
 545          /*                                                                                                                                              */
 546          /************************************************************************/
 547          unsigned long Jedec_ID_Read() 
 548          {
 549   1              unsigned long xdata temp;
 550   1              
 551   1              temp = 0;
 552   1      
 553   1              CE_Low();                                /* enable device */
 554   1              Send_Byte(0x9F);                 /* send JEDEC ID command (9Fh) */
 555   1          temp = (temp | Get_Byte()) << 8;     /* receive byte */
 556   1              temp = (temp | Get_Byte()) << 8;        
 557   1              temp = (temp | Get_Byte());      /* temp value = 0xBF258D */
 558   1              CE_High();                              /* disable device */
 559   1      
 560   1              return temp;
 561   1      }
 562          
 563          /************************************************************************/
 564          /* PROCEDURE:   Read                                                                                                    */
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 51  

 565          /*                                                                                                                                              */              
 566          /* This procedure reads one address of the device.  It will return the  */
 567          /* byte read in variable byte.                                                                                  */
 568          /*                                                                                                                                              */
 569          /*                                                                                                                                              */
 570          /*                                                                                                                                              */
 571          /* Input:                                                                                                                               */
 572          /*              Dst:    Destination Address 000000H - 07FFFFH                                   */
 573          /*          SST25VF020:Dst:     Destination Address 000000H - 03FFFFH                   */           
 574          /*                                                                                                                                      */
 575          /*                                                                                                                                              */
 576          /* Returns:                                                                                                                             */
 577          /*              byte                                                                                                                    */
 578          /*                                                                                                                                              */
 579          /************************************************************************/
 580          unsigned char Read(unsigned long Dst) 
 581          {
 582   1              unsigned char xdata byte = 0;   
 583   1      
 584   1              CE_Low();                               /* enable device */
 585   1              Send_Byte(0x03);                /* read command */
 586   1              Send_Byte(((Dst & 0xFFFFFF) >> 16));    /* send 3 address bytes */
 587   1              Send_Byte(((Dst & 0xFFFF) >> 8));
 588   1              Send_Byte(Dst & 0xFF);
 589   1              byte = Get_Byte();
 590   1              CE_High();                              /* disable device */
 591   1              return byte;                    /* return one byte read */
 592   1      }
 593          
 594          /************************************************************************/
 595          /* PROCEDURE:   Read_Cont                                                                                               */
 596          /*                                                                                                                                              */              
 597          /* This procedure reads multiple addresses of the device and stores             */
 598          /* data into 128 byte buffer. Maximum byte that can be read is 128 bytes*/
 599          /*                                                                                                                                              */
 600          /* Input:                                                                                                                               */
 601          /*              Dst:            Destination Address 000000H - 07FFFFH                           */
 602          /*          SST25VF020:Dst:     Destination Address 000000H - 03FFFFH                   */
 603          /*      no_bytes        Number of bytes to read (max = 128)                                     */
 604          /*                                                                                                                                              */
 605          /* Returns:                                                                                                                             */
 606          /*              Nothing                                                                                                                 */
 607          /*                                                                                                                                              */
 608          /************************************************************************/
 609          void Read_Cont(unsigned long Dst, unsigned long no_bytes,uint8 *pBuffer)
 610          {
 611   1              unsigned long xdata i = 0;
 612   1              CE_Low();                                       /* enable device */
 613   1              Send_Byte(0x03);                        /* read command */
 614   1              Send_Byte(((Dst & 0xFFFFFF) >> 16));    /* send 3 address bytes */
 615   1              Send_Byte(((Dst & 0xFFFF) >> 8));
 616   1              Send_Byte(Dst & 0xFF);
 617   1              for (i = 0; i < no_bytes; i++)          /* read until no_bytes is reached */
 618   1              {
 619   2                      pBuffer[i] = Get_Byte();        /* receive byte and store at address 80H - FFH */
 620   2              }
 621   1              CE_High();                                      /* disable device */
 622   1      
 623   1      }
 624          
 625          /************************************************************************/
 626          /* PROCEDURE:   HighSpeed_Read                                                                                  */
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 52  

 627          /*                                                                                                                                              */              
 628          /* This procedure reads one address of the device.  It will return the  */
 629          /* byte read in variable byte.                                                                                  */
 630          /*                                                                                                                                              */
 631          /*                                                                                                                                              */
 632          /*                                                                                                                                              */
 633          /* Input:                                                                                                                               */
 634          /*              Dst:    Destination Address 000000H - 07FFFFH                                   */
 635          /*          SST25VF020:Dst:     Destination Address 000000H - 03FFFFH                   */
 636          /*                                                                                                                                      */
 637          /*                                                                                                                                              */
 638          /* Returns:                                                                                                                             */
 639          /*              byte                                                                                                                    */
 640          /*                                                                                                                                              */
 641          /************************************************************************/
 642          unsigned char HighSpeed_Read(unsigned long Dst) 
 643          {
 644   1              unsigned char xdata byte = 0;   
 645   1      
 646   1              CE_Low();                               /* enable device */
 647   1              Send_Byte(0x0B);                /* read command */
 648   1              Send_Byte(((Dst & 0xFFFFFF) >> 16));    /* send 3 address bytes */
 649   1              Send_Byte(((Dst & 0xFFFF) >> 8));
 650   1              Send_Byte(Dst & 0xFF);
 651   1              Send_Byte(0xFF);                /*dummy byte*/
 652   1              byte = Get_Byte();
 653   1              CE_High();                              /* disable device */
 654   1              return byte;                    /* return one byte read */
 655   1      }
 656          
 657          /************************************************************************/
 658          /* PROCEDURE:   HighSpeed_Read_Cont                                                                             */
 659          /*                                                                                                                                              */              
 660          /* This procedure reads multiple addresses of the device and stores             */
 661          /* data into 128 byte buffer. Maximum byte that can be read is 128 bytes*/
 662          /*                                                                                                                                              */
 663          /* Input:                                                                                                                               */
 664          /*              Dst:            Destination Address 000000H - 07FFFFH                           */
 665          /*      no_bytes        Number of bytes to read (max = 128)                                     */
 666          /*                                                                                                                                              */
 667          /* Returns:                                                                                                                             */
 668          /*              Nothing                                                                                                                 */
 669          /*                                                                                                                                              */
 670          /************************************************************************/
 671          void HighSpeed_Read_Cont(unsigned long Dst, unsigned long no_bytes,uint8 *pBuffer)
 672          {
 673   1              unsigned long xdata i = 0;
 674   1              CE_Low();                                       /* enable device */
 675   1              Send_Byte(0x0B);                        /* read command */
 676   1              Send_Byte(((Dst & 0xFFFFFF) >> 16));    /* send 3 address bytes */
 677   1              Send_Byte(((Dst & 0xFFFF) >> 8));
 678   1              Send_Byte(Dst & 0xFF);
 679   1              Send_Byte(0xFF);                        /*dummy byte*/
 680   1              for (i = 0; i < no_bytes; i++)          /* read until no_bytes is reached */
 681   1              {
 682   2                      pBuffer[i] = Get_Byte();        /* receive byte and store at address 80H - FFH */
 683   2              }
 684   1              CE_High();                                      /* disable device */
 685   1      }
 686          
 687          /************************************************************************/
 688          /* PROCEDURE:   Byte_Program                                                                                    */
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 53  

 689          /*                                                                                                                                              */
 690          /* This procedure programs one address of the device.                                   */
 691          /* Assumption:  Address being programmed is already erased and is NOT   */
 692          /*                              block protected.                                                                                */
 693          /*                                                                                                                                              */
 694          /*                                                                                                                                              */
 695          /*                                                                                                                                              */
 696          /* Input:                                                                                                                               */
 697          /*              Dst:            Destination Address 000000H - 07FFFFH                           */
 698          /*              byte:           byte to be programmed                                                           */
 699          /*                                                                                                                                      */
 700          /*                                                                                                                                              */
 701          /* Returns:                                                                                                                             */
 702          /*              Nothing                                                                                                                 */
 703          /*                                                                                                                                              */
 704          /************************************************************************/
 705          void Byte_Program(unsigned long Dst, unsigned char byte)
 706          {
 707   1              CE_Low();                                       /* enable device */
 708   1              Send_Byte(0x02);                        /* send Byte Program command */
 709   1              Send_Byte(((Dst & 0xFFFFFF) >> 16));    /* send 3 address bytes */
 710   1              Send_Byte(((Dst & 0xFFFF) >> 8));
 711   1              Send_Byte(Dst & 0xFF);
 712   1              Send_Byte(byte);                        /* send byte to be programmed */
 713   1              CE_High();                                      /* disable device */
 714   1      }
 715          
 716          /************************************************************************/
 717          /* PROCEDURE:   Auto_Add_IncA                                                                                   */
 718          /*                                                                                                                                              */
 719          /* This procedure programs consecutive addresses of 2 bytes of data into*/
 720          /* the device:  1st data byte will be programmed into the initial               */
 721          /* address [A23-A1] and with A0 = 0.  The 2nd data byte will be be              */
 722          /* programmed into initial address [A23-A1] and with A0  = 1.  This             */
 723          /* is used to to start the AAI process.  It should be followed by               */
 724          /* Auto_Add_IncB.                                                                                                               */
 725          /* Assumption:  Address being programmed is already erased and is NOT   */
 726          /*                              block protected.                                                                                */
 727          /*                                                                                                                                              */
 728          /*                                                                                                                                              */
 729          /* Note: Only RDSR command can be executed once in AAI mode with SO     */
 730          /*       disable to output RY/BY# status.  Use WRDI to exit AAI mode            */
 731          /*       unless AAI is programming the last address or last address of          */
 732          /*       unprotected block, which automatically exits AAI mode.                         */
 733          /*                                                                                                                                              */
 734          /* Input:                                                                                                                               */
 735          /*              Dst:            Destination Address 000000H - 07FFFFH                           */
 736          /*          SST25VF020:Dst:     Destination Address 000000H - 03FFFFH                   */
 737          /*              byte1:          1st byte to be programmed                                                       */
 738          /*      byte1:          2nd byte to be programmed                                                       */
 739          /*                                                                                                                                              */
 740          /* Returns:                                                                                                                             */
 741          /*              Nothing                                                                                                                 */
 742          /*                                                                                                                                              */
 743          /************************************************************************/
 744          void Auto_Add_IncA(unsigned long Dst, unsigned char byte1, unsigned char byte2)
 745          {
 746   1              CE_Low();                                       /* enable device */
 747   1              Send_Byte(0xAD);                        /* send AAI command */
 748   1              Send_Byte(((Dst & 0xFFFFFF) >> 16));    /* send 3 address bytes */
 749   1              Send_Byte(((Dst & 0xFFFF) >> 8));
 750   1              Send_Byte(Dst & 0xFF);
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 54  

 751   1              Send_Byte(byte1);                       /* send 1st byte to be programmed */    
 752   1              Send_Byte(byte2);                       /* send 2nd byte to be programmed */
 753   1              CE_High();                                      /* disable device */
 754   1      }
 755          
 756          /************************************************************************/
 757          /* PROCEDURE:   Auto_Add_IncB                                                                                   */
 758          /*                                                                                                                                              */
 759          /* This procedure programs consecutive addresses of 2 bytes of data into*/
 760          /* the device:  1st data byte will be programmed into the initial               */
 761          /* address [A23-A1] and with A0 = 0.  The 2nd data byte will be be              */
 762          /* programmed into initial address [A23-A1] and with A0  = 1.    This   */
 763          /* is used after Auto_Address_IncA.                                                                             */
 764          /* Assumption:  Address being programmed is already erased and is NOT   */
 765          /*                              block protected.                                                                                */
 766          /*                                                                                                                                              */
 767          /* Note: Only WRDI and AAI command can be executed once in AAI mode     */
 768          /*       with SO enabled as RY/BY# status.  When the device is busy             */
 769          /*       asserting CE# will output the status of RY/BY# on SO.  Use WRDI        */
 770          /*       to exit AAI mode unless AAI is programming the last address or         */
 771          /*       last address of unprotected block, which automatically exits           */
 772          /*       AAI mode.                                                                                                                      */
 773          /*                                                                                                                                              */
 774          /* Input:                                                                                                                               */
 775          /*                                                                                                                                              */
 776          /*              byte1:          1st byte to be programmed                                                       */
 777          /*              byte2:          2nd byte to be programmed                                                       */
 778          /*                                                                                                                                      */
 779          /*                                                                                                                                              */
 780          /* Returns:                                                                                                                             */
 781          /*              Nothing                                                                                                                 */
 782          /*                                                                                                                                              */
 783          /************************************************************************/
 784          void Auto_Add_IncB(unsigned char byte1, unsigned char byte2)
 785          {
 786   1              CE_Low();                                       /* enable device */
 787   1              Send_Byte(0xAD);                        /* send AAI command */
 788   1              Send_Byte(byte1);                       /* send 1st byte to be programmed */
 789   1              Send_Byte(byte2);                       /* send 2nd byte to be programmed */
 790   1              CE_High();                                      /* disable device */
 791   1      }       
 792          
 793          /************************************************************************/
 794          /* PROCEDURE:   Auto_Add_IncA_EBSY                                                                              */
 795          /*                                                                                                                                              */
 796          /* This procedure is the same as procedure Auto_Add_IncA except that it */
 797          /* uses EBSY and Poll_SO functions to check for RY/BY. It programs              */
 798          /* consecutive addresses of the device.  The 1st data byte will be              */
 799          /* programmed into the initial address [A23-A1] and with A0 = 0.  The   */
 800          /* 2nd data byte will be programmed into initial address [A23-A1] and   */
 801          /* with A0  = 1.  This is used to to start the AAI process.  It should  */
 802          /* be followed by Auto_Add_IncB_EBSY.                                                                   */
 803          /* Assumption:  Address being programmed is already erased and is NOT   */
 804          /*                              block protected.                                                                                */
 805          /*                                                                                                                                              */
 806          /*                                                                                                                                              */
 807          /* Note: Only WRDI and AAI command can be executed once in AAI mode     */
 808          /*       with SO enabled as RY/BY# status.  When the device is busy                     */
 809          /*       asserting CE# will output the status of RY/BY# on SO.  Use WRDI        */
 810          /*       to exit AAI mode unless AAI is programming the last address or         */
 811          /*       last address of unprotected block, which automatically exits           */
 812          /*       AAI mode.                                                                                                                      */
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 55  

 813          /*                                                                                                                                              */
 814          /* Input:                                                                                                                               */
 815          /*              Dst:            Destination Address 000000H - 07FFFFH                           */
 816          /*              byte1:          1st byte to be programmed                                                       */
 817          /*      byte1:          2nd byte to be programmed                                                       */
 818          /*                                                                                                                                              */
 819          /* Returns:                                                                                                                             */
 820          /*              Nothing                                                                                                                 */
 821          /*                                                                                                                                              */
 822          /************************************************************************/
 823          void Auto_Add_IncA_EBSY(unsigned long Dst, unsigned char byte1, unsigned char byte2)
 824          {
 825   1              EBSY();                                 /* enable RY/BY# status for SO in AAI */        
 826   1      
 827   1              CE_Low();                               /* enable device */
 828   1              Send_Byte(0xAD);                        /* send AAI command */
 829   1              Send_Byte(((Dst & 0xFFFFFF) >> 16));    /* send 3 address bytes */
 830   1              Send_Byte(((Dst & 0xFFFF) >> 8));
 831   1              Send_Byte(Dst & 0xFF);
 832   1              Send_Byte(byte1);                       /* send 1st byte to be programmed */    
 833   1              Send_Byte(byte2);                       /* send 2nd byte to be programmed */
 834   1              CE_High();                              /* disable device */
 835   1              
 836   1              Poll_SO();                              /* polls RY/BY# using SO line */
 837   1      
 838   1      }
 839          
 840          /************************************************************************/
 841          /* PROCEDURE:   Auto_Add_IncB_EBSY                                                                              */
 842          /*                                                                                                                                              */
 843          /* This procedure is the same as Auto_Add_IncB excpet that it uses              */
 844          /* Poll_SO to poll for RY/BY#.  It demonstrate on how to use DBSY after */
 845          /* AAI programmming is completed.  It programs consecutive addresses of */
 846          /* the device.  The 1st data byte will be programmed into the initial   */
 847          /* address [A23-A1] and with A0 = 0.  The 2nd data byte will be                 */
 848          /* programmed into initial address [A23-A1] and with A0  = 1.  This is  */
 849          /* used after Auto_Address_IncA.                                                                                */
 850          /* Assumption:  Address being programmed is already erased and is NOT   */
 851          /*                              block protected.                                                                                */
 852          /*                                                                                                                                              */
 853          /* Note: Only WRDI and AAI command can be executed once in AAI mode     */
 854          /*       with SO enabled as RY/BY# status.  When the device is busy             */
 855          /*       asserting CE# will output the status of RY/BY# on SO.  Use WRDI        */
 856          /*       to exit AAI mode unless AAI is programming the last address or         */
 857          /*       last address of unprotected block, which automatically exits           */
 858          /*       AAI mode.                                                                                                                      */
 859          /*                                                                                                                                              */
 860          /* Input:                                                                                                                               */
 861          /*                                                                                                                                              */
 862          /*              byte1:          1st byte to be programmed                                                       */
 863          /*              byte2:          2nd byte to be programmed                                                       */
 864          /*                                                                                                                                      */
 865          /*                                                                                                                                              */
 866          /* Returns:                                                                                                                             */
 867          /*              Nothing                                                                                                                 */
 868          /*                                                                                                                                              */
 869          /************************************************************************/
 870          void Auto_Add_IncB_EBSY(unsigned char byte1, unsigned char byte2)
 871          {
 872   1              CE_Low();                                       /* enable device */
 873   1              Send_Byte(0xAD);                        /* send AAI command */
 874   1              Send_Byte(byte1);                       /* send 1st byte to be programmed */
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 56  

 875   1              Send_Byte(byte2);                       /* send 2nd byte to be programmed */
 876   1              CE_High();                                      /* disable device */
 877   1      
 878   1              Poll_SO();                                      /* polls RY/BY# using SO line */
 879   1              
 880   1              WRDI();                                         /* Exit AAI before executing DBSY */
 881   1              DBSY();                                         /* disable SO as RY/BY# output if in AAI */
 882   1      }       
 883          
 884          /************************************************************************/
 885          /* PROCEDURE: Chip_Erase                                                                                                */
 886          /*                                                                                                                                              */
 887          /* This procedure erases the entire Chip.                                                               */
 888          /*                                                                                                                                              */
 889          /* Input:                                                                                                                               */
 890          /*              None                                                                                                                    */
 891          /*                                                                                                                                              */
 892          /* Returns:                                                                                                                             */
 893          /*              Nothing                                                                                                                 */
 894          /************************************************************************/
 895          void Chip_Erase()
 896          {                                               
 897   1              CE_Low();                                       /* enable device */
 898   1              Send_Byte(0x60);                        /* send Chip Erase command (60h or C7h) */
 899   1              CE_High();                                      /* disable device */
 900   1      }
 901          
 902          /************************************************************************/
 903          /* PROCEDURE: Sector_Erase                                                                                              */
 904          /*                                                                                                                                              */
 905          /* This procedure Sector Erases the Chip.                                                               */
 906          /*                                                                                                                                              */
 907          /* Input:                                                                                                                               */
 908          /*              Dst:            Destination Address 000000H - 07FFFFH                           */
 909          /*                                                                                                                                              */
 910          /* Returns:                                                                                                                             */
 911          /*              Nothing                                                                                                                 */
 912          /************************************************************************/
 913          void Sector_Erase(unsigned long Dst)
 914          {
 915   1      
 916   1      
 917   1              CE_Low();                                       /* enable device */
 918   1              Send_Byte(0x20);                        /* send Sector Erase command */
 919   1              Send_Byte(((Dst & 0xFFFFFF) >> 16));    /* send 3 address bytes */
 920   1              Send_Byte(((Dst & 0xFFFF) >> 8));
 921   1              Send_Byte(Dst & 0xFF);
 922   1              CE_High();                                      /* disable device */
 923   1      }
 924          
 925          /************************************************************************/
 926          /* PROCEDURE: Block_Erase_32K                                                                                   */
 927          /*                                                                                                                                              */
 928          /* This procedure Block Erases 32 KByte of the Chip.                                    */
 929          /*                                                                                                                                              */
 930          /* Input:                                                                                                                               */
 931          /*              Dst:            Destination Address 000000H - 07FFFFH                           */
 932          /*                                                                                                                                              */
 933          /* Returns:                                                                                                                             */
 934          /*              Nothing                                                                                                                 */
 935          /************************************************************************/
 936          void Block_Erase_32K(unsigned long Dst)
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 57  

 937          {
 938   1              CE_Low();                                       /* enable device */
 939   1              Send_Byte(0x52);                        /* send 32 KByte Block Erase command */
 940   1              Send_Byte(((Dst & 0xFFFFFF) >> 16));    /* send 3 address bytes */
 941   1              Send_Byte(((Dst & 0xFFFF) >> 8));
 942   1              Send_Byte(Dst & 0xFF);
 943   1              CE_High();                                      /* disable device */
 944   1      }       
 945          
 946          /************************************************************************/
 947          /* PROCEDURE: Block_Erase_64K                                                                                   */
 948          /*                                                                                                                                              */
 949          /* This procedure Block Erases 64 KByte of the Chip.                                    */
 950          /*                                                                                                                                              */
 951          /* Input:                                                                                                                               */
 952          /*              Dst:            Destination Address 000000H - 07FFFFH                           */
 953          /*                                                                                                                                              */
 954          /* Returns:                                                                                                                             */
 955          /*              Nothing                                                                                                                 */
 956          /************************************************************************/
 957          void Block_Erase_64K(unsigned long Dst)
 958          {
 959   1              CE_Low();                                       /* enable device */
 960   1              Send_Byte(0xD8);                        /* send 64KByte Block Erase command */
 961   1              Send_Byte(((Dst & 0xFFFFFF) >> 16));    /* send 3 address bytes */
 962   1              Send_Byte(((Dst & 0xFFFF) >> 8));
 963   1              Send_Byte(Dst & 0xFF);
 964   1              CE_High();                                      /* disable device */
 965   1      }
 966          
 967          /************************************************************************/
 968          /* PROCEDURE: Wait_Busy                                                                                                 */
 969          /*                                                                                                                                              */
 970          /* This procedure waits until device is no longer busy (can be used by  */
 971          /* Byte-Program, Sector-Erase, Block-Erase, Chip-Erase).                                */
 972          /*                                                                                                                                              */
 973          /* Input:                                                                                                                               */
 974          /*              None                                                                                                                    */
 975          /*                                                                                                                                              */
 976          /* Returns:                                                                                                                             */
 977          /*              Nothing                                                                                                                 */
 978          /************************************************************************/
 979          void Wait_Busy()
 980          {
 981   1              uint16 xdata i=0xffff;
 982   1              while ((Read_Status_Register()&0x01) == 0x01)   /* waste time until not busy */
 983   1              {
 984   2                      delay_nus(10);
 985   2                      if( --i == 0) break;
 986   2              }
 987   1      
 988   1      }
 989          
 990          /************************************************************************/
 991          /* PROCEDURE: Wait_Busy_AAI                                                                                             */
 992          /*                                                                                                                                              */
 993          /* This procedure waits until device is no longer busy for AAI mode.    */
 994          /*                                                                                                                                              */
 995          /* Input:                                                                                                                               */
 996          /*              None                                                                                                                    */
 997          /*                                                                                                                                              */
 998          /* Returns:                                                                                                                             */
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 58  

 999          /*              Nothing                                                                                                                 */
1000          /************************************************************************/
1001          void Wait_Busy_AAI()
1002          {
1003   1              uint16 xdata i=100;
1004   1              while ((Read_Status_Register()&0X40) == 0x40)   /* waste time until not busy */
1005   1              {
1006   2                      delay_nms(1);
1007   2                      if( --i == 0) break;
1008   2              }
1009   1      }
1010          
1011          /************************************************************************/
1012          /* PROCEDURE: WREN_Check                                                                                                */
1013          /*                                                                                                                                              */
1014          /* This procedure checks to see if WEL bit set before program/erase.    */
1015          /*                                                                                                                                              */
1016          /* Input:                                                                                                                               */
1017          /*              None                                                                                                                    */
1018          /*                                                                                                                                              */
1019          /* Returns:                                                                                                                             */
1020          /*              Nothing                                                                                                                 */
1021          /************************************************************************/
1022          void WREN_Check()
1023          {
1024   1              uint16 xdata i=0xffff;
1025   1              while ((Read_Status_Register()&0x02) != 0x02)   /* verify that WEL bit is set */
1026   1      
1027   1              {
1028   2                      delay_nus(10);
1029   2                      if( --i == 0) break;
1030   2              }
1031   1      }
1032          
1033          /************************************************************************/
1034          /* PROCEDURE: WREN_AAI_Check                                                                                    */
1035          /*                                                                                                                                              */
1036          /* This procedure checks for AAI and WEL bit once in AAI mode.                  */
1037          /*                                                                                                                                              */
1038          /* Input:                                                                                                                               */
1039          /*              None                                                                                                                    */
1040          /*                                                                                                                                              */
1041          /* Returns:                                                                                                                             */
1042          /*              Nothing                                                                                                                 */
1043          /************************************************************************/
1044          void WREN_AAI_Check()
1045          {
1046   1              uint16 xdata i=0xffff;
1047   1              while ((Read_Status_Register()&0x42) != 0x42)   /* verify that AAI and WEL bit is set */
1048   1              {
1049   2                      delay_nus(10);
1050   2                      if( --i == 0) break;
1051   2              }
1052   1      }
1053          
1054          
1055          
1056          void Byte_Write(unsigned long Dst, unsigned char byte)
1057          {
1058   1              WREN();
1059   1              Sector_Erase(Dst);
1060   1              Wait_Busy();
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 59  

1061   1      //      delay_nms(25);
1062   1      
1063   1              WREN();
1064   1              Byte_Program(Dst,byte);
1065   1              Wait_Busy();
1066   1      //      delay_nus(20);
1067   1      }
1068          
1069          
1070          //SST25VF032
1071          void AAI_Write(unsigned long Dst, uint8 *p,uint8 no_bytes)
1072          {
1073   1              WREN();
1074   1              Sector_Erase(Dst);
1075   1              delay_nms(25);
1076   1      
1077   1      
1078   1              
1079   1              WREN();
1080   1              Auto_Add_IncA_EBSY(Dst,*p,*(p+1));
1081   1      
1082   1              no_bytes -=2;
1083   1              p +=2;
1084   1      
1085   1              for(;no_bytes>2;)
1086   1              {
1087   2                      CE_Low();                                       
1088   2                      Send_Byte(0xAD);                        
1089   2                      Send_Byte(*p);                  
1090   2                      Send_Byte(*(p+1));                      
1091   2                      CE_High();                                      
1092   2                      
1093   2                      Poll_SO();                                      
1094   2                      no_bytes -=2;
1095   2                      p +=2;
1096   2      
1097   2              }
1098   1              
1099   1              Auto_Add_IncB_EBSY(*p,*(p+1));
1100   1      
1101   1      }
1102          
1103          
1104          
1105          //SST25VF020 SST25VF040 
1106          /*void AAI_Write(unsigned long Dst, uint8 *p,uint8 no_bytes)
1107          {
1108                  WREN();
1109                  Sector_Erase(Dst);
1110          //      delay_nms(25);
1111                  Wait_Busy();
1112          
1113          
1114                  
1115                  WREN(); 
1116                  CE_Low();                               //enable device
1117                  Send_Byte(0xAF);                        //send AAI command 
1118                  Send_Byte(((Dst & 0xFFFFFF) >> 16));    //send 3 address bytes 
1119                  Send_Byte(((Dst & 0xFFFF) >> 8));
1120                  Send_Byte(Dst & 0xFF);
1121                  Send_Byte(*p);                  //send 1st byte to be programmed 
1122                  CE_High();                              // disable device 
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 60  

1123                  
1124          //      delay_nus(30);                  //ÑÓÊ±30us
1125                  Wait_Busy();
1126          
1127                  no_bytes--;
1128                  p ++;
1129          
1130                  for(;no_bytes>0;)
1131                  {
1132                          CE_Low();                                       //enable device 
1133                          Send_Byte(0xAf);                        //send AAI command 
1134                          Send_Byte(*p);                  //send 1st byte to be programmed 
1135                          CE_High();                                      // disable device 
1136                          //delay_nus(30);                        //ÑÓÊ±30us
1137                          Wait_Busy();
1138          
1139                          no_bytes -=1;
1140                          p +=1;
1141          
1142                  }
1143                  
1144                  
1145                  WRDI();                                         //Exit AAI before executing DBSY 
1146          //      delay_nus(30);                          //ÑÓÊ±30us
1147                  Wait_Busy();
1148                  
1149          }
1150          */      
1151          
1152          //Ô­ÒÑÕû¸öÉÈÇø²Á³ý,²»ÔÙÌ½³ý
1153          void Byte_Write1(unsigned long Dst, unsigned char byte)
1154          {
1155   1              WREN();
1156   1              Byte_Program(Dst,byte);
1157   1              Wait_Busy();
1158   1      //      delay_nus(20);
1159   1      }
1160          
1161          
1162          
1163          
1164          //SST25VF032
1165          //Ô­ÒÑÕû¸öÉÈÇø²Á³ý,²»ÔÙÌ½³ý
1166          void AAI_Write1(unsigned long Dst, uint8 *p,uint8 no_bytes)
1167          {
1168   1      
1169   1              WREN();
1170   1              Auto_Add_IncA_EBSY(Dst,*p,*(p+1));
1171   1      
1172   1              no_bytes -=2;
1173   1              p +=2;
1174   1      
1175   1              for(;no_bytes>2;)
1176   1              {
1177   2                      CE_Low();                                       
1178   2                      Send_Byte(0xAD);                        
1179   2                      Send_Byte(*p);                  
1180   2                      Send_Byte(*(p+1));                      
1181   2                      CE_High();                                      
1182   2                      
1183   2                      Poll_SO();                                      
1184   2                      no_bytes -=2;
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 61  

1185   2                      p +=2;
1186   2      
1187   2              }
1188   1              
1189   1              Auto_Add_IncB_EBSY(*p,*(p+1));
1190   1      
1191   1      }
1192          
1193          
1194          
1195          ////SST25VF020 SST25VF040
1196          /*void AAI_Write1(unsigned long Dst, uint8 *p,uint8 no_bytes)
1197          {       
1198                  WREN(); 
1199                  CE_Low();                               // enable device 
1200                  Send_Byte(0xAF);                        //send AAI command 
1201                  Send_Byte(((Dst & 0xFFFFFF) >> 16));    //send 3 address bytes 
1202                  Send_Byte(((Dst & 0xFFFF) >> 8));
1203                  Send_Byte(Dst & 0xFF);
1204                  Send_Byte(*p);                  //send 1st byte to be programmed        
1205                  CE_High();                              //disable device 
1206                  
1207          //      delay_nus(30);                  //ÑÓÊ±30us
1208                  Wait_Busy();
1209          
1210                  no_bytes--;
1211                  p ++;
1212          
1213                  for(;no_bytes>0;)
1214                  {
1215                          CE_Low();                                       // enable device 
1216                          Send_Byte(0xAf);                        // send AAI command 
1217                          Send_Byte(*p);                  //send 1st byte to be programmed 
1218                          CE_High();                                      //disable device 
1219          //              delay_nus(30);                  //ÑÓÊ±30us
1220                          Wait_Busy();
1221          
1222                          no_bytes -=1;
1223                          p +=1;
1224          
1225                  }
1226                  
1227                  
1228                  WRDI();                                         // Exit AAI before executing DBSY 
1229          //      delay_nus(30);                          //ÑÓÊ±30us
1230                  Wait_Busy();
1231                  
1232          }
1233          
1234          
1235          
1236          /**********************************************************
1237          *º¯ÊýÃû³Æ                       :FRAM_TEST      
1238          *º¯ÊýÃèÊö               :´æ´¢Ð¾Æ¬²âÊÔ²Ù×÷
1239          *ÊäÈë²ÎÊý               :
1240          *·µ»ØÖµ                         :       
1241          *È«¾Ö±äÁ¿                       :
1242          *µ÷ÓÃÄ£¿é                       :
1243          ***********************************************************
1244          *´´½¨ÈË                 :ÒüÔËÍ¬
1245          *´´½¨ÈÕÆÚ                       :2008-9-22
1246          ***********************************************************
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 62  

1247          *ÐÞ¸ÄÈË                         :
1248          *ÐÞ¸ÄÈÕÆÚ               :
1249          *×¢ÊÍ                   :
1250          **********************************************************/
1251          void FRAM_TEST(void)
1252          { 
1253   1              //SST25VF032   ²âÊÔ´æ´¢Êý¾Ý×î¶àÖ»µ½0x7fff0
1254   1              FRAM_BUFF[0]=Read(0x080000);
1255   1              delay_nms(1);
1256   1              
1257   1              FRAM_BUFF[1]=Read(0x090000);
1258   1      
1259   1              delay_nms(1);   
1260   1              FRAM_BUFF[2]=Read(0x0a0000);
1261   1              delay_nms(1);
1262   1              Send_Data(FRAM_BUFF,3); 
1263   1      
1264   1      }
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 63  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION SST25VF_Init (BEGIN)
                                           ; SOURCE LINE # 161
                                           ; SOURCE LINE # 162
                                           ; SOURCE LINE # 167
0000 120000      R     LCALL   EWSR
                                           ; SOURCE LINE # 168
0003 7F01              MOV     R7,#01H
0005 7E00              MOV     R6,#00H
0007 120000      E     LCALL   _delay_nms
                                           ; SOURCE LINE # 169
000A E4                CLR     A
000B FF                MOV     R7,A
000C FE                MOV     R6,A
000D 120000      R     LCALL   _WRSR
                                           ; SOURCE LINE # 170
0010 7F01              MOV     R7,#01H
0012 7E00              MOV     R6,#00H
0014 020000      E     LJMP    _delay_nms
             ; FUNCTION SST25VF_Init (END)

             ; FUNCTION L?0068 (BEGIN)
0000         L?0069:
0000 A3                INC     DPTR
0001 E0                MOVX    A,@DPTR
0002 FD                MOV     R5,A
0003 A3                INC     DPTR
0004 E0                MOVX    A,@DPTR
0005 FE                MOV     R6,A
0006 A3                INC     DPTR
0007 E0                MOVX    A,@DPTR
0008 FF                MOV     R7,A
0009 E4                CLR     A
000A 7810              MOV     R0,#010H
000C         L?0070:
000C FC                MOV     R4,A
000D 120000      E     LCALL   ?C?ULSHR
             ; FUNCTION _Send_Byte (BEGIN)
                                           ; SOURCE LINE # 187
;---- Variable 'out' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 188
                                           ; SOURCE LINE # 202
0010 020000      E     LJMP    _SPI_WriteByte
             ; FUNCTION _Send_Byte (END)

             ; FUNCTION L?0072 (BEGIN)
0000 900000      R     MOV     DPTR,#temp
0003 E0                MOVX    A,@DPTR
0004 F8                MOV     R0,A
0005 A3                INC     DPTR
0006 E0                MOVX    A,@DPTR
0007 F9                MOV     R1,A
0008 A3                INC     DPTR
0009 E0                MOVX    A,@DPTR
000A FA                MOV     R2,A
000B A3                INC     DPTR
000C E0                MOVX    A,@DPTR
000D 4F                ORL     A,R7
000E FF                MOV     R7,A
000F EA                MOV     A,R2
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 64  

0010 FE                MOV     R6,A
0011 E9                MOV     A,R1
0012 FD                MOV     R5,A
0013 E8                MOV     A,R0
0014 FC                MOV     R4,A
0015 7808              MOV     R0,#08H
0017 120000      E     LCALL   ?C?LSHL
001A 900000      R     MOV     DPTR,#temp
001D 120000      E     LCALL   ?C?LSTXDATA
             ; FUNCTION Get_Byte (BEGIN)
                                           ; SOURCE LINE # 217
                                           ; SOURCE LINE # 218
                                           ; SOURCE LINE # 234
0020 E4                CLR     A
0021 FF                MOV     R7,A
0022 120000      E     LCALL   _SPI_WriteByte
;---- Variable 'in' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 235
                                           ; SOURCE LINE # 236
0025         ?C0003:
0025 22                RET     
             ; FUNCTION Get_Byte (END)

             ; FUNCTION L?0078 (BEGIN)
0000 120000      R     LCALL   CE_High
             ; FUNCTION Poll_SO (BEGIN)
                                           ; SOURCE LINE # 251
                                           ; SOURCE LINE # 252
                                           ; SOURCE LINE # 253
0003 E4                CLR     A
0004 900000      R     MOV     DPTR,#temp
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 254
0008 120000      R     LCALL   CE_Low
000B         ?C0004:
                                           ; SOURCE LINE # 255
000B 900000      R     MOV     DPTR,#temp
000E E0                MOVX    A,@DPTR
000F 7006              JNZ     ?C0005
                                           ; SOURCE LINE # 256
0011 A296              MOV     C,MISO
0013 33                RLC     A
0014 F0                MOVX    @DPTR,A
0015 80F4              SJMP    ?C0004
0017         ?C0005:
                                           ; SOURCE LINE # 257
0017 020000      R     LJMP    CE_High
             ; FUNCTION Poll_SO (END)

             ; FUNCTION CE_High (BEGIN)
                                           ; SOURCE LINE # 272
                                           ; SOURCE LINE # 273
                                           ; SOURCE LINE # 274
0000 D294              SETB    SST25VF_CS
                                           ; SOURCE LINE # 275
0002 22                RET     
             ; FUNCTION CE_High (END)

             ; FUNCTION L?0074 (BEGIN)
0000 120000      E     LCALL   ?C?LSTXDATA
             ; FUNCTION CE_Low (BEGIN)
                                           ; SOURCE LINE # 289
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 65  

                                           ; SOURCE LINE # 290
                                           ; SOURCE LINE # 291
0003 C294              CLR     SST25VF_CS
                                           ; SOURCE LINE # 292
0005 22                RET     
             ; FUNCTION CE_Low (END)

             ; FUNCTION Hold_Low (BEGIN)
                                           ; SOURCE LINE # 305
                                           ; SOURCE LINE # 306
                                           ; SOURCE LINE # 310
0000 22                RET     
             ; FUNCTION Hold_Low (END)

             ; FUNCTION Unhold (BEGIN)
                                           ; SOURCE LINE # 323
                                           ; SOURCE LINE # 324
                                           ; SOURCE LINE # 328
0000 22                RET     
             ; FUNCTION Unhold (END)

             ; FUNCTION WP_Low (BEGIN)
                                           ; SOURCE LINE # 341
                                           ; SOURCE LINE # 342
                                           ; SOURCE LINE # 346
0000 22                RET     
             ; FUNCTION WP_Low (END)

             ; FUNCTION UnWP (BEGIN)
                                           ; SOURCE LINE # 359
                                           ; SOURCE LINE # 360
                                           ; SOURCE LINE # 364
0000 22                RET     
             ; FUNCTION UnWP (END)

             ; FUNCTION Read_Status_Register (BEGIN)
                                           ; SOURCE LINE # 377
                                           ; SOURCE LINE # 378
                                           ; SOURCE LINE # 379
;---- Variable 'byte' assigned to Register 'R7' ----
0000 E4                CLR     A
0001 FF                MOV     R7,A
                                           ; SOURCE LINE # 380
0002 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 381
0005 7F05              MOV     R7,#05H
0007 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 382
000A 120000      R     LCALL   Get_Byte
                                           ; SOURCE LINE # 383
000D 120000      R     LCALL   CE_High
                                           ; SOURCE LINE # 384
                                           ; SOURCE LINE # 385
0010         ?C0013:
0010 22                RET     
             ; FUNCTION Read_Status_Register (END)

             ; FUNCTION EWSR (BEGIN)
                                           ; SOURCE LINE # 398
                                           ; SOURCE LINE # 399
                                           ; SOURCE LINE # 400
0000 120000      R     LCALL   CE_Low
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 66  

                                           ; SOURCE LINE # 401
0003 7F50              MOV     R7,#050H
0005 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 402
0008 020000      R     LJMP    CE_High
             ; FUNCTION EWSR (END)

             ; FUNCTION _WRSR (BEGIN)
                                           ; SOURCE LINE # 416
0000 900000      R     MOV     DPTR,#byte
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 417
                                           ; SOURCE LINE # 418
0008 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 419
000B 7F01              MOV     R7,#01H
000D 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 420
0010 900000      R     MOV     DPTR,#byte
0013 A3                INC     DPTR
0014 E0                MOVX    A,@DPTR
0015 FF                MOV     R7,A
0016 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 422
0019 020000      R     LJMP    CE_High
             ; FUNCTION _WRSR (END)

             ; FUNCTION L?0077 (BEGIN)
0000 EB                MOV     A,R3
0001 F0                MOVX    @DPTR,A
0002 A3                INC     DPTR
0003 EA                MOV     A,R2
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 E9                MOV     A,R1
0007 F0                MOVX    @DPTR,A
             ; FUNCTION WREN (BEGIN)
                                           ; SOURCE LINE # 437
                                           ; SOURCE LINE # 438
                                           ; SOURCE LINE # 439
0008 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 440
000B 7F06              MOV     R7,#06H
000D 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 441
0010 120000      R     LCALL   CE_High
                                           ; SOURCE LINE # 442
0013 020000      R     LJMP    Wait_Busy
             ; FUNCTION WREN (END)

             ; FUNCTION WRDI (BEGIN)
                                           ; SOURCE LINE # 457
                                           ; SOURCE LINE # 458
                                           ; SOURCE LINE # 459
0000 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 460
0003 7F04              MOV     R7,#04H
0005 120000      R     LCALL   _Send_Byte
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 67  

                                           ; SOURCE LINE # 461
0008 020000      R     LJMP    CE_High
             ; FUNCTION WRDI (END)

             ; FUNCTION EBSY (BEGIN)
                                           ; SOURCE LINE # 476
                                           ; SOURCE LINE # 477
                                           ; SOURCE LINE # 478
0000 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 479
0003 7F70              MOV     R7,#070H
0005 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 480
0008 020000      R     LJMP    CE_High
             ; FUNCTION EBSY (END)

             ; FUNCTION DBSY (BEGIN)
                                           ; SOURCE LINE # 495
                                           ; SOURCE LINE # 496
                                           ; SOURCE LINE # 497
0000 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 498
0003 7F80              MOV     R7,#080H
0005 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 499
0008 020000      R     LJMP    CE_High
             ; FUNCTION DBSY (END)

             ; FUNCTION _Read_ID (BEGIN)
                                           ; SOURCE LINE # 519
0000 900000      R     MOV     DPTR,#ID_addr
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 520
                                           ; SOURCE LINE # 522
0008 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 523
000B 7F90              MOV     R7,#090H
000D 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 524
0010 E4                CLR     A
0011 FF                MOV     R7,A
0012 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 525
0015 E4                CLR     A
0016 FF                MOV     R7,A
0017 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 526
001A 900000      R     MOV     DPTR,#ID_addr
001D A3                INC     DPTR
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 527
0023 120000      R     LCALL   Get_Byte
;---- Variable 'byte' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 528
0026 120000      R     LCALL   CE_High
                                           ; SOURCE LINE # 529
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 68  

                                           ; SOURCE LINE # 530
0029         ?C0020:
0029 22                RET     
             ; FUNCTION _Read_ID (END)

             ; FUNCTION Jedec_ID_Read (BEGIN)
                                           ; SOURCE LINE # 547
                                           ; SOURCE LINE # 548
                                           ; SOURCE LINE # 551
0000 900000      R     MOV     DPTR,#temp
0003 120000      E     LCALL   ?C?LSTKXDATA
0006 00                DB      00H
0007 00                DB      00H
0008 00                DB      00H
0009 00                DB      00H
                                           ; SOURCE LINE # 553
000A 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 554
000D 7F9F              MOV     R7,#09FH
000F 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 555
0012 120000      R     LCALL   Get_Byte
                                           ; SOURCE LINE # 556
0015 120000      R     LCALL   L?0072
                                           ; SOURCE LINE # 557
0018 120000      R     LCALL   L?0072
001B 900000      R     MOV     DPTR,#temp
001E E0                MOVX    A,@DPTR
001F F8                MOV     R0,A
0020 A3                INC     DPTR
0021 E0                MOVX    A,@DPTR
0022 F9                MOV     R1,A
0023 A3                INC     DPTR
0024 E0                MOVX    A,@DPTR
0025 FA                MOV     R2,A
0026 A3                INC     DPTR
0027 E0                MOVX    A,@DPTR
0028 4F                ORL     A,R7
0029 FF                MOV     R7,A
002A EA                MOV     A,R2
002B FE                MOV     R6,A
002C E9                MOV     A,R1
002D FD                MOV     R5,A
002E E8                MOV     A,R0
002F FC                MOV     R4,A
0030 900000      R     MOV     DPTR,#temp
0033 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 558
0036 120000      R     LCALL   CE_High
                                           ; SOURCE LINE # 560
0039 900000      R     MOV     DPTR,#temp
003C E0                MOVX    A,@DPTR
003D FC                MOV     R4,A
003E A3                INC     DPTR
003F E0                MOVX    A,@DPTR
0040 FD                MOV     R5,A
0041 A3                INC     DPTR
0042 E0                MOVX    A,@DPTR
0043 FE                MOV     R6,A
0044 A3                INC     DPTR
0045 E0                MOVX    A,@DPTR
0046 FF                MOV     R7,A
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 69  

                                           ; SOURCE LINE # 561
0047         ?C0021:
0047 22                RET     
             ; FUNCTION Jedec_ID_Read (END)

             ; FUNCTION L?0075 (BEGIN)
0000 7F00              MOV     R7,#00H
0002 7E00              MOV     R6,#00H
0004 7C00              MOV     R4,#00H
             ; FUNCTION _Read (BEGIN)
                                           ; SOURCE LINE # 580
0006 900000      R     MOV     DPTR,#Dst
0009 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 581
                                           ; SOURCE LINE # 582
;---- Variable 'byte' assigned to Register 'R7' ----
000C E4                CLR     A
000D FF                MOV     R7,A
                                           ; SOURCE LINE # 584
000E 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 585
0011 7F03              MOV     R7,#03H
0013 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 586
0016 900000      R     MOV     DPTR,#Dst
0019 120000      R     LCALL   L?0068
                                           ; SOURCE LINE # 587
001C 900000      R     MOV     DPTR,#Dst
001F A3                INC     DPTR
0020 A3                INC     DPTR
0021 E0                MOVX    A,@DPTR
0022 FE                MOV     R6,A
0023 A3                INC     DPTR
0024 E0                MOVX    A,@DPTR
0025 FF                MOV     R7,A
0026 E4                CLR     A
0027 FD                MOV     R5,A
0028 7808              MOV     R0,#08H
002A 120000      R     LCALL   L?0070
                                           ; SOURCE LINE # 588
002D 900000      R     MOV     DPTR,#Dst
0030 E0                MOVX    A,@DPTR
0031 FC                MOV     R4,A
0032 A3                INC     DPTR
0033 E0                MOVX    A,@DPTR
0034 FD                MOV     R5,A
0035 A3                INC     DPTR
0036 E0                MOVX    A,@DPTR
0037 FE                MOV     R6,A
0038 A3                INC     DPTR
0039 E0                MOVX    A,@DPTR
003A FF                MOV     R7,A
003B 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 589
003E 120000      R     LCALL   Get_Byte
                                           ; SOURCE LINE # 590
0041 120000      R     LCALL   CE_High
                                           ; SOURCE LINE # 591
                                           ; SOURCE LINE # 592
0044         ?C0022:
0044 22                RET     
             ; FUNCTION _Read (END)
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 70  


             ; FUNCTION _Read_Cont (BEGIN)
                                           ; SOURCE LINE # 609
0000 900000      R     MOV     DPTR,#Dst
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 610
                                           ; SOURCE LINE # 611
0006 900000      R     MOV     DPTR,#i
0009 120000      E     LCALL   ?C?LSTKXDATA
000C 00                DB      00H
000D 00                DB      00H
000E 00                DB      00H
000F 00                DB      00H
                                           ; SOURCE LINE # 612
0010 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 613
0013 7F03              MOV     R7,#03H
0015 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 614
0018 900000      R     MOV     DPTR,#Dst
001B 120000      R     LCALL   L?0068
                                           ; SOURCE LINE # 615
001E 900000      R     MOV     DPTR,#Dst
0021 A3                INC     DPTR
0022 A3                INC     DPTR
0023 E0                MOVX    A,@DPTR
0024 FE                MOV     R6,A
0025 A3                INC     DPTR
0026 E0                MOVX    A,@DPTR
0027 FF                MOV     R7,A
0028 E4                CLR     A
0029 FD                MOV     R5,A
002A FC                MOV     R4,A
002B 7808              MOV     R0,#08H
002D 120000      E     LCALL   ?C?ULSHR
0030 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 616
0033 900000      R     MOV     DPTR,#Dst
0036 E0                MOVX    A,@DPTR
0037 FC                MOV     R4,A
0038 A3                INC     DPTR
0039 E0                MOVX    A,@DPTR
003A FD                MOV     R5,A
003B A3                INC     DPTR
003C E0                MOVX    A,@DPTR
003D FE                MOV     R6,A
003E A3                INC     DPTR
003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
0041 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 617
0044 900000      R     MOV     DPTR,#i
0047 120000      E     LCALL   ?C?LSTKXDATA
004A 00                DB      00H
004B 00                DB      00H
004C 00                DB      00H
004D 00                DB      00H
004E         ?C0023:
004E 900000      R     MOV     DPTR,#no_bytes
0051 E0                MOVX    A,@DPTR
0052 FC                MOV     R4,A
0053 A3                INC     DPTR
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 71  

0054 E0                MOVX    A,@DPTR
0055 FD                MOV     R5,A
0056 A3                INC     DPTR
0057 E0                MOVX    A,@DPTR
0058 FE                MOV     R6,A
0059 A3                INC     DPTR
005A E0                MOVX    A,@DPTR
005B FF                MOV     R7,A
005C 900000      R     MOV     DPTR,#i
005F E0                MOVX    A,@DPTR
0060 F8                MOV     R0,A
0061 A3                INC     DPTR
0062 E0                MOVX    A,@DPTR
0063 F9                MOV     R1,A
0064 A3                INC     DPTR
0065 E0                MOVX    A,@DPTR
0066 FA                MOV     R2,A
0067 A3                INC     DPTR
0068 E0                MOVX    A,@DPTR
0069 FB                MOV     R3,A
006A C3                CLR     C
006B 120000      E     LCALL   ?C?ULCMP
006E 5044              JNC     ?C0024
                                           ; SOURCE LINE # 618
                                           ; SOURCE LINE # 619
0070 120000      R     LCALL   Get_Byte
0073 C007              PUSH    AR7
0075 900000      R     MOV     DPTR,#i
0078 A3                INC     DPTR
0079 A3                INC     DPTR
007A E0                MOVX    A,@DPTR
007B FE                MOV     R6,A
007C A3                INC     DPTR
007D E0                MOVX    A,@DPTR
007E FF                MOV     R7,A
007F 900000      R     MOV     DPTR,#pBuffer
0082 E0                MOVX    A,@DPTR
0083 FB                MOV     R3,A
0084 A3                INC     DPTR
0085 E0                MOVX    A,@DPTR
0086 FA                MOV     R2,A
0087 A3                INC     DPTR
0088 E0                MOVX    A,@DPTR
0089 F9                MOV     R1,A
008A 8F82              MOV     DPL,R7
008C 8E83              MOV     DPH,R6
008E D0E0              POP     ACC
0090 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 620
0093 900000      R     MOV     DPTR,#i
0096 E0                MOVX    A,@DPTR
0097 FC                MOV     R4,A
0098 A3                INC     DPTR
0099 E0                MOVX    A,@DPTR
009A FD                MOV     R5,A
009B A3                INC     DPTR
009C E0                MOVX    A,@DPTR
009D FE                MOV     R6,A
009E A3                INC     DPTR
009F E0                MOVX    A,@DPTR
00A0 2401              ADD     A,#01H
00A2 FF                MOV     R7,A
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 72  

00A3 E4                CLR     A
00A4 3E                ADDC    A,R6
00A5 FE                MOV     R6,A
00A6 E4                CLR     A
00A7 3D                ADDC    A,R5
00A8 FD                MOV     R5,A
00A9 E4                CLR     A
00AA 3C                ADDC    A,R4
00AB FC                MOV     R4,A
00AC 900000      R     MOV     DPTR,#i
00AF 120000      E     LCALL   ?C?LSTXDATA
00B2 809A              SJMP    ?C0023
00B4         ?C0024:
                                           ; SOURCE LINE # 621
00B4 020000      R     LJMP    CE_High
             ; FUNCTION _Read_Cont (END)

             ; FUNCTION _HighSpeed_Read (BEGIN)
                                           ; SOURCE LINE # 642
0000 900000      R     MOV     DPTR,#Dst
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 643
                                           ; SOURCE LINE # 644
;---- Variable 'byte' assigned to Register 'R7' ----
0006 E4                CLR     A
0007 FF                MOV     R7,A
                                           ; SOURCE LINE # 646
0008 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 647
000B 7F0B              MOV     R7,#0BH
000D 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 648
0010 900000      R     MOV     DPTR,#Dst
0013 120000      R     LCALL   L?0069
                                           ; SOURCE LINE # 649
0016 900000      R     MOV     DPTR,#Dst
0019 A3                INC     DPTR
001A A3                INC     DPTR
001B E0                MOVX    A,@DPTR
001C FE                MOV     R6,A
001D A3                INC     DPTR
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 E4                CLR     A
0021 FD                MOV     R5,A
0022 FC                MOV     R4,A
0023 7808              MOV     R0,#08H
0025 120000      E     LCALL   ?C?ULSHR
0028 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 650
002B 900000      R     MOV     DPTR,#Dst
002E E0                MOVX    A,@DPTR
002F FC                MOV     R4,A
0030 A3                INC     DPTR
0031 E0                MOVX    A,@DPTR
0032 FD                MOV     R5,A
0033 A3                INC     DPTR
0034 E0                MOVX    A,@DPTR
0035 FE                MOV     R6,A
0036 A3                INC     DPTR
0037 E0                MOVX    A,@DPTR
0038 FF                MOV     R7,A
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 73  

0039 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 651
003C 7FFF              MOV     R7,#0FFH
003E 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 652
0041 120000      R     LCALL   Get_Byte
                                           ; SOURCE LINE # 653
0044 120000      R     LCALL   CE_High
                                           ; SOURCE LINE # 654
                                           ; SOURCE LINE # 655
0047         ?C0027:
0047 22                RET     
             ; FUNCTION _HighSpeed_Read (END)

             ; FUNCTION _HighSpeed_Read_Cont (BEGIN)
                                           ; SOURCE LINE # 671
0000 900000      R     MOV     DPTR,#Dst
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 672
                                           ; SOURCE LINE # 673
0006 900000      R     MOV     DPTR,#i
0009 120000      E     LCALL   ?C?LSTKXDATA
000C 00                DB      00H
000D 00                DB      00H
000E 00                DB      00H
000F 00                DB      00H
                                           ; SOURCE LINE # 674
0010 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 675
0013 7F0B              MOV     R7,#0BH
0015 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 676
0018 900000      R     MOV     DPTR,#Dst
001B 120000      R     LCALL   L?0069
                                           ; SOURCE LINE # 677
001E 900000      R     MOV     DPTR,#Dst
0021 A3                INC     DPTR
0022 A3                INC     DPTR
0023 E0                MOVX    A,@DPTR
0024 FE                MOV     R6,A
0025 A3                INC     DPTR
0026 E0                MOVX    A,@DPTR
0027 FF                MOV     R7,A
0028 E4                CLR     A
0029 FD                MOV     R5,A
002A FC                MOV     R4,A
002B 7808              MOV     R0,#08H
002D 120000      E     LCALL   ?C?ULSHR
0030 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 678
0033 900000      R     MOV     DPTR,#Dst
0036 E0                MOVX    A,@DPTR
0037 FC                MOV     R4,A
0038 A3                INC     DPTR
0039 E0                MOVX    A,@DPTR
003A FD                MOV     R5,A
003B A3                INC     DPTR
003C E0                MOVX    A,@DPTR
003D FE                MOV     R6,A
003E A3                INC     DPTR
003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 74  

0041 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 679
0044 7FFF              MOV     R7,#0FFH
0046 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 680
0049 900000      R     MOV     DPTR,#i
004C 120000      E     LCALL   ?C?LSTKXDATA
004F 00                DB      00H
0050 00                DB      00H
0051 00                DB      00H
0052 00                DB      00H
0053         ?C0028:
0053 900000      R     MOV     DPTR,#no_bytes
0056 E0                MOVX    A,@DPTR
0057 FC                MOV     R4,A
0058 A3                INC     DPTR
0059 E0                MOVX    A,@DPTR
005A FD                MOV     R5,A
005B A3                INC     DPTR
005C E0                MOVX    A,@DPTR
005D FE                MOV     R6,A
005E A3                INC     DPTR
005F E0                MOVX    A,@DPTR
0060 FF                MOV     R7,A
0061 900000      R     MOV     DPTR,#i
0064 E0                MOVX    A,@DPTR
0065 F8                MOV     R0,A
0066 A3                INC     DPTR
0067 E0                MOVX    A,@DPTR
0068 F9                MOV     R1,A
0069 A3                INC     DPTR
006A E0                MOVX    A,@DPTR
006B FA                MOV     R2,A
006C A3                INC     DPTR
006D E0                MOVX    A,@DPTR
006E FB                MOV     R3,A
006F C3                CLR     C
0070 120000      E     LCALL   ?C?ULCMP
0073 5044              JNC     ?C0029
                                           ; SOURCE LINE # 681
                                           ; SOURCE LINE # 682
0075 120000      R     LCALL   Get_Byte
0078 C007              PUSH    AR7
007A 900000      R     MOV     DPTR,#i
007D A3                INC     DPTR
007E A3                INC     DPTR
007F E0                MOVX    A,@DPTR
0080 FE                MOV     R6,A
0081 A3                INC     DPTR
0082 E0                MOVX    A,@DPTR
0083 FF                MOV     R7,A
0084 900000      R     MOV     DPTR,#pBuffer
0087 E0                MOVX    A,@DPTR
0088 FB                MOV     R3,A
0089 A3                INC     DPTR
008A E0                MOVX    A,@DPTR
008B FA                MOV     R2,A
008C A3                INC     DPTR
008D E0                MOVX    A,@DPTR
008E F9                MOV     R1,A
008F 8F82              MOV     DPL,R7
0091 8E83              MOV     DPH,R6
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 75  

0093 D0E0              POP     ACC
0095 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 683
0098 900000      R     MOV     DPTR,#i
009B E0                MOVX    A,@DPTR
009C FC                MOV     R4,A
009D A3                INC     DPTR
009E E0                MOVX    A,@DPTR
009F FD                MOV     R5,A
00A0 A3                INC     DPTR
00A1 E0                MOVX    A,@DPTR
00A2 FE                MOV     R6,A
00A3 A3                INC     DPTR
00A4 E0                MOVX    A,@DPTR
00A5 2401              ADD     A,#01H
00A7 FF                MOV     R7,A
00A8 E4                CLR     A
00A9 3E                ADDC    A,R6
00AA FE                MOV     R6,A
00AB E4                CLR     A
00AC 3D                ADDC    A,R5
00AD FD                MOV     R5,A
00AE E4                CLR     A
00AF 3C                ADDC    A,R4
00B0 FC                MOV     R4,A
00B1 900000      R     MOV     DPTR,#i
00B4 120000      E     LCALL   ?C?LSTXDATA
00B7 809A              SJMP    ?C0028
00B9         ?C0029:
                                           ; SOURCE LINE # 684
00B9 020000      R     LJMP    CE_High
             ; FUNCTION _HighSpeed_Read_Cont (END)

             ; FUNCTION L?0073 (BEGIN)
0000 E0                MOVX    A,@DPTR
0001 FC                MOV     R4,A
0002 A3                INC     DPTR
0003 E0                MOVX    A,@DPTR
0004 FD                MOV     R5,A
0005 A3                INC     DPTR
0006 E0                MOVX    A,@DPTR
0007 FE                MOV     R6,A
0008 A3                INC     DPTR
0009 E0                MOVX    A,@DPTR
000A FF                MOV     R7,A
000B A3                INC     DPTR
000C E0                MOVX    A,@DPTR
000D 900000      R     MOV     DPTR,#?_Byte_Program?BYTE+04H
0010 F0                MOVX    @DPTR,A
             ; FUNCTION _Byte_Program (BEGIN)
                                           ; SOURCE LINE # 705
0011 900000      R     MOV     DPTR,#Dst
                                           ; SOURCE LINE # 706
                                           ; SOURCE LINE # 707
0014 120000      R     LCALL   L?0074
                                           ; SOURCE LINE # 708
0017 7F02              MOV     R7,#02H
0019 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 709
001C 900000      R     MOV     DPTR,#Dst
001F 120000      R     LCALL   L?0069
                                           ; SOURCE LINE # 710
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 76  

0022 900000      R     MOV     DPTR,#Dst
0025 A3                INC     DPTR
0026 A3                INC     DPTR
0027 E0                MOVX    A,@DPTR
0028 FE                MOV     R6,A
0029 A3                INC     DPTR
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C E4                CLR     A
002D FD                MOV     R5,A
002E FC                MOV     R4,A
002F 7808              MOV     R0,#08H
0031 120000      E     LCALL   ?C?ULSHR
0034 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 711
0037 900000      R     MOV     DPTR,#Dst
003A E0                MOVX    A,@DPTR
003B FC                MOV     R4,A
003C A3                INC     DPTR
003D E0                MOVX    A,@DPTR
003E FD                MOV     R5,A
003F A3                INC     DPTR
0040 E0                MOVX    A,@DPTR
0041 FE                MOV     R6,A
0042 A3                INC     DPTR
0043 E0                MOVX    A,@DPTR
0044 FF                MOV     R7,A
0045 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 712
0048 900000      R     MOV     DPTR,#byte
004B E0                MOVX    A,@DPTR
004C FF                MOV     R7,A
004D 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 713
0050 020000      R     LJMP    CE_High
             ; FUNCTION _Byte_Program (END)

             ; FUNCTION _Auto_Add_IncA (BEGIN)
                                           ; SOURCE LINE # 744
0000 900000      R     MOV     DPTR,#Dst
                                           ; SOURCE LINE # 745
                                           ; SOURCE LINE # 746
0003 120000      R     LCALL   L?0074
                                           ; SOURCE LINE # 747
0006 7FAD              MOV     R7,#0ADH
0008 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 748
000B 900000      R     MOV     DPTR,#Dst
000E 120000      R     LCALL   L?0069
                                           ; SOURCE LINE # 749
0011 900000      R     MOV     DPTR,#Dst
0014 A3                INC     DPTR
0015 A3                INC     DPTR
0016 E0                MOVX    A,@DPTR
0017 FE                MOV     R6,A
0018 A3                INC     DPTR
0019 E0                MOVX    A,@DPTR
001A FF                MOV     R7,A
001B E4                CLR     A
001C FD                MOV     R5,A
001D FC                MOV     R4,A
001E 7808              MOV     R0,#08H
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 77  

0020 120000      E     LCALL   ?C?ULSHR
0023 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 750
0026 900000      R     MOV     DPTR,#Dst
0029 E0                MOVX    A,@DPTR
002A FC                MOV     R4,A
002B A3                INC     DPTR
002C E0                MOVX    A,@DPTR
002D FD                MOV     R5,A
002E A3                INC     DPTR
002F E0                MOVX    A,@DPTR
0030 FE                MOV     R6,A
0031 A3                INC     DPTR
0032 E0                MOVX    A,@DPTR
0033 FF                MOV     R7,A
0034 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 751
0037 900000      R     MOV     DPTR,#byte1
003A E0                MOVX    A,@DPTR
003B FF                MOV     R7,A
003C 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 752
003F 900000      R     MOV     DPTR,#byte2
0042 E0                MOVX    A,@DPTR
0043 FF                MOV     R7,A
0044 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 753
0047 020000      R     LJMP    CE_High
             ; FUNCTION _Auto_Add_IncA (END)

             ; FUNCTION _Auto_Add_IncB (BEGIN)
                                           ; SOURCE LINE # 784
0000 900000      R     MOV     DPTR,#byte1
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 785
                                           ; SOURCE LINE # 786
0008 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 787
000B 7FAD              MOV     R7,#0ADH
000D 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 788
0010 900000      R     MOV     DPTR,#byte1
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 789
0018 900000      R     MOV     DPTR,#byte2
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 790
0020 020000      R     LJMP    CE_High
             ; FUNCTION _Auto_Add_IncB (END)

             ; FUNCTION L?0071 (BEGIN)
0000 E0                MOVX    A,@DPTR
0001 FC                MOV     R4,A
0002 A3                INC     DPTR
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 78  

0003 E0                MOVX    A,@DPTR
0004 FD                MOV     R5,A
0005 A3                INC     DPTR
0006 E0                MOVX    A,@DPTR
0007 FE                MOV     R6,A
0008 A3                INC     DPTR
0009 E0                MOVX    A,@DPTR
000A FF                MOV     R7,A
000B A3                INC     DPTR
000C E0                MOVX    A,@DPTR
000D FB                MOV     R3,A
000E A3                INC     DPTR
000F E0                MOVX    A,@DPTR
0010 FA                MOV     R2,A
0011 A3                INC     DPTR
0012 E0                MOVX    A,@DPTR
0013 F9                MOV     R1,A
0014 120000      E     LCALL   ?C?CLDPTR
0017 900000      R     MOV     DPTR,#?_Auto_Add_IncA_EBSY?BYTE+04H
001A F0                MOVX    @DPTR,A
001B 900001            MOV     DPTR,#01H
001E 120000      E     LCALL   ?C?CLDOPTR
0021 900000      R     MOV     DPTR,#?_Auto_Add_IncA_EBSY?BYTE+05H
0024 F0                MOVX    @DPTR,A
             ; FUNCTION _Auto_Add_IncA_EBSY (BEGIN)
                                           ; SOURCE LINE # 823
0025 900000      R     MOV     DPTR,#Dst
0028 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 824
                                           ; SOURCE LINE # 825
002B 120000      R     LCALL   EBSY
                                           ; SOURCE LINE # 827
002E 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 828
0031 7FAD              MOV     R7,#0ADH
0033 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 829
0036 900000      R     MOV     DPTR,#Dst
0039 120000      R     LCALL   L?0069
                                           ; SOURCE LINE # 830
003C 900000      R     MOV     DPTR,#Dst
003F A3                INC     DPTR
0040 A3                INC     DPTR
0041 E0                MOVX    A,@DPTR
0042 FE                MOV     R6,A
0043 A3                INC     DPTR
0044 E0                MOVX    A,@DPTR
0045 FF                MOV     R7,A
0046 E4                CLR     A
0047 FD                MOV     R5,A
0048 FC                MOV     R4,A
0049 7808              MOV     R0,#08H
004B 120000      E     LCALL   ?C?ULSHR
004E 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 831
0051 900000      R     MOV     DPTR,#Dst
0054 E0                MOVX    A,@DPTR
0055 FC                MOV     R4,A
0056 A3                INC     DPTR
0057 E0                MOVX    A,@DPTR
0058 FD                MOV     R5,A
0059 A3                INC     DPTR
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 79  

005A E0                MOVX    A,@DPTR
005B FE                MOV     R6,A
005C A3                INC     DPTR
005D E0                MOVX    A,@DPTR
005E FF                MOV     R7,A
005F 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 832
0062 900000      R     MOV     DPTR,#byte1
0065 E0                MOVX    A,@DPTR
0066 FF                MOV     R7,A
0067 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 833
006A 900000      R     MOV     DPTR,#byte2
006D E0                MOVX    A,@DPTR
006E FF                MOV     R7,A
006F 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 834
0072 120000      R     LCALL   CE_High
                                           ; SOURCE LINE # 836
0075 020000      R     LJMP    Poll_SO
             ; FUNCTION _Auto_Add_IncA_EBSY (END)

             ; FUNCTION _Auto_Add_IncB_EBSY (BEGIN)
                                           ; SOURCE LINE # 870
0000 900000      R     MOV     DPTR,#byte1
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 871
                                           ; SOURCE LINE # 872
0008 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 873
000B 7FAD              MOV     R7,#0ADH
000D 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 874
0010 900000      R     MOV     DPTR,#byte1
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 875
0018 900000      R     MOV     DPTR,#byte2
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 876
                                           ; SOURCE LINE # 878
0020 120000      R     LCALL   L?0078
                                           ; SOURCE LINE # 880
0023 120000      R     LCALL   WRDI
                                           ; SOURCE LINE # 881
0026 020000      R     LJMP    DBSY
             ; FUNCTION _Auto_Add_IncB_EBSY (END)

             ; FUNCTION Chip_Erase (BEGIN)
                                           ; SOURCE LINE # 895
                                           ; SOURCE LINE # 896
                                           ; SOURCE LINE # 897
0000 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 898
0003 7F60              MOV     R7,#060H
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 80  

0005 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 899
0008 020000      R     LJMP    CE_High
             ; FUNCTION Chip_Erase (END)

             ; FUNCTION L?0076 (BEGIN)
0000 E0                MOVX    A,@DPTR
0001 FC                MOV     R4,A
0002 A3                INC     DPTR
0003 E0                MOVX    A,@DPTR
0004 FD                MOV     R5,A
0005 A3                INC     DPTR
0006 E0                MOVX    A,@DPTR
0007 FE                MOV     R6,A
0008 A3                INC     DPTR
0009 E0                MOVX    A,@DPTR
000A FF                MOV     R7,A
             ; FUNCTION _Sector_Erase (BEGIN)
                                           ; SOURCE LINE # 913
000B 900000      R     MOV     DPTR,#Dst
000E 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 914
                                           ; SOURCE LINE # 917
0011 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 918
0014 7F20              MOV     R7,#020H
0016 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 919
0019 900000      R     MOV     DPTR,#Dst
001C 120000      R     LCALL   L?0069
                                           ; SOURCE LINE # 920
001F 900000      R     MOV     DPTR,#Dst
0022 A3                INC     DPTR
0023 A3                INC     DPTR
0024 E0                MOVX    A,@DPTR
0025 FE                MOV     R6,A
0026 A3                INC     DPTR
0027 E0                MOVX    A,@DPTR
0028 FF                MOV     R7,A
0029 E4                CLR     A
002A FD                MOV     R5,A
002B FC                MOV     R4,A
002C 7808              MOV     R0,#08H
002E 120000      E     LCALL   ?C?ULSHR
0031 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 921
0034 900000      R     MOV     DPTR,#Dst
0037 E0                MOVX    A,@DPTR
0038 FC                MOV     R4,A
0039 A3                INC     DPTR
003A E0                MOVX    A,@DPTR
003B FD                MOV     R5,A
003C A3                INC     DPTR
003D E0                MOVX    A,@DPTR
003E FE                MOV     R6,A
003F A3                INC     DPTR
0040 E0                MOVX    A,@DPTR
0041 FF                MOV     R7,A
0042 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 922
0045 020000      R     LJMP    CE_High
             ; FUNCTION _Sector_Erase (END)
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 81  


             ; FUNCTION _Block_Erase_32K (BEGIN)
                                           ; SOURCE LINE # 936
0000 900000      R     MOV     DPTR,#Dst
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 937
                                           ; SOURCE LINE # 938
0006 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 939
0009 7F52              MOV     R7,#052H
000B 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 940
000E 900000      R     MOV     DPTR,#Dst
0011 120000      R     LCALL   L?0069
                                           ; SOURCE LINE # 941
0014 900000      R     MOV     DPTR,#Dst
0017 A3                INC     DPTR
0018 A3                INC     DPTR
0019 E0                MOVX    A,@DPTR
001A FE                MOV     R6,A
001B A3                INC     DPTR
001C E0                MOVX    A,@DPTR
001D FF                MOV     R7,A
001E E4                CLR     A
001F FD                MOV     R5,A
0020 FC                MOV     R4,A
0021 7808              MOV     R0,#08H
0023 120000      E     LCALL   ?C?ULSHR
0026 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 942
0029 900000      R     MOV     DPTR,#Dst
002C E0                MOVX    A,@DPTR
002D FC                MOV     R4,A
002E A3                INC     DPTR
002F E0                MOVX    A,@DPTR
0030 FD                MOV     R5,A
0031 A3                INC     DPTR
0032 E0                MOVX    A,@DPTR
0033 FE                MOV     R6,A
0034 A3                INC     DPTR
0035 E0                MOVX    A,@DPTR
0036 FF                MOV     R7,A
0037 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 943
003A 020000      R     LJMP    CE_High
             ; FUNCTION _Block_Erase_32K (END)

             ; FUNCTION _Block_Erase_64K (BEGIN)
                                           ; SOURCE LINE # 957
0000 900000      R     MOV     DPTR,#Dst
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 958
                                           ; SOURCE LINE # 959
0006 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 960
0009 7FD8              MOV     R7,#0D8H
000B 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 961
000E 900000      R     MOV     DPTR,#Dst
0011 120000      R     LCALL   L?0069
                                           ; SOURCE LINE # 962
0014 900000      R     MOV     DPTR,#Dst
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 82  

0017 A3                INC     DPTR
0018 A3                INC     DPTR
0019 E0                MOVX    A,@DPTR
001A FE                MOV     R6,A
001B A3                INC     DPTR
001C E0                MOVX    A,@DPTR
001D FF                MOV     R7,A
001E E4                CLR     A
001F FD                MOV     R5,A
0020 FC                MOV     R4,A
0021 7808              MOV     R0,#08H
0023 120000      E     LCALL   ?C?ULSHR
0026 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 963
0029 900000      R     MOV     DPTR,#Dst
002C E0                MOVX    A,@DPTR
002D FC                MOV     R4,A
002E A3                INC     DPTR
002F E0                MOVX    A,@DPTR
0030 FD                MOV     R5,A
0031 A3                INC     DPTR
0032 E0                MOVX    A,@DPTR
0033 FE                MOV     R6,A
0034 A3                INC     DPTR
0035 E0                MOVX    A,@DPTR
0036 FF                MOV     R7,A
0037 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 964
003A 020000      R     LJMP    CE_High
             ; FUNCTION _Block_Erase_64K (END)

             ; FUNCTION Wait_Busy (BEGIN)
                                           ; SOURCE LINE # 979
                                           ; SOURCE LINE # 980
                                           ; SOURCE LINE # 981
0000 74FF              MOV     A,#0FFH
0002 900000      R     MOV     DPTR,#i
0005 F0                MOVX    @DPTR,A
0006 A3                INC     DPTR
0007 F0                MOVX    @DPTR,A
0008         ?C0041:
                                           ; SOURCE LINE # 982
0008 120000      R     LCALL   Read_Status_Register
000B EF                MOV     A,R7
000C 30E015            JNB     ACC.0,?C0044
                                           ; SOURCE LINE # 983
                                           ; SOURCE LINE # 984
000F 7F0A              MOV     R7,#0AH
0011 7E00              MOV     R6,#00H
0013 120000      E     LCALL   _delay_nus
                                           ; SOURCE LINE # 985
0016 900000      R     MOV     DPTR,#i
0019 74FF              MOV     A,#0FFH
001B F5F0              MOV     B,A
001D 120000      E     LCALL   ?C?IILDX
0020 45F0              ORL     A,B
0022 70E4              JNZ     ?C0041
                                           ; SOURCE LINE # 986
                                           ; SOURCE LINE # 988
0024         ?C0044:
0024 22                RET     
             ; FUNCTION Wait_Busy (END)
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 83  


             ; FUNCTION Wait_Busy_AAI (BEGIN)
                                           ; SOURCE LINE # 1001
                                           ; SOURCE LINE # 1002
                                           ; SOURCE LINE # 1003
0000 900000      R     MOV     DPTR,#i
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 7464              MOV     A,#064H
0008 F0                MOVX    @DPTR,A
0009         ?C0045:
                                           ; SOURCE LINE # 1004
0009 120000      R     LCALL   Read_Status_Register
000C EF                MOV     A,R7
000D 30E615            JNB     ACC.6,?C0048
                                           ; SOURCE LINE # 1005
                                           ; SOURCE LINE # 1006
0010 7F01              MOV     R7,#01H
0012 7E00              MOV     R6,#00H
0014 120000      E     LCALL   _delay_nms
                                           ; SOURCE LINE # 1007
0017 900000      R     MOV     DPTR,#i
001A 74FF              MOV     A,#0FFH
001C F5F0              MOV     B,A
001E 120000      E     LCALL   ?C?IILDX
0021 45F0              ORL     A,B
0023 70E4              JNZ     ?C0045
                                           ; SOURCE LINE # 1008
                                           ; SOURCE LINE # 1009
0025         ?C0048:
0025 22                RET     
             ; FUNCTION Wait_Busy_AAI (END)

             ; FUNCTION WREN_Check (BEGIN)
                                           ; SOURCE LINE # 1022
                                           ; SOURCE LINE # 1023
                                           ; SOURCE LINE # 1024
0000 74FF              MOV     A,#0FFH
0002 900000      R     MOV     DPTR,#i
0005 F0                MOVX    @DPTR,A
0006 A3                INC     DPTR
0007 F0                MOVX    @DPTR,A
0008         ?C0049:
                                           ; SOURCE LINE # 1025
0008 120000      R     LCALL   Read_Status_Register
000B EF                MOV     A,R7
000C 20E115            JB      ACC.1,?C0052
                                           ; SOURCE LINE # 1027
                                           ; SOURCE LINE # 1028
000F 7F0A              MOV     R7,#0AH
0011 7E00              MOV     R6,#00H
0013 120000      E     LCALL   _delay_nus
                                           ; SOURCE LINE # 1029
0016 900000      R     MOV     DPTR,#i
0019 74FF              MOV     A,#0FFH
001B F5F0              MOV     B,A
001D 120000      E     LCALL   ?C?IILDX
0020 45F0              ORL     A,B
0022 70E4              JNZ     ?C0049
                                           ; SOURCE LINE # 1030
                                           ; SOURCE LINE # 1031
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 84  

0024         ?C0052:
0024 22                RET     
             ; FUNCTION WREN_Check (END)

             ; FUNCTION WREN_AAI_Check (BEGIN)
                                           ; SOURCE LINE # 1044
                                           ; SOURCE LINE # 1045
                                           ; SOURCE LINE # 1046
0000 74FF              MOV     A,#0FFH
0002 900000      R     MOV     DPTR,#i
0005 F0                MOVX    @DPTR,A
0006 A3                INC     DPTR
0007 F0                MOVX    @DPTR,A
0008         ?C0053:
                                           ; SOURCE LINE # 1047
0008 120000      R     LCALL   Read_Status_Register
000B EF                MOV     A,R7
000C 5442              ANL     A,#042H
000E 6442              XRL     A,#042H
0010 6015              JZ      ?C0056
                                           ; SOURCE LINE # 1048
                                           ; SOURCE LINE # 1049
0012 7F0A              MOV     R7,#0AH
0014 7E00              MOV     R6,#00H
0016 120000      E     LCALL   _delay_nus
                                           ; SOURCE LINE # 1050
0019 900000      R     MOV     DPTR,#i
001C 74FF              MOV     A,#0FFH
001E F5F0              MOV     B,A
0020 120000      E     LCALL   ?C?IILDX
0023 45F0              ORL     A,B
0025 70E1              JNZ     ?C0053
                                           ; SOURCE LINE # 1051
                                           ; SOURCE LINE # 1052
0027         ?C0056:
0027 22                RET     
             ; FUNCTION WREN_AAI_Check (END)

             ; FUNCTION _Byte_Write (BEGIN)
                                           ; SOURCE LINE # 1056
0000 900000      R     MOV     DPTR,#Dst
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1057
                                           ; SOURCE LINE # 1058
0006 120000      R     LCALL   WREN
                                           ; SOURCE LINE # 1059
0009 900000      R     MOV     DPTR,#Dst
000C 120000      R     LCALL   L?0076
                                           ; SOURCE LINE # 1060
000F 120000      R     LCALL   Wait_Busy
                                           ; SOURCE LINE # 1063
0012 120000      R     LCALL   WREN
                                           ; SOURCE LINE # 1064
0015 900000      R     MOV     DPTR,#Dst
0018 120000      R     LCALL   L?0073
                                           ; SOURCE LINE # 1065
001B 020000      R     LJMP    Wait_Busy
             ; FUNCTION _Byte_Write (END)

             ; FUNCTION _AAI_Write (BEGIN)
                                           ; SOURCE LINE # 1071
0000 900000      R     MOV     DPTR,#Dst
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 85  

0003 120000      E     LCALL   ?C?LSTXDATA
0006 900000      R     MOV     DPTR,#p
                                           ; SOURCE LINE # 1072
                                           ; SOURCE LINE # 1073
0009 120000      R     LCALL   L?0077
                                           ; SOURCE LINE # 1074
000C 900000      R     MOV     DPTR,#Dst
000F 120000      R     LCALL   L?0076
                                           ; SOURCE LINE # 1075
0012 7F19              MOV     R7,#019H
0014 7E00              MOV     R6,#00H
0016 120000      E     LCALL   _delay_nms
                                           ; SOURCE LINE # 1079
0019 120000      R     LCALL   WREN
                                           ; SOURCE LINE # 1080
001C 900000      R     MOV     DPTR,#Dst
001F 120000      R     LCALL   L?0071
                                           ; SOURCE LINE # 1082
                                           ; SOURCE LINE # 1083
                                           ; SOURCE LINE # 1085
0022 803B              SJMP    ?C0066
0024         ?C0058:
0024 900000      R     MOV     DPTR,#no_bytes
0027 E0                MOVX    A,@DPTR
0028 D3                SETB    C
0029 9402              SUBB    A,#02H
002B 4045              JC      ?C0059
                                           ; SOURCE LINE # 1086
                                           ; SOURCE LINE # 1087
002D 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 1088
0030 7FAD              MOV     R7,#0ADH
0032 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 1089
0035 900000      R     MOV     DPTR,#p
0038 E0                MOVX    A,@DPTR
0039 FB                MOV     R3,A
003A A3                INC     DPTR
003B E0                MOVX    A,@DPTR
003C FA                MOV     R2,A
003D A3                INC     DPTR
003E E0                MOVX    A,@DPTR
003F F9                MOV     R1,A
0040 120000      E     LCALL   ?C?CLDPTR
0043 FF                MOV     R7,A
0044 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 1090
0047 900000      R     MOV     DPTR,#p
004A E0                MOVX    A,@DPTR
004B FB                MOV     R3,A
004C A3                INC     DPTR
004D E0                MOVX    A,@DPTR
004E FA                MOV     R2,A
004F A3                INC     DPTR
0050 E0                MOVX    A,@DPTR
0051 F9                MOV     R1,A
0052 900001            MOV     DPTR,#01H
0055 120000      E     LCALL   ?C?CLDOPTR
0058 FF                MOV     R7,A
0059 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 1091
                                           ; SOURCE LINE # 1093
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 86  

005C 120000      R     LCALL   L?0078
                                           ; SOURCE LINE # 1094
005F         ?C0066:
005F 900000      R     MOV     DPTR,#no_bytes
0062 E0                MOVX    A,@DPTR
0063 24FE              ADD     A,#0FEH
0065 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1095
0066 900000      R     MOV     DPTR,#p+01H
0069 E4                CLR     A
006A 75F002            MOV     B,#02H
006D 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 1097
0070 80B2              SJMP    ?C0058
0072         ?C0059:
                                           ; SOURCE LINE # 1099
0072 900000      R     MOV     DPTR,#p
0075 E0                MOVX    A,@DPTR
0076 FB                MOV     R3,A
0077 A3                INC     DPTR
0078 E0                MOVX    A,@DPTR
0079 FA                MOV     R2,A
007A A3                INC     DPTR
007B E0                MOVX    A,@DPTR
007C F9                MOV     R1,A
007D 120000      E     LCALL   ?C?CLDPTR
0080 FF                MOV     R7,A
0081 900001            MOV     DPTR,#01H
0084 120000      E     LCALL   ?C?CLDOPTR
0087 FD                MOV     R5,A
0088 020000      R     LJMP    _Auto_Add_IncB_EBSY
             ; FUNCTION _AAI_Write (END)

             ; FUNCTION _Byte_Write1 (BEGIN)
                                           ; SOURCE LINE # 1153
0000 900000      R     MOV     DPTR,#Dst
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1154
                                           ; SOURCE LINE # 1155
0006 120000      R     LCALL   WREN
                                           ; SOURCE LINE # 1156
0009 900000      R     MOV     DPTR,#Dst
000C 120000      R     LCALL   L?0073
                                           ; SOURCE LINE # 1157
000F 020000      R     LJMP    Wait_Busy
             ; FUNCTION _Byte_Write1 (END)

             ; FUNCTION _AAI_Write1 (BEGIN)
                                           ; SOURCE LINE # 1166
0000 900000      R     MOV     DPTR,#Dst
0003 120000      E     LCALL   ?C?LSTXDATA
0006 900000      R     MOV     DPTR,#p
                                           ; SOURCE LINE # 1167
                                           ; SOURCE LINE # 1169
0009 120000      R     LCALL   L?0077
                                           ; SOURCE LINE # 1170
000C 900000      R     MOV     DPTR,#Dst
000F 120000      R     LCALL   L?0071
                                           ; SOURCE LINE # 1172
                                           ; SOURCE LINE # 1173
                                           ; SOURCE LINE # 1175
0012 803E              SJMP    ?C0067
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 87  

0014         ?C0062:
0014 900000      R     MOV     DPTR,#no_bytes
0017 E0                MOVX    A,@DPTR
0018 D3                SETB    C
0019 9402              SUBB    A,#02H
001B 4048              JC      ?C0063
                                           ; SOURCE LINE # 1176
                                           ; SOURCE LINE # 1177
001D 120000      R     LCALL   CE_Low
                                           ; SOURCE LINE # 1178
0020 7FAD              MOV     R7,#0ADH
0022 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 1179
0025 900000      R     MOV     DPTR,#p
0028 E0                MOVX    A,@DPTR
0029 FB                MOV     R3,A
002A A3                INC     DPTR
002B E0                MOVX    A,@DPTR
002C FA                MOV     R2,A
002D A3                INC     DPTR
002E E0                MOVX    A,@DPTR
002F F9                MOV     R1,A
0030 120000      E     LCALL   ?C?CLDPTR
0033 FF                MOV     R7,A
0034 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 1180
0037 900000      R     MOV     DPTR,#p
003A E0                MOVX    A,@DPTR
003B FB                MOV     R3,A
003C A3                INC     DPTR
003D E0                MOVX    A,@DPTR
003E FA                MOV     R2,A
003F A3                INC     DPTR
0040 E0                MOVX    A,@DPTR
0041 F9                MOV     R1,A
0042 900001            MOV     DPTR,#01H
0045 120000      E     LCALL   ?C?CLDOPTR
0048 FF                MOV     R7,A
0049 120000      R     LCALL   _Send_Byte
                                           ; SOURCE LINE # 1181
004C 120000      R     LCALL   CE_High
                                           ; SOURCE LINE # 1183
004F 120000      R     LCALL   Poll_SO
                                           ; SOURCE LINE # 1184
0052         ?C0067:
0052 900000      R     MOV     DPTR,#no_bytes
0055 E0                MOVX    A,@DPTR
0056 24FE              ADD     A,#0FEH
0058 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1185
0059 900000      R     MOV     DPTR,#p+01H
005C E4                CLR     A
005D 75F002            MOV     B,#02H
0060 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 1187
0063 80AF              SJMP    ?C0062
0065         ?C0063:
                                           ; SOURCE LINE # 1189
0065 900000      R     MOV     DPTR,#p
0068 E0                MOVX    A,@DPTR
0069 FB                MOV     R3,A
006A A3                INC     DPTR
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 88  

006B E0                MOVX    A,@DPTR
006C FA                MOV     R2,A
006D A3                INC     DPTR
006E E0                MOVX    A,@DPTR
006F F9                MOV     R1,A
0070 120000      E     LCALL   ?C?CLDPTR
0073 FF                MOV     R7,A
0074 900001            MOV     DPTR,#01H
0077 120000      E     LCALL   ?C?CLDOPTR
007A FD                MOV     R5,A
007B 020000      R     LJMP    _Auto_Add_IncB_EBSY
             ; FUNCTION _AAI_Write1 (END)

             ; FUNCTION FRAM_TEST (BEGIN)
                                           ; SOURCE LINE # 1251
                                           ; SOURCE LINE # 1252
                                           ; SOURCE LINE # 1254
0000 7D08              MOV     R5,#08H
0002 120000      R     LCALL   L?0075
0005 900000      R     MOV     DPTR,#FRAM_BUFF
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1255
000A 7F01              MOV     R7,#01H
000C 7E00              MOV     R6,#00H
000E 120000      E     LCALL   _delay_nms
                                           ; SOURCE LINE # 1257
0011 7D09              MOV     R5,#09H
0013 120000      R     LCALL   L?0075
0016 900000      R     MOV     DPTR,#FRAM_BUFF+01H
0019 EF                MOV     A,R7
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1259
001B 7F01              MOV     R7,#01H
001D 7E00              MOV     R6,#00H
001F 120000      E     LCALL   _delay_nms
                                           ; SOURCE LINE # 1260
0022 7F00              MOV     R7,#00H
0024 7E00              MOV     R6,#00H
0026 7D0A              MOV     R5,#0AH
0028 7C00              MOV     R4,#00H
002A 120000      R     LCALL   _Read
002D 900000      R     MOV     DPTR,#FRAM_BUFF+02H
0030 EF                MOV     A,R7
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1261
0032 7F01              MOV     R7,#01H
0034 7E00              MOV     R6,#00H
0036 120000      E     LCALL   _delay_nms
                                           ; SOURCE LINE # 1262
0039 7B01              MOV     R3,#01H
003B 7A00        R     MOV     R2,#HIGH FRAM_BUFF
003D 7900        R     MOV     R1,#LOW FRAM_BUFF
003F 7D03              MOV     R5,#03H
0041 020000      E     LJMP    _Send_Data
             ; FUNCTION FRAM_TEST (END)

C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 89  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


WREN_Check . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0000H  2
P0 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0080H  1
P1 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0090H  1
P2 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A0H  1
_Send_Byte . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0010H  -----
  out. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
P3 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B0H  1
_Byte_Write. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  byte . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0004H  1
int8 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
_STIndicationData. . . . . . . . . . .  * TAG *  -----  STRUCT   -----  5
  byIndicationSecAddr. . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  byIndicationRoomAddr . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  byIndicationBedAddr. . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  byCallCmd. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  byState. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
IE . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
Read_Status_Register . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  byte . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
pSTEepromCfgData . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
Get_Byte . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0020H  -----
  in . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
IP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
_STVoicePlay . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  20
  byVoiceData. . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  16
  byVoicePosition. . . . . . . . . . .  MEMBER   -----  U_CHAR   0010H  1
  byVoiceSize. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0011H  1
  byVS1003State. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0012H  1
  byVoiceTimes . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0013H  1
CE_Low . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0003H  -----
Poll_SO. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0003H  -----
  temp . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
Wait_Busy. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0000H  2
Hold_Low . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
pSTIndicationData. . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
STEepromCfgData. . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  1
  byInitFlag . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
CCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
uint32 . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
Jedec_ID_Read. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  temp . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
uint16 . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
WREN_AAI_Check . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0000H  2
pSTVoicePlay . . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
FRAM_BUFF. . . . . . . . . . . . . . .  PUBLIC   XDATA  ARRAY    0000H  32
STIndicationData . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  5
  byIndicationSecAddr. . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  byIndicationRoomAddr . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  byIndicationBedAddr. . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  byCallCmd. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  byState. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
int32. . . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 90  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


DBSY . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
EBSY . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
int16. . . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
SCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
TCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
_Byte_Write1 . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  byte . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0004H  1
WRDI . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
MISO . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
_AAI_Write . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  p. . . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0004H  3
  no_bytes . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0007H  1
STVoicePlay. . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  20
  byVoiceData. . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  16
  byVoicePosition. . . . . . . . . . .  MEMBER   -----  U_CHAR   0010H  1
  byVoiceSize. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0011H  1
  byVS1003State. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0012H  1
  byVoiceTimes . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0013H  1
WP_Low . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
WREN . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0008H  -----
EWSR . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_delay_nms . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Auto_Add_IncA . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  byte1. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0004H  1
  byte2. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0005H  1
_Auto_Add_IncB . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  byte1. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  byte2. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
_Sector_Erase. . . . . . . . . . . . .  PUBLIC   CODE   PROC     000BH  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
ACC. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E0H  1
FRAM_TEST. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Wait_Busy_AAI. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0000H  2
_delay_nus . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_HighSpeed_Read_Cont . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  no_bytes . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0004H  4
  pBuffer. . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0008H  3
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   000BH  4
_WRSR. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  byte . . . . . . . . . . . . . . . .  AUTO     XDATA  INT      0000H  2
_Block_Erase_32K . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
_Byte_Program. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0011H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  byte . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0004H  1
_HighSpeed_Read. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  byte . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
pSTBusFreq . . . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
_Block_Erase_64K . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
pSTTimerOut. . . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 91  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_Auto_Add_IncA_EBSY. . . . . . . . . .  PUBLIC   CODE   PROC     0025H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  byte1. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0004H  1
  byte2. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0005H  1
Chip_Erase . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_Auto_Add_IncB_EBSY. . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  byte1. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  byte2. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
STBusFreq. . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  7
  bySndSecAddr . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  bySndRoomAddr. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  bySndBedAddr . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  byCmd. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  byRecSecAddr . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  byRecRoomAddr. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  byRecBedAddr . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
STTimerOut . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  byTimerOutSet. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  byTimerOut . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  byTimerOutCount. . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
_Send_Data . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
CE_High. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_AAI_Write1. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  p. . . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0004H  3
  no_bytes . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0007H  1
_Read_ID . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ID_addr. . . . . . . . . . . . . . .  AUTO     XDATA  INT      0000H  2
  byte . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
UnWP . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Unhold . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
pSTLocalControl. . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
_SPI_WriteByte . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Read_Cont . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  no_bytes . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0004H  4
  pBuffer. . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0008H  3
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   000BH  4
SST25VF_Init . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
SST25VF_CS . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
uint8. . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
PSW. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D0H  1
STLocalControl . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  36
  byChar1. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  uiShortType. . . . . . . . . . . . .  MEMBER   -----  U_INT    0001H  2
  pbyData. . . . . . . . . . . . . . .  MEMBER   -----  PTR      0003H  2
  stBusDealFreq. . . . . . . . . . . .  MEMBER   -----  STRUCT   0005H  7
  stVoicePlay. . . . . . . . . . . . .  MEMBER   -----  STRUCT   000CH  20
  stCH0TimerOut. . . . . . . . . . . .  MEMBER   -----  STRUCT   0020H  3
  stEepromCfgData. . . . . . . . . . .  MEMBER   -----  STRUCT   0023H  1
_Read. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0006H  -----
  Dst. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  byte . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1947    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V8.08   SST25VF040_2005                                                       02/22/2013 13:09:20 PAGE 92  

   XDATA SIZE       =     32     114
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
