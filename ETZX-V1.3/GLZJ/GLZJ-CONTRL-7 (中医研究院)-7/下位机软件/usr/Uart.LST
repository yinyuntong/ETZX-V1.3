C51 COMPILER V9.00   UART                                                                  02/15/2019 15:09:08 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN Uart.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Uart.c LARGE BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*
   2          ************************Copyright(c)************************
   3          *            ºþÄÏÒ»ÌØµç×Ó¹É·ÝÓÐÏÞ¹«Ë¾
   4          *             All Rights Reserved
   5          *              
   6          *
   7          *-----------------------ÎÄ¼þÐÅÏ¢---------------------------
   8          *ÎÄ¼þÃû³Æ         :Uart.c
   9          *ÎÄ¼þÃèÊö       :´®¿ÚÇý¶¯³ÌÐò
  10          *´´½¨ÈË         :ÒüÔËÍ¬
  11          *´´½¨ÈÕÆÚ       :2009-4-6
  12          *°æ±¾ºÅ           :V1.0
  13          *×¢ÊÍ         :         
  14          *----------------------------------------------------------
  15          *ÐÞ¸ÄÈË       :
  16          *ÐÞ¸ÄÈÕÆÚ       :
  17          *°æ±¾ºÅ           :
  18          *×¢ÊÍ         :
  19          ***********************************************************
  20          */
  21          #define _IN_USART_
  22          #include "config.h"
  23          
  24          //´®¿Ú±äÁ¿¶¨Òå
  25          STUsartCfg  xdata stUsartCfg[2];
  26          
  27          //´®¿Ú0ÅäÖÃ   ÓëÏÂÎ»»úÍ¨Ñ¸
  28          uint8 xdata byUsart0SndBuf[UART0_TX_BUF_SIZE];
  29          
  30          //´®¿Ú1ÅäÖÃ    ÓëÉÏÎ»»úÍ¨Ñ¸
  31          uint8 xdata byUsart1RecBuf[UART1_RX_BUF_SIZE];
  32          uint8 xdata byUsart1SndBuf[UART1_TX_BUF_SIZE];
  33          //uint8   xdata byUsart1RecDealBuf[UART1_RX_DEAL_BUF_SIZE];
  34          
  35          uint8   xdata errtime =0;
  36          
  37          
  38          bit bUsart1RecFinish  = 0;
  39          bit bRS485DataTreat =0;
  40          
  41          /**********************************************************
  42          *º¯ÊýÃû³Æ     :UsartInit  
  43          *º¯ÊýÃèÊö         :´®¿Ú³õÊ¼»¯º¯Êý
  44          *ÊäÈë²ÎÊý       :
  45          *·µ»ØÖµ       :
  46          *È«¾Ö±äÁ¿     :
  47          *µ÷ÓÃÄ£¿é       :
  48          ***********************************************************
  49          *´´½¨ÈË           :ÒüÔËÍ¬
  50          *´´½¨ÈÕÆÚ     :2009-4-6
  51          ***********************************************************
  52          *ÐÞ¸ÄÈË         :
  53          *ÐÞ¸ÄÈÕÆÚ       :
  54          *×¢ÊÍ           :
  55          **********************************************************/
C51 COMPILER V9.00   UART                                                                  02/15/2019 15:09:08 PAGE 2   

  56          void Usart0Init(uint16 uiRs485Brt)
  57          {
  58   1        TR1=0;
  59   1        //´®¿Ú0³õÊ¼»¯
  60   1        stUsartCfg[0].pbyRecBuf = NULL;
  61   1        stUsartCfg[0].pbySndBuf = byUsart0SndBuf; 
  62   1        stUsartCfg[0].uiRecPosition=0;
  63   1        stUsartCfg[0].uiRecLen=0;
  64   1        stUsartCfg[0].byRecCount=0; 
  65   1        stUsartCfg[0].byRecTimeout =0;
  66   1        stUsartCfg[0].uiSndLen  = stUsartCfg[0].uiSndPos  = 0;
  67   1        
  68   1        SCON=0X50;    //¹¤×÷·½Ê½1
  69   1      
  70   1        TMOD&=0X0F;   //TO·½Ê½²»±ä
  71   1        TMOD|=0X20;   //T1 ·½Ê½2 :8Î»×Ô¶¯ÖØÔØ
  72   1      
  73   1      
  74   1      //  TL1 = 0XF6;   //²¨ÌØÂÊ4800  ÔÚ18.432M¾§ÕñµÄÇé¿öÏÂ
  75   1        if(uiRs485Brt>=2400)
  76   1        {
  77   2          AUXR |= T1x12;    //1TÄ£Ê½,×îºó²¨ÌØÂÊÎª:4800*12=57.6K
  78   2          TL1= 256-(CPU_CLK/32/uiRs485Brt );  
  79   2        }
  80   1        
  81   1        else
  82   1        {
  83   2          AUXR  &=  ~T1x12; //T1x12=0; 12TÄ£Ê½
  84   2          TL1= 256-(CPU_CLK/32/12/uiRs485Brt);    
  85   2        }
  86   1      
  87   1      
  88   1        TH1 = TL1;
  89   1          PCON&=  ~SMOD;   //  ;²¨ÌØÂÊ±¶ÔöÑ¡Ôñ    smod=0
  90   1      
  91   1          TF1=0;
  92   1          TR1=1;
  93   1      
  94   1        
  95   1        RI=0;
  96   1        TI=0;
  97   1        REN=1;
  98   1        ES=1; 
  99   1      }
 100          
 101          
 102          void Usart1Init(void)
 103          {
 104   1        //´®¿Ú1³õÊ¼»¯
 105   1      //  AUXR1 |= S2_P4;   //´®¿Ú2ÇÐ»»µ½P4¿Ú
 106   1        stUsartCfg[1].pbyRecBuf = byUsart1RecBuf;
 107   1        stUsartCfg[1].pbySndBuf = byUsart1SndBuf;
 108   1        stUsartCfg[1].byRecState=0;
 109   1        stUsartCfg[1].uiRecPosition=0;
 110   1        stUsartCfg[1].uiRecLen=0;
 111   1        stUsartCfg[1].byRecCount=0; 
 112   1        stUsartCfg[1].byRecTimeout=0;
 113   1        stUsartCfg[1].uiSndLen  = stUsartCfg[1].uiSndPos  = 0;
 114   1      
 115   1        S2CON = 0X50;   //0101 0000 8Î»¿É±ä²¨ÌØÂÊ,ÎÞÆæÅ¼Ð£ÑéÎ»
 116   1        AUXR  &=  ~S2SMOD;  //S2MOD=0;
 117   1        AUXR  |=  BRTx12;   //BRTX12=1; 1TÄ£Ê½,×îºó²¨ÌØÂÊÎª:4800*12=57.6K
C51 COMPILER V9.00   UART                                                                  02/15/2019 15:09:08 PAGE 3   

 118   1        BRT   = 0XF6;
 119   1        AUXR  |=  BRTR;   //Æô¶¯¶ÀÁ¢²¨ÌØÂÊ·¢ÉúÆ÷
 120   1        
 121   1        IE2   |= ES2;
 122   1      }
 123          /**********************************************************
 124          *º¯ÊýÃû³Æ     :UART0(void)  
 125          *º¯ÊýÃèÊö         :´®¿Ú0ÖÐ¶Ïº¯Êý
 126          *ÊäÈë²ÎÊý       :
 127          *·µ»ØÖµ       :
 128          *È«¾Ö±äÁ¿     :stUsartCfg
 129          *µ÷ÓÃÄ£¿é       :
 130          ***********************************************************
 131          *´´½¨ÈË           :ÒüÔËÍ¬
 132          *´´½¨ÈÕÆÚ     :2009-4-6
 133          ***********************************************************
 134          *ÐÞ¸ÄÈË         :
 135          *ÐÞ¸ÄÈÕÆÚ       :
 136          *×¢ÊÍ           :
 137          **********************************************************/
 138          #pragma disable
 139          void UART0(void) interrupt UART_INTNO
 140          {
 141   1        if(RI==1)
 142   1        {  
 143   2          RI=0;
 144   2        }
 145   1        
 146   1        else if(TI==1)
 147   1        {
 148   2          TI=0;
 149   2          stUsartCfg[0].uiSndLen--;
 150   2          stUsartCfg[0].uiSndPos++;
 151   2          if(stUsartCfg[0].uiSndLen!=0)
 152   2          {
 153   3            SBUF = stUsartCfg[0].pbySndBuf[stUsartCfg[0].uiSndPos];       
 154   3            
 155   3          }
 156   2          else 
 157   2          {//Ò»Ö¡Êý¾Ý·¢ËÍÍê³É
 158   3      
 159   3            if((stUsartCfg[0].pbySndBuf[REC_ROOM_POSITION]== 0xf0) ||(stUsartCfg[0].pbySndBuf[REC_ROOM_POSITION]== 
             -YHFJ_ADDR2))  //×ßÀÈÏÔÊ¾ÆÁµÄÊý¾Ý»òÒ½»¤·Ö»úµÄÊý¾Ý
 160   3            {
 161   4              stLocalControl.byWaitRS485AckDTime = 0;   //¹ã²¥Êý¾Ý²»ÔÙµÈÊÌ
 162   4              stLocalControl.byUsart1SdResultDTime = 50;  //50*20 = 1000ms
 163   4            }
 164   3            else
 165   3            {
 166   4              if(stUsartCfg[0].pbySndBuf[DATA4_POSITION]==0x00) //²»ÊÇ½áÊøÖ¡
 167   4              {
 168   5      
 169   5                stLocalControl.byWaitRS485AckDTime = 0;
 170   5                if(stUsartCfg[0].pbySndBuf[DATA2_POSITION]==1)
 171   5                {
 172   6                  //µÚÒ»Ö¡Êý¾ÝÒªÇå´æ´¢Æ÷ £¬²Á³ý32KµäÐÍ18ms
 173   6                  stLocalControl.byUsart1SdResultDTime = 20;  //20*20 = 400ms
 174   6                }
 175   5                    
 176   5                else stLocalControl.byUsart1SdResultDTime = 10; //10*20 = 200ms
 177   5              }
 178   4      
C51 COMPILER V9.00   UART                                                                  02/15/2019 15:09:08 PAGE 4   

 179   4              else 
 180   4              {//ÊÇ½áÊøÖ¡
 181   5        //        DE0=0;    //  Õû¸öÊý¾Ý·¢ËÍÍê³Éºó²Å½ûÖ¹R485·¢ËÍ  
 182   5                if(stUsartCfg[0].pbySndBuf[CMD_POSITION]==CMD_DISPLAY_FORM)
 183   5                {//ÊÇ·¢ËÍ´²Í··Ö»ú¸ñÊ½
 184   6                  stLocalControl.byUsart1SdResultDTime = 10;  //10*20 = 200ms   Îª·Ö»ú±£´æÊý¾Ý¶ø±£ÁôÊ±¼äÒÔÃâ´®¿Ú½ÓÊÕ»º³
             -åÇøµÄÊý¾Ý±»¸Ç
 185   6                }
 186   5              }
 187   4            }
 188   3          }
 189   2        }
 190   1      } 
 191          
 192          
 193          /**********************************************************
 194          *º¯ÊýÃû³Æ     :UART1(void)  
 195          *º¯ÊýÃèÊö         :´®¿Ú2ÖÐ¶Ïº¯Êý
 196          *ÊäÈë²ÎÊý       :
 197          *·µ»ØÖµ       :
 198          *È«¾Ö±äÁ¿     :stUsartCfg
 199          *µ÷ÓÃÄ£¿é       :
 200          ***********************************************************
 201          *´´½¨ÈË           :ÒüÔËÍ¬
 202          *´´½¨ÈÕÆÚ     :2009-4-6
 203          ***********************************************************
 204          *ÐÞ¸ÄÈË         :
 205          *ÐÞ¸ÄÈÕÆÚ       :
 206          *×¢ÊÍ           :
 207          **********************************************************/
 208          #pragma disable
 209          void UART1(void) interrupt UART2_INTNO
 210          {
 211   1        uint8 xdata byTemp;
 212   1      
 213   1        if(S2CON&S2RI)
 214   1        {  
 215   2          S2CON &= ~S2RI;
 216   2          byTemp = S2BUF;
 217   2      
 218   2          
 219   2      /*    if(stUsartCfg[1].uiRecPosition!=0)  //²»ÊÇÆðÊ¼×Ö½Ú
 220   2          {
 221   2            if(stUsartCfg[1].byRecTimeout==0)
 222   2            {//³¬Ê±µ½ÁË
 223   2              stUsartCfg[1].byRecState=0;
 224   2              stUsartCfg[1].uiRecPosition=0;
 225   2              return;
 226   2            }
 227   2          }
 228   2      */    
 229   2          stUsartCfg[1].byRecTimeout=200; //ÓÖ¿ªÊ¼¶¨Ê±5ms*200=1000ms
 230   2          byUsart1RecBuf[stUsartCfg[1].uiRecPosition++] = byTemp;   
 231   2          switch(stUsartCfg[1].byRecState)
 232   2          {
 233   3            case 0:               
 234   3              if(byTemp == START_BYTE1)
 235   3              {
 236   4                stUsartCfg[1].byRecState = 1;
 237   4      //          byCount = 7;
 238   4                stUsartCfg[1].byRecCount = 6;
 239   4              }
C51 COMPILER V9.00   UART                                                                  02/15/2019 15:09:08 PAGE 5   

 240   3              else
 241   3              {
 242   4                stUsartCfg[1].uiRecPosition = 0;
 243   4              }
 244   3              break;
 245   3            case 1:               
 246   3              if(--stUsartCfg[1].byRecCount == 0)
 247   3              { //ÊÕÍêµØÖ·Êý¾Ý                                    
 248   4                stUsartCfg[1].byRecState = 2;
 249   4                stUsartCfg[1].byRecCount = 3; 
 250   4              }
 251   3              break;        
 252   3            case 2:       
 253   3              stUsartCfg[1].byRecCount--;
 254   3              if(stUsartCfg[1].byRecCount == 1)
 255   3              { 
 256   4                stUsartCfg[1].uiRecLen = byTemp<<8; 
 257   4              }
 258   3              else if(stUsartCfg[1].byRecCount == 0)
 259   3              { //½ÓÊÕÍêÊý¾Ý³¤¶È
 260   4                //stUsartCfg[0].uiRecLen += (byTemp << 8);      //»ñÈ¡Êý¾ÝÓò³¤¶ÈÖµ
 261   4                stUsartCfg[1].uiRecLen += byTemp;
 262   4                if(stUsartCfg[1].uiRecLen <= MAX_UART1_DATA_LEN)          
 263   4                { //Êý¾Ý³¤¶È·ûºÏÒªÇó
 264   5                  stUsartCfg[1].byRecState = 3;
 265   5                  stUsartCfg[1].uiRecLen += 2; 
 266   5                }
 267   4                else
 268   4                {
 269   5                  stUsartCfg[1].byRecState = 0;
 270   5                  stUsartCfg[1].uiRecPosition = 0;
 271   5                }                   
 272   4              }
 273   3              break;      
 274   3            case 3:       
 275   3              if(--stUsartCfg[1].uiRecLen == 0)
 276   3              { //½ÓÊÕÍêËùÓÐÊý¾Ý
 277   4                if(END_BYTE == byTemp)
 278   4                { //½áÊøÎ»ÕýÈ·
 279   5                  bUsart1RecFinish=1; 
 280   5                }
 281   4                stUsartCfg[1].byRecState = 0;
 282   4                stUsartCfg[1].uiRecPosition = 0;      
 283   4              }
 284   3              break;      
 285   3            default:
 286   3              stUsartCfg[1].byRecState = 0;
 287   3              stUsartCfg[1].uiRecPosition = 0;
 288   3              break;    
 289   3          }
 290   2        }
 291   1      
 292   1      
 293   1        if(S2CON&S2TI)
 294   1        { 
 295   2          S2CON &= ~S2TI;
 296   2          stUsartCfg[1].uiSndLen--;
 297   2          stUsartCfg[1].uiSndPos++;   
 298   2          if(stUsartCfg[1].uiSndLen!=0)
 299   2          {    
 300   3      
 301   3            S2BUF = stUsartCfg[1].pbySndBuf[stUsartCfg[1].uiSndPos];      
C51 COMPILER V9.00   UART                                                                  02/15/2019 15:09:08 PAGE 6   

 302   3          }   
 303   2        }
 304   1      }
 305          /**********************************************************
 306          *º¯ÊýÃû³Æ     :GetPskCrc  
 307          *º¯ÊýÃèÊö         :¼ÆËãÊý¾ÝèåÀÛ¼ÓÐ£ÑéºÍ
 308          *ÊäÈë²ÎÊý       :pstDataFreq:´ý¼ÆËãµÄÊý¾ÝèåÖ¸Õë
 309          *·µ»ØÖµ       :ÀÛ¼ÓÐ£ÑéºÍ
 310          *È«¾Ö±äÁ¿     :stUsartCfg
 311          *µ÷ÓÃÄ£¿é       :
 312          ***********************************************************
 313          *´´½¨ÈË           :ÒüÔËÍ¬
 314          *´´½¨ÈÕÆÚ     :2009-4-6
 315          ***********************************************************
 316          *ÐÞ¸ÄÈË         :
 317          *ÐÞ¸ÄÈÕÆÚ       :
 318          *×¢ÊÍ           :
 319          **********************************************************/
 320          uint8 GetPskCrc(pSTUartFreq pstDataFreq)
 321          {
 322   1        uint8  *pbyData;
 323   1        uint16 uiLen;
 324   1        uint8  byCrc = 0;
 325   1        
 326   1        pbyData = &(pstDataFreq->bySndSecAddr);
 327   1        uiLen = pstDataFreq->uiLen + HEAD_SIZE;
 328   1        while(uiLen--)
 329   1        {
 330   2          byCrc += *pbyData++;
 331   2        } 
 332   1        return(byCrc);
 333   1      }
 334          /**********************************************************
 335          *º¯ÊýÃû³Æ     :CheckPsk 
 336          *º¯ÊýÃèÊö         :¼ìÑéÊý¾Ý°üµÄÕýÈ·ÐÍ
 337          *ÊäÈë²ÎÊý       :pstDataFreq:´ýÐ£ÑéµÄÊý¾ÝèåÖ¸Õë
 338          *·µ»ØÖµ       :true:Êý¾Ý°üÕýÈ·,false:Êý¾Ý°üÓÐÎó
 339          *È«¾Ö±äÁ¿     :
 340          *µ÷ÓÃÄ£¿é       :
 341          ***********************************************************
 342          *´´½¨ÈË           :ÒüÔËÍ¬
 343          *´´½¨ÈÕÆÚ     :2009-4-6
 344          ***********************************************************
 345          *ÐÞ¸ÄÈË         :
 346          *ÐÞ¸ÄÈÕÆÚ       :
 347          *×¢ÊÍ           :
 348          **********************************************************/
 349          uint8 CheckPsk(pSTUartFreq pstDataFreq)
 350          {
 351   1        uint8* pbyData;
 352   1        uint16 uiLen;
 353   1        uint8  byCrc = 0;
 354   1        
 355   1        pbyData = &(pstDataFreq->bySndSecAddr);
 356   1        uiLen = pstDataFreq->uiLen + HEAD_SIZE;
 357   1        while(uiLen--)
 358   1        {
 359   2          byCrc += *pbyData++;
 360   2        }
 361   1        if(byCrc != *pbyData)
 362   1        {
 363   2          return(false);
C51 COMPILER V9.00   UART                                                                  02/15/2019 15:09:08 PAGE 7   

 364   2        }
 365   1        return(true); 
 366   1      }
 367          
 368          /**********************************************************
 369          *º¯ÊýÃû³Æ     :UsartSndCmd  
 370          *º¯ÊýÃèÊö         :´®¿Ú·¢ËÍÃüÁî¸øPC»ú
 371          *ÊäÈë²ÎÊý       
 372                                              byCmd:ÃüÁî
 373                                              byLen:Êý¾Ý³¤¶È
 374                                              pData:Êý¾ÝÖ¸Õë
 375          *·µ»ØÖµ       :
 376          *È«¾Ö±äÁ¿     :
 377          *µ÷ÓÃÄ£¿é       :
 378          ***********************************************************
 379          *´´½¨ÈË           :ÒüÔËÍ¬
 380          *´´½¨ÈÕÆÚ     :2009-4-6
 381          ***********************************************************
 382          *ÐÞ¸ÄÈË         :
 383          *ÐÞ¸ÄÈÕÆÚ       :
 384          *×¢ÊÍ           :
 385          **********************************************************/
 386          void Usart1SndCmd(uint8 Cmd,uint8 byLen,uint8 *pData)
 387          {
 388   1        pSTUartFreq pstDataFreq;
 389   1        errtime =0xff;
 390   1        while(stUsartCfg[1].uiSndLen!=0)  
 391   1        {//ÓÐÊý¾ÝÕýÔÚ·¢ËÍÖÐ
 392   2          Delayms(1);
 393   2          WDT_CONTR = 0x3e;   //¿´ÃÅ¹·¶¨Ê±2.5s@20M  
 394   2          if(--errtime ==0) break;
 395   2        }
 396   1        pstDataFreq = (pSTUartFreq)byUsart1SndBuf;
 397   1        
 398   1        pstDataFreq->byStartByte1   =START_BYTE1;
 399   1        pstDataFreq->bySndSecAddr   =stLocalControl.stEepromCfgData.bySelfSecAddr;
 400   1        pstDataFreq->bySndRoomAddr  =stLocalControl.stEepromCfgData.bySelfRoomAddr;
 401   1        pstDataFreq->bySndBedAddr   =stLocalControl.stEepromCfgData.bySelfBedAddr;
 402   1        pstDataFreq->byRecSecAddr   =stLocalControl.stEepromCfgData.bySelfSecAddr;
 403   1        pstDataFreq->byRecRoomAddr  =PC_ADDR2;
 404   1        pstDataFreq->byRecBedAddr   =PC_ADDR3;  
 405   1        pstDataFreq->byCmd      =Cmd;   //ÃüÁî
 406   1        pstDataFreq->uiLen      =byLen;
 407   1        if(byLen)
 408   1        {
 409   2          memcpy(pstDataFreq->byData,pData,byLen);  //¸´ÖÆÊý¾Ý
 410   2        }
 411   1        pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
 412   1        pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE;
 413   1        
 414   1        stUsartCfg[1].uiSndLen  = pstDataFreq->uiLen+EXT_SIZE;
 415   1        stUsartCfg[1].uiSndPos = 0;   //´ÓÊý¾ÝÖ¡Í·²¿¿ªÊ¼·¢ËÍÊý¾Ý
 416   1      
 417   1        S2CON &= ~S2TI;
 418   1        S2BUF=pstDataFreq->byStartByte1;    
 419   1      }
 420          
 421          
 422          /**********************************************************
 423          *º¯ÊýÃû³Æ     :UsartSndEnter  
 424          *º¯ÊýÃèÊö         :´®¿Ú·¢ËÍÈ·ÈÏÃüÁî
 425          *ÊäÈë²ÎÊý       :byPort :´®¿ÚºÅ
C51 COMPILER V9.00   UART                                                                  02/15/2019 15:09:08 PAGE 8   

 426                                              byOriginalCmd:Ô­ÃüÁî
 427                                              byData:Êý¾Ý
 428          *·µ»ØÖµ       :
 429          *È«¾Ö±äÁ¿     :
 430          *µ÷ÓÃÄ£¿é       :
 431          ***********************************************************
 432          *´´½¨ÈË           :ÒüÔËÍ¬
 433          *´´½¨ÈÕÆÚ     :2009-4-6
 434          ***********************************************************
 435          *ÐÞ¸ÄÈË         :
 436          *ÐÞ¸ÄÈÕÆÚ       :
 437          *×¢ÊÍ           :
 438          **********************************************************/
 439          void Usart1SndEnter(uint8 byOriginalCmd,uint8 byData)
 440          {
 441   1        pSTUartFreq pstDataFreq;
 442   1        errtime =0xff;
 443   1        while(stUsartCfg[1].uiSndLen!=0)  
 444   1        {//ÓÐÊý¾ÝÕýÔÚ·¢ËÍÖÐ
 445   2          Delayms(1);
 446   2          WDT_CONTR = 0x3e;   //¿´ÃÅ¹·¶¨Ê±2.5s@20M  
 447   2          if(--errtime ==0) break;
 448   2      
 449   2        }
 450   1        pstDataFreq = (pSTUartFreq)byUsart1SndBuf;
 451   1        
 452   1        pstDataFreq->byStartByte1   =START_BYTE1;
 453   1        pstDataFreq->bySndSecAddr   =stLocalControl.stEepromCfgData.bySelfSecAddr;
 454   1        pstDataFreq->bySndRoomAddr  =stLocalControl.stEepromCfgData.bySelfRoomAddr;
 455   1        pstDataFreq->bySndBedAddr   =stLocalControl.stEepromCfgData.bySelfBedAddr;
 456   1        pstDataFreq->byRecSecAddr   =stLocalControl.stEepromCfgData.bySelfSecAddr;
 457   1        pstDataFreq->byRecRoomAddr  =PC_ADDR2;
 458   1        pstDataFreq->byRecBedAddr   =PC_ADDR3;  
 459   1        pstDataFreq->byCmd      =CMD_ENTER_PC;    //È·ÈÏÃüÁî
 460   1        pstDataFreq->uiLen      =0X02;
 461   1        pstDataFreq->byData[0]    =byOriginalCmd; //Ô­ÃüÁî  
 462   1        pstDataFreq->byData[1]    =byData;    //³É¹¦»òÊ§°Ü
 463   1        pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
 464   1        pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE;
 465   1        
 466   1        stUsartCfg[1].uiSndLen  = pstDataFreq->uiLen+EXT_SIZE;
 467   1        stUsartCfg[1].uiSndPos = 0;   //´ÓÊý¾ÝÖ¡Í·²¿¿ªÊ¼·¢ËÍÊý¾Ý
 468   1      
 469   1        S2CON &= ~S2TI;
 470   1        S2BUF=pstDataFreq->byStartByte1;    
 471   1      }
 472          /**********************************************************
 473          *º¯ÊýÃû³Æ     :Usart1SndResult  
 474          *º¯ÊýÃèÊö         :´®¿Ú·¢ËÍ½á¹ûÃüÁî
 475          *ÊäÈë²ÎÊý       :byPort :´®¿ÚºÅ
 476                                              byOriginalCmd:Ô­ÃüÁî
 477                                              byData:Êý¾Ý
 478          *·µ»ØÖµ       :
 479          *È«¾Ö±äÁ¿     :
 480          *µ÷ÓÃÄ£¿é       :
 481          ***********************************************************
 482          *´´½¨ÈË           :ÒüÔËÍ¬
 483          *´´½¨ÈÕÆÚ     :2009-4-6
 484          ***********************************************************
 485          *ÐÞ¸ÄÈË         :
 486          *ÐÞ¸ÄÈÕÆÚ       :
 487          *×¢ÊÍ           :
C51 COMPILER V9.00   UART                                                                  02/15/2019 15:09:08 PAGE 9   

 488          **********************************************************/
 489          void Usart1SndResult(uint8 byOriginalCmd,uint8 byData)
 490          {
 491   1        pSTUartFreq pstDataFreq;
 492   1        errtime =0xff;
 493   1        while(stUsartCfg[1].uiSndLen!=0)  
 494   1        {//ÓÐÊý¾ÝÕýÔÚ·¢ËÍÖÐ
 495   2          Delayms(1);
 496   2          WDT_CONTR = 0x3e;   //¿´ÃÅ¹·¶¨Ê±2.5s@20M  
 497   2          if(--errtime ==0) break;
 498   2        }
 499   1        pstDataFreq = (pSTUartFreq)byUsart1SndBuf;
 500   1      
 501   1        pstDataFreq->byStartByte1   =START_BYTE1;
 502   1      /*  pstDataFreq->bySndSecAddr   =stLocalControl.stEepromCfgData.bySelfSecAddr;
 503   1        pstDataFreq->bySndRoomAddr  =stLocalControl.stEepromCfgData.bySelfRoomAddr;
 504   1        pstDataFreq->bySndBedAddr   =stLocalControl.stEepromCfgData.bySelfBedAddr;
 505   1        if( (byUsart1RecBuf[CMD_POSITION] == CMD_OPEN_LCD) || (byUsart1RecBuf[CMD_POSITION] == CMD_CLOSE_LCD) || 
 506   1          (byUsart1RecBuf[CMD_POSITION] == CMD_CLEAR_LCD)|| (byUsart1RecBuf[CMD_POSITION] == CMD_CLEAR_HANDLE_LCD)
             -||
 507   1          (byUsart1RecBuf[CMD_POSITION] == CMD_CLEAR_MK_LCD) ||
 508   1          (byUsart1RecBuf[CMD_POSITION] == CMD_START_VOICE)||  (byUsart1RecBuf[CMD_POSITION] == CMD_STOP_VOICE)||
 509   1          (byUsart1RecBuf[CMD_POSITION] == CMD_MUSIC_PLAY) ||  (byUsart1RecBuf[CMD_POSITION] == CMD_BROADCAST1) ||
 510   1          (byUsart1RecBuf[CMD_POSITION] == CMD_BROADCAST2) ||  (byUsart1RecBuf[CMD_POSITION] == CMD_BROADCAST3) 
 511   1          )*/
 512   1        {//Îª±ÜÃâ¹ÜÀíÖ÷»úÇøºÅÓëÉÏÎ»»úÇøºÅ²»Ò»ÖÂ£¬½«»Ø½á¹ûÃüÊ±µÄÔ´µØÖ·Ö±½ÓÎªÊÕµ½´®¿ÚÊý¾ÝµÄÄ¿µÄµØ±ê
 513   2          pstDataFreq->bySndSecAddr   =byUsart1RecBuf[REC_SEC_POSITION];
 514   2          pstDataFreq->bySndRoomAddr  =byUsart1RecBuf[REC_ROOM_POSITION];
 515   2          pstDataFreq->bySndBedAddr   =byUsart1RecBuf[REC_BED_POSITION];  
 516   2        } 
 517   1        pstDataFreq->byRecSecAddr   =stLocalControl.stEepromCfgData.bySelfSecAddr;
 518   1        pstDataFreq->byRecRoomAddr  =PC_ADDR2;
 519   1        pstDataFreq->byRecBedAddr   =PC_ADDR3;
 520   1        pstDataFreq->byCmd      =CMD_RESULT_PC;   //È·ÈÏÃüÁî
 521   1        pstDataFreq->uiLen      =0X02;
 522   1        pstDataFreq->byData[0]    =byOriginalCmd; //Ô­ÃüÁî  
 523   1        pstDataFreq->byData[1]    =byData;    //³É¹¦»òÊ§°Ü
 524   1        pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
 525   1        pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE; 
 526   1        stUsartCfg[1].uiSndLen  = pstDataFreq->uiLen+EXT_SIZE;
 527   1        stUsartCfg[1].uiSndPos = 0;   //´ÓÊý¾ÝÖ¡Í·²¿¿ªÊ¼·¢ËÍÊý¾Ý
 528   1      
 529   1        S2CON &= ~S2TI;
 530   1        S2BUF=pstDataFreq->byStartByte1;    
 531   1      }
 532          
 533          
 534          /**********************************************************
 535          *º¯ÊýÃû³Æ     :Usart1SndRS485Result 
 536          *º¯ÊýÃèÊö         :´®¿Ú·¢ËÍ½á¹ûÃüÁî
 537          *ÊäÈë²ÎÊý       :byPort :´®¿ÚºÅ
 538                                              byOriginalCmd:Ô­ÃüÁî
 539                                              byData:Êý¾Ý
 540          *·µ»ØÖµ       :
 541          *È«¾Ö±äÁ¿     :
 542          *µ÷ÓÃÄ£¿é       :
 543          ***********************************************************
 544          *´´½¨ÈË           :ÒüÔËÍ¬
 545          *´´½¨ÈÕÆÚ     :2009-4-6
 546          ***********************************************************
 547          *ÐÞ¸ÄÈË         :
 548          *ÐÞ¸ÄÈÕÆÚ       :
C51 COMPILER V9.00   UART                                                                  02/15/2019 15:09:08 PAGE 10  

 549          *×¢ÊÍ           :
 550          **********************************************************/
 551          void Usart1SndRS485Result(uint8 byOriginalCmd,uint8 byData)
 552          {
 553   1        pSTUartFreq pstDataFreq;
 554   1      
 555   1        errtime =0xff;
 556   1        while(stUsartCfg[1].uiSndLen!=0)  
 557   1        {//ÓÐÊý¾ÝÕýÔÚ·¢ËÍÖÐ
 558   2          Delayms(1);
 559   2          WDT_CONTR = 0x3e;   //¿´ÃÅ¹·¶¨Ê±2.5s@20M  
 560   2          if(--errtime ==0) break;
 561   2        }
 562   1        pstDataFreq = (pSTUartFreq)byUsart1SndBuf;
 563   1      
 564   1        pstDataFreq->byStartByte1 =START_BYTE1;
 565   1        pstDataFreq->bySndSecAddr =stLocalControl.stRS485Addr.bySecAddr;
 566   1        pstDataFreq->bySndRoomAddr  =stLocalControl.stRS485Addr.byRoomAddr;
 567   1        pstDataFreq->bySndBedAddr =stLocalControl.stRS485Addr.byBedAddr;
 568   1        pstDataFreq->byRecSecAddr =stLocalControl.stEepromCfgData.bySelfSecAddr;
 569   1        pstDataFreq->byRecRoomAddr  =PC_ADDR2;
 570   1        pstDataFreq->byRecBedAddr =PC_ADDR3;
 571   1        pstDataFreq->byCmd      =CMD_RESULT_PC;   //È·ÈÏÃüÁî
 572   1        pstDataFreq->uiLen      =0X02;
 573   1        pstDataFreq->byData[0]    =byOriginalCmd;
 574   1        pstDataFreq->byData[1]    =byData;    //³É¹¦»òÊ§°Ü
 575   1        pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
 576   1        pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE; 
 577   1        stUsartCfg[1].uiSndLen  = pstDataFreq->uiLen+EXT_SIZE;
 578   1        stUsartCfg[1].uiSndPos = 0;   //´ÓÊý¾ÝÖ¡Í·²¿¿ªÊ¼·¢ËÍÊý¾Ý
 579   1      
 580   1        S2CON &= ~S2TI;
 581   1        S2BUF=pstDataFreq->byStartByte1;
 582   1      
 583   1        stLocalControl.stRS485Addr.byBedAddr=0;   //½á¹û·¢Íê£¬½«485´²ºÅÇåÁã
 584   1      }
 585          
 586          
 587          /**********************************************************
 588          *º¯ÊýÃû³Æ     :UsartSndResult1  
 589          *º¯ÊýÃèÊö         :´®¿Ú·¢ËÍ½á¹ûÃüÁî
 590          *ÊäÈë²ÎÊý       :byPort :´®¿ÚºÅ
 591                                              byOriginalCmd:Ô­ÃüÁî
 592                                              byData0:Êý¾Ý0
 593                                              byData1:Êý¾Ý1
 594          *·µ»ØÖµ       :
 595          *È«¾Ö±äÁ¿     :
 596          *µ÷ÓÃÄ£¿é       :
 597          ***********************************************************
 598          *´´½¨ÈË           :ÒüÔËÍ¬
 599          *´´½¨ÈÕÆÚ     :2009-4-6
 600          ***********************************************************
 601          *ÐÞ¸ÄÈË         :
 602          *ÐÞ¸ÄÈÕÆÚ       :
 603          *×¢ÊÍ           :
 604          **********************************************************/
 605          void Usart1SndResult1(uint8 byOriginalCmd,uint8 byData0,uint8 byData1)
 606          {
 607   1        pSTUartFreq pstDataFreq;
 608   1        errtime =0xff;
 609   1        while(stUsartCfg[1].uiSndLen!=0)  
 610   1        {//ÓÐÊý¾ÝÕýÔÚ·¢ËÍÖÐ
C51 COMPILER V9.00   UART                                                                  02/15/2019 15:09:08 PAGE 11  

 611   2          Delayms(1);
 612   2          WDT_CONTR = 0x3e;   //¿´ÃÅ¹·¶¨Ê±2.5s@20M  
 613   2          if(--errtime ==0) break;
 614   2        }
 615   1        pstDataFreq = (pSTUartFreq)byUsart1SndBuf;
 616   1      
 617   1        pstDataFreq->byStartByte1   =START_BYTE1;
 618   1        pstDataFreq->bySndSecAddr   =stLocalControl.stEepromCfgData.bySelfSecAddr;
 619   1        pstDataFreq->bySndRoomAddr  =stLocalControl.stEepromCfgData.bySelfRoomAddr;
 620   1        pstDataFreq->bySndBedAddr   =stLocalControl.stEepromCfgData.bySelfBedAddr;
 621   1        pstDataFreq->byRecSecAddr   =stLocalControl.stEepromCfgData.bySelfSecAddr;
 622   1        pstDataFreq->byRecRoomAddr  =PC_ADDR2;
 623   1        pstDataFreq->byRecBedAddr   =PC_ADDR3;
 624   1        pstDataFreq->byCmd      =CMD_RESULT_PC;   //È·ÈÏÃüÁî
 625   1        pstDataFreq->uiLen      =0X03;
 626   1        pstDataFreq->byData[0]    =byOriginalCmd; //Ô­ÃüÁî  
 627   1        pstDataFreq->byData[1]    =byData0;   //³É¹¦»òÊ§°Ü
 628   1        pstDataFreq->byData[2]    =byData1;   //Êý¾Ý  
 629   1        pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
 630   1        pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE;
 631   1        
 632   1        stUsartCfg[1].uiSndLen  = pstDataFreq->uiLen+EXT_SIZE;
 633   1        stUsartCfg[1].uiSndPos = 0;   //´ÓÊý¾ÝÖ¡Í·²¿¿ªÊ¼·¢ËÍÊý¾Ý
 634   1      
 635   1        S2CON &= ~S2TI;
 636   1        S2BUF=pstDataFreq->byStartByte1;    
 637   1      
 638   1      }
 639          /**********************************************************
 640          *º¯ÊýÃû³Æ     :UsartSndResult3  
 641          *º¯ÊýÃèÊö         :´®¿Ú·¢ËÍ½á¹ûÃüÁî
 642          *ÊäÈë²ÎÊý       :byPort :´®¿ÚºÅ
 643                                              byOriginalCmd:Ô­ÃüÁî
 644                                              byData0:Êý¾Ý0
 645                                              *byData:½á¹ûÃüÁîÖÐ¸½´øµÄÒª·µ»ØÊý¾ÝµÄÊý¾ÝÖ¸Õë
 646                                              byLen:¸½´øÒª·µ»ØÊý¾ÝµÄÊý¾Ý³¤¶È
 647          *·µ»ØÖµ       :
 648          *È«¾Ö±äÁ¿     :
 649          *µ÷ÓÃÄ£¿é       :
 650          ***********************************************************
 651          *´´½¨ÈË           :ÒüÔËÍ¬
 652          *´´½¨ÈÕÆÚ     :2009-4-6
 653          ***********************************************************
 654          *ÐÞ¸ÄÈË         :
 655          *ÐÞ¸ÄÈÕÆÚ       :
 656          *×¢ÊÍ           :
 657          **********************************************************/
 658          void Usart1SndResult3(uint8 byOriginalCmd,uint8 byData0,uint8 *byData,uint8 byLen)
 659          {
 660   1        pSTUartFreq pstDataFreq;
 661   1        errtime =0xff;
 662   1        while(stUsartCfg[1].uiSndLen!=0)  
 663   1        {//ÓÐÊý¾ÝÕýÔÚ·¢ËÍÖÐ
 664   2          Delayms(1);
 665   2          WDT_CONTR = 0x3e;   //¿´ÃÅ¹·¶¨Ê±2.5s@20M  
 666   2          if(--errtime ==0) break;
 667   2      
 668   2        }
 669   1      
 670   1        pstDataFreq = (pSTUartFreq)byUsart1SndBuf;
 671   1      
 672   1        pstDataFreq->byStartByte1   =START_BYTE1;
C51 COMPILER V9.00   UART                                                                  02/15/2019 15:09:08 PAGE 12  

 673   1        pstDataFreq->bySndSecAddr   =stLocalControl.stEepromCfgData.bySelfSecAddr;
 674   1        pstDataFreq->bySndRoomAddr  =stLocalControl.stEepromCfgData.bySelfRoomAddr;
 675   1        pstDataFreq->bySndBedAddr   =stLocalControl.stEepromCfgData.bySelfBedAddr;
 676   1        pstDataFreq->byRecSecAddr   =stLocalControl.stEepromCfgData.bySelfSecAddr;
 677   1        pstDataFreq->byRecRoomAddr  =PC_ADDR2;
 678   1        pstDataFreq->byRecBedAddr   =PC_ADDR3;
 679   1        pstDataFreq->byCmd      =CMD_RESULT_PC;   //È·ÈÏÃüÁî
 680   1        pstDataFreq->uiLen      =0X02+byLen;
 681   1        pstDataFreq->byData[0]    =byOriginalCmd; //Ô­ÃüÁî  
 682   1        pstDataFreq->byData[1]    =byData0;   //³É¹¦»òÊ§°Ü
 683   1        memcpy(&(pstDataFreq->byData[2]),byData,byLen); //¸´ÖÆ¸½´øµÄÊý¾Ý
 684   1        pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
 685   1        pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE;
 686   1        
 687   1        stUsartCfg[1].uiSndLen  = pstDataFreq->uiLen+EXT_SIZE;
 688   1        stUsartCfg[1].uiSndPos = 0;   //´ÓÊý¾ÝÖ¡Í·²¿¿ªÊ¼·¢ËÍÊý¾Ý
 689   1      
 690   1        S2CON &= ~S2TI;
 691   1        S2BUF=pstDataFreq->byStartByte1;    
 692   1      
 693   1      }
 694          
 695          /**********************************************************
 696          *º¯ÊýÃû³Æ     :Usart1SndResult  
 697          *º¯ÊýÃèÊö         :´®¿Ú·¢ËÍ´íÎóÃüÁî
 698          *ÊäÈë²ÎÊý       :byPort :´®¿ÚºÅ
 699                                              byData:Êý¾Ý
 700          *·µ»ØÖµ       :
 701          *È«¾Ö±äÁ¿     :
 702          *µ÷ÓÃÄ£¿é       :
 703          ***********************************************************
 704          *´´½¨ÈË           :ÒüÔËÍ¬
 705          *´´½¨ÈÕÆÚ     :2009-4-6
 706          ***********************************************************
 707          *ÐÞ¸ÄÈË         :
 708          *ÐÞ¸ÄÈÕÆÚ       :
 709          *×¢ÊÍ           :
 710          **********************************************************/
 711          void Usart1SndError(uint8 byData)
 712          {
 713   1        pSTUartFreq pstDataFreq;
 714   1        errtime =0xff;
 715   1        while(stUsartCfg[1].uiSndLen!=0)  
 716   1        {//ÓÐÊý¾ÝÕýÔÚ·¢ËÍÖÐ
 717   2          Delayms(1);
 718   2          WDT_CONTR = 0x3e;   //¿´ÃÅ¹·¶¨Ê±2.5s@20M  
 719   2          if(--errtime ==0) break;
 720   2      
 721   2        }
 722   1      
 723   1        pstDataFreq = (pSTUartFreq)byUsart1SndBuf;
 724   1      
 725   1        pstDataFreq->byStartByte1   =START_BYTE1;
 726   1        pstDataFreq->bySndSecAddr   =stLocalControl.stEepromCfgData.bySelfSecAddr;
 727   1        pstDataFreq->bySndRoomAddr  =stLocalControl.stEepromCfgData.bySelfRoomAddr;
 728   1        pstDataFreq->bySndBedAddr   =stLocalControl.stEepromCfgData.bySelfBedAddr;
 729   1        pstDataFreq->byRecSecAddr   =stLocalControl.stEepromCfgData.bySelfSecAddr;
 730   1        pstDataFreq->byRecRoomAddr  =PC_ADDR2;
 731   1        pstDataFreq->byRecBedAddr   =PC_ADDR3;
 732   1        pstDataFreq->byCmd      =CMD_ERROR_PC;    //´íÎóÃüÁî
 733   1        pstDataFreq->uiLen      =0X01;
 734   1        pstDataFreq->byData[0]    =byData;    //´íÎó´úÂë  
C51 COMPILER V9.00   UART                                                                  02/15/2019 15:09:08 PAGE 13  

 735   1      
 736   1        pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
 737   1        pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE;
 738   1        
 739   1        stUsartCfg[1].uiSndLen  = pstDataFreq->uiLen+EXT_SIZE;
 740   1        stUsartCfg[1].uiSndPos = 0;   //´ÓÊý¾ÝÖ¡Í·²¿¿ªÊ¼·¢ËÍÊý¾Ý
 741   1      
 742   1        S2CON &= ~S2TI;
 743   1        S2BUF =pstDataFreq->byStartByte1;   
 744   1      }
 745          
 746          
 747          /**********************************************************/
 748          
 749          void Usart1Sendbyte(uint8 dat)
 750          {
 751   1        stUsartCfg[1].uiSndLen  = 1;
 752   1        stUsartCfg[1].uiSndPos = 0;   //´ÓÊý¾ÝÖ¡Í·²¿¿ªÊ¼·¢ËÍÊý¾Ý
 753   1      
 754   1        S2CON &= ~S2TI;
 755   1        S2BUF =dat; 
 756   1      }
 757          
 758          /**********************************************************
 759          *º¯ÊýÃû³Æ     :Usart1RecDeal  
 760          *º¯ÊýÃèÊö         :´®¿Ú1Ð­Òé´¦Àí
 761          *ÊäÈë²ÎÊý       :
 762          *·µ»ØÖµ       :
 763          *È«¾Ö±äÁ¿     :
 764          *µ÷ÓÃÄ£¿é       :
 765          ***********************************************************
 766          *´´½¨ÈË           :ÒüÔËÍ¬
 767          *´´½¨ÈÕÆÚ     :2009-4-6
 768          ***********************************************************
 769          *ÐÞ¸ÄÈË         :
 770          *ÐÞ¸ÄÈÕÆÚ       :
 771          *×¢ÊÍ           :
 772          **********************************************************/
 773          void Usart1RecDeal(void)
 774          {   
 775   1        pSTUartFreq pstDataFreq=byUsart1RecBuf;
 776   1        bUsart1RecFinish=0;
 777   1      
 778   1        if(CheckPsk(pstDataFreq))
 779   1        {//Ð£ÑéºÍÕýÈ·
 780   2      
 781   2        if(byUsart1RecBuf[CMD_POSITION]  == CMD_ENTER_PC)
 782   2        {   
 783   3          return; //ÊÕµ½PC»úµÄÈ·ÈÏÃüÁî
 784   3        }
 785   2      
 786   2      
 787   2        Usart1SndEnter(byUsart1RecBuf[CMD_POSITION],TRUE);  //·¢ËÍÈ·ÈÏÃüÁî
 788   2      
 789   2        pstDataFreq = (pSTUartFreq)byUsart1RecBuf;
 790   2      
 791   2        if((pstDataFreq->byCmd!= CMD_DISPLAY_DATA) && (pstDataFreq->byCmd!= CMD_HANDLE_DISPLAY_DATA) && (pstDataF
             -req->byCmd!= CMD_DISPLAY_FORM))
 792   2          bRS485DataTreat=0;    //ÒòÎªÊý¾Ý¿ÉÄÜÒÑ¸²¸Ç£¬½«485Êý¾Ý´¦Àí±êÖ¾Çå0
 793   2      
 794   2        
 795   2        switch(pstDataFreq->byCmd)
C51 COMPILER V9.00   UART                                                                  02/15/2019 15:09:08 PAGE 14  

 796   2        {
 797   3          case CMD_VOICE_PLAY_ROOM: //±¨ºÅÊÇ·ñ²¥±¨·¿ºÅ
 798   3            stLocalControl.stBusFreq.byCmd = CMD_VOICE_PLAY_ROOM;
 799   3             if(pstDataFreq->byData[0])
 800   3            {//±¨·¿ºÅ
 801   4              stLocalControl.stBusFreq.byRecSecAddr = 0x01;
 802   4            }
 803   3            else stLocalControl.stBusFreq.byRecSecAddr = 0x00;
 804   3            Bus1OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
 805   3            break;
 806   3          
 807   3          case CMD_DATE_SEND:   //Ð£Ê±Êý¾Ý
 808   3            memcpy(&(stTime.bySecond),&(byUsart1RecBuf[DATA0_POSITION]),6);
 809   3            
 810   3            //¹¹½¨×ÜÏßÉÏµÄÐ£Ê±Êý¾Ý°ü   
 811   3            if((stTime.bySecond>=0x60)||(stTime.byMinute>=0x60)
 812   3             ||(stTime.byHour>=0x24)||(stTime.byDay>=0x32)
 813   3             ||(stTime.byMonth>=0x13)||(stTime.byYear>0x99))
 814   3            {
 815   4              Usart1SndResult(CMD_DATE_SEND,FALSE);       //·¢ËÍ²Ù×÷Ê§°ÜÃüÁî
 816   4              break;
 817   4            }
 818   3            P8563_settime();
 819   3            memcpy(&(stLocalControl.stBusFreq.bySndSecAddr),&(stTime.bySecond),3);
 820   3              memcpy(&(stLocalControl.stBusFreq.byRecSecAddr),&(stTime.byDay),3);
 821   3              stLocalControl.stBusFreq.byCmd = CMD_DATE_SEND;   
 822   3              Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
 823   3            Usart1SndResult(CMD_DATE_SEND,TRUE);        //·¢ËÍ²Ù×÷³É¹¦ÃüÁî      
 824   3            break;
 825   3          case CMD_POWER_ON:
 826   3              if((pstDataFreq->byData[0] == 0xff) ||(pstDataFreq->byData[1] == 0xff) ||(pstDataFreq->byData[2] == 0
             -xff)||
 827   3              (pstDataFreq->byRecRoomAddr ==GLZJ_ADDR2)   )
 828   3              {//È«ÌåÉè±¸ÖØÆô
 829   4                Usart1SndResult(CMD_POWER_ON,TRUE);       //·¢ËÍ²Ù×÷³É¹¦ÃüÁî
 830   4              while(stUsartCfg[1].uiSndLen!=0)  
 831   4              {//ÓÐÊý¾ÝÕýÔÚ·¢ËÍÖÐ,µÈ´ý½á¹ûÂë·¢ËÍÍê³É
 832   5                _nop_();    //ÑÓÊ±
 833   5              }
 834   4               //¹Ø±ÕËùÓÐ´ò¿ªµÄÖÐ¶Ï
 835   4              CCAPM0 = 0x00;
 836   4              ET0 = 0;
 837   4              TR0 = 0;
 838   4              EX0 = 0;
 839   4              IE=0X00;
 840   4              IE2=0X00;
 841   4              IAP_CONTR = 0x20;   //Èí¸´Î»
 842   4                while(1);
 843   4              }
 844   3            else
 845   3            {//Ä³¸öµ¥Ò»Éè±¸ÖØÆô
 846   4              stLocalControl.stBusFreq.byCmd = CMD_POWER_ON;
 847   4              stLocalControl.stBusFreq.byRecSecAddr = pstDataFreq->byData[0];
 848   4              stLocalControl.stBusFreq.byRecRoomAddr = pstDataFreq->byData[1];
 849   4              stLocalControl.stBusFreq.byRecBedAddr = pstDataFreq->byData[2];
 850   4              Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
 851   4            }
 852   3              break;
 853   3          case CMD_DISPLAY_DATA:   //Ò»Ö¡Òº¾§ÆÁÊý¾Ý
 854   3          case CMD_HANDLE_DISPLAY_DATA: //·¢ËÍÒ»Ö¡ÊÖ±ú Òº¾§ÆÁÊý¾Ý
 855   3            if(stUsartCfg[0].uiSndLen )
 856   3            {//RS485ÓÐÊý¾ÝÕýÔÚ·¢ËÍ
C51 COMPILER V9.00   UART                                                                  02/15/2019 15:09:08 PAGE 15  

 857   4              bRS485DataTreat=1;
 858   4              return;
 859   4            }
 860   3        
 861   3            DE0=1;
 862   3      //      Delayms(1);
 863   3            EA=0;
 864   3            memcpy(byUsart0SndBuf,byUsart1RecBuf,pstDataFreq->uiLen+EXT_SIZE);
 865   3            EA=1;
 866   3            
 867   3            stUsartCfg[0].pbySndBuf = byUsart0SndBuf;
 868   3            stUsartCfg[0].uiSndLen = pstDataFreq->uiLen+EXT_SIZE;
 869   3            stUsartCfg[0].uiSndPos = 0;   //´ÓÊý¾ÝÖ¡Í·²¿¿ªÊ¼·¢ËÍÊý¾Ý  
 870   3            TI=0;
 871   3            SBUF= stUsartCfg[0].pbySndBuf[stUsartCfg[0].uiSndPos];
 872   3            
 873   3            //±£´æ·Ö»úµØÖ·          
 874   3            stLocalControl.stRS485Addr.bySecAddr = pstDataFreq->byRecSecAddr;
 875   3            stLocalControl.stRS485Addr.byRoomAddr = pstDataFreq->byRecRoomAddr;
 876   3            stLocalControl.stRS485Addr.byBedAddr = pstDataFreq->byRecBedAddr;
 877   3      
 878   3            //ÉèÖÃµÈ´ýÓ¦´ð³¬Ê±2S  ÔÚ²¨ÌØÂÊÎª57.6KµÄÇé¿öÏÂ,100×Ö½ÚÊý¾ÝÖ»Òª17.3ms
 879   3            stLocalControl.byWaitRS485AckDTime = 95;    //µÈ´ý1.9S  
 880   3            break;
 881   3            
 882   3          case CMD_DISPLAY_FORM:  //·¢ËÍÒ»Ö¡´²Í··Ö»ú¸ñÊ½
 883   3            if(stUsartCfg[0].uiSndLen )
 884   3            {//RS485ÓÐÊý¾ÝÕýÔÚ·¢ËÍ
 885   4              bRS485DataTreat=1;
 886   4              return;
 887   4            }
 888   3        
 889   3            DE0=1;
 890   3      //      Delayms(1);
 891   3            EA=0;
 892   3            memcpy(byUsart0SndBuf,byUsart1RecBuf,pstDataFreq->uiLen+EXT_SIZE);
 893   3            EA=1;
 894   3      
 895   3            
 896   3            stUsartCfg[0].pbySndBuf = byUsart0SndBuf;
 897   3            stUsartCfg[0].uiSndLen = pstDataFreq->uiLen+EXT_SIZE;
 898   3            stUsartCfg[0].uiSndPos = 0;   //´ÓÊý¾ÝÖ¡Í·²¿¿ªÊ¼·¢ËÍÊý¾Ý  
 899   3            TI=0;
 900   3            SBUF= stUsartCfg[0].pbySndBuf[stUsartCfg[0].uiSndPos];
 901   3      
 902   3            //±£´æ·Ö»úµØÖ·          
 903   3            stLocalControl.stRS485Addr.bySecAddr = pstDataFreq->byRecSecAddr;
 904   3            stLocalControl.stRS485Addr.byRoomAddr = pstDataFreq->byRecRoomAddr;
 905   3            stLocalControl.stRS485Addr.byBedAddr = pstDataFreq->byRecBedAddr;     
 906   3            break;
 907   3        
 908   3          case CMD_INFUSION_ANSWER:
 909   3          case CMD_SERVICE_ANSWER:
 910   3          case CMD_EMERGENCY_ANSWER:
 911   3          case CMD_HELP_ANSWER:
 912   3            if(stLocalControl.uiDevState & FLAG_BUSY)
 913   3            { //Ã¦£¬ÍË³ö
 914   4              Usart1SndResult(pstDataFreq->byCmd,FALSE);
 915   4              break;
 916   4            }
 917   3            memcpy(&(stLocalControl.stBusFreq.bySndSecAddr),&(stLocalControl.stEepromCfgData.bySelfSecAddr),3);
 918   3            stLocalControl.stBusFreq.byCmd = pstDataFreq->byCmd;  //Ô­ÃüÁî
C51 COMPILER V9.00   UART                                                                  02/15/2019 15:09:08 PAGE 16  

 919   3            memcpy(&(stLocalControl.stBusFreq.byRecSecAddr),&(pstDataFreq->byData[0]),3);
 920   3            Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
 921   3            break;
 922   3          case CMD_INFUSION_CLEAR:
 923   3          case CMD_SERVICE_CLEAR:
 924   3          case CMD_EMERGENCY_CLEAR:
 925   3          case CMD_HELP_CLEAR:
 926   3            memcpy(&(stLocalControl.stBusFreq.bySndSecAddr),&(stLocalControl.stEepromCfgData.bySelfSecAddr),3);
 927   3            stLocalControl.stBusFreq.byCmd = pstDataFreq->byCmd;  //Ô­ÃüÁî
 928   3            memcpy(&(stLocalControl.stBusFreq.byRecSecAddr),&(pstDataFreq->byData[0]),3);
 929   3            Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
 930   3            break;
 931   3          case CMD_COMM_CALL:
 932   3            if(stLocalControl.uiDevState & FLAG_BUSY)
 933   3            { //ÏµÍ³Ã¦
 934   4              Usart1SndResult(CMD_COMM_CALL,FALSE);       //·¢ËÍ²Ù×÷Ê§°ÜÃüÁî
 935   4            }
 936   3            else
 937   3            {
 938   4              memcpy(&(stLocalControl.stBusFreq.bySndSecAddr),&(stLocalControl.stEepromCfgData.bySelfSecAddr),3);
 939   4              stLocalControl.stBusFreq.byCmd = CMD_COMM_CALL; //Ô­ÃüÁî
 940   4              memcpy(&(stLocalControl.stBusFreq.byRecSecAddr),&(pstDataFreq->byData[0]),3);
 941   4              Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
 942   4            }
 943   3            break;  
 944   3          case CMD_TALK_CLEAR:
 945   3            if(0x0000 == (stLocalControl.uiDevState & (FLAG_TALK1|FLAG_TALK)))
 946   3            {//Í¨µÀ0ÓëÍ¨µÀ1¶¼Î´´¦ÓÚ¶Ô½²×´Ì¬
 947   4              Usart1SndResult(CMD_TALK_CLEAR,FALSE);        //·¢ËÍ²Ù×÷Ê§°ÜÃüÁî
 948   4              break;
 949   4            }
 950   3            
 951   3            if(stLocalControl.uiDevState & FLAG_CHANNEL_CHANGE_EXIST) 
 952   3            {//ÓÐÍ¨µÀÇÐ»»ÔÚ×ÜÏß·¢ËÍ¶ÓÁÐÖÐ
 953   4              Usart1SndResult(CMD_TALK_CLEAR,FALSE);
 954   4              break;
 955   4            }
 956   3            
 957   3            if((stLocalControl.uiDevState & FLAG_TALK))
 958   3            {//Í¨µÀ0´¦ÓÚ¶Ô½²×´Ì¬
 959   4              if(((byUsart1RecBuf[DATA0_POSITION] == stLocalControl.stCallAddr.bySndSecAddr)&&
 960   4                (byUsart1RecBuf[DATA1_POSITION] == stLocalControl.stCallAddr.bySndRoomAddr)&&
 961   4                (byUsart1RecBuf[DATA2_POSITION] == stLocalControl.stCallAddr.bySndBedAddr))||
 962   4                 ((byUsart1RecBuf[DATA0_POSITION] == stLocalControl.stCallAddr.byRecSecAddr)&&
 963   4                (byUsart1RecBuf[DATA1_POSITION] == stLocalControl.stCallAddr.byRecRoomAddr)&&
 964   4                (byUsart1RecBuf[DATA2_POSITION] == stLocalControl.stCallAddr.byRecBedAddr))||          
 965   4                 ((byUsart1RecBuf[DATA3_POSITION] == stLocalControl.stCallAddr.bySndSecAddr)&&
 966   4                  (byUsart1RecBuf[DATA4_POSITION] == stLocalControl.stCallAddr.bySndRoomAddr)&&
 967   4                  (byUsart1RecBuf[DATA5_POSITION] == stLocalControl.stCallAddr.bySndBedAddr))||
 968   4                 ((byUsart1RecBuf[DATA3_POSITION] == stLocalControl.stCallAddr.byRecSecAddr)&&
 969   4                  (byUsart1RecBuf[DATA4_POSITION] == stLocalControl.stCallAddr.byRecRoomAddr)&&
 970   4                  (byUsart1RecBuf[DATA5_POSITION] == stLocalControl.stCallAddr.byRecBedAddr)))
 971   4              {//ÊÇÍ¨µÀ0ÖÐµÄ·Ö»ú,·¢ËÍÏµÍ³¸´Î»ÃüÁî
 972   5                MakeCH0TimerOut(5,0);// Ëõ¶Ì³¬Ê±Ê±¼ä,×¼±¸ÍË³ö
 973   5                Usart1SndResult(CMD_TALK_CLEAR,TRUE);       //·¢ËÍ²Ù×÷³É¹¦ÃüÁî
 974   5                break;
 975   5              }
 976   4            }
 977   3            
 978   3            if((stLocalControl.uiDevState & FLAG_TALK1))
 979   3            {//Í¨µÀ1´¦ÓÚ¶Ô½²×´Ì¬
 980   4              if(((byUsart1RecBuf[DATA0_POSITION] == stLocalControl.stCH1CallAddr.bySndSecAddr)&&
C51 COMPILER V9.00   UART                                                                  02/15/2019 15:09:08 PAGE 17  

 981   4                (byUsart1RecBuf[DATA1_POSITION] == stLocalControl.stCH1CallAddr.bySndRoomAddr)&&
 982   4                (byUsart1RecBuf[DATA2_POSITION] == stLocalControl.stCH1CallAddr.bySndBedAddr))||
 983   4                 ((byUsart1RecBuf[DATA0_POSITION] == stLocalControl.stCH1CallAddr.byRecSecAddr)&&
 984   4                (byUsart1RecBuf[DATA1_POSITION] == stLocalControl.stCH1CallAddr.byRecRoomAddr)&&
 985   4                (byUsart1RecBuf[DATA2_POSITION] == stLocalControl.stCH1CallAddr.byRecBedAddr))||          
 986   4                 ((byUsart1RecBuf[DATA3_POSITION] == stLocalControl.stCH1CallAddr.bySndSecAddr)&&
 987   4                (byUsart1RecBuf[DATA4_POSITION] == stLocalControl.stCH1CallAddr.bySndRoomAddr)&&
 988   4                (byUsart1RecBuf[DATA5_POSITION] == stLocalControl.stCH1CallAddr.bySndBedAddr))||
 989   4                 ((byUsart1RecBuf[DATA3_POSITION] == stLocalControl.stCH1CallAddr.byRecSecAddr)&&
 990   4                (byUsart1RecBuf[DATA4_POSITION] == stLocalControl.stCH1CallAddr.byRecRoomAddr)&&
 991   4                (byUsart1RecBuf[DATA5_POSITION] == stLocalControl.stCH1CallAddr.byRecBedAddr)))
 992   4      
 993   4      
 994   4              {//ÊÇÍ¨µÀ1ÖÐµÄ·Ö»ú,·¢ËÍÏµÍ³¸´Î»ÃüÁî
 995   5                MakeCH1TimerOut(5,0);// Ëõ¶Ì³¬Ê±Ê±¼ä,×¼±¸ÍË³ö
 996   5                Usart1SndResult(CMD_TALK_CLEAR,TRUE);       //·¢ËÍ²Ù×÷³É¹¦ÃüÁî
 997   5                break;
 998   5      
 999   5              }
1000   4            }
1001   3      
1002   3            //µØÖ·²»¶Ô
1003   3            Usart1SndResult(CMD_TALK_CLEAR,FALSE);        //·¢ËÍ²Ù×÷Ê§°ÜÃüÁî
1004   3            break;
1005   3            
1006   3          case CMD_NUMBER_SET:    //¸ù¾ÝµØÖ·ÐÞ¸Ä¹ÜÀíÖ÷»úµØÖ·
1007   3            if(byUsart1RecBuf[REC_ROOM_POSITION]==GLZJ_ADDR2)
1008   3            {//¸ø¹ÜÀíÖ÷»ú±àÇøºÅ,Í¬Ê±½«´ËÇøºÅ·¢ËÍ¸øÆäËüÏÂÎ»»úÉè±¸
1009   4              stLocalControl.stEepromCfgData.bySelfSecAddr = byUsart1RecBuf[DATA0_POSITION];
1010   4              EA=0;
1011   4              SaveParameter(IAP0_ADDR);
1012   4              EA=1;
1013   4              
1014   4              stLocalControl.stBusFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1015   4              stLocalControl.stBusFreq.bySndRoomAddr= stLocalControl.stEepromCfgData.bySelfRoomAddr;
1016   4              stLocalControl.stBusFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1017   4              stLocalControl.stBusFreq.byCmd      = CMD_SYSTEM_SEC_SET;
1018   4              stLocalControl.stBusFreq.byRecSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1019   4              Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
1020   4            }
1021   3            break;  
1022   3      
1023   3          case CMD_QUEST:
1024   3            stLocalControl.stBusFreq.byCmd = byUsart1RecBuf[CMD_POSITION];
1025   3            stLocalControl.stBusFreq.byRecSecAddr = pstDataFreq->byData[0];
1026   3            stLocalControl.stBusFreq.byRecRoomAddr = pstDataFreq->byData[1];
1027   3            stLocalControl.stBusFreq.byRecBedAddr = pstDataFreq->byData[2];
1028   3            Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
1029   3            break;  
1030   3            
1031   3          case CMD_SCHEDULE_SEND: //»¤Àí¼¶±ðÐÞ¸ÄÃüÁî    
1032   3            stLocalControl.stBusFreq.bySndSecAddr = byUsart1RecBuf[DATA3_POSITION]; //ADDR»òdata
1033   3            stLocalControl.stBusFreq.byCmd = byUsart1RecBuf[CMD_POSITION];
1034   3            stLocalControl.stBusFreq.byRecSecAddr = pstDataFreq->byData[0];
1035   3            stLocalControl.stBusFreq.byRecRoomAddr = pstDataFreq->byData[1];
1036   3            stLocalControl.stBusFreq.byRecBedAddr = pstDataFreq->byData[2];
1037   3            Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
1038   3            break;  
1039   3          case CMD_OPEN_LCD:
1040   3          case CMD_CLOSE_LCD:
1041   3          case CMD_CLEAR_LCD:
1042   3          case CMD_CLEAR_HANDLE_LCD:
C51 COMPILER V9.00   UART                                                                  02/15/2019 15:09:08 PAGE 18  

1043   3          case CMD_CLEAR_MK_LCD:
1044   3            stLocalControl.stBusFreq.byCmd = byUsart1RecBuf[CMD_POSITION];
1045   3            stLocalControl.stBusFreq.byRecSecAddr = pstDataFreq->byData[0];
1046   3            stLocalControl.stBusFreq.byRecRoomAddr = pstDataFreq->byData[1];
1047   3            stLocalControl.stBusFreq.byRecBedAddr = pstDataFreq->byData[2];
1048   3            Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
1049   3            break;
1050   3      
1051   3          case CMD_STOP_VOICE:      
1052   3            stLocalControl.stBusFreq.byCmd = byUsart1RecBuf[CMD_POSITION];
1053   3            stLocalControl.stBusFreq.byRecSecAddr = 0xff;
1054   3            stLocalControl.stBusFreq.byRecRoomAddr = 0xff;
1055   3            stLocalControl.stBusFreq.byRecBedAddr = 0xff;
1056   3            Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
1057   3            flag_origin_music =0;
1058   3            break;
1059   3      
1060   3          case CMD_START_VOICE:     
1061   3          case CMD_BROADCAST1:
1062   3          case CMD_BROADCAST2:
1063   3          case CMD_BROADCAST3:
1064   3            if((stLocalControl.uiDevState & FLAG_BUSY)||(stLocalControl.uiDevState & FLAG_TALK1))
1065   3            { //ÏµÍ³Ã¦
1066   4              Usart1SndResult(byUsart1RecBuf[CMD_POSITION],FALSE);        //·¢ËÍ²Ù×÷Ê§°ÜÃüÁî
1067   4              break;
1068   4            }
1069   3      
1070   3            stLocalControl.stBusFreq.byCmd = byUsart1RecBuf[CMD_POSITION];
1071   3            stLocalControl.stBusFreq.byRecSecAddr = 0xff;
1072   3            stLocalControl.stBusFreq.byRecRoomAddr = 0xff;
1073   3            stLocalControl.stBusFreq.byRecBedAddr = 0xff;
1074   3            Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
1075   3            break;
1076   3      
1077   3          case CMD_MUSIC_PLAY:      
1078   3            if((stLocalControl.uiDevState & FLAG_BUSY)||(stLocalControl.uiDevState & FLAG_TALK1))
1079   3            { //ÏµÍ³Ã¦
1080   4              Usart1SndResult(byUsart1RecBuf[CMD_POSITION],FALSE);        //·¢ËÍ²Ù×÷Ê§°ÜÃüÁî
1081   4              break;
1082   4            }
1083   3      
1084   3            stLocalControl.stBusFreq.byCmd = byUsart1RecBuf[CMD_POSITION];
1085   3            stLocalControl.stBusFreq.byRecSecAddr = 0xff;
1086   3            stLocalControl.stBusFreq.byRecRoomAddr = 0xff;
1087   3            stLocalControl.stBusFreq.byRecBedAddr = 0xff;
1088   3            Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
1089   3            flag_origin_music =1;
1090   3            break;
1091   3      
1092   3            
1093   3          case CMD_VOICE_TIMER_SET:
1094   3          case CMD_BL_TIMER_SET:
1095   3            stLocalControl.stBusFreq.bySndSecAddr = byUsart1RecBuf[DATA0_POSITION]; //ÆðÊ¼Ð¡Ê±
1096   3            stLocalControl.stBusFreq.bySndRoomAddr = byUsart1RecBuf[DATA1_POSITION];  //ÆðÊ¼·ÖÖÓ
1097   3            stLocalControl.stBusFreq.bySndBedAddr = 0x00;
1098   3            stLocalControl.stBusFreq.byCmd = byUsart1RecBuf[CMD_POSITION];
1099   3            stLocalControl.stBusFreq.byRecSecAddr = byUsart1RecBuf[DATA2_POSITION]; //½áÊøÐ¡Ê±
1100   3            stLocalControl.stBusFreq.byRecRoomAddr = byUsart1RecBuf[DATA3_POSITION];  //½áÊø·ÖÖÓ
1101   3            stLocalControl.stBusFreq.byRecBedAddr = byUsart1RecBuf[DATA4_POSITION]; //ÒôÁ¿Öµ
1102   3            Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
1103   3            break;  
1104   3      
C51 COMPILER V9.00   UART                                                                  02/15/2019 15:09:08 PAGE 19  

1105   3            
1106   3          case CMD_ENTER: //À´×ÔPC»úÉÏµÄµÇ¼ÇÈ·ÈÏÃüÁî
1107   3            if(stLocalControl.byWaitAckTimeLanding)
1108   3            {//ÕýÔÚµÈ´ýPC»úÉÏµÄµÇ¼ÇÈ·ÈÏÃüÁî
1109   4              stLocalControl.byWaitAckTimeLanding = 0;
1110   4              stLocalControl.uiDetectPcTime = 30000;  //ÕìÌýPC»ú¼ä¸ô10·ÖÖÓ
1111   4              
1112   4              stLocalControl.stBusFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1113   4              stLocalControl.stBusFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1114   4              stLocalControl.stBusFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr; 
1115   4              stLocalControl.stBusFreq.byCmd = CMD_PC_OPEN;
1116   4              stLocalControl.stBusFreq.byRecSecAddr = 0xff;
1117   4              stLocalControl.stBusFreq.byRecRoomAddr =0xff;
1118   4              stLocalControl.stBusFreq.byRecBedAddr = 0xff;
1119   4              Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
1120   4              bPCState =1;  //¼¯³ÉÖ÷»ú¿ª»ú×´Ì¬
1121   4            }
1122   3            break;
1123   3            
1124   3          case CMD_RS485_BRT_SET:
1125   3            if(byUsart1RecBuf[DATA0_POSITION] >0 && byUsart1RecBuf[DATA0_POSITION] <10)
1126   3            {
1127   4              switch(byUsart1RecBuf[DATA0_POSITION])
1128   4              {
1129   5                case 1:
1130   5                  stLocalControl.stEepromCfgData.uiRs485Brt =1200;
1131   5                  break;
1132   5                case 2:
1133   5                  stLocalControl.stEepromCfgData.uiRs485Brt = 2400;
1134   5                  break;
1135   5                case 3:
1136   5                  stLocalControl.stEepromCfgData.uiRs485Brt = 4800;
1137   5                  break;
1138   5                case 4:
1139   5                  stLocalControl.stEepromCfgData.uiRs485Brt = 9600;
1140   5                  break;
1141   5                case 5:
1142   5                  stLocalControl.stEepromCfgData.uiRs485Brt = 14400;
1143   5                  break;
1144   5                case 6:
1145   5                  stLocalControl.stEepromCfgData.uiRs485Brt = 19200;
1146   5                  break;
1147   5                case 7:
1148   5                  stLocalControl.stEepromCfgData.uiRs485Brt = 28800;
1149   5                  break;
1150   5                case 8:
1151   5                  stLocalControl.stEepromCfgData.uiRs485Brt = 38400;
1152   5                  break;
1153   5                case 9:
1154   5                  stLocalControl.stEepromCfgData.uiRs485Brt = 57600;
1155   5                  break;
1156   5                default:
1157   5                  stLocalControl.stEepromCfgData.uiRs485Brt =1200;
1158   5                  break;        
1159   5              }         
1160   4              //Í¬Ê±½«RS485×ÜÏßµÄ²¨ÌØ£¨´®¿Ú0£©½øÐÐÉèÖÃ
1161   4              Usart0Init(stLocalControl.stEepromCfgData.uiRs485Brt);
1162   4              SaveParameter(IAP0_ADDR);       
1163   4              stLocalControl.stBusFreq.bySndSecAddr   =   stLocalControl.stEepromCfgData.bySelfSecAddr;
1164   4              stLocalControl.stBusFreq.bySndRoomAddr  = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1165   4              stLocalControl.stBusFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1166   4              stLocalControl.stBusFreq.byCmd      = CMD_RS485_BRT_SET;
C51 COMPILER V9.00   UART                                                                  02/15/2019 15:09:08 PAGE 20  

1167   4              stLocalControl.stBusFreq.byRecSecAddr = byUsart1RecBuf[DATA0_POSITION]; //²¨ÌØÂÊ´úÂë
1168   4              Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
1169   4              stLocalControl.byReSndBrtTimes = RE_SND_TIMES;
1170   4            }
1171   3            else Usart1SndResult(CMD_RS485_BRT_SET,FALSE);
1172   3            break;
1173   3      
1174   3          case CMD_RS485_INFO_SEC_ROOM:
1175   3            if(byUsart1RecBuf[DATA0_POSITION] ==0 || byUsart1RecBuf[DATA0_POSITION] ==1)
1176   3            {
1177   4              stLocalControl.stBusFreq.bySndSecAddr   =   stLocalControl.stEepromCfgData.bySelfSecAddr;
1178   4              stLocalControl.stBusFreq.bySndRoomAddr  = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1179   4              stLocalControl.stBusFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1180   4              stLocalControl.stBusFreq.byCmd      = CMD_RS485_INFO_SEC_ROOM;
1181   4              stLocalControl.stBusFreq.byRecSecAddr = byUsart1RecBuf[DATA0_POSITION]; //´²Í··Ö»ú½ÓâôRS485ÐÅÏ¢ÊÇ·ñÐèÒ
             -ªÅÐ¶Ï·¿ºÅ
1182   4              Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
1183   4              stLocalControl.byReSndRs485RoomTimes = RE_SND_TIMES;      //ÖØ¸´·¢ËÍÈý´Î
1184   4            }
1185   3            else Usart1SndResult(CMD_RS485_INFO_SEC_ROOM,FALSE);
1186   3            break;
1187   3      
1188   3          case CMD_BED_VOICE_PLAY:
1189   3            if(byUsart1RecBuf[DATA0_POSITION] ==0 || byUsart1RecBuf[DATA0_POSITION] ==1)
1190   3            {
1191   4              stLocalControl.stBusFreq.bySndSecAddr   =   stLocalControl.stEepromCfgData.bySelfSecAddr;
1192   4              stLocalControl.stBusFreq.bySndRoomAddr  = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1193   4              stLocalControl.stBusFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1194   4              stLocalControl.stBusFreq.byCmd      = CMD_BED_VOICE_PLAY;
1195   4              stLocalControl.stBusFreq.byRecSecAddr = byUsart1RecBuf[DATA0_POSITION]; //´²Í··Ö»úÊÇ·ñÐèÒªÓïÒô±¨ºÅ
1196   4              Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
1197   4              stLocalControl.byReSndBedVoiPlaTimes = RE_SND_TIMES;      //ÖØ¸´·¢ËÍÈý´Î  
1198   4            }
1199   3            else Usart1SndResult(CMD_BED_VOICE_PLAY,FALSE);
1200   3            break;
1201   3            
1202   3          case CMD_VOICE_TIMES:
1203   3            if(byUsart1RecBuf[DATA0_POSITION] !=0 && byUsart1RecBuf[DATA0_POSITION] <=10)
1204   3            {//ÓïÒô±¨ºÅ±éÊýÉèÖÃ10±éÒÔ¼°ÏÂ
1205   4              stLocalControl.stBusFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1206   4              stLocalControl.stBusFreq.bySndRoomAddr  = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1207   4              stLocalControl.stBusFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1208   4              stLocalControl.stBusFreq.byCmd      = CMD_VOICE_TIMES;
1209   4              stLocalControl.stBusFreq.byRecSecAddr = byUsart1RecBuf[DATA0_POSITION]; //±¨ºÅ±éÊý
1210   4              Bus1OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
1211   4                
1212   4            }
1213   3            else Usart1SndResult(CMD_VOICE_TIMES,FALSE);
1214   3            break;
1215   3      
1216   3            
1217   3          case CMD_DISP_MODE:
1218   3            if(byUsart1RecBuf[DATA0_POSITION] ==0 || byUsart1RecBuf[DATA0_POSITION] ==1)
1219   3            {     
1220   4              stLocalControl.stBusFreq.bySndSecAddr   =   stLocalControl.stEepromCfgData.bySelfSecAddr;
1221   4              stLocalControl.stBusFreq.bySndRoomAddr  = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1222   4              stLocalControl.stBusFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1223   4              stLocalControl.stBusFreq.byCmd      = CMD_DISP_MODE;  
1224   4              stLocalControl.stBusFreq.byRecSecAddr = byUsart1RecBuf[DATA0_POSITION];
1225   4              stLocalControl.stBusFreq.byRecRoomAddr  = byUsart1RecBuf[DATA1_POSITION];
1226   4              stLocalControl.stBusFreq.byRecBedAddr = byUsart1RecBuf[DATA2_POSITION];
1227   4              Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
C51 COMPILER V9.00   UART                                                                  02/15/2019 15:09:08 PAGE 21  

1228   4            }
1229   3            else Usart1SndResult(CMD_DISP_MODE,FALSE);
1230   3            break;
1231   3      
1232   3          case CMD_COLOR_CLEAR:
1233   3            stLocalControl.stBusFreq.bySndSecAddr   =   stLocalControl.stEepromCfgData.bySelfSecAddr;
1234   3            stLocalControl.stBusFreq.bySndRoomAddr  = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1235   3            stLocalControl.stBusFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1236   3            stLocalControl.stBusFreq.byCmd      = CMD_COLOR_CLEAR;  
1237   3            stLocalControl.stBusFreq.byRecSecAddr = byUsart1RecBuf[DATA0_POSITION];
1238   3            stLocalControl.stBusFreq.byRecRoomAddr  = byUsart1RecBuf[DATA1_POSITION];
1239   3            stLocalControl.stBusFreq.byRecBedAddr = byUsart1RecBuf[DATA2_POSITION];
1240   3            Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
1241   3            break;
1242   3              
1243   3          default:
1244   3            Usart1SndResult(byUsart1RecBuf[CMD_POSITION],FALSE);        //·¢ËÍ²Ù×÷Ê§°ÜÃüÁî
1245   3            break;
1246   3        }
1247   2        }
1248   1      }
1249          
1250          
1251          
1252          /**********************************************************
1253          *º¯ÊýÃû³Æ     :Usart1SndData
1254          *º¯ÊýÃèÊö         :´®¿Ú·¢ËÍÊý¾Ý
1255          *ÊäÈë²ÎÊý        
1256          *·µ»ØÖµ       :
1257          *È«¾Ö±äÁ¿     :
1258          *µ÷ÓÃÄ£¿é       :
1259          ***********************************************************
1260          *´´½¨ÈË           :ÒüÔËÍ¬
1261          *´´½¨ÈÕÆÚ     :2009-4-6
1262          ***********************************************************
1263          *ÐÞ¸ÄÈË         :
1264          *ÐÞ¸ÄÈÕÆÚ       :
1265          *×¢ÊÍ           :
1266          **********************************************************/
1267          void Usart1SndData(pSTBusFreq pstBusFreq)
1268          {
1269   1        pSTUartFreq pstDataFreq;
1270   1        errtime =0xff;
1271   1        while(stUsartCfg[1].uiSndLen!=0)  
1272   1        {//ÓÐÊý¾ÝÕýÔÚ·¢ËÍÖÐ
1273   2          Delayms(1);
1274   2          WDT_CONTR = 0x3e;   //¿´ÃÅ¹·¶¨Ê±2.5s@20M  
1275   2          if(--errtime ==0) break;
1276   2        }
1277   1        pstDataFreq = (pSTUartFreq)byUsart1SndBuf;
1278   1      
1279   1        pstDataFreq->byStartByte1   =START_BYTE1;
1280   1          memcpy(&(pstDataFreq->bySndSecAddr),&(pstBusFreq->bySndSecAddr),3);
1281   1        memcpy(&(pstDataFreq->byRecSecAddr),&(pstBusFreq->byRecSecAddr),3);
1282   1        pstDataFreq->byCmd      =pstBusFreq->byCmd;   
1283   1        pstDataFreq->uiLen      =0X00;
1284   1        pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
1285   1        pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE;
1286   1        
1287   1        stUsartCfg[1].uiSndLen  = pstDataFreq->uiLen+EXT_SIZE;
1288   1        stUsartCfg[1].uiSndPos = 0;   //´ÓÊý¾ÝÖ¡Í·²¿¿ªÊ¼·¢ËÍÊý¾Ý
1289   1        S2CON &= ~S2TI;
C51 COMPILER V9.00   UART                                                                  02/15/2019 15:09:08 PAGE 22  

1290   1        S2BUF=pstDataFreq->byStartByte1;
1291   1      
1292   1      }
1293          
1294          
1295          
1296          void uart1_send_byte(unsigned char SDATA)
1297          {
1298   1      #if DEBUG==1
1299   1        errtime =0xff;
1300   1        while(stUsartCfg[1].uiSndLen!=0)  
1301   1        {//ÓÐÊý¾ÝÕýÔÚ·¢ËÍÖÐ
1302   2          Delayms(1);
1303   2          WDT_CONTR = 0x3e;   //¿´ÃÅ¹·¶¨Ê±2.5s@20M  
1304   2          if(--errtime ==0) break;
1305   2      
1306   2        }
1307   1        stUsartCfg[1].uiSndLen  = 1;
1308   1        stUsartCfg[1].uiSndPos = 0;   //´ÓÊý¾ÝÖ¡Í·²¿¿ªÊ¼·¢ËÍÊý¾Ý
1309   1        S2CON &= ~S2TI;
1310   1        S2BUF=SDATA;
1311   1      #endif
1312   1      }
1313          
1314          
1315          void uart0_send_byte(unsigned char SDATA)
1316          {
1317   1      /*#if DEBUG==1
1318   1        stUsartCfg[0].pbySndBuf[DATA4_POSITION]  = 0X01;
1319   1        errtime =0xff;
1320   1        while(stUsartCfg[0].uiSndLen!=0)  
1321   1        {//ÓÐÊý¾ÝÕýÔÚ·¢ËÍÖÐ
1322   1          Delayms(1);
1323   1          WDT_CONTR = 0x3e;   //¿´ÃÅ¹·¶¨Ê±2.5s@20M  
1324   1          if(--errtime ==0) break;
1325   1        }
1326   1        stUsartCfg[0].uiSndLen  = 1;
1327   1        stUsartCfg[0].uiSndPos = 0;   //´ÓÊý¾ÝÖ¡Í·²¿¿ªÊ¼·¢ËÍÊý¾Ý
1328   1        TI=0;
1329   1        SBUF=SDATA;
1330   1      #endif*/
1331   1      
1332   1        uint8 xdata i;
1333   1        SDATA=SDATA;
1334   1        i=i;
1335   1      #if DEBUG ==1
1336   1        errtime =0xff;
1337   1        while(stUsartCfg[0].uiSndLen!=0)  
1338   1        {//ÓÐÊý¾ÝÕýÔÚ·¢ËÍÖÐ
1339   2          Delayms(1);
1340   2          WDT_CONTR = 0x3e;   //¿´ÃÅ¹·¶¨Ê±2.5s@20M  
1341   2          if(--errtime ==0) break;
1342   2        }
1343   1        ES=0;
1344   1          SBUF=SDATA;
1345   1          while(!TI);
1346   1          TI=0;
1347   1        ES=1;
1348   1      #endif
1349   1      
1350   1      }
1351          
C51 COMPILER V9.00   UART                                                                  02/15/2019 15:09:08 PAGE 23  



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5852    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    331      72
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
