C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SINGLEBUS
OBJECT MODULE PLACED IN SingleBus.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE SingleBus.c LARGE BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*
   2          ************************Copyright(c)************************
   3          *            湖南一特电子股份有限公司
   4          *             All Rights Reserved
   5          *              
   6          *
   7          *-----------------------文件信息---------------------------
   8          *文件名称         :SingleBus.c
   9          *文件描述       :单总线驱动程序
  10          *创建人         :尹运同
  11          *创建日期       :2009-4-6
  12          *版本号           :V1.0
  13          *注释         :         
  14          *----------------------------------------------------------
  15          *修改人       :
  16          *修改日期       :
  17          *版本号           :
  18          *注释         :
  19          ***********************************************************
  20          */
  21          
  22          #define _IN_SINGLE_BUS_
  23          #include "config.h"
  24          //总线0变量定义
  25          uint8 bdata byBus0State0  = 0;              //单总线0状态字1
  26          sbit  bBus0StartRec     = byBus0State0^0;       //单总线0开始接收起始位标志
  27          sbit  bBus0OnRec      = byBus0State0^1;       //单总线0开始接收数据位标志
  28          sbit  bBus0Enable     = byBus0State0^2;       //单总线0允许发送标志
  29          sbit  bBus0ReqSend      = byBus0State0^3;       //单总线0请求发送标志
  30          sbit  bBus0OnSendBit    = byBus0State0^4;       //单总线0正在发送一个数据位标志
  31          sbit  bBus0OnSendFreq   = byBus0State0^5;       //单总线0正在发送一个数据帧标志
  32          sbit  bBus0SendError    = byBus0State0^6;       //单总线0发送错误标志
  33          sbit  bBus0Error      = byBus0State0^7;       //单总线0故障标志
  34          uint8 bdata byBus0State1  = 0;                //单总线0状态字2
  35          sbit  bBus0RecFinish    = byBus0State1^0;       //单总线0接收完成标志
  36          sbit  bBus0RecBit9      = byBus0State1^1;       //单总线0接收字节数据的第9位
  37          sbit  bBus0SendFinish   = byBus0State1^2;       //单总线0发送完成标志
  38          sbit  bBus0Disable      = byBus0State1^3;       //单总线0禁止发送标志
  39          sbit  bBus0SendBit      = byBus0State1^4;       //单总线0正在发送的数据位
  40          sbit  bBus0RecBit     = byBus0State1^5; 
  41           
  42          uint8 data byBus0RecCount = 0;            //高4位是总线0接收定时中断计数，低4位是接收到的位计数
  43          uint8 data byBus0RecBuf;                //总线0接收缓冲单元
  44          uint8 data byBus0SendBuf;             //总线0发送缓冲单元 
  45          uint8 data byBus0RecData[BUS0_FREQ_SIZE];     //总线0接收缓冲区
  46          uint8 data byBus0SendData[BUS0_FREQ_SIZE];      //总线0发送缓冲区
  47          uint8 data byBus0SendCount = 0;           //高4位是总线0发送定时中断计数，低4位是发送的位计数
  48          uint8 data byBus0RecSendCount = 0;          //高4位是总线0接收到的字节计数，低4位是总线0发送完的字节计数
  49          uint8 data byBus0SendStopCount;           //总线停止时间计数
  50          uint8 data byBus0RecTimeOut = 0;            //总线0接收超时计数
  51          uint8 data byBus0DisableCount = 0;          //总线0禁止计数
  52          uint8 xdata byBus0TxQ[BUS0_TX_Q_ZISE];        //总线0发送队列             
  53          uint8 data byBus0TxHead = 0;
  54          uint8 data byBus0TxTail = 0;
  55          #define IncBus0TxPtr(addr)    {addr=(addr+1)%BUS0_TX_Q_ZISE;}
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 2   

  56          #define Bus0TxBuffLen()       ((byBus0TxTail+BUS0_TX_Q_ZISE-byBus0TxHead)%BUS0_TX_Q_ZISE) 
  57          
  58          sbit  Bus0RecPin  = P3^2;                 //单总线0接收引脚定义
  59          sbit  Bus0SendPin = P3^5;                 //单总线0发送引脚定义
  60          
  61          
  62          
  63          
  64          
  65          
  66          //总线1变量定义
  67          uint8 bdata byBus1State0  = 0;              //单总线1状态字1
  68          sbit  bBus1StartRec     = byBus1State0^0;       //单总线1开始接收起始位标志
  69          sbit  bBus1OnRec      = byBus1State0^1;       //单总线1开始接收数据位标志
  70          sbit  bBus1Enable     = byBus1State0^2;       //单总线1允许发送标志
  71          sbit  bBus1ReqSend      = byBus1State0^3;       //单总线1请求发送标志
  72          sbit  bBus1OnSendBit    = byBus1State0^4;       //单总线1正在发送一个数据位标志
  73          sbit  bBus1OnSendFreq   = byBus1State0^5;       //单总线1正在发送一个数据帧标志
  74          sbit  bBus1SendError    = byBus1State0^6;       //单总线1发送错误标志
  75          sbit  bBus1Error      = byBus1State0^7;       //单总线1故障标志
  76          uint8 bdata byBus1State1  = 0;                //单总线1状态字2
  77          sbit  bBus1RecFinish    = byBus1State1^0;       //单总线1接收完成标志
  78          sbit  bBus1RecBit9      = byBus1State1^1;       //单总线1接收字节数据的第9位
  79          sbit  bBus1SendFinish   = byBus1State1^2;       //单总线1发送完成标志
  80          sbit  bBus1Disable      = byBus1State1^3;       //单总线1禁止发送标志
  81          sbit  bBus1SendBit      = byBus1State1^4;       //单总线1正在发送的数据位
  82          sbit  bBus1RecBit     = byBus1State1^5;         //单总线1正在接收的数据位
  83          uint8 xdata byBus1RecCount = 0;               //高4位是总线1接收定时中断计数，低4位是接收到的位计数
  84          uint8 xdata byBus1RecBuf;                 //总线1接收缓冲单元
  85          uint8 xdata byBus1SendBuf;                  //总线1发送缓冲单元 
  86          uint8 xdata byBus1RecData[BUS1_FREQ_SIZE];          //总线1接收缓冲区
  87          uint8 xdata byBus1SendData[BUS1_FREQ_SIZE];         //总线1发送缓冲区
  88          uint8 xdata byBus1SendCount = 0;              //高4位是总线1发送定时中断计数，低4位是发送的位计数
  89          uint8 xdata byBus1RecSendCount = 0;             //高4位是总线1接收到的字节计数，低4位是总线1发送完的字节计数
  90          uint8 xdata byBus1SendStopCount;                //总线1停止时间计数
  91          uint8 xdata byBus1RecTimeOut = 0;             //总线1接收超时计数
  92          uint8 xdata byBus1DisableCount = 0;             //总线1禁止计数  
  93          uint8 xdata byBus1TxQ[BUS1_TX_Q_ZISE];            //总线1发送队列             
  94          uint8 xdata byBus1TxHead = 0;               //单总线1发送队列头指针
  95          uint8 xdata byBus1TxTail = 0;                 //单总线1发送队列尾指针
  96          #define IncBus1TxPtr(addr)    {addr=(addr+1)%BUS1_TX_Q_ZISE;}
  97          #define Bus1TxBuffLen()       ((byBus1TxTail+BUS1_TX_Q_ZISE-byBus1TxHead)%BUS1_TX_Q_ZISE)  
  98          sbit  Bus1RecPin  = P3^3;                 //单总线1接收引脚定义
  99          sbit  Bus1SendPin = P3^4;                   //单总线1发送引脚定义
 100          
 101          
 102          bit flag_origin_music=0;      //播放背蠊音乐的原始状态
 103          bit bBus0SndBitOk=0;
 104          
 105          
 106          uint8 DTimeState=0;
 107          /*
 108          #define bCH0TimerOutDeal  0x01
 109          #define bCH1TimerOutDeal  0x02
 110          #define bWaitCommAckDTime 0x04
 111          #define bWaitAckTimeLand  0x08
 112          #define bWaitRS485AckDTime  0x10
 113          #define bDetectPcTime   0x20
 114          #define bUsart1SdResultDTime 0x40
 115          #define bDataTimeUpdate     0x80
 116          */
 117          
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 3   

 118          /**********************************************************
 119          *函数名称     :SingleBusInit  
 120          *函数描述         :单总线初始化
 121          *输入参数       :
 122          *返回值       :
 123          *全局变量     :
 124          *调用模块       :
 125          ***********************************************************
 126          *创建人           :尹运同
 127          *创建日期     :2009-4-6
 128          ***********************************************************
 129          *修改人         :
 130          *修改日期       :
 131          *注释           :
 132          **********************************************************/
 133          void SingleBusInit(void)
 134          {
 135   1      //     单总线1
 136   1        //P3^3,高阻输入
 137   1        P3M0 &= (~(Bin(0,0,0,0,1,0,0,0)));
 138   1        P3M1 |=   Bin(0,0,0,0,1,0,0,0);
 139   1      
 140   1      
 141   1        //P3^4,开漏输出 
 142   1        P3M0 |=  (Bin(0,0,0,1,0,0,0,0));
 143   1        P3M1 |=  (Bin(0,0,0,1,0,0,0,0));
 144   1      
 145   1      
 146   1          
 147   1        //总线电平设置
 148   1        Bus0SendPin = 1;
 149   1        Bus0RecPin = 1;  
 150   1        Bus1SendPin = 1;
 151   1        Bus1RecPin = 1;   
 152   1        
 153   1        TMOD &= 0xf0;  //  ;t1作波特率发生器(不变)，
 154   1        TMOD |= 0X01; //t0作方式1（16位)定时器
 155   1      
 156   1        TL0 = TIMER0_L;
 157   1        TH0 = TIMER0_H;
 158   1        TF0 = 0;                        //清除中断标志
 159   1        AUXR &= (~T0x12);                   //传统12分频速度  
 160   1        ET0 = 1;                        //允许定时器0中断 
 161   1        TR0 = 1;                        //启动定时器
 162   1        //其它控制设置
 163   1        byBus0SendStopCount = 240;                //上电总线0禁止发送时间设置   
 164   1        byBus1SendStopCount = 240;                //上电总线1禁止发送时间设置
 165   1      
 166   1        IE0 = 0;                        //清除中断标志
 167   1        IT0 = 1;                        //外部中断0为下降沿触发模式         
 168   1        PT0=1;
 169   1        IE1 = 0;                        //清除外部中断1标志
 170   1        IT1 = 1;                        //外部中断1为下降沿触发模式       
 171   1        
 172   1        if(Bus0RecPin)
 173   1        { //如果总线正常,开中断 
 174   2          EX0 = 1;
 175   2        }
 176   1        else
 177   1        { //如果总线不正常,置总线故障标志         
 178   2          bBus0Error = 1;
 179   2        } 
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 4   

 180   1        if(Bus1RecPin)
 181   1        { //如果总线正常,开中断   
 182   2          EX1 = 1;
 183   2        }
 184   1        else
 185   1        { //如果总线不正常,置总线故障标志       
 186   2          bBus1Error = 1;
 187   2        } 
 188   1      
 189   1      }
 190          
 191          /**********************************************************
 192          *函数名称     :Bus0RecInt 
 193          *函数描述         :外部中断0函数,单总线0接收中断
 194          *输入参数       :
 195          *返回值       :   
 196          *全局变量     :
 197          *调用模块       :
 198          ***********************************************************
 199          *创建人           :尹运同
 200          *创建日期     :2008-9-22
 201          ***********************************************************
 202          *修改人         :
 203          *修改日期       :
 204          *注释           :
 205          **********************************************************/
 206          //#pragma disable
 207          void Bus0RecInt(void) interrupt X0_INTNO
 208          {   
 209   1        EA=0;
 210   1        DisableBus0RecInt();                  //禁止再次下降沿中断
 211   1        bBus0StartRec = 1;                    //启动起始位沿检测
 212   1        bBus0Enable = 0;                    //禁止总线发送              
 213   1        byBus0RecCount = 0;                   //清接收寄存器
 214   1        EA=1;
 215   1      }
 216          /**********************************************************
 217          *函数名称     :Bus1RecInt 
 218          *函数描述         :外部中断1函数,单总线1接收中断
 219          *输入参数       :
 220          *返回值       :   
 221          *全局变量     :
 222          *调用模块       :
 223          ***********************************************************
 224          *创建人           :尹运同
 225          *创建日期     :2008-9-22
 226          ***********************************************************
 227          *修改人         :
 228          *修改日期       :
 229          *注释           :
 230          **********************************************************/
 231          //#pragma disable
 232          void Bus1RecInt(void) interrupt 2
 233          {   
 234   1        EA=0;
 235   1        DisableBus1RecInt();                  //禁止再次下降沿中断
 236   1        bBus1StartRec = 1;                    //启动起始位沿检测
 237   1        bBus1Enable = 0;                    //禁止总线发送              
 238   1        byBus1RecCount = 0;                   //清接收寄存器  
 239   1        EA=1;
 240   1      }
 241          
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 5   

 242          /**********************************************************
 243          *函数名称     :Timer0Int  
 244          *函数描述         :定时器0溢出中断,定时器每93.75us中断一次
 245                     程序间隔检查总线0与总线1的接收和发送
 246          *输入参数       :
 247          *返回值       :   
 248          *全局变量     :
 249          *调用模块       :
 250          ***********************************************************
 251          *创建人           :尹运同
 252          *创建日期     :2008-9-22
 253          ***********************************************************
 254          *修改人         :
 255          *修改日期       :
 256          *注释           :
 257          **********************************************************/
 258          //#pragma disable
 259          void Timer0Int(void) interrupt T0_INTNO
 260          { 
 261   1      
 262   1        EA=0;
 263   1        TR0=0;
 264   1        TH0=TIMER0_H;
 265   1        TL0=TIMER0_L;
 266   1        TR0=1;  
 267   1        
 268   1        bBus0RecBit = Bus0RecPin; 
 269   1        bBus1RecBit = Bus1RecPin;
 270   1        /*******************************总线0接收处理***********************************/
 271   1        if(bBus0StartRec)                   //判断总线所处的状态，接收到起始位
 272   1        {     
 273   2          byBus0RecCount += 0x10;               //增加定时中断计数次数
 274   2          if(0x50 == (byBus0RecCount & 0xf0))         //到总线起始位检测时间
 275   2          {     
 276   3            bBus0StartRec = 0;
 277   3            byBus0RecCount = 0x00;              //重新开始计数      
 278   3            if(bBus0RecBit)     
 279   3            { //无效起始位                                    
 280   4              if((!bBus0SendError)&&bBus0OnSendFreq)
 281   4              { //没有发生过总线发送错误,且有一帧数据正在发送,停止帧数据发送,置发送错误标志           
 282   5                byBus0State0 &= (~BUS0_SEND_CON);
 283   5                bBus0SendError = 1;
 284   5                Bus0SendPin = 1;            //释放总线          
 285   5              }       
 286   4              byBus0SendStopCount = 240;          
 287   4              byBus0RecSendCount = 0x00;          //接收出错,重置接收发送计数值
 288   4              EnableBus0RecInt();       
 289   4            }
 290   3            else                
 291   3            { //有效起始位
 292   4              bBus0OnRec = 1;               //开始接收数据位                      
 293   4            }
 294   3          }
 295   2        }
 296   1        else if(bBus0OnRec)
 297   1        {   
 298   2          byBus0RecCount += 0x10;               //增加定时中断计数次数      
 299   2          if(0xa0 == (byBus0RecCount & 0xf0))
 300   2          {
 301   3            byBus0RecCount &= 0x0f;             //清除定时中断计数次数
 302   3            byBus0RecCount += 0x01;
 303   3            if(0x0a == (byBus0RecCount & 0x0f)) 
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 6   

 304   3            { //收到第10位,结束位         
 305   4              bBus0OnRec = 0;               //停止数据接收          
 306   4              if(bBus0RecBit)
 307   4              { //有效的结束位              
 308   5                if(((bit)(byBus0RecSendCount & 0xf0) == bBus0RecBit9)) 
 309   5                { //数据桢错误
 310   6                  byBus0RecTimeOut = 0;
 311   6                  byBus0RecSendCount &= 0x0f;                     
 312   6                }
 313   5                else 
 314   5                { //数据桢正确          
 315   6                  byBus0RecTimeOut = 230;       //设置下一个字节数据接收超时时间
 316   6                  byBus0RecData[byBus0RecSendCount>>4] = byBus0RecBuf;
 317   6                  byBus0RecSendCount += 0x10;                                         
 318   6                  if((byBus0RecSendCount & 0xf0) >= BUS0_FREQ_SIZE_HI)
 319   6                  {                                           
 320   7                    byBus0RecSendCount &= 0x0f;             
 321   7                    if(!((bBus0OnSendFreq == 1)&&(bBus0ReqSend == 0)))
 322   7                    { //如果接收到的这帧数据是自己发送的不置标志              
 323   8                      bBus0RecFinish = 1;                                                                           
 324   8                    }                                   
 325   7                    byBus0RecTimeOut = 0;
 326   7                    byBus0DisableCount = 10;
 327   7                    bBus0Disable = 1;       //禁止总线使用              
 328   7                  } 
 329   6                }       
 330   5                byBus0SendStopCount = 240;
 331   5                EnableBus0RecInt();           
 332   5              }
 333   4              else              
 334   4              { //无效结束位
 335   5                bBus0Error = 1;                   
 336   5                if((!bBus0SendError) && bBus0OnSendFreq)
 337   5                { //没有发生过总线发送错误,且有一帧数据正在发送,停止帧数据发送,置发送错误标志
 338   6                  byBus0State0 &= (~BUS0_SEND_CON);
 339   6                  bBus0SendError = 1;             
 340   6                  Bus0SendPin = 1;          //释放总线
 341   6                }
 342   5                byBus0RecSendCount = 0x00;        //接收出错,重置接收发送计数值         
 343   5              }
 344   4            }
 345   3            else if(0x09 == (byBus0RecCount & 0x0f))
 346   3            { //第9位数据
 347   4              bBus0RecBit9 = bBus0RecBit;         
 348   4            }
 349   3            else                      
 350   3            { //有效数据位
 351   4              byBus0RecBuf >>= 1;
 352   4              if(bBus0RecBit)
 353   4              { //为高电平
 354   5                byBus0RecBuf |= 0x80;
 355   5              } 
 356   4            }
 357   3          }
 358   2        }
 359   1        /*******************************总线1接收处理***********************************/
 360   1        if(bBus1StartRec)                   //判断总线所处的状态,接收到起始位
 361   1        {     
 362   2          byBus1RecCount += 0x10;               //增加定时中断计数次数
 363   2          if(0x50 == (byBus1RecCount & 0xf0))         //到总线起始位检测时间
 364   2          {     
 365   3            bBus1StartRec = 0;
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 7   

 366   3            byBus1RecCount = 0x00;              //重新开始计数      
 367   3            if(bBus1RecBit)     
 368   3            {   //无效起始位                                    
 369   4              if((!bBus1SendError)&&bBus1OnSendFreq)
 370   4              { //没有发生过总线发送错误,且有一帧数据正在发送,停止帧数据发送,置发送错误标志         
 371   5                byBus1State0 &= (~BUS1_SEND_CON);
 372   5                bBus1SendError = 1;
 373   5                Bus1SendPin = 1;            //释放总线          
 374   5              }       
 375   4              byBus1SendStopCount = 240;          
 376   4              byBus1RecSendCount = 0x00;          //接收出错，重置接收发送计数值
 377   4              EnableBus1RecInt();
 378   4            }
 379   3            else                      //有效起始位
 380   3            {
 381   4              bBus1OnRec = 1;               //开始接收数据位                      
 382   4            }
 383   3          }
 384   2        }
 385   1        else if(bBus1OnRec)
 386   1        {   
 387   2          byBus1RecCount += 0x10;               //增加定时中断计数次数      
 388   2          if(0xa0 == (byBus1RecCount & 0xf0))
 389   2          {
 390   3            byBus1RecCount &= 0x0f;             //清除定时中断计数次数
 391   3            byBus1RecCount += 0x01;
 392   3            if(0x0a == (byBus1RecCount & 0x0f)) 
 393   3            { //收到第10位,结束位           
 394   4              bBus1OnRec = 0;               //停止数据接收          
 395   4              if(bBus1RecBit)
 396   4              { //有效的结束位              
 397   5                if(((bit)(byBus1RecSendCount & 0xf0) == bBus1RecBit9)) 
 398   5                { //数据桢错误
 399   6                  byBus1RecTimeOut = 0;
 400   6                  byBus1RecSendCount &= 0x0f;                     
 401   6                }
 402   5                else 
 403   5                { //数据桢正确          
 404   6                  byBus1RecTimeOut = 230;
 405   6                  byBus1RecData[byBus1RecSendCount>>4] = byBus1RecBuf;
 406   6                  byBus1RecSendCount += 0x10;                                         
 407   6                  if((byBus1RecSendCount & 0xf0) >= BUS1_FREQ_SIZE_HI)
 408   6                  {                                           
 409   7                    byBus1RecSendCount &= 0x0f; 
 410   7                    if(!((bBus1OnSendFreq == 1)&&(bBus1ReqSend==0)))
 411   7                    { //如果接收到的这帧数据是自己发送的不置标志            
 412   8                      bBus1RecFinish = 1;                                                                           
 413   8                    }                                     
 414   7                    byBus1RecTimeOut = 0;
 415   7                    byBus1DisableCount = 10;
 416   7                    bBus1Disable = 1;       //禁止总线使用              
 417   7                  } 
 418   6                }       
 419   5                byBus1SendStopCount = 240;
 420   5                EnableBus1RecInt();           
 421   5              }
 422   4              else              
 423   4              { //无效结束位
 424   5                bBus1Error = 1;                   
 425   5                if((!bBus1SendError) && bBus1OnSendFreq)
 426   5                { //没有发生过总线发送错误,且有一帧数据正在发送,停止帧数据发送,置发送错误标志
 427   6                  byBus1State0 &= (~BUS1_SEND_CON);
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 8   

 428   6                  bBus1SendError = 1;             
 429   6                  Bus1SendPin = 1;          //释放总线
 430   6                }
 431   5                byBus1RecSendCount = 0x00;        //接收出错,重置接收发送计数值
 432   5              }
 433   4            }
 434   3            else if(0x09 == (byBus1RecCount & 0x0f))
 435   3            { //第9位数据
 436   4              bBus1RecBit9 = bBus1RecBit;         
 437   4            }
 438   3            else                      //有效数据位
 439   3            { 
 440   4              byBus1RecBuf >>= 1;
 441   4              if(bBus1RecBit)
 442   4              { //为高电平
 443   5                byBus1RecBuf |= 0x80;
 444   5              } 
 445   4            }
 446   3          }
 447   2        } 
 448   1        
 449   1        /*******************************总线0发送处理***********************************/
 450   1        if((byBus0State0 & BUS0_CAN_SEND) == BUS0_CAN_SEND)
 451   1        { //总线0上有数据发送请求,且总线允许发送    
 452   2          if(bBus0RecBit)
 453   2          { //总线正常,可以发送
 454   3            Bus0SendPin = 0;
 455   3            bBus0SendBit = 0;               //发送起始位数据      
 456   3            byBus0SendCount = 0;
 457   3            byBus0State0 &= (~BUS0_CAN_SEND);
 458   3            byBus0SendBuf = byBus0SendData[byBus0RecSendCount & 0x0f];
 459   3            bBus0OnSendBit = 1;               //取出待发送的数据并置正在发送标志    
 460   3          }
 461   2          else
 462   2          { //总线不正常,停止发送
 463   3            byBus0State0 &= (~BUS0_SEND_CON);
 464   3            bBus0SendError = 1;     
 465   3            byBus0RecSendCount &= 0xf0;
 466   3            Bus0SendPin = 1;
 467   3            byBus0SendStopCount = 240;
 468   3          }
 469   2        }
 470   1        else if(bBus0OnSendBit)
 471   1        { //有数据位正在发送,首先发送的是起始位
 472   2          byBus0SendCount += 0x10;
 473   2          if(0x50 == (byBus0SendCount & 0xf0))
 474   2          {
 475   3            if(bBus0SendBit == bBus0RecBit) bBus0SndBitOk=1;
 476   3            else
 477   3            { //不相同,发送失败     
 478   4              byBus0State0 &= ~BUS0_SEND_CON;
 479   4              byBus0RecSendCount &= 0xf0;
 480   4              bBus0SendError = 1;         
 481   4              Bus0SendPin = 1; 
 482   4              byBus0SendStopCount = 240;
 483   4              bBus0SndBitOk =0;
 484   4            }
 485   3      
 486   3          }
 487   2      
 488   2            
 489   2          //if(bBus0SendBit == bBus0RecBit)   
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 9   

 490   2          else if(bBus0SndBitOk==1)
 491   2          { //发送的数据和接收的数据相同  
 492   3            //byBus0SendCount += 0x10;
 493   3            if(0xa0 == (byBus0SendCount & 0xf0))
 494   3            { //一位数据发送完毕,首先发送的是起始位
 495   4              bBus0SndBitOk =0;
 496   4      
 497   4              byBus0SendCount &= 0x0f;
 498   4              byBus0SendCount += 0x01;        
 499   4              if(0x09 == (byBus0SendCount & 0x0f))
 500   4              { //发送到第9位了
 501   5            
 502   5                bBus0SendBit = !(bit)(byBus0RecSendCount & 0x0f);
 503   5                Bus0SendPin = bBus0SendBit;           
 504   5              }
 505   4              else if(0x0a == (byBus0SendCount & 0x0f))
 506   4              { //发送到结束位了
 507   5                bBus0SendBit = 1;
 508   5                Bus0SendPin = 1;  
 509   5              }
 510   4              else if(0x0b == (byBus0SendCount & 0x0f))
 511   4              { //已经发送完结束位了
 512   5                bBus0OnSendBit = 0;           
 513   5                byBus0RecSendCount += 0x01;                 
 514   5                if((byBus0RecSendCount & 0x0f) >= BUS0_FREQ_SIZE)
 515   5                { //发送完一帧数据                        
 516   6                  byBus0RecSendCount &= 0xf0;     //重新进入数据帧的发送阶段
 517   6                  byBus0State0 &= (~BUS0_SEND_CON);
 518   6                  byBus0SendStopCount = 240;
 519   6                  byBus0State1 |= BUS0_SEND_FINISH;               
 520   6                  byBus0DisableCount = 10;            
 521   6                }
 522   5                else
 523   5                {           
 524   6                  byBus0SendStopCount = 10;
 525   6                  bBus0ReqSend = 1;
 526   6                }
 527   5                EnableBus0RecInt();           //再次使能接收中断
 528   5              }
 529   4              else
 530   4              {
 531   5                if(byBus0SendBuf & 0x01)
 532   5                { //发送高电平
 533   6                  bBus0SendBit = 1;
 534   6                  Bus0SendPin = 1;          
 535   6                }
 536   5                else
 537   5                { //发送低电平
 538   6                  bBus0SendBit = 0;
 539   6                  Bus0SendPin = 0;
 540   6                }
 541   5                byBus0SendBuf >>= 1;          //发送数据位移位操作
 542   5              }
 543   4            }
 544   3          }
 545   2      /*    else
 546   2          { //不相同,发送失败     
 547   2            byBus0State0 &= ~BUS0_SEND_CON;
 548   2            byBus0RecSendCount &= 0xf0;
 549   2            bBus0SendError = 1;         
 550   2            Bus0SendPin = 1; 
 551   2            byBus0SendStopCount = 240;
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 10  

 552   2          }*/
 553   2        } 
 554   1        /*******************************总线1发送处理***********************************/
 555   1        if((byBus1State0 & BUS1_CAN_SEND) == BUS1_CAN_SEND)
 556   1        { //总线0上有数据发送请求,且总线允许发送    
 557   2          if(bBus1RecBit)
 558   2          { //总线正常,可以发送
 559   3            Bus1SendPin = 0;
 560   3            bBus1SendBit = 0;       
 561   3            byBus1SendCount = 0;
 562   3            byBus1State0 &= (~BUS1_CAN_SEND);
 563   3            byBus1SendBuf = byBus1SendData[byBus1RecSendCount & 0x0f];
 564   3            bBus1OnSendBit = 1;     
 565   3          }
 566   2          else
 567   2          { //总线不正常,停止发送
 568   3            byBus1State0 &= (~BUS1_SEND_CON);
 569   3            bBus1SendError = 1;     
 570   3            byBus1RecSendCount &= 0xf0;
 571   3            Bus1SendPin = 1;
 572   3            byBus1SendStopCount = 240;
 573   3          }
 574   2        }
 575   1        else if(bBus1OnSendBit)
 576   1        {   //有数据位正在发送,首先发送的是起始位     
 577   2          if(bBus1SendBit == bBus1RecBit)       
 578   2          { //发送的数据和接收的数据相同
 579   3            byBus1SendCount += 0x10;
 580   3            if(0xa0 == (byBus1SendCount & 0xf0))
 581   3            { //一位数据发送完毕,首先发送的是起始位
 582   4              byBus1SendCount &= 0x0f;
 583   4              byBus1SendCount += 0x01;        
 584   4              if(0x09 == (byBus1SendCount & 0x0f))
 585   4              { //发送到第9位了
 586   5                bBus1SendBit = !(bit)(byBus1RecSendCount & 0x0f);
 587   5                Bus1SendPin = bBus1SendBit;           
 588   5              }
 589   4              else if(0x0a == (byBus1SendCount & 0x0f))
 590   4              { //发送到结束位了
 591   5                bBus1SendBit = 1;
 592   5                Bus1SendPin = 1;  
 593   5              }
 594   4              else if(0x0b == (byBus1SendCount & 0x0f))
 595   4              { //已经发送完结束位了
 596   5                bBus1OnSendBit = 0;           
 597   5                byBus1RecSendCount += 0x01;                 
 598   5                if((byBus1RecSendCount & 0x0f) >= BUS1_FREQ_SIZE)
 599   5                { //发送完一帧数据                        
 600   6                  byBus1RecSendCount &= 0xf0;     //重新进入数据帧的发送阶段
 601   6                  byBus1State0 &= (~BUS1_SEND_CON);
 602   6                  byBus1SendStopCount = 240;
 603   6                  byBus1State1 |= BUS1_SEND_FINISH;                 
 604   6                  byBus1DisableCount = 10;                
 605   6                }
 606   5                else
 607   5                {             
 608   6                  byBus1SendStopCount = 10;
 609   6                  bBus1ReqSend = 1;
 610   6                }
 611   5                EnableBus1RecInt();           //再次使能接收中断
 612   5              }
 613   4              else
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 11  

 614   4              {
 615   5                if(byBus1SendBuf & 0x01)
 616   5                { //发送高电平
 617   6                  bBus1SendBit = 1;
 618   6                  Bus1SendPin = 1;          
 619   6                }
 620   5                else
 621   5                { //发送低电平
 622   6                  bBus1SendBit = 0;
 623   6                  Bus1SendPin = 0;
 624   6                }
 625   5                byBus1SendBuf >>= 1;          //发送数据位移位操作
 626   5              }
 627   4            }
 628   3          }
 629   2          else
 630   2          { //不相同,发送失败               
 631   3            byBus1State0 &= ~BUS1_SEND_CON;
 632   3            byBus1RecSendCount &= 0xf0;
 633   3            bBus1SendError = 1;         
 634   3            Bus1SendPin = 1; 
 635   3            byBus1SendStopCount = 240;
 636   3          }
 637   2        }   
 638   1        
 639   1        /*******************************总线0控制处理***********************************/
 640   1        if(0 == (byBus0State0 & BUS0_ON_REC))
 641   1        { 
 642   2          if(byBus0SendStopCount != 0)
 643   2          {
 644   3            if((--byBus0SendStopCount) == 0)
 645   3            {       
 646   4              bBus0Enable = 1;                
 647   4            }
 648   3          }   
 649   2          if(bBus0Error)
 650   2          {               
 651   3            bBus0Enable = 0;      
 652   3            if(bBus0RecBit)
 653   3            {       
 654   4              bBus0Error = 0;
 655   4              EnableBus0RecInt();
 656   4              byBus0SendStopCount = 240;
 657   4            }
 658   3          }
 659   2        } 
 660   1        /*******************************总线1控制处理***********************************/
 661   1        if(0 == (byBus1State0 & BUS1_ON_REC))
 662   1        {
 663   2          if(byBus1SendStopCount != 0)
 664   2          {
 665   3            if((--byBus1SendStopCount) == 0)
 666   3            {       
 667   4              bBus1Enable = 1;                
 668   4            }
 669   3          }   
 670   2          if(bBus1Error)
 671   2          {               
 672   3            bBus1Enable = 0;      
 673   3            if(bBus1RecBit)
 674   3            {       
 675   4              bBus1Error = 0;
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 12  

 676   4              EnableBus1RecInt();
 677   4              byBus1SendStopCount = 240;
 678   4            }
 679   3          }
 680   2        }   
 681   1        
 682   1        /*******************************总线0超时处理***********************************/
 683   1        if(byBus0RecTimeOut != 0)
 684   1        {
 685   2          if(--byBus0RecTimeOut == 0)             
 686   2          { //接收超时到
 687   3            byBus0RecSendCount &= 0x0f;     
 688   3          }
 689   2        }
 690   1        if(byBus0DisableCount != 0)
 691   1        {
 692   2          if(--byBus0DisableCount == 0)           
 693   2          { //禁止超时到    
 694   3            bBus0Disable = 0;
 695   3          }
 696   2        }
 697   1        
 698   1        /*******************************总线1超时处理***********************************/
 699   1        if(byBus1RecTimeOut != 0)
 700   1        {
 701   2          if(--byBus1RecTimeOut == 0)             
 702   2          { //接收超时到
 703   3            byBus1RecSendCount &= 0x0f;
 704   3          }
 705   2        }
 706   1        if(byBus1DisableCount != 0)
 707   1        {
 708   2          if(--byBus1DisableCount == 0)           
 709   2          { //禁止超时到    
 710   3            bBus1Disable = 0;
 711   3          }
 712   2        } 
 713   1        
 714   1        /***********总线0自动发送管理**********/   
 715   1        if((byBus0State0 & BUS0_ON_WORK) == 0x00)       
 716   1        { //总线0没有工作       
 717   2          if(bBus0SendError)            
 718   2          { //产生了发送错误,自动重发               
 719   3            bBus0SendError = 0;       
 720   3            byBus0State0 |= BUS0_REQ_SEND;    
 721   3          }
 722   2          else                  
 723   2          { //总线0无发送错误   
 724   3            if(!(bBus0SendFinish|bBus0Disable))
 725   3            { //总线0没有禁止使用,且发送结束处理已经完成
 726   4              if(Bus0TxBuffLen() >= BUS0_FREQ_SIZE)
 727   4              { //有一帧完整的数据在发送队列中                                    
 728   5                byBus0SendData[0] = byBus0TxQ[byBus0TxHead];
 729   5                IncBus0TxPtr(byBus0TxHead);
 730   5                byBus0SendData[1] = byBus0TxQ[byBus0TxHead];
 731   5                IncBus0TxPtr(byBus0TxHead);
 732   5                byBus0SendData[2] = byBus0TxQ[byBus0TxHead];
 733   5                IncBus0TxPtr(byBus0TxHead);
 734   5                byBus0SendData[3] = byBus0TxQ[byBus0TxHead];
 735   5                IncBus0TxPtr(byBus0TxHead);
 736   5                byBus0SendData[4] = byBus0TxQ[byBus0TxHead];
 737   5                IncBus0TxPtr(byBus0TxHead);
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 13  

 738   5                byBus0SendData[5] = byBus0TxQ[byBus0TxHead];
 739   5                IncBus0TxPtr(byBus0TxHead);
 740   5                byBus0SendData[6] = byBus0TxQ[byBus0TxHead];
 741   5                IncBus0TxPtr(byBus0TxHead); 
 742   5                byBus0State0 |= BUS0_REQ_SEND;  
 743   5      
 744   5              }
 745   4              else
 746   4              { //没有一帧完整的数据在发送队列中了
 747   5                byBus0TxHead = byBus0TxTail = 0;
 748   5              }               
 749   4            }
 750   3          }
 751   2        } 
 752   1        /***********总线1自动发送管理**********/   
 753   1        if((byBus1State0 & BUS1_ON_WORK) == 0x00) 
 754   1        { //总线1没有工作       
 755   2          if(bBus1SendError)            
 756   2          { //产生了发送错误,自动重发               
 757   3            bBus1SendError = 0;       
 758   3            byBus1State0 |= BUS1_REQ_SEND;    
 759   3          }
 760   2          else                  
 761   2          { //总线1无发送错误   
 762   3            if(!(bBus1SendFinish|bBus1Disable))
 763   3            { //总线0没有禁止使用,且发送结束处理已经完成
 764   4              if(Bus1TxBuffLen() >= BUS1_FREQ_SIZE)
 765   4              { //有一帧完整的数据在发送队列中                                      
 766   5                byBus1SendData[0] = byBus1TxQ[byBus1TxHead];
 767   5                IncBus1TxPtr(byBus1TxHead);
 768   5                byBus1SendData[1] = byBus1TxQ[byBus1TxHead];
 769   5                IncBus1TxPtr(byBus1TxHead);
 770   5                byBus1SendData[2] = byBus1TxQ[byBus1TxHead];
 771   5                IncBus1TxPtr(byBus1TxHead);
 772   5                byBus1SendData[3] = byBus1TxQ[byBus1TxHead];
 773   5                IncBus1TxPtr(byBus1TxHead);
 774   5                byBus1SendData[4] = byBus1TxQ[byBus1TxHead];
 775   5                IncBus1TxPtr(byBus1TxHead);
 776   5                byBus1SendData[5] = byBus1TxQ[byBus1TxHead];
 777   5                IncBus1TxPtr(byBus1TxHead);
 778   5                byBus1SendData[6] = byBus1TxQ[byBus1TxHead];
 779   5                IncBus1TxPtr(byBus1TxHead); 
 780   5                byBus1State0 |= BUS1_REQ_SEND;            
 781   5              }
 782   4              else
 783   4              { //没有一帧完整的数据在发送队列中了
 784   5                byBus1TxHead = byBus1TxTail = 0;
 785   5              }               
 786   4            }
 787   3          }
 788   2        }
 789   1        EA=1;
 790   1      }
 791          
 792          
 793          /**********************************************************
 794          *函数名称     :SaveCallAddr 
 795          *函数描述         :保存主动通话方地址
 796          *输入参数       :pstBus0SendFreq:待保存的数据帧指针
 797          *返回值       :
 798          *全局变量     :stLocalControl
 799          *调用模块       :
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 14  

 800          ***********************************************************
 801          *创建人           :尹运同
 802          *创建日期     :2008-9-22
 803          ***********************************************************
 804          *修改人         :
 805          *修改日期       :
 806          *注释           :
 807          **********************************************************/
 808          void SaveCallAddr(pSTBusFreq pstBusFreq)
 809          {   
 810   1        stLocalControl.stCallAddr.bySndSecAddr = pstBusFreq->bySndSecAddr;
 811   1        stLocalControl.stCallAddr.bySndRoomAddr = pstBusFreq->bySndRoomAddr;
 812   1        stLocalControl.stCallAddr.bySndBedAddr = pstBusFreq->bySndBedAddr;
 813   1      
 814   1        stLocalControl.stCallAddr.byRecSecAddr = pstBusFreq->byRecSecAddr;
 815   1        stLocalControl.stCallAddr.byRecRoomAddr = pstBusFreq->byRecRoomAddr;
 816   1        stLocalControl.stCallAddr.byRecBedAddr = pstBusFreq->byRecBedAddr;  
 817   1      }
 818          
 819          /**********************************************************
 820          *函数名称     :AddrCompare  
 821          *函数描述         :比较地址(含广播地址)
 822          *输入参数       :pstBusFreq:待比较的数据帧指针
 823          *返回值       :1:发送到本机的数据,0:不是发送到本机的数据  
 824          *全局变量     :
 825          *调用模块       :
 826          ***********************************************************
 827          *创建人           :尹运同
 828          *创建日期     :2008-9-22
 829          ***********************************************************
 830          *修改人         :
 831          *修改日期       :
 832          *注释           :
 833          **********************************************************/
 834          bit AddrCompare(uint8 *pAddrA,uint8 *pAddrB)
 835          {
 836   1      
 837   1        if((*pAddrA != 0xff) && (*pAddrA != *pAddrB) && (*pAddrB != 0xff))
 838   1        { 
 839   2          return(0);
 840   2        } 
 841   1        
 842   1        if((*(pAddrA+1) != 0xff) && (*(pAddrA+1) != *(pAddrB+1)) && (*(pAddrB+1) != 0xff))
 843   1        { 
 844   2          return(0);
 845   2        }
 846   1        
 847   1        if((*(pAddrA+2) != 0xff) && (*(pAddrA+2) != *(pAddrB+2)) && (*(pAddrB+2) != 0xff))
 848   1        { 
 849   2          return(0);
 850   2        }
 851   1        
 852   1        return(1); 
 853   1      
 854   1      }
 855          
 856          /**********************************************************
 857          *函数名称     :DirAddrCompare 
 858          *函数描述         :绝对比较地址
 859          *输入参数       :pstBusFreq:待比较的数据帧指针
 860          *返回值       :1:发送到本机的数据,0:不是发送到本机的数据  
 861          *全局变量     :
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 15  

 862          *调用模块       :
 863          ***********************************************************
 864          *创建人           :尹运同
 865          *创建日期     :2008-9-22
 866          ***********************************************************
 867          *修改人         :
 868          *修改日期       :
 869          *注释           :
 870          **********************************************************/
 871          bit DirAddrCompare(uint8 *pAddrA,uint8 *pAddrB)
 872          {
 873   1        if(*pAddrA != *pAddrB)
 874   1        { 
 875   2          return(0);
 876   2        } 
 877   1        if(*(pAddrA+1) != *(pAddrB+1))
 878   1        { 
 879   2          return(0);
 880   2        }
 881   1        if(*(pAddrA+2) != *(pAddrB+2))
 882   1        { 
 883   2          return(0);
 884   2        }
 885   1        return(1); 
 886   1      }
 887          /**********************************************************
 888          *函数名称     :Bus0OutputData 
 889          *函数描述         :单总线0将待发送数据放入缓冲区
 890          *输入参数       :pbyData:待发送的数据指针
 891          *返回值       :true:发送成功,false:发送失败
 892          *全局变量     :
 893          *调用模块       :
 894          ***********************************************************
 895          *创建人           :尹运同
 896          *创建日期     :2009-4-6
 897          ***********************************************************
 898          *修改人         :
 899          *修改日期       :
 900          *注释           :
 901          **********************************************************/
 902          uint8 Bus0OutputData(uint8* pbyData)
 903          {
 904   1        uint8 byTemp = BUS0_FREQ_SIZE;
 905   1      
 906   1        EA=0;
 907   1        if(Bus0TxBuffLen() >= (BUS0_TX_Q_ZISE - 1))
 908   1        { //已经没有存储空间了
 909   2          EA=1;
 910   2          return(false);
 911   2        } 
 912   1        while(byTemp--)
 913   1        {
 914   2          byBus0TxQ[byBus0TxTail] = *pbyData++;
 915   2          IncBus0TxPtr(byBus0TxTail);
 916   2        }
 917   1        EA=1; 
 918   1        return(true); 
 919   1      }
 920          
 921          /**********************************************************
 922          *函数名称     :Bus1OutputData 
 923          *函数描述         :单总线1将待发送数据放入缓冲区
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 16  

 924          *输入参数       :pbyData:待发送的数据指针
 925          *返回值       :TRUE:发送成功,FALSE:队列满,发送失败  
 926          *全局变量     :
 927          *调用模块       :
 928          ***********************************************************
 929          *创建人           :尹运同
 930          *创建日期     :2008-9-22
 931          ***********************************************************
 932          *修改人         :
 933          *修改日期       :
 934          *注释           :
 935          **********************************************************/
 936          uint8 Bus1OutputData(uint8* pbyData)
 937          {
 938   1        uint8 byTemp = BUS1_FREQ_SIZE;
 939   1      
 940   1        EA=0;
 941   1        if(Bus1TxBuffLen() >= (BUS1_TX_Q_ZISE - 1))
 942   1        { //没有空间存储了,失败 
 943   2          EA=1;
 944   2          return(FALSE);
 945   2        }  
 946   1        while(byTemp--)
 947   1        { //数据入发送队列
 948   2          byBus1TxQ[byBus1TxTail] = *pbyData++;
 949   2          IncBus1TxPtr(byBus1TxTail);
 950   2        }
 951   1        EA=1; 
 952   1        return(TRUE); 
 953   1      }
 954          
 955          /**********************************************************
 956          *函数名称     :MakeCH0TimerOut  
 957          *函数描述         :设置通道0超时参数
 958          *输入参数       :byTimerOut:超时时间计数,byTimerOutCount:超时次数
 959          *返回值       :
 960          *全局变量     :
 961          *调用模块       :
 962          ***********************************************************
 963          *创建人           :尹运同
 964          *创建日期     :2009-4-6
 965          ***********************************************************
 966          *修改人         :
 967          *修改日期       :
 968          *注释           :
 969          **********************************************************/
 970          void MakeCH0TimerOut(uint8 byTimerOut, uint8 byTimerOutCount)
 971          {
 972   1        stLocalControl.stCH0TimerOut.byTimerOutSet = byTimerOut;
 973   1        stLocalControl.stCH0TimerOut.byTimerOut = byTimerOut;
 974   1        stLocalControl.stCH0TimerOut.byTimerOutCount = byTimerOutCount; 
 975   1      }
 976          /**********************************************************
 977          *函数名称     :MakeCH1TimerOut  
 978          *函数描述         :设置通道1超时参数
 979          *输入参数       :byTimerOut:超时时间计数,byTimerOutCount:超时次数
 980          *返回值       :
 981          *全局变量     :
 982          *调用模块       :
 983          ***********************************************************
 984          *创建人           :尹运同
 985          *创建日期     :2009-4-6
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 17  

 986          ***********************************************************
 987          *修改人         :
 988          *修改日期       :
 989          *注释           :
 990          **********************************************************/
 991          void MakeCH1TimerOut(uint8 byTimerOut, uint8 byTimerOutCount)
 992          {
 993   1        stLocalControl.stCH1TimerOut.byTimerOutSet = byTimerOut;
 994   1        stLocalControl.stCH1TimerOut.byTimerOut = byTimerOut;
 995   1        stLocalControl.stCH1TimerOut.byTimerOutCount = byTimerOutCount; 
 996   1      }
 997           
 998          /**********************************************************
 999          *函数名称     :AddCallNod 
1000          *函数描述         :增加呼叫节点
1001          *输入参数       :pstBusFreq:待入链表的总线数据指针
1002          *返回值       :SAVE_FAIL:失败,SAVE_NORMAL:成功,
1003                     SAVE_PRIO_HI:成功,且有高优先级            
1004          *全局变量     :stLocalControl
1005          *调用模块       :
1006          ***********************************************************
1007          *创建人           :尹运同
1008          *创建日期     :2009-4-6
1009          ***********************************************************
1010          *修改人         :
1011          *修改日期       :
1012          *注释           :
1013          **********************************************************/
1014          uint8 AddCallNod(pSTBusFreq pstBusFreq)
1015          {
1016   1          pSTNod xdata pstNodTemp;
1017   1          pSTNod xdata pstCallNod;
1018   1          
1019   1          if(NULL == (uint8 xdata *)(stLocalControl.stCallPointer.pstHead))
1020   1          {   //链表为空
1021   2          
1022   2            //pstNodTemp = OSMemNew(sizeof(STNod));
1023   2              pstNodTemp = malloc(sizeof(STNod));
1024   2              if(NULL ==(uint8 xdata *)pstNodTemp)
1025   2              {         
1026   3                  return(SAVE_FAIL);
1027   3              }
1028   2              pstNodTemp->byCallSecAddr = pstBusFreq->bySndSecAddr;
1029   2              pstNodTemp->byCallRoomAddr = pstBusFreq->bySndRoomAddr;
1030   2              pstNodTemp->byCallBedAddr = pstBusFreq->bySndBedAddr;  
1031   2              pstNodTemp->byCallPriority = pstBusFreq->byRecSecAddr & 0xe0;
1032   2              pstNodTemp->byCallPriority |= (pstBusFreq->byCmd & 0x1f);   
1033   2              pstNodTemp->pstPrev = pstNodTemp->pstNext = NULL;
1034   2              stLocalControl.stCallPointer.pstTail = 
1035   2              stLocalControl.stCallPointer.pstHead = pstNodTemp;      
1036   2              return(SAVE_ONLY); 
1037   2          }
1038   1          //链表不为空,先查找是否有该节点了
1039   1          pstCallNod = stLocalControl.stCallPointer.pstHead;
1040   1          while(NULL != (uint8 xdata *)pstCallNod)
1041   1          {
1042   2              if((pstCallNod->byCallSecAddr == pstBusFreq->bySndSecAddr) &&
1043   2                (pstCallNod->byCallRoomAddr == pstBusFreq->bySndRoomAddr) &&
1044   2                (pstCallNod->byCallBedAddr == pstBusFreq->bySndBedAddr) &&
1045   2                ((pstCallNod->byCallPriority & 0x1f) == (pstBusFreq->byCmd & 0x1f)))
1046   2              { //已经有了该呼叫节点的信息
1047   3                  return(SAVE_EXIST);
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 18  

1048   3              }
1049   2              pstCallNod = pstCallNod->pstNext;
1050   2          }
1051   1          //没有相同的呼叫,重新排列呼叫优先级
1052   1          pstCallNod = stLocalControl.stCallPointer.pstTail;
1053   1        //查看是否为最后一个节点
1054   1        if(((pstCallNod->byCallPriority) & 0xe0) >= (pstBusFreq->byRecSecAddr & 0xe0))
1055   1        { //为最后一个节点
1056   2          //pstNodTemp = OSMemNew(sizeof(STNod));
1057   2          pstNodTemp = malloc(sizeof(STNod));
1058   2              if(NULL ==(uint8 xdata *)pstNodTemp)
1059   2              {         
1060   3                  return(SAVE_FAIL);
1061   3              }
1062   2              pstNodTemp->byCallSecAddr = pstBusFreq->bySndSecAddr;
1063   2              pstNodTemp->byCallRoomAddr = pstBusFreq->bySndRoomAddr;
1064   2              pstNodTemp->byCallBedAddr = pstBusFreq->bySndBedAddr;  
1065   2              pstNodTemp->byCallPriority = pstBusFreq->byRecSecAddr & 0xe0;
1066   2              pstNodTemp->byCallPriority |= (pstBusFreq->byCmd & 0x1f); 
1067   2          pstCallNod->pstNext = pstNodTemp;
1068   2          pstNodTemp->pstPrev = pstCallNod; 
1069   2          pstNodTemp->pstNext = NULL;
1070   2          stLocalControl.stCallPointer.pstTail = pstNodTemp;  
1071   2          if(NULL == (stLocalControl.stIndicationData.pstNext))
1072   2          { //正在指示的节点为最后一个节点，将刚才添加的节点添加到后面
1073   3            stLocalControl.stIndicationData.pstNext = pstNodTemp;
1074   3          } 
1075   2          return(SAVE_NORMAL);    
1076   2        }
1077   1        //不是最后一个节点,向前查找
1078   1        pstCallNod = pstCallNod->pstPrev;
1079   1        while(NULL !=(uint8 xdata *)pstCallNod)
1080   1        {
1081   2          if(((pstCallNod->byCallPriority) & 0xe0) < (pstBusFreq->byRecSecAddr & 0xe0))
1082   2          { //继续向前查找
1083   3            pstCallNod = pstCallNod->pstPrev;
1084   3          }
1085   2          else
1086   2          { //找到合适的位置,不为第一个节点，插入节点
1087   3      //        pstNodTemp = OSMemNew(sizeof(STNod));  
1088   3                pstNodTemp = malloc(sizeof(STNod));
1089   3                if(NULL == (uint8 xdata *)pstNodTemp)
1090   3                {         
1091   4                    return(SAVE_FAIL);
1092   4                }
1093   3            pstNodTemp->byCallSecAddr = pstBusFreq->bySndSecAddr;
1094   3                pstNodTemp->byCallRoomAddr = pstBusFreq->bySndRoomAddr;
1095   3                pstNodTemp->byCallBedAddr = pstBusFreq->bySndBedAddr;  
1096   3                pstNodTemp->byCallPriority = pstBusFreq->byRecSecAddr & 0xe0;
1097   3                pstNodTemp->byCallPriority |= pstBusFreq->byCmd;
1098   3                (pstCallNod->pstNext)->pstPrev = pstNodTemp;
1099   3                pstNodTemp->pstPrev = pstCallNod;
1100   3                pstNodTemp->pstNext = pstCallNod->pstNext;
1101   3                pstCallNod->pstNext = pstNodTemp;   
1102   3                if(pstNodTemp->pstNext == stLocalControl.stIndicationData.pstNext)
1103   3                { //该节点添加到了正在指示的节点的后面，更新正在指示的节点指针信息
1104   4                  stLocalControl.stIndicationData.pstNext = pstNodTemp;
1105   4                }       
1106   3                return(SAVE_NORMAL);                          
1107   3          }
1108   2        }
1109   1        //该插入的节点优先级为最高优先级，插入到链表的头部
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 19  

1110   1        if(NULL == (uint8 xdata *)pstCallNod)
1111   1        {
1112   2          //pstNodTemp = OSMemNew(sizeof(STNod));
1113   2          pstNodTemp = malloc(sizeof(STNod));
1114   2            if(NULL ==(uint8 xdata *)pstNodTemp)
1115   2          {         
1116   3            return(SAVE_FAIL);
1117   3          }
1118   2          pstNodTemp->byCallSecAddr = pstBusFreq->bySndSecAddr;
1119   2              pstNodTemp->byCallRoomAddr = pstBusFreq->bySndRoomAddr;
1120   2              pstNodTemp->byCallBedAddr = pstBusFreq->bySndBedAddr;  
1121   2              pstNodTemp->byCallPriority = pstBusFreq->byRecSecAddr & 0xe0;
1122   2              pstNodTemp->byCallPriority |= pstBusFreq->byCmd;
1123   2              (stLocalControl.stCallPointer.pstHead)->pstPrev = pstNodTemp;
1124   2              pstNodTemp->pstNext = stLocalControl.stCallPointer.pstHead;
1125   2              pstNodTemp->pstPrev = NULL;
1126   2              stLocalControl.stCallPointer.pstHead = pstNodTemp;  
1127   2              stLocalControl.stIndicationData.byState = STATE_HI;              
1128   2              return(SAVE_PRIO_HI);
1129   2        }  
1130   1        return(SAVE_FAIL);
1131   1      }
1132          /**********************************************************
1133          *函数名称     :RemoveCallNod  
1134          *函数描述         :删除呼叫节点
1135          *输入参数       :pstBusFreq:待删除的节点数据指针
1136          *返回值       :
1137          *全局变量     :stLocalControl
1138          *调用模块       :
1139          ***********************************************************
1140          *创建人           :尹运同
1141          *创建日期     :2009-4-6
1142          ***********************************************************
1143          *修改人         :
1144          *修改日期       :
1145          *注释           :
1146          **********************************************************/
1147          void RemoveCallNod(pSTBusFreq pstBusFreq)
1148          {
1149   1        pSTNod xdata pstCallNod;
1150   1        
1151   1        //查找是否有该呼叫纪录
1152   1        pstCallNod = stLocalControl.stCallPointer.pstHead;
1153   1        if((uint8 xdata *)pstCallNod == NULL)
1154   1        { //没有呼叫纪录,直接退出   
1155   2          return;
1156   2        }
1157   1        //如果删除的该呼叫为正在指示的节点，置正在指示的节点的不存在标志
1158   1        if((stLocalControl.stIndicationData.byIndicationSecAddr == pstBusFreq->byRecSecAddr) &&
1159   1          (stLocalControl.stIndicationData.byIndicationRoomAddr == pstBusFreq->byRecRoomAddr) &&
1160   1          (stLocalControl.stIndicationData.byIndicationBedAddr == pstBusFreq->byRecBedAddr) && 
1161   1          ((stLocalControl.stIndicationData.byCallCmd & 0x1f) == (pstBusFreq->byCmd & 0x1f)))
1162   1        {
1163   2          stLocalControl.stIndicationData.byState = STATE_DEL;
1164   2        }
1165   1        else
1166   1        { //删除的节点不是正在指示的节点，看是否为后一个节点
1167   2          if(((uint8 xdata *)stLocalControl.stIndicationData.pstNext != NULL) && 
1168   2            (stLocalControl.stIndicationData.pstNext->byCallSecAddr == pstBusFreq->byRecSecAddr) &&
1169   2            ((stLocalControl.stIndicationData.pstNext)->byCallRoomAddr == pstBusFreq->byRecRoomAddr) &&
1170   2            (stLocalControl.stIndicationData.pstNext->byCallBedAddr == pstBusFreq->byRecBedAddr) &&
1171   2            ((stLocalControl.stIndicationData.pstNext->byCallPriority & 0x1f) == (pstBusFreq->byCmd & 0x1f))) 
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 20  

1172   2          { //是正在指示的呼叫的后一个节点，调整指针
1173   3            stLocalControl.stIndicationData.pstNext = stLocalControl.stIndicationData.pstNext->pstNext;
1174   3          } 
1175   2        }   
1176   1        if((pstCallNod->byCallSecAddr == pstBusFreq->byRecSecAddr) &&
1177   1            (pstCallNod->byCallRoomAddr == pstBusFreq->byRecRoomAddr) &&
1178   1            (pstCallNod->byCallBedAddr == pstBusFreq->byRecBedAddr) &&
1179   1            ((pstCallNod->byCallPriority & 0x1f) == (pstBusFreq->byCmd & 0x1f)))
1180   1        { //找到该呼叫信息，并且是最高优先级的
1181   2          if(NULL ==(uint8 xdata *)pstCallNod->pstNext)
1182   2          { //该呼叫纪录为唯一的一条纪录
1183   3            stLocalControl.stCallPointer.pstHead = 
1184   3              stLocalControl.stCallPointer.pstTail = NULL; 
1185   3            //OSMemFree(pstCallNod);
1186   3            free(pstCallNod);       
1187   3            return;     
1188   3          }
1189   2          else
1190   2          { //不是唯一的一条记录
1191   3            stLocalControl.stCallPointer.pstHead = pstCallNod->pstNext;
1192   3            (pstCallNod->pstNext)->pstPrev = NULL;
1193   3            //OSMemFree(pstCallNod);
1194   3            free(pstCallNod);
1195   3            return;
1196   3          }
1197   2        }
1198   1        //不是第一条记录,继续查找
1199   1        pstCallNod = pstCallNod->pstNext;
1200   1        while(NULL != (uint8 xdata *)pstCallNod)
1201   1        {
1202   2          if((pstCallNod->byCallSecAddr == pstBusFreq->byRecSecAddr) &&
1203   2              (pstCallNod->byCallRoomAddr == pstBusFreq->byRecRoomAddr) &&
1204   2              (pstCallNod->byCallBedAddr == pstBusFreq->byRecBedAddr) &&
1205   2              ((pstCallNod->byCallPriority & 0x1f) == (pstBusFreq->byCmd & 0x1f)))
1206   2          { //找到该呼叫信息
1207   3            if(NULL == (uint8 xdata *)pstCallNod->pstNext)
1208   3            { //该呼叫信息为最后一条记录,直接删除最后一个节点
1209   4              (pstCallNod->pstPrev)->pstNext = NULL;
1210   4              stLocalControl.stCallPointer.pstTail = pstCallNod->pstPrev;       
1211   4            }
1212   3            else
1213   3            { //不是最后一条记录,从链表中删除该节点 
1214   4              (pstCallNod->pstPrev)->pstNext = pstCallNod->pstNext;
1215   4              (pstCallNod->pstNext)->pstPrev = pstCallNod->pstPrev;
1216   4            }
1217   3            //OSMemFree(pstCallNod);
1218   3            free(pstCallNod);
1219   3            return;
1220   3          }
1221   2          pstCallNod = pstCallNod->pstNext;
1222   2        } 
1223   1      }
1224          /**********************************************************
1225          *函数名称     :CheckCallNod 
1226          *函数描述         :检查该节点是否还存在
1227          *输入参数       :pstBus0SendFreq:数据指针
1228          *返回值       :true:查找到该节点,false:没有查找到该节点
1229          *全局变量     :
1230          *调用模块       :
1231          ***********************************************************
1232          *创建人           :尹运同
1233          *创建日期     :2009-4-6
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 21  

1234          ***********************************************************
1235          *修改人         :
1236          *修改日期       :
1237          *注释           :
1238          **********************************************************/
1239          /*uint8 CheckCallNod(pSTBusFreq pstBusFreq)
1240          {
1241            pSTNod xdata pstCallNod;
1242            
1243            pstCallNod = stLocalControl.stCallPointer.pstHead;
1244              while(NULL != (uint8 xdata *)pstCallNod)
1245              {
1246                  if((pstCallNod->byCallSecAddr == pstBusFreq->bySndSecAddr) &&
1247                    (pstCallNod->byCallRoomAddr == pstBusFreq->bySndRoomAddr) &&
1248                    (pstCallNod->byCallBedAddr == pstBusFreq->bySndBedAddr) &&
1249                    ((pstCallNod->byCallPriority & 0x1f) == (pstBusFreq->byCmd & 0x1f)))
1250                  { //该呼叫信息还存在
1251                      return(true);
1252                  }
1253                  pstCallNod = pstCallNod->pstNext;
1254              }
1255             return(false);
1256          }*/
1257          /**********************************************************
1258          *函数名称     :SaveIndicationData 
1259          *函数描述         :保存信息指示数据内容
1260          *输入参数       :pstBus0SendFreq:总线数据指针，byFistNod:是否为保存第一个节点信息
1261          *返回值       :
1262          *全局变量     :stLocalControl
1263          *调用模块       :
1264          ***********************************************************
1265          *创建人           :尹运同
1266          *创建日期     :2009-4-6
1267          ***********************************************************
1268          *修改人         :
1269          *修改日期       :
1270          *注释           :
1271          **********************************************************/
1272          void SaveIndicationData(pSTBusFreq pstBusFreq, uint8 byFirstNod)
1273          {
1274   1        //保存信息指示方的地址
1275   1        stLocalControl.stIndicationData.byIndicationSecAddr = pstBusFreq->bySndSecAddr;
1276   1        stLocalControl.stIndicationData.byIndicationRoomAddr = pstBusFreq->bySndRoomAddr;
1277   1        stLocalControl.stIndicationData.byIndicationBedAddr = pstBusFreq->bySndBedAddr;
1278   1        stLocalControl.stIndicationData.byCallCmd = pstBusFreq->byRecSecAddr;
1279   1        stLocalControl.stIndicationData.byState = STATE_EXIST;
1280   1        if(byFirstNod)
1281   1        { //保存第一个节点信息    
1282   2          stLocalControl.stIndicationData.pstNext = stLocalControl.stCallPointer.pstHead->pstNext;
1283   2        }
1284   1        else
1285   1        { //保存当前记录的下一条记录      
1286   2          stLocalControl.stIndicationData.pstNext = stLocalControl.stIndicationData.pstNext->pstNext;
1287   2        }   
1288   1      }
1289          
1290          
1291          /**********************************************************
1292          *函数名称     :StopVoicePlay  
1293          *函数描述         :停止振铃
1294          *输入参数       :
1295          *返回值       :
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 22  

1296          *全局变量     :
1297          *调用模块       :
1298          ***********************************************************
1299          *创建人           :尹运同
1300          *创建日期     :2009-4-6
1301          ***********************************************************
1302          *修改人         :
1303          *修改日期       :
1304          *注释           :
1305          **********************************************************/
1306          void StopVoicePlay(void)
1307          { 
1308   1      //  stLocalControl.stVoicePlay.byISD1700State &= ~(ISD_REPLAY|ISD_PLAYING);
1309   1      }
1310          /**********************************************************
1311          *函数名称     :StartVoicePlay 
1312          *函数描述         :开始语音报号
1313          *输入参数       :
1314          *返回值       :
1315          *全局变量     :
1316          *调用模块       :
1317          ***********************************************************
1318          *创建人           :尹运同
1319          *创建日期     :2009-4-6
1320          ***********************************************************
1321          *修改人         :
1322          *修改日期       :
1323          *注释           :
1324          **********************************************************/
1325          void StartVoicePlay(void)
1326          {
1327   1      //  stLocalControl.stVoicePlay.byISD1700State &= ~ISD_TIME_OVER;
1328   1      //  stLocalControl.stVoicePlay.byISD1700State |= ISD_REPLAY;
1329   1      }
1330          /**********************************************************
1331          *函数名称     :VoiceChannelCtx
1332          *函数描述         :语音通道切换处理函数
1333          *输入参数       :
1334          *返回值       :
1335          *全局变量     :stLocalControl
1336          *调用模块       :
1337          ***********************************************************
1338          *创建人           :尹运同
1339          *创建日期     :2009-4-7
1340          ***********************************************************
1341          *修改人         :
1342          *修改日期       :
1343          *注释           :
1344          **********************************************************/
1345          void VoiceChannelCtx(void)
1346          {
1347   1      /*  if(stLocalControl.uiDevState & (FLAG_NOTE|FLAG_MUSIC))
1348   1        { //背景音乐播放或者提示音状态    
1349   1          KBD = 1;
1350   1        }
1351   1        else 
1352   1        {   
1353   1          KBD = 0;
1354   1        }
1355   1        if(stLocalControl.uiDevState & (FLAG_WAIT_LISTEN|FLAG_INDICATION))
1356   1        { //等待接听或者报号状态    
1357   1          KBC = 0;
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 23  

1358   1          GB_FZ=0;
1359   1          KGB=1;    //通道0打开
1360   1          return;
1361   1        }
1362   1        if(stLocalControl.uiDevState & FLAG_BROADCAST)
1363   1        { //广播状态        
1364   1      //     KGB = 0;
1365   1      //     KBC = 1;
1366   1      
1367   1      //为了使广播音量加大 ,增加SD通道负载
1368   1      //    KGB = 1;
1369   1      //    KBC = 0;
1370   1      
1371   1          GB_FZ=1;
1372   1          return;
1373   1        }   
1374   1        //其它状态，全部关闭      
1375   1         KGB = 0;
1376   1         KBC = 0;
1377   1         GB_FZ=0;
1378   1         */
1379   1      
1380   1        if(stLocalControl.uiDevState & (FLAG_NOTE|FLAG_MUSIC))
1381   1        { //背景音乐播放或者提示音状态    
1382   2          KBD = 1;
1383   2          KBC = 0;
1384   2          KGB = 0;
1385   2          GB_FZ=0;    
1386   2        }
1387   1        else
1388   1        {
1389   2          if(stLocalControl.uiDevState & (/*FLAG_WAIT_LISTEN|*/FLAG_INDICATION))
1390   2          {//等待接听或者报号状态     
1391   3            KBD = 0;
1392   3            KBC = 0;
1393   3            KGB=1;    //通道0打开     
1394   3            GB_FZ=0;  
1395   3          }
1396   2      
1397   2          else 
1398   2          {
1399   3            if(stLocalControl.uiDevState & FLAG_BROADCAST)
1400   3            { //广播状态        
1401   4              KBD = 0;
1402   4              KBC = 0;
1403   4              KGB=0;    
1404   4              GB_FZ=1;
1405   4            } 
1406   3            else
1407   3            {
1408   4            //其它状态，全部关闭
1409   4             KBD = 0; 
1410   4             KGB = 0;
1411   4             KBC = 0;
1412   4             GB_FZ=0;
1413   4            }
1414   3          }
1415   2        } 
1416   1      }
1417          /**********************************************************
1418          *函数名称     :RestartIndication  
1419          *函数描述         :重新开始信息指示
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 24  

1420          *输入参数       :
1421          *返回值       :
1422          *全局变量     :
1423          *调用模块       :
1424          ***********************************************************
1425          *创建人           :尹运同
1426          *创建日期     :2009-4-6
1427          ***********************************************************
1428          *修改人         :
1429          *修改日期       :
1430          *注释           :
1431          **********************************************************/
1432          void RestartIndication(void)
1433          { 
1434   1        pSTNod  xdata pstNod;
1435   1        
1436   1        if(stLocalControl.uiDevState & (FLAG_BUSY|FLAG_INDICATION_EXIST))
1437   1        { //如果有呼叫指示的命令正在发送或者忙，直接退出
1438   2          return;
1439   2        }
1440   1        //检查上次报号记录
1441   1        if(STATE_HI == (stLocalControl.stIndicationData.byState))
1442   1        { //有更高优先级的呼叫存在，直接从第一条呼叫开始      
1443   2      FeltchFirst:
1444   2          //取出第一条记录
1445   2          pstNod = stLocalControl.stCallPointer.pstHead;
1446   2          if(NULL ==(uint8 xdata *)pstNod)
1447   2          { //没有呼叫记录了，直接退出
1448   3          
1449   3            if(!(stLocalControl.uiDevState & (FLAG_TALK |FLAG_TALK1|FLAG_NOTE|FLAG_MUSIC|FLAG_BROADCAST|FLAG_INDICA
             -TION)))
1450   3            {//没有通话存在
1451   4                stLocalControl.byChar =0x00;  //系统不忙
1452   4                Usart1SndCmd(CMD_SYSTEM_STATE,1,&(stLocalControl.byChar));  //报告系统不忙状态
1453   4            }   
1454   3            return;
1455   3          }                   
1456   2          stLocalControl.stBusFreq.bySndSecAddr = pstNod->byCallSecAddr;
1457   2          stLocalControl.stBusFreq.bySndRoomAddr = pstNod->byCallRoomAddr;
1458   2          stLocalControl.stBusFreq.bySndBedAddr = pstNod->byCallBedAddr;
1459   2          stLocalControl.stBusFreq.byCmd = CMD_INFO_INDICATION;
1460   2          stLocalControl.stBusFreq.byRecSecAddr = pstNod->byCallPriority;
1461   2          stLocalControl.stBusFreq.byRecRoomAddr = 0x00;
1462   2          stLocalControl.stBusFreq.byRecBedAddr = 0x00;         
1463   2          if(true == Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr)))
1464   2          {
1465   3            stLocalControl.stBusFreq.byCmd = pstNod->byCallPriority & 0x1f;
1466   3            SaveIndicationData(&(stLocalControl.stBusFreq), true);
1467   3            stLocalControl.uiDevState |= FLAG_INDICATION_EXIST;
1468   3          }
1469   2          return; 
1470   2        }
1471   1        else
1472   1        { //没有更高优先级呼叫存在
1473   2          //看是否还有呼叫记录
1474   2          pstNod = stLocalControl.stCallPointer.pstHead;
1475   2          if(NULL ==(uint8 xdata *)pstNod)
1476   2          { //没有呼叫记录了，直接退出
1477   3            if(!(stLocalControl.uiDevState & (FLAG_TALK |FLAG_TALK1|FLAG_NOTE|FLAG_MUSIC|FLAG_BROADCAST|FLAG_INDICA
             -TION)))
1478   3            {//没有通话存在
1479   4              stLocalControl.byChar =0x00;  //系统不忙
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 25  

1480   4              Usart1SndCmd(CMD_SYSTEM_STATE,1,&(stLocalControl.byChar));  //报告系统不忙状态    
1481   4            }
1482   3            return;
1483   3          } 
1484   2          else
1485   2          { //还有呼叫记录
1486   3            pstNod = stLocalControl.stIndicationData.pstNext;
1487   3            if(NULL == (uint8 xdata *)pstNod)
1488   3            { //后面没有呼叫了，直接取第一条呼叫
1489   4              goto FeltchFirst;
1490   4            }
1491   3            else
1492   3            { //后面还有呼叫
1493   4              if((stLocalControl.stIndicationData.byCallCmd & 0xe0)
1494   4                == (pstNod->byCallPriority & 0xe0))
1495   4              { //是同一个优先级的呼叫，取出来                                      
1496   5                stLocalControl.stBusFreq.bySndSecAddr = pstNod->byCallSecAddr;
1497   5                stLocalControl.stBusFreq.bySndRoomAddr = pstNod->byCallRoomAddr;
1498   5                stLocalControl.stBusFreq.bySndBedAddr = pstNod->byCallBedAddr;
1499   5                stLocalControl.stBusFreq.byCmd = CMD_INFO_INDICATION;
1500   5                stLocalControl.stBusFreq.byRecSecAddr = pstNod->byCallPriority;
1501   5                stLocalControl.stBusFreq.byRecRoomAddr = 0x00;
1502   5                stLocalControl.stBusFreq.byRecBedAddr = 0x00;                   
1503   5                if(true == Bus0OutputData(&stLocalControl.stBusFreq.bySndSecAddr))
1504   5                {
1505   6                  stLocalControl.stBusFreq.byCmd = pstNod->byCallPriority & 0x1f;
1506   6                  SaveIndicationData(&(stLocalControl.stBusFreq), false);
1507   6                  stLocalControl.uiDevState |= FLAG_INDICATION_EXIST;
1508   6                }
1509   5                return;               
1510   5              }
1511   4              else
1512   4              { //后面的优先级低，直接取第一条呼叫
1513   5                goto FeltchFirst;
1514   5              }
1515   4            }
1516   3          }
1517   2        } 
1518   1      }
1519          /**********************************************************
1520          *函数名称     :Bus0RecDeal
1521          *函数描述         :单总线0数据接收处理
1522          *输入参数       :
1523          *返回值       :
1524          *全局变量     :stLocalControl
1525          *调用模块       :
1526          ***********************************************************
1527          *创建人           :尹运同
1528          *创建日期     :2009-4-7
1529          ***********************************************************
1530          *修改人         :
1531          *修改日期       :
1532          *注释           :
1533          **********************************************************/
1534          void Bus0RecDeal(void)
1535          {   
1536   1        static uint8 byTemp;
1537   1        static uint8 byCmd;
1538   1        static uint8 byPriority;  
1539   1        pSTUartFreq pstDataFreq;
1540   1      
1541   1      
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 26  

1542   1        //复位看门狗                                                                                             
             -                                                                                                                        
             -                                                                
1543   1        WDT_CONTR = 0x3e;     //看门狗定时2.5s@20M
1544   1      
1545   1        LedStateFlash();
1546   1        
1547   1        EA=0;     
1548   1        memcpy(&(stLocalControl.stBusFreq.bySndSecAddr), byBus0RecData, sizeof(STBusFreq)); //获取单总线数据
1549   1        bBus0RecFinish = 0;
1550   1        EA=1; 
1551   1      
1552   1      
1553   1        //调试用
1554   1        #if DEBUG==1
1555   1      //  Usart1SndData(&(stLocalControl.stBusFreq));
1556   1        #endif
1557   1          /////////////////////////////////////////////////////////////////////////////
1558   1      
1559   1        //数据处理  
1560   1        switch(stLocalControl.stBusFreq.byCmd)
1561   1        {
1562   2          case CMD_LANDING:                 //登记命令,返回确认命令
1563   2            stLocalControl.stBusFreq.byRecSecAddr = stLocalControl.stBusFreq.bySndSecAddr;
1564   2            stLocalControl.stBusFreq.byRecRoomAddr = stLocalControl.stBusFreq.bySndRoomAddr;
1565   2            stLocalControl.stBusFreq.byRecBedAddr = stLocalControl.stBusFreq.bySndBedAddr;
1566   2            stLocalControl.stBusFreq.byCmd = CMD_ENTER;
1567   2            if(stLocalControl.uiDevState & FLAG_BUSY)
1568   2            {
1569   3              stLocalControl.stBusFreq.bySndSecAddr = 0x80;
1570   3            }
1571   2            else
1572   2            {
1573   3              stLocalControl.stBusFreq.bySndSecAddr = 0x00;
1574   3            }
1575   2      
1576   2            if(bPCState)
1577   2            {
1578   3              stLocalControl.stBusFreq.bySndSecAddr |= 0x40;
1579   3            }
1580   2            
1581   2            stLocalControl.stBusFreq.bySndRoomAddr = 0x00;
1582   2            stLocalControl.stBusFreq.bySndBedAddr = 0x00;
1583   2            Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
1584   2            break;
1585   2            
1586   2          case CMD_INSPECTOR_CALL:              //查房呼叫命令,返回确认命令
1587   2            errtime = 0xff;
1588   2            while(stUsartCfg[1].uiSndLen!=0)  
1589   2            {//有数据正在发送中
1590   3              Delayms(1);
1591   3              WDT_CONTR = 0x3e;     //看门狗定时2.5s@20M  
1592   3              if(--errtime ==0) break;    
1593   3            }     
1594   2            pstDataFreq = (pSTUartFreq)byUsart1SndBuf;
1595   2            pstDataFreq->byStartByte1 = START_BYTE1;
1596   2      
1597   2            pstDataFreq->byData[0] = stLocalControl.stBusFreq.bySndBedAddr;
1598   2            memcpy(&(pstDataFreq->byData[1]),&(stLocalControl.stBusFreq.byRecSecAddr),3);
1599   2            pstDataFreq->byCmd = stLocalControl.stBusFreq.byCmd;
1600   2            pstDataFreq->uiLen = 0x04;
1601   2            pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 27  

1602   2            pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE;
1603   2                  
1604   2            stUsartCfg[1].uiSndLen  = pstDataFreq->uiLen+EXT_SIZE;
1605   2            stUsartCfg[1].uiSndPos = 0;   //从数据帧头部开始发送数据
1606   2            S2CON &= ~S2TI;
1607   2            S2BUF=pstDataFreq->byStartByte1;
1608   2      
1609   2            stLocalControl.stBusFreq.byCmd = CMD_INSPERCTOR_ENTER;
1610   2            Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));     
1611   2            break;
1612   2          case CMD_INFUSION_CALL:               //输液呼叫命令
1613   2          case CMD_SERVICE_CALL:                //服务呼叫命令
1614   2          case CMD_EMERGENCY_CALL:              //紧急呼叫命令
1615   2          case CMD_HELP_CALL:                 //求援呼叫命令
1616   2            if((stLocalControl.stBusFreq.bySndRoomAddr == ADD_BED_FJ)&&
1617   2               (stLocalControl.stBusFreq.bySndSecAddr!=stLocalControl.stEepromCfgData.bySelfSecAddr))
1618   2            {//是加床分机发过来的呼叫且区号不对 ,直接返回
1619   3              return;
1620   3            }
1621   2            //保存命令和优先级
1622   2            byCmd = stLocalControl.stBusFreq.byCmd;
1623   2            byPriority = stLocalControl.stBusFreq.byRecSecAddr & 0xe0;
1624   2            byTemp = AddCallNod(&(stLocalControl.stBusFreq));
1625   2            if(SAVE_FAIL == byTemp)
1626   2            { //添加呼叫队列失败，直接返回
1627   3              return;
1628   3            } 
1629   2      
1630   2            //其他类型，都是添加成功，返回确认命令
1631   2            stLocalControl.stBusFreq.byRecSecAddr = stLocalControl.stBusFreq.bySndSecAddr;
1632   2            stLocalControl.stBusFreq.byRecRoomAddr = stLocalControl.stBusFreq.bySndRoomAddr;
1633   2            stLocalControl.stBusFreq.byRecBedAddr = stLocalControl.stBusFreq.bySndBedAddr;
1634   2            
1635   2            stLocalControl.stBusFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1636   2            stLocalControl.stBusFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1637   2            stLocalControl.stBusFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1638   2            stLocalControl.stBusFreq.byCmd = byCmd + 0x1b;
1639   2      
1640   2            Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr)); 
1641   2      
1642   2            
1643   2            if(flag_origin_music)
1644   2            {//之前在播放背景音乐,停止
1645   3              stLocalControl.stBusFreq.bySndSecAddr = stLocalControl.stBusFreq.byRecSecAddr;
1646   3              stLocalControl.stBusFreq.bySndRoomAddr = stLocalControl.stBusFreq.byRecRoomAddr;
1647   3              stLocalControl.stBusFreq.bySndBedAddr = stLocalControl.stBusFreq.byRecBedAddr;      
1648   3              stLocalControl.stBusFreq.byCmd = CMD_STOP_VOICE;
1649   3              stLocalControl.stBusFreq.byRecSecAddr = 0xff;
1650   3              stLocalControl.stBusFreq.byRecRoomAddr = 0xff;
1651   3              stLocalControl.stBusFreq.byRecBedAddr = 0xff;
1652   3              Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
1653   3      
1654   3              stLocalControl.stBusFreq.byRecSecAddr = stLocalControl.stBusFreq.bySndSecAddr;
1655   3              stLocalControl.stBusFreq.byRecRoomAddr = stLocalControl.stBusFreq.bySndRoomAddr;
1656   3              stLocalControl.stBusFreq.byRecBedAddr = stLocalControl.stBusFreq.bySndBedAddr;        
1657   3            }
1658   2            
1659   2            if(stLocalControl.uiDevState & (FLAG_INDICATION_EXIST|FLAG_BUSY|FLAG_TALK1))
1660   2            { //有呼叫指示命令正在发送队列中,但没有发送完或者处于忙状态,退出
1661   3              return;
1662   3            }
1663   2            //没有指示正在发送,也不忙
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 28  

1664   2            if(stLocalControl.uiDevState & FLAG_INDICATION)
1665   2            { //有呼叫正在指示中
1666   3              if(SAVE_PRIO_HI == byTemp)
1667   3              { //有高优先级呼叫存在,发送终止指示命令
1668   4                if(stLocalControl.uiDevState & FLAG_STOP_EXIST)
1669   4                { //有正在发送停止命令
1670   5                  return;
1671   5                }
1672   4                stLocalControl.stBusFreq.bySndSecAddr = stLocalControl.stIndicationData.byIndicationSecAddr;
1673   4                stLocalControl.stBusFreq.bySndRoomAddr = stLocalControl.stIndicationData.byIndicationRoomAddr;
1674   4                stLocalControl.stBusFreq.bySndBedAddr = stLocalControl.stIndicationData.byIndicationBedAddr;
1675   4                stLocalControl.stBusFreq.byCmd = CMD_STOP_INDICATION; 
1676   4                stLocalControl.stBusFreq.byRecSecAddr =0;
1677   4                stLocalControl.stBusFreq.byRecRoomAddr=0;
1678   4                stLocalControl.stBusFreq.byRecBedAddr=0;          
1679   4                if(true == Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr)))
1680   4                {
1681   5                  stLocalControl.uiDevState |= FLAG_STOP_EXIST;
1682   5                }               
1683   4              }
1684   3            }
1685   2            else
1686   2            { //没有呼叫在指示中,直接发送指示命令,保存呼叫指示的指针位置
1687   3              if(SAVE_ONLY == byTemp)
1688   3              { //该呼叫是唯一一条呼叫记录
1689   4                if(stLocalControl.uiDevState & FLAG_STOP_EXIST)
1690   4                { //有正在发送停止命令
1691   5                  return;
1692   5                }
1693   4                stLocalControl.stBusFreq.bySndSecAddr = stLocalControl.stBusFreq.byRecSecAddr;
1694   4                stLocalControl.stBusFreq.bySndRoomAddr = stLocalControl.stBusFreq.byRecRoomAddr;
1695   4                stLocalControl.stBusFreq.bySndBedAddr = stLocalControl.stBusFreq.byRecBedAddr;
1696   4                stLocalControl.stBusFreq.byCmd = CMD_INFO_INDICATION;
1697   4                stLocalControl.stBusFreq.byRecSecAddr = byPriority|byCmd;                         
1698   4                if(true == Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr)))
1699   4                { //置指示正在发送队列中标志
1700   5                  //保存指示方地址、命令、优先级和正在指示的呼叫记录指针
1701   5                  stLocalControl.stBusFreq.byCmd = byCmd;
1702   5                  SaveIndicationData(&(stLocalControl.stBusFreq), true);  
1703   5                  stLocalControl.uiDevState |= FLAG_INDICATION_EXIST;
1704   5                }
1705   4                return;
1706   4              }
1707   3              else
1708   3              { //有多条呼叫记录存在,但是没有FLAG_INDICATION_EXIST,
1709   4                //FLAG_BUSY,FLAG_INDICATION标志,表明指示发送完成后呼叫信息不存在了
1710   4                //停止信息指示正在发送,发送完成后再处理   
1711   4                if(stLocalControl.uiDevState & FLAG_STOP_EXIST)
1712   4                { //有正在发送停止命令
1713   5                  return;
1714   5                }
1715   4                byCmd = stLocalControl.stCallPointer.pstHead->byCallPriority & 0x1f;                              
1716   4                stLocalControl.stBusFreq.bySndSecAddr = 
1717   4                    stLocalControl.stCallPointer.pstHead->byCallSecAddr;
1718   4                stLocalControl.stBusFreq.bySndRoomAddr = 
1719   4                    stLocalControl.stCallPointer.pstHead->byCallRoomAddr;
1720   4                stLocalControl.stBusFreq.bySndBedAddr = 
1721   4                    stLocalControl.stCallPointer.pstHead->byCallBedAddr;
1722   4                stLocalControl.stBusFreq.byCmd = CMD_INFO_INDICATION;
1723   4                stLocalControl.stBusFreq.byRecSecAddr = 
1724   4                    stLocalControl.stCallPointer.pstHead->byCallPriority;
1725   4                if(true == Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr)))
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 29  

1726   4                { //保存指示方地址和命令
1727   5                  stLocalControl.stBusFreq.byCmd = byCmd;
1728   5                  SaveIndicationData(&(stLocalControl.stBusFreq), true);
1729   5                  stLocalControl.uiDevState |= FLAG_INDICATION_EXIST;
1730   5                }
1731   4                return; 
1732   4              }               
1733   3            }     
1734   2            break;    
1735   2          case CMD_INFUSION_CLEAR:              //清除输液呼叫命令
1736   2          case CMD_SERVICE_CLEAR:               //清除服务呼叫命令
1737   2          case CMD_EMERGENCY_CLEAR:             //清除紧急呼叫命令
1738   2          case CMD_HELP_CLEAR:                //清除求援呼叫命令
1739   2            if((stLocalControl.stBusFreq.bySndRoomAddr == MOVE_FJ)&&
1740   2               (stLocalControl.stBusFreq.bySndSecAddr!=stLocalControl.stEepromCfgData.bySelfSecAddr))
1741   2            {//是移动分机发过来的清除呼叫且区号不对 ,直接返回
1742   3              return;
1743   3            }   
1744   2            if( (stLocalControl.stBusFreq.byRecSecAddr == stLocalControl.stBusFreq.bySndSecAddr) &&
1745   2              (stLocalControl.stBusFreq.byRecRoomAddr == stLocalControl.stBusFreq.bySndRoomAddr) &&
1746   2              (stLocalControl.stBusFreq.byRecBedAddr == stLocalControl.stBusFreq.bySndBedAddr) )
1747   2            {//是呼叫分机自己挂断
1748   3              errtime =0xff;
1749   3              while(stUsartCfg[1].uiSndLen!=0)  
1750   3              {//有数据正在发送中
1751   4                Delayms(1);
1752   4                WDT_CONTR = 0x3e;   //看门狗定时2.5s@20M  
1753   4                if(--errtime ==0) break;
1754   4      
1755   4              }     
1756   3              pstDataFreq = (pSTUartFreq)byUsart1SndBuf;
1757   3              pstDataFreq->byStartByte1 = START_BYTE1;
1758   3              
1759   3              memcpy(&(pstDataFreq->byData[0]),&(stLocalControl.stBusFreq.bySndSecAddr),3); //主呼分机地址
1760   3              memcpy(&(pstDataFreq->byData[3]),&(stLocalControl.stBusFreq.bySndSecAddr),3); //主呼分机地址      
1761   3              pstDataFreq->byCmd = stLocalControl.stBusFreq.byCmd;
1762   3              pstDataFreq->uiLen      =0X06;
1763   3              pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
1764   3              pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE;       
1765   3              stUsartCfg[1].uiSndLen  = pstDataFreq->uiLen+EXT_SIZE;
1766   3              stUsartCfg[1].uiSndPos = 0;   //从数据帧头部开始发送数据
1767   3              S2CON &= ~S2TI;
1768   3              S2BUF=pstDataFreq->byStartByte1;          
1769   3            }
1770   2            else
1771   2            {//是其它处理分机挂断分机
1772   3              errtime=0xff;
1773   3              while(stUsartCfg[1].uiSndLen!=0)  
1774   3              {//有数据正在发送中
1775   4                Delayms(1);
1776   4                WDT_CONTR = 0x3e;     //看门狗定时2.5s@20M  
1777   4                if(--errtime ==0) break;
1778   4              }     
1779   3              pstDataFreq = (pSTUartFreq)byUsart1SndBuf;
1780   3              pstDataFreq->byStartByte1 = START_BYTE1;
1781   3              
1782   3              memcpy(&(pstDataFreq->byData[0]),&(stLocalControl.stBusFreq.bySndSecAddr),3); //主呼分机地址
1783   3              memcpy(&(pstDataFreq->byData[3]),&(stLocalControl.stBusFreq.byRecSecAddr),3); //主呼分机地址      
1784   3              pstDataFreq->byCmd = stLocalControl.stBusFreq.byCmd;
1785   3              pstDataFreq->uiLen      =0X06;
1786   3              pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
1787   3              pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE;       
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 30  

1788   3              stUsartCfg[1].uiSndLen  = pstDataFreq->uiLen+EXT_SIZE;
1789   3              stUsartCfg[1].uiSndPos = 0;   //从数据帧头部开始发送数据
1790   3              S2CON &= ~S2TI;
1791   3              S2BUF=pstDataFreq->byStartByte1;      
1792   3            }
1793   2            //清呼叫记录
1794   2            stLocalControl.stBusFreq.byCmd -= 0x0a;     //将清除命令还原成对应的呼叫命令    
1795   2            RemoveCallNod(&(stLocalControl.stBusFreq));     
1796   2            if((stLocalControl.uiDevState & FLAG_INDICATION) && 
1797   2              (stLocalControl.stBusFreq.byRecSecAddr == stLocalControl.stIndicationData.byIndicationSecAddr) &&
1798   2              (stLocalControl.stBusFreq.byRecRoomAddr == stLocalControl.stIndicationData.byIndicationRoomAddr) &&
1799   2              (stLocalControl.stBusFreq.byRecBedAddr == stLocalControl.stIndicationData.byIndicationBedAddr) &&
1800   2              ((stLocalControl.stBusFreq.byCmd & 0x1f) == (stLocalControl.stIndicationData.byCallCmd & 0x1f)))
1801   2            { //正在呼叫指示，且清除的呼叫为正在指示的呼叫,发送终止呼叫指示命令
1802   3              if(stLocalControl.uiDevState & FLAG_STOP_EXIST)
1803   3              { //有正在发送停止命令
1804   4                return;
1805   4              }
1806   3              //没有停止指示正在发送中        
1807   3              stLocalControl.stBusFreq.byCmd = CMD_STOP_INDICATION;       
1808   3              if(true == Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr)))
1809   3              {
1810   4                stLocalControl.uiDevState |= FLAG_STOP_EXIST;
1811   4              }             
1812   3            }
1813   2      
1814   2            if(NULL ==(uint8 xdata *)(stLocalControl.stCallPointer.pstHead))
1815   2            {//没有分机存在
1816   3              if(flag_origin_music)
1817   3              {//之前有播放背景音乐
1818   4                 stLocalControl.stBusFreq.byCmd = CMD_MUSIC_PLAY;
1819   4                 stLocalControl.stBusFreq.byRecSecAddr =0xff;
1820   4                 stLocalControl.stBusFreq.byRecRoomAddr = 0xff;
1821   4                 stLocalControl.stBusFreq.byRecBedAddr  =0xff;
1822   4                 Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));             
1823   4              }
1824   3            }
1825   2            break;  
1826   2          case CMD_INFUSION_ANSWER:             //处理输液呼叫
1827   2          case CMD_SERVICE_ANSWER:              //处理服务呼叫
1828   2          case CMD_EMERGENCY_ANSWER:              //处理紧急呼叫
1829   2          case CMD_HELP_ANSWER:               //处理求援呼叫  
1830   2            if(stLocalControl.uiDevState & FLAG_BUSY)
1831   2            { //忙，退出
1832   3              break;
1833   3            }
1834   2            
1835   2            //保存主动呼叫方、被动呼叫方地址
1836   2            SaveCallAddr(&(stLocalControl.stBusFreq));      
1837   2            stLocalControl.stCallAddr.byCmd = stLocalControl.stBusFreq.byCmd;
1838   2      
1839   2      
1840   2            //清呼叫记录
1841   2            stLocalControl.stBusFreq.byCmd -= 0x06;     //将处理命令还原成对应的呼叫命令
1842   2            RemoveCallNod(&(stLocalControl.stBusFreq));     
1843   2            //置等待应答和忙标志
1844   2            stLocalControl.uiDevState |= (FLAG_WAIT_ACK|FLAG_BUSY); 
1845   2            if(stLocalControl.uiDevState & FLAG_INDICATION)
1846   2            { //正在呼叫指示,清指示标志       
1847   3              stLocalControl.uiDevState &= ~FLAG_INDICATION;
1848   3              
1849   3      //        //停止报号      
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 31  

1850   3      //        StopVoicePlay();
1851   3      
1852   3              //向语音模块发送停止报号命令
1853   3              stLocalControl.stBusFreq.byCmd = CMD_STOP_VOICE_PLAY;
1854   3              Bus1OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
1855   3              //语音通道切换
1856   3              VoiceChannelCtx();                
1857   3            }     
1858   2      
1859   2            //设置等待应答超时1S
1860   2            MakeCH0TimerOut(50, 0);     
1861   2            break;
1862   2      
1863   2            
1864   2          case CMD_COMM_CALL:                 //普通呼叫命令
1865   2            if(stLocalControl.uiDevState & FLAG_BUSY)
1866   2            { //忙，直接退出
1867   3              break;
1868   3            }
1869   2            //置忙和等待应答标志 
1870   2            stLocalControl.uiDevState |= (FLAG_BUSY|FLAG_WAIT_ACK);     
1871   2            if(stLocalControl.uiDevState & FLAG_INDICATION)
1872   2            { //正在呼叫指示,清指示标志       
1873   3              stLocalControl.uiDevState &= ~FLAG_INDICATION;        
1874   3      //        //停止报号      
1875   3      //        StopVoicePlay();
1876   3      
1877   3              //向语音模块发送停止报号命令
1878   3              stLocalControl.stBusFreq.byCmd = CMD_STOP_VOICE_PLAY;
1879   3              Bus1OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
1880   3      
1881   3              //语音通道切换
1882   3              VoiceChannelCtx();                
1883   3            }
1884   2            
1885   2            //保存主动呼叫方、被动呼叫方地址
1886   2            SaveCallAddr(&(stLocalControl.stBusFreq));      
1887   2            
1888   2            //设置等待应答超时5S
1889   2            MakeCH0TimerOut(50, 5);
1890   2            break;
1891   2          case CMD_COMM_ANSWER:               //应答命令
1892   2            if(0x0000 == (stLocalControl.uiDevState & FLAG_BUSY))
1893   2            { //不忙，发送系统复位命令
1894   3              stLocalControl.stBusFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1895   3              stLocalControl.stBusFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1896   3              stLocalControl.stBusFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1897   3              stLocalControl.stBusFreq.byCmd = CMD_SYSTERM_RESET;
1898   3              stLocalControl.stBusFreq.byRecSecAddr = 0xff;
1899   3              stLocalControl.stBusFreq.byRecRoomAddr = 0xff;
1900   3              stLocalControl.stBusFreq.byRecBedAddr = 0xff;       
1901   3              Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
1902   3              break;
1903   3            }
1904   2      
1905   2            if(AddrCompare(&(stLocalControl.stBusFreq.bySndSecAddr),&(stLocalControl.stCallAddr.byRecSecAddr)))
1906   2            {//是对应分机的应答信号
1907   3              //忙,清等待应答标志 
1908   3              stLocalControl.uiDevState &= ~FLAG_WAIT_ACK;      
1909   3              //置等待接听标志      
1910   3              stLocalControl.uiDevState |= FLAG_WAIT_LISTEN;  
1911   3      
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 32  

1912   3              
1913   3      /*        //启动振铃
1914   3              MakeRingVoiceData(stLocalControl.stBusFreq.byRecBedAddr); 
1915   3              //构建语音信息
1916   3              //MakeRingVoiceData(&(stLocalControl.stIndicationData));  
1917   3              //播放语音
1918   3              StartVoicePlay();
1919   3              //语音通道切换
1920   3              VoiceChannelCtx();
1921   3      
1922   3      */
1923   3              //设置等待接听超时15S
1924   3              MakeCH0TimerOut(250, 3);  
1925   3      
1926   3            }
1927   2            else MakeCH0TimerOut(1, 0); //使通道0超时时间到
1928   2            break;
1929   2      
1930   2          case CMD_CALL_LISTEN:             //接听命令
1931   2            if(0x0000 == (stLocalControl.uiDevState & FLAG_BUSY))
1932   2            { //不忙，发送系统复位命令
1933   3              stLocalControl.stBusFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1934   3              stLocalControl.stBusFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1935   3              stLocalControl.stBusFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1936   3              stLocalControl.stBusFreq.byCmd = CMD_SYSTERM_RESET;
1937   3              stLocalControl.stBusFreq.byRecSecAddr = 0xff;
1938   3              stLocalControl.stBusFreq.byRecRoomAddr = 0xff;
1939   3              stLocalControl.stBusFreq.byRecBedAddr = 0xff;       
1940   3              Bus0OutputData(&stLocalControl.stBusFreq.bySndSecAddr);
1941   3              break;
1942   3            }
1943   2      
1944   2            if(AddrCompare(&(stLocalControl.stBusFreq.bySndSecAddr),&(stLocalControl.stCallAddr.byRecSecAddr)))
1945   2            {//是对应分机的接听信号     
1946   3              //忙,清等待接听标志，置通话标志 
1947   3              stLocalControl.uiDevState &= ~FLAG_WAIT_LISTEN;     
1948   3              stLocalControl.uiDevState |= FLAG_TALK;
1949   3              
1950   3      //        //停止振铃
1951   3      //        StopVoicePlay();  
1952   3              //向语音模块发送停止报号命令
1953   3              stLocalControl.stBusFreq.byCmd = CMD_STOP_VOICE_PLAY;
1954   3              Bus1OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
1955   3      
1956   3      
1957   3              //语音通道切换
1958   3              VoiceChannelCtx();
1959   3              //设置等待通话超时60S
1960   3              MakeCH0TimerOut(250, 12);     
1961   3              if(0x0000 == (stLocalControl.uiDevState & (FLAG_TALK1|FLAG_NOTE|FLAG_MUSIC)))
1962   3              { //没有通话1，语音提示，背景音乐播放存在，发送切换语音通道命令               
1963   4                stLocalControl.stBusFreq.byCmd = CMD_CHANNEL_CHANGE;                
1964   4                Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
1965   4                //置通道切换命令在总线队列中标志
1966   4                stLocalControl.uiDevState |= FLAG_CHANNEL_CHANGE_EXIST;
1967   4              }
1968   3      
1969   3              if((stLocalControl.stBusFreq.byRecSecAddr == stLocalControl.stEepromCfgData.bySelfSecAddr)&&
1970   3                (stLocalControl.stBusFreq.byRecRoomAddr == stLocalControl.stEepromCfgData.bySelfRoomAddr)&&
1971   3                (stLocalControl.stBusFreq.byRecBedAddr == stLocalControl.stEepromCfgData.bySelfBedAddr))
1972   3              { //是管理主机处理床头分机的呼叫
1973   4                Usart1SndResult(byUsart1RecBuf[CMD_POSITION],TRUE);
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 33  

1974   4                byUsart1RecBuf[CMD_POSITION]=0x00;  //清空原命令数据
1975   4              }
1976   3              else
1977   3              { //是其他分机处理床头分机的呼叫
1978   4                errtime =0xff;
1979   4                while(stUsartCfg[1].uiSndLen!=0)  
1980   4                {//有数据正在发送中
1981   5                  Delayms(1);
1982   5                  WDT_CONTR = 0x3e;   //看门狗定时2.5s@20M  
1983   5                  if(--errtime ==0) break;
1984   5                }     
1985   4                pstDataFreq = (pSTUartFreq)byUsart1SndBuf;
1986   4                pstDataFreq->byStartByte1 = START_BYTE1;
1987   4                memcpy(&(pstDataFreq->byData[0]),&(stLocalControl.stBusFreq.byRecSecAddr),3); //处理分机地址
1988   4                memcpy(&(pstDataFreq->byData[3]),&(stLocalControl.stBusFreq.bySndSecAddr),3); //主呼分机地址      
1989   4                pstDataFreq->byCmd = stLocalControl.stCallAddr.byCmd; //原命令;
1990   4                pstDataFreq->uiLen      =0X06;
1991   4                pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
1992   4                pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE;       
1993   4                stUsartCfg[1].uiSndLen  = pstDataFreq->uiLen+EXT_SIZE;
1994   4                stUsartCfg[1].uiSndPos = 0;   //从数据帧头部开始发送数据
1995   4                S2CON &= ~S2TI;
1996   4                S2BUF=pstDataFreq->byStartByte1;
1997   4              }
1998   3            }
1999   2            else MakeCH0TimerOut(1, 0); //使通道0超时时间到
2000   2            break;    
2001   2          case CMD_BROADCAST1:                
2002   2          case CMD_BROADCAST2:
2003   2          case CMD_BROADCAST3:                //广播命令
2004   2            if(stLocalControl.uiDevState & FLAG_BUSY)
2005   2            { //忙，发送系统复位命令
2006   3              stLocalControl.stBusFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2007   3              stLocalControl.stBusFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2008   3              stLocalControl.stBusFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2009   3              stLocalControl.stBusFreq.byCmd = CMD_SYSTERM_RESET;
2010   3              stLocalControl.stBusFreq.byRecSecAddr = 0xff;
2011   3              stLocalControl.stBusFreq.byRecRoomAddr = 0xff;
2012   3              stLocalControl.stBusFreq.byRecBedAddr = 0xff;       
2013   3              Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
2014   3              break;
2015   3            }
2016   2            //不忙，置忙标志和广播标志
2017   2            stLocalControl.uiDevState |= (FLAG_BUSY|FLAG_BROADCAST);
2018   2            
2019   2            //保存主动呼叫方、被动呼叫方地址
2020   2            SaveCallAddr(&(stLocalControl.stBusFreq));
2021   2      
2022   2            //清呼叫指示标志
2023   2            stLocalControl.uiDevState &= ~FLAG_INDICATION;
2024   2            
2025   2      //      //停止报号      
2026   2      //      StopVoicePlay();
2027   2      
2028   2            //向语音模块发送停止报号命令
2029   2            stLocalControl.stBusFreq.byCmd = CMD_STOP_VOICE_PLAY;
2030   2            Bus1OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
2031   2      
2032   2            //语音通道切换
2033   2            VoiceChannelCtx();
2034   2            //设置等待广播超时180S
2035   2            MakeCH0TimerOut(250, 36);
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 34  

2036   2            break;  
2037   2          case CMD_SYSTERM_RESET:               //系统复位命令
2038   2            //清标志 //这些标志之外的标志被清0
2039   2            stLocalControl.uiDevState &= (FLAG_TALK1|FLAG_NOTE|FLAG_MUSIC|FLAG_INDICATION_EXIST|FLAG_STOP_EXIST);
2040   2          
2041   2      //      //停止报号
2042   2      //      StopVoicePlay();
2043   2      
2044   2            //向语音模块发送停止报号命令
2045   2            stLocalControl.stBusFreq.byCmd = CMD_STOP_VOICE_PLAY;
2046   2            Bus1OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
2047   2      
2048   2            //语音通道切换
2049   2            VoiceChannelCtx();
2050   2            //清超时
2051   2            MakeCH0TimerOut(0, 0);
2052   2      
2053   2            errtime =0xff;
2054   2            while(stUsartCfg[1].uiSndLen!=0)  
2055   2            {//有数据正在发送中
2056   3              Delayms(1);
2057   3              WDT_CONTR = 0x3e;     //看门狗定时2.5s@20M  
2058   3              if(--errtime ==0) break;
2059   3      
2060   3            }     
2061   2            pstDataFreq = (pSTUartFreq)byUsart1SndBuf;
2062   2            pstDataFreq->byStartByte1 = START_BYTE1;
2063   2            
2064   2            memcpy(&(pstDataFreq->byData[0]),&(stLocalControl.stBusFreq.bySndSecAddr),3); 
2065   2            memcpy(&(pstDataFreq->byData[3]),&(stLocalControl.stBusFreq.byRecSecAddr),3);
2066   2            pstDataFreq->byCmd = CMD_TALK_CLEAR;
2067   2            pstDataFreq->uiLen      =0X06;
2068   2            pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
2069   2            pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE;       
2070   2            stUsartCfg[1].uiSndLen  = pstDataFreq->uiLen+EXT_SIZE;
2071   2            stUsartCfg[1].uiSndPos = 0;   //从数据帧头部开始发送数据
2072   2            S2CON &= ~S2TI;
2073   2            S2BUF=pstDataFreq->byStartByte1;
2074   2      
2075   2                
2076   2            //重新开始报号  
2077   2            if(0x00 == (stLocalControl.uiDevState&(FLAG_INDICATION_EXIST|FLAG_STOP_EXIST)))
2078   2            {
2079   3              RestartIndication();
2080   3            } 
2081   2      
2082   2            if(NULL ==(uint8 xdata *)(stLocalControl.stCallPointer.pstHead))
2083   2            {//没有分机存在
2084   3              if(flag_origin_music)
2085   3              {//之前有播放背景音乐
2086   4                 stLocalControl.stBusFreq.byCmd = CMD_MUSIC_PLAY;
2087   4                 stLocalControl.stBusFreq.byRecSecAddr =0xff;
2088   4                 stLocalControl.stBusFreq.byRecRoomAddr = 0xff;
2089   4                 stLocalControl.stBusFreq.byRecBedAddr  =0xff;
2090   4                 Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));         
2091   4              }
2092   3            } 
2093   2              
2094   2            break;
2095   2          case CMD_CHANNEL_CLOSE:               //关闭语音通道命令
2096   2            stLocalControl.uiDevState &= ~FLAG_TALK1;
2097   2            
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 35  

2098   2            if(NULL ==(uint8 xdata *)(stLocalControl.stCallPointer.pstHead))
2099   2            { //没有呼叫记录了
2100   3            
2101   3              if(!(stLocalControl.uiDevState & (FLAG_TALK |FLAG_TALK1|FLAG_NOTE|FLAG_MUSIC|FLAG_BROADCAST|FLAG_INDIC
             -ATION)))
2102   3              {//没有通话存在
2103   4                stLocalControl.byChar =0x00;  //系统不忙
2104   4                Usart1SndCmd(CMD_SYSTEM_STATE,1,&(stLocalControl.byChar));  //报告系统不忙状态
2105   4              } 
2106   3            } 
2107   2        
2108   2            //语音通道切换
2109   2            VoiceChannelCtx();
2110   2            //清通道1通话超时
2111   2            MakeCH1TimerOut(0, 0);
2112   2      
2113   2            errtime =0xff;
2114   2            while(stUsartCfg[1].uiSndLen!=0)  
2115   2            {//有数据正在发送中
2116   3              Delayms(1);
2117   3              WDT_CONTR = 0x3e;     //看门狗定时2.5s@20M  
2118   3              if(--errtime ==0) break;
2119   3      
2120   3            }     
2121   2            pstDataFreq = (pSTUartFreq)byUsart1SndBuf;
2122   2            pstDataFreq->byStartByte1 = START_BYTE1;
2123   2            
2124   2            memcpy(&(pstDataFreq->byData[0]),&(stLocalControl.stBusFreq.bySndSecAddr),3); 
2125   2            memcpy(&(pstDataFreq->byData[3]),&(stLocalControl.stBusFreq.byRecSecAddr),3);
2126   2            pstDataFreq->byCmd = CMD_TALK_CLEAR;
2127   2            pstDataFreq->uiLen      =0X06;
2128   2            pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
2129   2            pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE;       
2130   2            stUsartCfg[1].uiSndLen  = pstDataFreq->uiLen+EXT_SIZE;
2131   2            stUsartCfg[1].uiSndPos = 0;   //从数据帧头部开始发送数据
2132   2            S2CON &= ~S2TI;
2133   2            S2BUF=pstDataFreq->byStartByte1;
2134   2            
2135   2            if(stLocalControl.uiDevState & FLAG_TALK)
2136   2            { //通道0通话存在，发送切换语音通道命令       
2137   3              stLocalControl.stBusFreq.byCmd = CMD_CHANNEL_CHANGE;
2138   3              //置通道切换命令在总线队列中标志
2139   3              stLocalControl.uiDevState |= FLAG_CHANNEL_CHANGE_EXIST;
2140   3              Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr)); 
2141   3            }
2142   2      
2143   2      
2144   2            if(NULL ==(uint8 xdata *)(stLocalControl.stCallPointer.pstHead))
2145   2            {//没有分机存在
2146   3              if(flag_origin_music)
2147   3              {//之前有播放背景音乐
2148   4                 stLocalControl.stBusFreq.byCmd = CMD_MUSIC_PLAY;
2149   4                 stLocalControl.stBusFreq.byRecSecAddr =0xff;
2150   4                 stLocalControl.stBusFreq.byRecRoomAddr = 0xff;
2151   4                 stLocalControl.stBusFreq.byRecBedAddr  =0xff;
2152   4                 Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));         
2153   4              }
2154   3            } 
2155   2      
2156   2            else
2157   2            {
2158   3              RestartIndication();
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 36  

2159   3            }
2160   2            break;  
2161   2      
2162   2            
2163   2          case CMD_DATE_SEND:
2164   2            stTime.bySecond=0x00;
2165   2            stTime.byMinute = stLocalControl.stBusFreq.bySndRoomAddr;
2166   2            stTime.byHour   = stLocalControl.stBusFreq.bySndBedAddr;
2167   2            memcpy(&(stTime.byDay),&(stLocalControl.stBusFreq.byRecSecAddr),3);
2168   2            P8563_settime();      
2169   2            break;  
2170   2            
2171   2           case CMD_BUS_ANSWER: //总线通用应答命令
2172   2             switch(stLocalControl.stBusFreq.byRecSecAddr)
2173   2            {
2174   3              case CMD_COLOR_CLEAR:
2175   3              case CMD_BL_TIMER_SET:
2176   3              case CMD_VOICE_TIMER_SET:
2177   3                stLocalControl.uiDevState &= ~(FLAG_WAIT_COMM_ACK);
2178   3                //清等待总线应答超时
2179   3                stLocalControl.byWaitCommAckDTime = 0;
2180   3              
2181   3                Usart1SndResult(stLocalControl.stBusFreq.byRecSecAddr,TRUE);
2182   3                return;
2183   3                
2184   3              case CMD_DISPLAY_DATA:
2185   3              case CMD_HANDLE_DISPLAY_DATA: 
2186   3                if(/*(stLocalControl.stBusFreq.bySndRoomAddr == YHFJ_ADDR2) ||(stLocalControl.stBusFreq.bySndRoomAddr
             - == ZLDIS_ADDR2)||*/
2187   3                   (stLocalControl.stBusFreq.bySndBedAddr == stLocalControl.stRS485Addr.byBedAddr))
2188   3                {//床号相等
2189   4                  stLocalControl.byWaitRS485AckDTime = 0;
2190   4                  errtime =0xff;
2191   4                  while(stUsartCfg[1].uiSndLen!=0)  
2192   4                  {//有数据正在发送中
2193   5                    Delayms(1);
2194   5                    WDT_CONTR = 0x3e;   //看门狗定时2.5s@20M  
2195   5                    if(--errtime ==0) break;
2196   5      
2197   5                  }
2198   4                  pstDataFreq = (pSTUartFreq)byUsart1SndBuf;
2199   4                  
2200   4                  pstDataFreq->byStartByte1 =START_BYTE1;
2201   4                  pstDataFreq->bySndSecAddr =stLocalControl.stBusFreq.bySndSecAddr;
2202   4                  pstDataFreq->bySndRoomAddr  =stLocalControl.stBusFreq.bySndRoomAddr;
2203   4                  pstDataFreq->bySndBedAddr =stLocalControl.stBusFreq.bySndBedAddr;
2204   4      //            if((stLocalControl.stBusFreq.bySndRoomAddr == YHFJ_ADDR2) )
2205   4      //              pstDataFreq->bySndBedAddr =0xff;        //医护分机第3个地址发广播地址
2206   4                  
2207   4                  pstDataFreq->byRecSecAddr =stLocalControl.stEepromCfgData.bySelfSecAddr;
2208   4                  pstDataFreq->byRecRoomAddr  =PC_ADDR2;
2209   4                  pstDataFreq->byRecBedAddr =PC_ADDR3;
2210   4                  pstDataFreq->byCmd      =CMD_RESULT_PC;   //确认命令
2211   4                  pstDataFreq->uiLen      =0X02;
2212   4                  pstDataFreq->byData[0]    =stLocalControl.stBusFreq.byRecSecAddr;
2213   4                  pstDataFreq->byData[1]    =TRUE;    //成功或失败
2214   4                  pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
2215   4                  pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE; 
2216   4                  stUsartCfg[1].uiSndLen  = pstDataFreq->uiLen+EXT_SIZE;
2217   4                  stUsartCfg[1].uiSndPos = 0;   //从数据帧头部开始发送数据
2218   4                  
2219   4                  S2CON &= ~S2TI;
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 37  

2220   4                  S2BUF=pstDataFreq->byStartByte1;
2221   4                  
2222   4                  stLocalControl.stRS485Addr.byBedAddr=0;   //结果发完，将485床号清零
2223   4      
2224   4                }
2225   3                return;
2226   3      
2227   3              default:
2228   3                break;
2229   3              } 
2230   2             
2231   2              //if(AddrCompare(&(stLocalControl.stBusFreq.bySndSecAddr),&(stLocalControl.stCommAddr.bySecAddr)))
2232   2              if((stLocalControl.stBusFreq.bySndBedAddr == stLocalControl.stCommAddr.byBedAddr)||
2233   2              (stLocalControl.stBusFreq.bySndBedAddr == 0xff) ||
2234   2              (stLocalControl.stCommAddr.byBedAddr == 0xff) )
2235   2              {
2236   3              stLocalControl.uiDevState &= ~(FLAG_WAIT_COMM_ACK);
2237   3              //清等待总线应答超时
2238   3              stLocalControl.byWaitCommAckDTime = 0;
2239   3              switch(stLocalControl.stBusFreq.byRecSecAddr)
2240   3              {
2241   4              case CMD_POWER_ON:
2242   4              case CMD_ONLINE_WRITE:
2243   4              case CMD_SCHEDULE_SEND:
2244   4              case CMD_OPEN_LCD:
2245   4              case CMD_CLOSE_LCD:
2246   4              case CMD_CLEAR_LCD:
2247   4              case CMD_CLEAR_HANDLE_LCD:
2248   4              case CMD_CLEAR_MK_LCD:            
2249   4                Usart1SndResult(stLocalControl.stBusFreq.byRecSecAddr,TRUE);
2250   4                break;
2251   4              default:
2252   4                break;
2253   4              }
2254   3              
2255   3              }
2256   2            else stLocalControl.byWaitCommAckDTime = 1; //地址不区配,提前退出
2257   2            break;
2258   2          case CMD_DATA_ERROR:    //一帧数据出错
2259   2            //清等待应答超时
2260   2            if(stLocalControl.stBusFreq.bySndBedAddr == stLocalControl.stRS485Addr.byBedAddr)
2261   2            {//床号相等     
2262   3                     stLocalControl.byWaitRS485AckDTime = 0;            
2263   3               Usart1SndRS485Result(byUsart0SndBuf[CMD_POSITION],FALSE);
2264   3            }
2265   2            break;
2266   2          case CMD_ONLINE_OUTPUT:
2267   2              if((stLocalControl.stBusFreq.bySndSecAddr==stLocalControl.stCommAddr.bySecAddr)&&
2268   2              (stLocalControl.stBusFreq.bySndRoomAddr==stLocalControl.stCommAddr.byRoomAddr)&&
2269   2              (stLocalControl.stBusFreq.bySndBedAddr==stLocalControl.stCommAddr.byBedAddr))
2270   2              {
2271   3              stLocalControl.uiDevState &= ~(FLAG_WAIT_COMM_ACK);
2272   3              //清等待总线应答超时
2273   3              stLocalControl.byWaitCommAckDTime = 0;
2274   3              Usart1SndResult1(CMD_ONLINE_READ,TRUE,stLocalControl.stBusFreq.byRecSecAddr);   
2275   3              }
2276   2            else stLocalControl.byWaitCommAckDTime = 1; //地址不区配,提前退出
2277   2            break;
2278   2      
2279   2          case CMD_QUEST_ANSWER:
2280   2              if((stLocalControl.stBusFreq.bySndSecAddr==stLocalControl.stCommAddr.bySecAddr)&&
2281   2              (stLocalControl.stBusFreq.bySndRoomAddr==stLocalControl.stCommAddr.byRoomAddr)&&
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 38  

2282   2              (stLocalControl.stBusFreq.bySndBedAddr==stLocalControl.stCommAddr.byBedAddr))
2283   2              {
2284   3              //stLocalControl.uiDevState &= ~(FLAG_WAIT_ACK|FLAG_BUSY);
2285   3              stLocalControl.uiDevState &= ~(FLAG_WAIT_COMM_ACK);
2286   3              //清等待总线应答超时
2287   3              stLocalControl.byWaitCommAckDTime = 0;
2288   3              Usart1SndResult3(byUsart1RecBuf[CMD_POSITION],TRUE,&(stLocalControl.stBusFreq.byRecSecAddr),3); //发送
             -附带参数的结果码      
2289   3              }
2290   2            else stLocalControl.byWaitCommAckDTime = 1; //地址不区配,提前退出
2291   2            break;
2292   2      
2293   2          case CMD_NURSE_IN:
2294   2          case CMD_NURSE_OUT:
2295   2            errtime =0xff;
2296   2            while(stUsartCfg[1].uiSndLen!=0)  
2297   2            {//有数据正在发送中
2298   3              Delayms(1);
2299   3              WDT_CONTR = 0x3e;     //看门狗定时2.5s@20M  
2300   3              if(--errtime ==0) break;
2301   3            }     
2302   2            pstDataFreq = (pSTUartFreq)byUsart1SndBuf;
2303   2            pstDataFreq->byStartByte1 = START_BYTE1;
2304   2            pstDataFreq->bySndSecAddr =stLocalControl.stEepromCfgData.bySelfSecAddr;
2305   2            pstDataFreq->bySndRoomAddr  =stLocalControl.stEepromCfgData.bySelfRoomAddr;
2306   2            pstDataFreq->bySndBedAddr =stLocalControl.stEepromCfgData.bySelfBedAddr;
2307   2            pstDataFreq->byRecSecAddr =stLocalControl.stEepromCfgData.bySelfSecAddr;
2308   2            pstDataFreq->byRecRoomAddr  =PC_ADDR2;
2309   2            pstDataFreq->byRecBedAddr =PC_ADDR3;
2310   2            pstDataFreq->byCmd = stLocalControl.stBusFreq.byCmd;
2311   2            pstDataFreq->uiLen = 04;
2312   2            pstDataFreq->byData[0]= stLocalControl.stBusFreq.bySndBedAddr;
2313   2            memcpy(&(pstDataFreq->byData[1]),&(stLocalControl.stBusFreq.byRecSecAddr),3);
2314   2            pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
2315   2            pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE;
2316   2                  
2317   2            stUsartCfg[1].uiSndLen  = pstDataFreq->uiLen+EXT_SIZE;
2318   2            stUsartCfg[1].uiSndPos = 0;   //从数据帧头部开始发送数据
2319   2            S2CON &= ~S2TI;
2320   2            S2BUF=pstDataFreq->byStartByte1;
2321   2            break;
2322   2      
2323   2          case CMD_SUPPLY_OX_START:     
2324   2          case CMD_SUPPLY_OX_END:
2325   2            errtime =0xff;
2326   2            while(stUsartCfg[1].uiSndLen!=0)  
2327   2            {//有数据正在发送中
2328   3              Delayms(1);
2329   3              WDT_CONTR = 0x3e;     //看门狗定时2.5s@20M  
2330   3              if(--errtime ==0) break;
2331   3            }     
2332   2            pstDataFreq = (pSTUartFreq)byUsart1SndBuf;
2333   2            pstDataFreq->byStartByte1 = START_BYTE1;
2334   2            pstDataFreq->bySndSecAddr =stLocalControl.stEepromCfgData.bySelfSecAddr;
2335   2            pstDataFreq->bySndRoomAddr  =stLocalControl.stEepromCfgData.bySelfRoomAddr;
2336   2            pstDataFreq->bySndBedAddr =stLocalControl.stEepromCfgData.bySelfBedAddr;
2337   2            pstDataFreq->byRecSecAddr =stLocalControl.stEepromCfgData.bySelfSecAddr;
2338   2            pstDataFreq->byRecRoomAddr  =PC_ADDR2;
2339   2            pstDataFreq->byRecBedAddr =PC_ADDR3;
2340   2            pstDataFreq->byCmd = stLocalControl.stBusFreq.byCmd;
2341   2            pstDataFreq->uiLen = 0x05;
2342   2            memcpy(&(pstDataFreq->byData[0]),&(stLocalControl.stBusFreq.bySndSecAddr),3);
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 39  

2343   2            pstDataFreq->byData[3]=stLocalControl.stBusFreq.byRecRoomAddr;
2344   2            pstDataFreq->byData[4]=stLocalControl.stBusFreq.byRecBedAddr;
2345   2            pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
2346   2            pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE;
2347   2                  
2348   2            stUsartCfg[1].uiSndLen  = pstDataFreq->uiLen+EXT_SIZE;
2349   2            stUsartCfg[1].uiSndPos = 0;   //从数据帧头部开始发送数据
2350   2            S2CON &= ~S2TI;
2351   2            S2BUF=pstDataFreq->byStartByte1;
2352   2            break;
2353   2      
2354   2          case CMD_VOICE_TIMER_SET:
2355   2            errtime =0xff;
2356   2            while(stUsartCfg[1].uiSndLen!=0)  
2357   2            {//有数据正在发送中
2358   3              Delayms(1);
2359   3              WDT_CONTR = 0x3e;     //看门狗定时2.5s@20M  
2360   3              if(--errtime ==0) break;
2361   3      
2362   3            }     
2363   2            pstDataFreq = (pSTUartFreq)byUsart1SndBuf;
2364   2            pstDataFreq->byStartByte1 = START_BYTE1;
2365   2            memcpy(&(pstDataFreq->bySndSecAddr),&(stLocalControl.stEepromCfgData.bySelfSecAddr),3);
2366   2            memset(&(pstDataFreq->byRecSecAddr),0x00,3);
2367   2            pstDataFreq->byCmd = stLocalControl.stBusFreq.byCmd;
2368   2            pstDataFreq->uiLen = 0x05;
2369   2            pstDataFreq->byData[0]=stLocalControl.stBusFreq.bySndSecAddr;
2370   2            pstDataFreq->byData[1]=stLocalControl.stBusFreq.bySndRoomAddr;
2371   2            pstDataFreq->byData[2]=stLocalControl.stBusFreq.byRecSecAddr;
2372   2            pstDataFreq->byData[3]=stLocalControl.stBusFreq.byRecRoomAddr;
2373   2            pstDataFreq->byData[4]=stLocalControl.stBusFreq.byRecBedAddr;
2374   2            pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
2375   2            pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE;
2376   2                  
2377   2            stUsartCfg[1].uiSndLen  = pstDataFreq->uiLen+EXT_SIZE;
2378   2            stUsartCfg[1].uiSndPos = 0;   //从数据帧头部开始发送数据
2379   2            S2CON &= ~S2TI;
2380   2            S2BUF=pstDataFreq->byStartByte1;
2381   2            break;
2382   2      
2383   2          case CMD_BL_TIMER_SET:
2384   2            errtime =0xff;
2385   2            while(stUsartCfg[1].uiSndLen!=0)  
2386   2            {//有数据正在发送中
2387   3              Delayms(1);
2388   3              WDT_CONTR = 0x3e;     //看门狗定时2.5s@20M  
2389   3              if(--errtime ==0) break;
2390   3            }     
2391   2            pstDataFreq = (pSTUartFreq)byUsart1SndBuf;
2392   2            pstDataFreq->byStartByte1 = START_BYTE1;
2393   2            memcpy(&(pstDataFreq->bySndSecAddr),&(stLocalControl.stEepromCfgData.bySelfSecAddr),3);
2394   2            memset(&(pstDataFreq->byRecSecAddr),0x00,3);
2395   2            pstDataFreq->byCmd = stLocalControl.stBusFreq.byCmd;
2396   2            pstDataFreq->uiLen = 0x04;
2397   2            pstDataFreq->byData[0]=stLocalControl.stBusFreq.bySndSecAddr;
2398   2            pstDataFreq->byData[1]=stLocalControl.stBusFreq.bySndRoomAddr;
2399   2            pstDataFreq->byData[2]=stLocalControl.stBusFreq.byRecSecAddr;
2400   2            pstDataFreq->byData[3]=stLocalControl.stBusFreq.byRecRoomAddr;
2401   2      
2402   2            pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
2403   2            pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE;
2404   2                  
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 40  

2405   2            stUsartCfg[1].uiSndLen  = pstDataFreq->uiLen+EXT_SIZE;
2406   2            stUsartCfg[1].uiSndPos = 0;   //从数据帧头部开始发送数据
2407   2            S2CON &= ~S2TI;
2408   2            S2BUF=pstDataFreq->byStartByte1;
2409   2            break;
2410   2          case CMD_COLOR_CLEAR:
2411   2            errtime =0xff;
2412   2            while(stUsartCfg[1].uiSndLen!=0)  
2413   2            {//有数据正在发送中
2414   3              Delayms(1);
2415   3              WDT_CONTR = 0x3e;     //看门狗定时2.5s@20M  
2416   3              if(--errtime ==0) break;
2417   3            }
2418   2            pstDataFreq = (pSTUartFreq)byUsart1SndBuf;
2419   2            pstDataFreq->byStartByte1 = START_BYTE1;
2420   2            memcpy(&(pstDataFreq->bySndSecAddr),&(stLocalControl.stEepromCfgData.bySelfSecAddr),3);
2421   2            memset(&(pstDataFreq->byRecSecAddr),0x00,3);
2422   2            pstDataFreq->byCmd = stLocalControl.stBusFreq.byCmd;
2423   2            pstDataFreq->uiLen = 0x03;
2424   2            pstDataFreq->byData[0]=stLocalControl.stBusFreq.bySndSecAddr;
2425   2            pstDataFreq->byData[1]=stLocalControl.stBusFreq.bySndRoomAddr;
2426   2            pstDataFreq->byData[2]=stLocalControl.stBusFreq.bySndBedAddr;
2427   2       
2428   2      
2429   2            pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
2430   2            pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE;
2431   2                  
2432   2            stUsartCfg[1].uiSndLen  = pstDataFreq->uiLen+EXT_SIZE;
2433   2            stUsartCfg[1].uiSndPos = 0;   //从数据帧头部开始发送数据
2434   2            S2CON &= ~S2TI;
2435   2            S2BUF=pstDataFreq->byStartByte1;
2436   2            break;
2437   2            
2438   2      
2439   2          default:
2440   2            break;
2441   2        }
2442   1      }
2443          
2444          
2445          /**********************************************************
2446          *函数名称     :Bus0SendFinishDeal
2447          *函数描述         :单总线0数据发送完成处理
2448          *输入参数       :
2449          *返回值       :
2450          *全局变量     :stLocalControl
2451          *调用模块       :
2452          ***********************************************************
2453          *创建人           :尹运同
2454          *创建日期     :2009-4-7
2455          ***********************************************************
2456          *修改人         :
2457          *修改日期       :
2458          *注释           :
2459          **********************************************************/
2460          void Bus0SendFinishDeal(void)
2461          {  
2462   1        pSTUartFreq pstDataFreq;
2463   1      
2464   1        //复位看门狗                                                                                             
             -                                                                                                                        
             -                                                                
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 41  

2465   1        WDT_CONTR = 0x3e;     //看门狗定时2.5s@20M  
2466   1        EA=0; 
2467   1        bBus0SendFinish=0;    
2468   1        memcpy(&(stLocalControl.stBusFreq.bySndSecAddr), byBus0SendData, sizeof(STBusFreq));  //获取单总线数据
2469   1        EA=1;
2470   1      
2471   1      //调试用
2472   1        #if DEBUG==1
2473   1      //  Usart1SndData(&(stLocalControl.stBusFreq));
2474   1        ///////////////////////////////////////////////////////////////////////////// 
2475   1        #endif
2476   1        
2477   1        //数据处理  
2478   1        switch(stLocalControl.stBusFreq.byCmd)
2479   1        {
2480   2          case CMD_POWER_ON:                  //上电复位命令发送完成
2481   2            if(stLocalControl.uiDevState & FLAG_LANDING)
2482   2            { //确实处在上电状态
2483   3              stLocalControl.uiDevState &= ~FLAG_LANDING;
2484   3              stLocalControl.uiDetectPcTime = 250;
2485   3            }
2486   2            else
2487   2            {
2488   3              //置等待应答和忙标志
2489   3              stLocalControl.uiDevState |= (FLAG_WAIT_COMM_ACK);
2490   3              //保存分机地址
2491   3              stLocalControl.stCommAddr.bySecAddr = stLocalControl.stBusFreq.byRecSecAddr;
2492   3              stLocalControl.stCommAddr.byRoomAddr = stLocalControl.stBusFreq.byRecRoomAddr;
2493   3              stLocalControl.stCommAddr.byBedAddr = stLocalControl.stBusFreq.byRecBedAddr;
2494   3              //设置等待应答超时1S
2495   3              stLocalControl.byWaitCommAckDTime = 50;       
2496   3            }
2497   2            break;
2498   2          case CMD_INFO_INDICATION:             //呼叫指示命令      
2499   2            stLocalControl.uiDevState &= ~FLAG_INDICATION_EXIST;
2500   2            if(stLocalControl.uiDevState & FLAG_BUSY)
2501   2            { //忙，退出        
2502   3              break;
2503   3            }     
2504   2            //检查该记录      
2505   2            if((stLocalControl.stIndicationData.byState == STATE_HI) ||
2506   2              (stLocalControl.stIndicationData.byState == STATE_DEL))
2507   2            { //有高优先级呼叫存在或者该呼叫已经不存在了，发送终止呼叫命令
2508   3              if(stLocalControl.uiDevState & FLAG_STOP_EXIST)
2509   3              { //有正在发送停止命令
2510   4                return;
2511   4              }
2512   3              stLocalControl.stBusFreq.byCmd = CMD_STOP_INDICATION;           
2513   3              if(true == Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr)))
2514   3              {
2515   4                stLocalControl.uiDevState |= FLAG_STOP_EXIST;
2516   4              }       
2517   3            }
2518   2            else
2519   2            { //该呼叫还存在于记录中,且没有高优先级的呼叫存在,置指示标志
2520   3              stLocalControl.uiDevState |= FLAG_INDICATION;
2521   3              
2522   3      /*        //构建语音信息
2523   3              MakeCallVoiceData(&(stLocalControl.stIndicationData));  
2524   3              //播放语音
2525   3              StartVoicePlay();
2526   3      */
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 42  

2527   3      
2528   3              //因中医研究院分机多，线路长，SD与SA之间存在很大的线间电容，造成在对讲时，
2529   3              //如果语音报号，医护分机通话时有很大的语音报号声，造成通话听不到。
2530   3      //        if((stLocalControl.uiDevState &(FLAG_TALK |FLAG_TALK1)) ==0)
2531   3              {
2532   4      
2533   4                //将单总线0上的数据原样发给单总线1
2534   4                Bus1OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
2535   4                //语音通道切换
2536   4                VoiceChannelCtx();
2537   4                //设置报号超时15S
2538   4                MakeCH0TimerOut(250, 3);
2539   4              }
2540   3            }             
2541   2            break;
2542   2          case CMD_STOP_INDICATION:             //终止呼叫指示命令      
2543   2            //清指示标志
2544   2            stLocalControl.uiDevState &= ~(FLAG_INDICATION|FLAG_STOP_EXIST);
2545   2            //清报号超时
2546   2            MakeCH0TimerOut(0, 0);
2547   2            
2548   2      //      //停止报号
2549   2      //      StopVoicePlay();
2550   2      
2551   2            //向语音模块发送停止报号命令
2552   2            stLocalControl.stBusFreq.byCmd = CMD_STOP_VOICE_PLAY;
2553   2            Bus1OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
2554   2      
2555   2            //语音通道切换
2556   2            VoiceChannelCtx();      
2557   2            //不忙，且没有呼叫指示正在发送队列中,重新开始报号     
2558   2            RestartIndication();      
2559   2            break;  
2560   2          case CMD_SYSTERM_RESET:               //系统复位命令
2561   2            stLocalControl.uiDevState &= (FLAG_TALK1|FLAG_NOTE|FLAG_MUSIC|FLAG_INDICATION_EXIST|FLAG_STOP_EXIST); /
             -/ 将此几位保持原状态,其它标志清0    
2562   2      
2563   2      //      //停止报号
2564   2      //      StopVoicePlay();
2565   2      
2566   2            //向语音模块发送停止报号命令
2567   2            stLocalControl.stBusFreq.byCmd = CMD_STOP_VOICE_PLAY;
2568   2            Bus1OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));   
2569   2            
2570   2            //语音通道切换
2571   2            VoiceChannelCtx();
2572   2            //清超时
2573   2            MakeCH0TimerOut(0, 0);        
2574   2            //重新开始报号
2575   2            if(0x00 == (stLocalControl.uiDevState&(FLAG_INDICATION_EXIST|FLAG_STOP_EXIST)))
2576   2            {
2577   3              RestartIndication();
2578   3            }                 
2579   2            break;  
2580   2          case CMD_START_VOICE:               //语音提示命令
2581   2            //清通道1通话标志和超时等待
2582   2            stLocalControl.uiDevState &= ~FLAG_TALK1;     
2583   2            MakeCH1TimerOut(0, 0);
2584   2            //置语音提醒标志
2585   2            stLocalControl.uiDevState |= FLAG_NOTE;
2586   2            //语音通道切换
2587   2            VoiceChannelCtx();  
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 43  

2588   2            Usart1SndResult(CMD_START_VOICE,TRUE);
2589   2            break;
2590   2          case CMD_MUSIC_PLAY:                //背景音乐播放标志
2591   2            //清通道1通话标志和超时等待
2592   2            stLocalControl.uiDevState &= ~FLAG_TALK1;       
2593   2            MakeCH1TimerOut(0, 0);
2594   2            //置背景音乐标志
2595   2            stLocalControl.uiDevState |= FLAG_MUSIC;
2596   2            //语音通道切换
2597   2            VoiceChannelCtx();
2598   2            Usart1SndResult(CMD_MUSIC_PLAY,TRUE);
2599   2            break;
2600   2          case CMD_STOP_VOICE:
2601   2            //清播音和背景音乐标志
2602   2            stLocalControl.uiDevState &= ~(FLAG_NOTE|FLAG_MUSIC);
2603   2            //语音通道切换
2604   2            VoiceChannelCtx();
2605   2            Usart1SndResult(CMD_STOP_VOICE,TRUE);
2606   2            
2607   2            if(NULL ==(uint8 xdata *)(stLocalControl.stCallPointer.pstHead))
2608   2            { //没有呼叫记录了，直接退出
2609   3            
2610   3              if(!(stLocalControl.uiDevState & (FLAG_TALK |FLAG_TALK1|FLAG_NOTE|FLAG_MUSIC|FLAG_BROADCAST|FLAG_INDIC
             -ATION)))
2611   3              {//没有通话存在
2612   4                stLocalControl.byChar =0x00;  //系统不忙
2613   4                Usart1SndCmd(CMD_SYSTEM_STATE,1,&(stLocalControl.byChar));  //报告系统不忙状态
2614   4              } 
2615   3            }     
2616   2            break;  
2617   2          case CMD_INFUSION_CLEAR:              //清除输液呼叫命令
2618   2          case CMD_SERVICE_CLEAR:               //清除服务呼叫
2619   2          case CMD_HELP_CLEAR:                //清除求援呼叫
2620   2          case CMD_EMERGENCY_CLEAR:             //清除紧急呼叫
2621   2            //暂存原命令数据
2622   2            stLocalControl.byChar = stLocalControl.stBusFreq.byCmd; 
2623   2            
2624   2            //清呼叫记录
2625   2            stLocalControl.stBusFreq.byCmd -= 0x0a;     //将清除命令还原成对应的呼叫命令    
2626   2            RemoveCallNod(&(stLocalControl.stBusFreq));     
2627   2            if((stLocalControl.uiDevState & FLAG_INDICATION) && 
2628   2              (stLocalControl.stBusFreq.byRecSecAddr == stLocalControl.stIndicationData.byIndicationSecAddr) &&
2629   2              (stLocalControl.stBusFreq.byRecRoomAddr == stLocalControl.stIndicationData.byIndicationRoomAddr) &&
2630   2              (stLocalControl.stBusFreq.byRecBedAddr == stLocalControl.stIndicationData.byIndicationBedAddr) &&
2631   2              (stLocalControl.stBusFreq.byCmd == (stLocalControl.stIndicationData.byCallCmd & 0x1f)))
2632   2            { //正在呼叫指示,且清除的呼叫为正在指示的呼叫,清报号标志
2633   3              stLocalControl.uiDevState &= ~FLAG_INDICATION;
2634   3              
2635   3      //        //停止报号
2636   3      //        StopVoicePlay();
2637   3      
2638   3              //向语音模块发送停止报号命令
2639   3              stLocalControl.stBusFreq.byCmd = CMD_STOP_VOICE_PLAY;
2640   3              Bus1OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
2641   3      
2642   3              //语音通道切换
2643   3              VoiceChannelCtx();
2644   3              //清超时
2645   3              MakeCH0TimerOut(0, 0);        
2646   3              //重新开始报号
2647   3              if(0x00 == (stLocalControl.uiDevState&FLAG_STOP_EXIST))
2648   3              {
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 44  

2649   4                RestartIndication();
2650   4              }
2651   3            }
2652   2            stLocalControl.stBusFreq.byCmd = stLocalControl.byChar;                   
2653   2            Usart1SndResult(stLocalControl.stBusFreq.byCmd,TRUE);     
2654   2            break;  
2655   2          case CMD_CHANNEL_CHANGE:              //通道切换命令
2656   2            if(stLocalControl.uiDevState & FLAG_TALK)
2657   2            { //通话状态
2658   3              stLocalControl.uiDevState &= ~(FLAG_BUSY|FLAG_TALK);
2659   3      
2660   3              //将通道0的主动呼叫方地址复制到通道1的主动呼叫方地址中
2661   3              memcpy(&(stLocalControl.stCH1CallAddr),&(stLocalControl.stCallAddr),sizeof(STAddr));
2662   3              //将通道0的主动呼叫方地址清0
2663   3              stLocalControl.stCallAddr.bySndSecAddr = 0x00;
2664   3              stLocalControl.stCallAddr.bySndRoomAddr = 0x00;
2665   3              stLocalControl.stCallAddr.bySndBedAddr = 0x00;
2666   3              stLocalControl.stCallAddr.byRecSecAddr = 0x00;
2667   3              stLocalControl.stCallAddr.byRecRoomAddr = 0x00;
2668   3              stLocalControl.stCallAddr.byRecBedAddr = 0x00;        
2669   3              //清通道切换在总线队列中标志
2670   3              stLocalControl.uiDevState &= ~(FLAG_CHANNEL_CHANGE_EXIST);
2671   3      
2672   3      
2673   3              //清超时
2674   3              MakeCH0TimerOut(0, 0);  
2675   3              //置通话1标志
2676   3              stLocalControl.uiDevState |= FLAG_TALK1;          
2677   3              //语音通道切换
2678   3              VoiceChannelCtx();
2679   3              //通道1通话定时60S
2680   3              MakeCH1TimerOut(250, 12);
2681   3      
2682   3      
2683   3              //因中医研究院分机多，线路长，SD与SA之间存在很大的线间电容，造成在对讲时，
2684   3              //如果语音报号，医护分机通话时有很大的语音报号声，造成通话听不到?
2685   3      
2686   3              
2687   3      /*        //重新开始报号
2688   3              if(0x00 == (stLocalControl.uiDevState&(FLAG_INDICATION_EXIST|FLAG_STOP_EXIST)))
2689   3              {
2690   3      
2691   3                RestartIndication();
2692   3              }*/
2693   3            }
2694   2            else
2695   2            { //不是通话状态，发送关闭通道命令
2696   3              stLocalControl.stBusFreq.bySndSecAddr = stLocalControl.stCallAddr.bySndSecAddr;
2697   3              stLocalControl.stBusFreq.bySndRoomAddr = stLocalControl.stCallAddr.bySndRoomAddr;
2698   3              stLocalControl.stBusFreq.bySndBedAddr = stLocalControl.stCallAddr.bySndBedAddr;     
2699   3              stLocalControl.stBusFreq.byCmd = CMD_CHANNEL_CLOSE;
2700   3              stLocalControl.stBusFreq.byRecSecAddr = stLocalControl.stCallAddr.byRecSecAddr;
2701   3              stLocalControl.stBusFreq.byRecRoomAddr = stLocalControl.stCallAddr.byRecRoomAddr;
2702   3              stLocalControl.stBusFreq.byRecBedAddr = stLocalControl.stCallAddr.byRecBedAddr;
2703   3              Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
2704   3            }         
2705   2            break;
2706   2            
2707   2          case CMD_CHANNEL_CLOSE:     
2708   2            stLocalControl.uiDevState &= ~FLAG_TALK1;
2709   2            
2710   2            if(NULL ==(uint8 xdata *)(stLocalControl.stCallPointer.pstHead))
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 45  

2711   2            { //没有呼叫记录了，直接退出
2712   3            
2713   3              if(!(stLocalControl.uiDevState & (FLAG_TALK |FLAG_TALK1|FLAG_NOTE|FLAG_MUSIC|FLAG_BROADCAST|FLAG_INDIC
             -ATION)))
2714   3              {//没有通话存在
2715   4                stLocalControl.byChar =0x00;  //系统不忙
2716   4                Usart1SndCmd(CMD_SYSTEM_STATE,1,&(stLocalControl.byChar));  //报告系统不忙状态
2717   4              } 
2718   3            } 
2719   2            
2720   2            //语音通道切换
2721   2            VoiceChannelCtx();
2722   2            //清通道1通话超时
2723   2            MakeCH1TimerOut(0, 0);
2724   2            if(stLocalControl.uiDevState & FLAG_TALK)
2725   2            { //通道0通话存在，发送切换语音通道命令       
2726   3              stLocalControl.stBusFreq.byCmd = CMD_CHANNEL_CHANGE;
2727   3              //置通道切换命令在总线队列中标志
2728   3              stLocalControl.uiDevState |= FLAG_CHANNEL_CHANGE_EXIST;
2729   3              Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr)); 
2730   3            }
2731   2            break;
2732   2      
2733   2          case CMD_INFUSION_ENTER:    //发送完呼叫确认命令后才将此信息上传至PC机
2734   2          case CMD_SERVICE_ENTER:
2735   2          case CMD_EMERGENCY_ENTER:
2736   2          case CMD_HELP_ENTER:
2737   2            errtime =0xff;
2738   2            while(stUsartCfg[1].uiSndLen!=0)  
2739   2            {//有数据正在发送中
2740   3              Delayms(1);
2741   3              WDT_CONTR = 0x3e;     //看门狗定时2.5s@20M  
2742   3              if(--errtime ==0) break;
2743   3            }     
2744   2            pstDataFreq = (pSTUartFreq)byUsart1SndBuf;
2745   2            pstDataFreq->byStartByte1 = START_BYTE1;
2746   2            pstDataFreq->bySndSecAddr   =stLocalControl.stEepromCfgData.bySelfSecAddr;
2747   2            pstDataFreq->bySndRoomAddr  =stLocalControl.stEepromCfgData.bySelfRoomAddr;
2748   2            pstDataFreq->bySndBedAddr   =stLocalControl.stEepromCfgData.bySelfBedAddr;
2749   2            pstDataFreq->byRecSecAddr   =stLocalControl.stEepromCfgData.bySelfSecAddr;
2750   2            pstDataFreq->byRecRoomAddr  =PC_ADDR2;
2751   2            pstDataFreq->byRecBedAddr   =PC_ADDR3;      
2752   2            memcpy(&(pstDataFreq->byData[0]),&(stLocalControl.stBusFreq.byRecSecAddr),3);
2753   2            pstDataFreq->byCmd = stLocalControl.stBusFreq.byCmd-0x1b;
2754   2            pstDataFreq->uiLen = 0x03;
2755   2            pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
2756   2            pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE;
2757   2                  
2758   2            stUsartCfg[1].uiSndLen  = pstDataFreq->uiLen+EXT_SIZE;
2759   2            stUsartCfg[1].uiSndPos = 0;   //从数据帧头部开始发送数据
2760   2            S2CON &= ~S2TI;
2761   2            S2BUF=pstDataFreq->byStartByte1;
2762   2            break;
2763   2          case CMD_INFUSION_ANSWER:
2764   2          case CMD_SERVICE_ANSWER:
2765   2          case CMD_EMERGENCY_ANSWER:
2766   2          case CMD_HELP_ANSWER:
2767   2            if(stLocalControl.uiDevState & FLAG_BUSY)
2768   2            { //忙，退出
2769   3              Usart1SndResult(byUsart1RecBuf[CMD_POSITION],FALSE);  //发送操作失败命令
2770   3              break;
2771   3            } 
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 46  

2772   2            //清呼叫记录
2773   2            stLocalControl.stBusFreq.byCmd -= 0x06;     //将处理命令还原成对应的呼叫命令
2774   2            RemoveCallNod(&(stLocalControl.stBusFreq));     
2775   2            //置等待应答和忙标志
2776   2            stLocalControl.uiDevState |= (FLAG_WAIT_ACK|FLAG_BUSY); 
2777   2            if(stLocalControl.uiDevState & FLAG_INDICATION)
2778   2            { //正在呼叫指示,清指示标志       
2779   3              stLocalControl.uiDevState &= ~FLAG_INDICATION;
2780   3              
2781   3      //        //停止报号      
2782   3      //        StopVoicePlay();
2783   3      
2784   3              //向语音模块发送停止报号命令
2785   3              stLocalControl.stBusFreq.byCmd = CMD_STOP_VOICE_PLAY;
2786   3              Bus1OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
2787   3      
2788   3              //语音通道切换
2789   3              VoiceChannelCtx();                
2790   3            } 
2791   2            
2792   2            //保存主动呼叫方、被动呼叫方地址
2793   2            SaveCallAddr(&(stLocalControl.stBusFreq));
2794   2      
2795   2            //设置等待应答超时1S
2796   2            MakeCH0TimerOut(50, 0);     
2797   2            break;
2798   2          case CMD_COMM_CALL:                 //普通呼叫命令
2799   2            if(stLocalControl.uiDevState & FLAG_BUSY)
2800   2            { //忙，直接退出
2801   3              break;
2802   3            }
2803   2            //置忙和等待应答标志 
2804   2            stLocalControl.uiDevState |= (FLAG_BUSY|FLAG_WAIT_ACK);     
2805   2            if(stLocalControl.uiDevState & FLAG_INDICATION)
2806   2            { //正在呼叫指示,清指示标志       
2807   3              stLocalControl.uiDevState &= ~FLAG_INDICATION;
2808   3              
2809   3      //        //停止报号      
2810   3      //        StopVoicePlay();
2811   3      
2812   3              //向语音模块发送停止报号命令
2813   3              stLocalControl.stBusFreq.byCmd = CMD_STOP_VOICE_PLAY;
2814   3              Bus1OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
2815   3      
2816   3              //语音通道切换
2817   3              VoiceChannelCtx();                
2818   3            } 
2819   2            
2820   2            //保存主动呼叫方、被动呼叫方地址
2821   2            SaveCallAddr(&(stLocalControl.stBusFreq));
2822   2      
2823   2            //设置等待应答超时1S
2824   2            MakeCH0TimerOut(50, 0);
2825   2            break;    
2826   2          case CMD_ONLINE_WRITE:
2827   2          case CMD_ONLINE_READ:
2828   2          case CMD_SCHEDULE_SEND:
2829   2          case CMD_QUEST:
2830   2            //置等待应答和忙标志
2831   2            //stLocalControl.uiDevState |= (FLAG_WAIT_ACK|FLAG_BUSY);
2832   2            stLocalControl.uiDevState |= (FLAG_WAIT_COMM_ACK);
2833   2            //保存分机地址
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 47  

2834   2            stLocalControl.stCommAddr.bySecAddr = stLocalControl.stBusFreq.byRecSecAddr;
2835   2            stLocalControl.stCommAddr.byRoomAddr = stLocalControl.stBusFreq.byRecRoomAddr;
2836   2            stLocalControl.stCommAddr.byBedAddr = stLocalControl.stBusFreq.byRecBedAddr;
2837   2            //设置等待应答超时1S
2838   2            stLocalControl.byWaitCommAckDTime = 50;
2839   2            break;
2840   2          case CMD_OPEN_LCD:
2841   2          case CMD_CLOSE_LCD:
2842   2          case CMD_CLEAR_LCD:
2843   2          case CMD_CLEAR_HANDLE_LCD:
2844   2          case CMD_CLEAR_MK_LCD:
2845   2            if((stLocalControl.stBusFreq.byRecSecAddr == 0xff)||(stLocalControl.stBusFreq.byRecRoomAddr == 0xff)||(
             -stLocalControl.stBusFreq.byRecBedAddr == 0xff))
2846   2            {//是广播地址
2847   3              Usart1SndResult(byUsart1RecBuf[CMD_POSITION],TRUE);       //发送操作成功命令
2848   3            }     
2849   2            else
2850   2            {//单个
2851   3              //置等待应答和忙标志
2852   3              //stLocalControl.uiDevState |= (FLAG_WAIT_ACK|FLAG_BUSY);
2853   3              stLocalControl.uiDevState |= (FLAG_WAIT_COMM_ACK);
2854   3              //保存分机地址
2855   3              stLocalControl.stCommAddr.bySecAddr = stLocalControl.stBusFreq.byRecSecAddr;
2856   3              stLocalControl.stCommAddr.byRoomAddr = stLocalControl.stBusFreq.byRecRoomAddr;
2857   3              stLocalControl.stCommAddr.byBedAddr = stLocalControl.stBusFreq.byRecBedAddr;
2858   3              //设置等待应答超时1S
2859   3              stLocalControl.byWaitCommAckDTime = 50;     
2860   3            }
2861   2            break;
2862   2          case CMD_BROADCAST1:                
2863   2          case CMD_BROADCAST2:
2864   2          case CMD_BROADCAST3:                //广播命令
2865   2            if(stLocalControl.uiDevState & FLAG_BUSY)
2866   2            { //忙，发送系统复位命令
2867   3              stLocalControl.stBusFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2868   3              stLocalControl.stBusFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2869   3              stLocalControl.stBusFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2870   3              stLocalControl.stBusFreq.byCmd = CMD_SYSTERM_RESET;
2871   3              stLocalControl.stBusFreq.byRecSecAddr = 0xff;
2872   3              stLocalControl.stBusFreq.byRecRoomAddr = 0xff;
2873   3              stLocalControl.stBusFreq.byRecBedAddr = 0xff;       
2874   3              Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
2875   3              Usart1SndResult(stLocalControl.stBusFreq.byCmd,FALSE);
2876   3              break;
2877   3            }
2878   2            //不忙，置忙标志和广播标志
2879   2            stLocalControl.uiDevState |= (FLAG_BUSY|FLAG_BROADCAST);
2880   2            
2881   2            //保存主动呼叫方、被动呼叫方地址
2882   2            SaveCallAddr(&(stLocalControl.stBusFreq));
2883   2      
2884   2            //清呼叫指示标志
2885   2            stLocalControl.uiDevState &= ~FLAG_INDICATION;
2886   2            
2887   2      //      //停止报号      
2888   2      //      StopVoicePlay();
2889   2      
2890   2            //暂存原命令
2891   2            stLocalControl.byChar = stLocalControl.stBusFreq.byCmd;
2892   2      
2893   2            //向语音模块发送停止报号命令
2894   2            stLocalControl.stBusFreq.byCmd = CMD_STOP_VOICE_PLAY;
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 48  

2895   2            Bus1OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));
2896   2      
2897   2            //语音通道切换
2898   2            VoiceChannelCtx();
2899   2            //设置等待广播超时180S
2900   2            MakeCH0TimerOut(250, 36);
2901   2      
2902   2            stLocalControl.stBusFreq.byCmd= stLocalControl.byChar;
2903   2            Usart1SndResult(stLocalControl.stBusFreq.byCmd,TRUE);
2904   2            break;
2905   2          case CMD_VOICE_TIMER_SET:
2906   2          case CMD_BL_TIMER_SET:
2907   2            //置等待应答标志
2908   2            stLocalControl.uiDevState |= (FLAG_WAIT_COMM_ACK);  
2909   2            break;
2910   2            
2911   2          case CMD_RS485_BRT_SET:
2912   2            stLocalControl.byReSndBrtTimes--;
2913   2            if(stLocalControl.byReSndBrtTimes!=0) 
2914   2            {       
2915   3              Delayms(500); //延时1S,再发送一次
2916   3              if(stLocalControl.byReSndBrtTimes == RE_SND_TIMES-1)
2917   3              {
2918   4                Usart1SndResult(stLocalControl.stBusFreq.byCmd,TRUE); //发送完第一次发结果命令
2919   4              }
2920   3              Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr));     
2921   3            }
2922   2            break;
2923   2      
2924   2      
2925   2          case CMD_RS485_INFO_SEC_ROOM:
2926   2            stLocalControl.byReSndRs485RoomTimes--;
2927   2            if(stLocalControl.byReSndRs485RoomTimes!=0)
2928   2            {
2929   3              Delayms(500); //延时1S,再发送一次
2930   3              if(stLocalControl.byReSndRs485RoomTimes == RE_SND_TIMES-1)
2931   3              {
2932   4                Usart1SndResult(stLocalControl.stBusFreq.byCmd,TRUE);       
2933   4              }
2934   3              Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr)); 
2935   3            }
2936   2            break;
2937   2            
2938   2          case CMD_BED_VOICE_PLAY:
2939   2            stLocalControl.byReSndBedVoiPlaTimes--;
2940   2            if(stLocalControl.byReSndBedVoiPlaTimes!=0)
2941   2            {
2942   3              Delayms(500); //延时1S,再发送一次 
2943   3              if(stLocalControl.byReSndBedVoiPlaTimes == RE_SND_TIMES-1)
2944   3              {
2945   4                Usart1SndResult(stLocalControl.stBusFreq.byCmd,TRUE);       
2946   4              }
2947   3              Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr)); 
2948   3            }
2949   2            break;      
2950   2      
2951   2          case CMD_SYSTEM_SEC_SET:
2952   2            Delayms(500);
2953   2            Usart1SndResult(CMD_NUMBER_SET,TRUE);       //发送操作成功命令
2954   2            break;
2955   2            
2956   2          case CMD_DISP_MODE:
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 49  

2957   2            Delayms(500);
2958   2            Usart1SndResult(stLocalControl.stBusFreq.byCmd,TRUE);
2959   2            break;
2960   2      
2961   2          case CMD_COLOR_CLEAR:
2962   2            stLocalControl.uiDevState |= (FLAG_WAIT_COMM_ACK); 
2963   2            //设置等待应答超时1S
2964   2            stLocalControl.byWaitCommAckDTime = 50; 
2965   2            break;
2966   2            
2967   2          case CMD_GET_BUS:                 //占用总线
2968   2            Bus0SendPin = 0;                //制造总线故障
2969   2            SaveParameter(IAP0_ADDR);
2970   2            Bus0SendPin = 1;                //释放总线        
2971   2            break;      
2972   2          default:
2973   2            break;
2974   2      
2975   2        }
2976   1      }
2977          
2978          /**********************************************************
2979          *函数名称     :Bus1RecDeal  
2980          *函数描述         :单总线1收到一帧数据处理函数,该函数首先
2981                     取出收到的数据,针对每条命令执行对应的控
2982                     制动作
2983          *输入参数       :
2984          *返回值       :
2985          *全局变量     :
2986          *调用模块       :
2987          ***********************************************************
2988          *创建人           :尹运同
2989          *创建日期     :2008-9-22
2990          ***********************************************************
2991          *修改人         :
2992          *修改日期       :
2993          *注释           :
2994          **********************************************************/
2995          void Bus1RecDeal(void)
2996          {
2997   1        //取出单总线1收到的数据帧 
2998   1        EA=0;
2999   1        memcpy(&(stLocalControl.stBusFreq), byBus1RecData, sizeof(STBusFreq));  
3000   1        bBus1RecFinish = 0;
3001   1        EA=1;
3002   1      
3003   1      //调试用
3004   1        #if DEBUG==1
3005   1      //  Usart1SndData(&(stLocalControl.stBusFreq));
3006   1        ///////////////////////////////////////////////////////////////////////////// 
3007   1        #endif  
3008   1      
3009   1        //数据处理  
3010   1        switch(stLocalControl.stBusFreq.byCmd)
3011   1        {
3012   2          case CMD_STOP_VOICE_PLAY:
3013   2            if(stLocalControl.uiDevState & FLAG_INDICATION)
3014   2            {
3015   3              if(0x00 == (stLocalControl.uiDevState & FLAG_STOP_EXIST))
3016   3              { //没有正在发送停止命令
3017   4      
3018   4                stLocalControl.stBusFreq.byCmd = CMD_STOP_INDICATION;           
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 50  

3019   4                if(true == Bus0OutputData(&(stLocalControl.stBusFreq.bySndSecAddr)))
3020   4                {
3021   5                  stLocalControl.uiDevState |= FLAG_STOP_EXIST;
3022   5                }           
3023   4              }
3024   3            }
3025   2            break;
3026   2            
3027   2          default:
3028   2            break;
3029   2        }
3030   1      }
3031          /**********************************************************
3032          *函数名称     :Bus1SendDeal 
3033          *函数描述         :单总线1发送完一帧数据处理函数,该函数首先
3034                     取出收到的数据,针对每条命令执行对应的控
3035                     制动作
3036          *输入参数       :
3037          *返回值       :
3038          *全局变量     :
3039          *调用模块       :
3040          ***********************************************************
3041          *创建人           :尹运同
3042          *创建日期     :2008-9-22
3043          ***********************************************************
3044          *修改人         :
3045          *修改日期       :
3046          *注释           :
3047          **********************************************************/
3048          void Bus1SendFinishDeal(void)
3049          { 
3050   1        //取出数据帧
3051   1        EA=0; 
3052   1        bBus1SendFinish = 0;
3053   1        memcpy(&(stLocalControl.stBusFreq), byBus1SendData, sizeof(STBusFreq)); 
3054   1        EA=1; 
3055   1        
3056   1      //调试用
3057   1        #if DEBUG==1
3058   1      //  Usart1SndData(&(stLocalControl.stBusFreq));
3059   1        #endif  
3060   1        ///////////////////////////////////////////////////////////////////////////// 
3061   1        switch(stLocalControl.stBusFreq.byCmd)
3062   1        {
3063   2          case CMD_VOICE_PLAY_ROOM:
3064   2            Usart1SndResult(CMD_VOICE_PLAY_ROOM,TRUE);        //发送操作成功命令
3065   2            break;
3066   2      
3067   2          case CMD_VOICE_TIMES:
3068   2            Usart1SndResult(CMD_VOICE_TIMES,TRUE);        //发送操作成功命令
3069   2            break;
3070   2      
3071   2            
3072   2          default:
3073   2            break;
3074   2        }
3075   1      
3076   1      }
3077          
3078          /**********************************************************
3079          *函数名称     :TimerOutDeal
3080          *函数描述         :超时处理程序
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 51  

3081          *输入参数       :
3082          *返回值       :
3083          *全局变量     :stLocalControl
3084          *调用模块       :
3085          ***********************************************************
3086          *创建人           :尹运同
3087          *创建日期     :2009-4-7
3088          ***********************************************************
3089          *修改人         :
3090          *修改日期       :
3091          *注释           :
3092          **********************************************************/
3093          void TimerOutDeal(void)
3094          {
3095   1      //  wdt_reset();                      //复位看门狗  
3096   1        //通话通道0超时处理
3097   1        if(stLocalControl.stCH0TimerOut.byTimerOut != 0)
3098   1        { //有超时设置存在
3099   2          stLocalControl.stCH0TimerOut.byTimerOut--;
3100   2          if(stLocalControl.stCH0TimerOut.byTimerOut == 0)
3101   2          { //超时一次到了      
3102   3            if(stLocalControl.stCH0TimerOut.byTimerOutCount == 0x00)
3103   3            { //所有超时次数已到  
3104   4      CH0TimerOutDeal:
3105   4      
3106   4              DTimeState |= bCH0TimerOutDeal;
3107   4      
3108   4            }
3109   3            else
3110   3            { //超时次数没有到        
3111   4              stLocalControl.stCH0TimerOut.byTimerOutCount--;
3112   4              if(stLocalControl.stCH0TimerOut.byTimerOutCount == 0x00) //所有超时次数已到 
3113   4                goto CH0TimerOutDeal;
3114   4              else
3115   4              { //所有超时次数没有到,重新加载超时单位时间
3116   5                stLocalControl.stCH0TimerOut.byTimerOut = stLocalControl.stCH0TimerOut.byTimerOutSet;
3117   5              }
3118   4            }
3119   3          }     
3120   2        }
3121   1        //通话通道1超时处理
3122   1        if(stLocalControl.stCH1TimerOut.byTimerOut != 0)
3123   1        { //有超时设置存在
3124   2          stLocalControl.stCH1TimerOut.byTimerOut--;
3125   2          if(stLocalControl.stCH1TimerOut.byTimerOut == 0)
3126   2          { //超时一次到了
3127   3            if(stLocalControl.stCH1TimerOut.byTimerOutCount == 0x00)
3128   3            { //所有超时次数已到
3129   4      CH1TimerOutDeal:
3130   4              DTimeState |= bCH1TimerOutDeal;
3131   4      
3132   4            }
3133   3            else
3134   3            { //超时次数没有到
3135   4              stLocalControl.stCH1TimerOut.byTimerOutCount--;
3136   4              if(stLocalControl.stCH1TimerOut.byTimerOutCount == 0x00) goto CH1TimerOutDeal;
3137   4              else
3138   4              { //所有超时次数没有到,重新加载超时单位时间
3139   5                stLocalControl.stCH1TimerOut.byTimerOut = stLocalControl.stCH1TimerOut.byTimerOutSet;
3140   5              }
3141   4            }
3142   3          }     
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 52  

3143   2        }
3144   1      
3145   1      
3146   1      
3147   1        if(stLocalControl.byWaitCommAckDTime)
3148   1        {
3149   2          if(--stLocalControl.byWaitCommAckDTime ==0)
3150   2          {
3151   3            if(stLocalControl.uiDevState & FLAG_WAIT_COMM_ACK)
3152   3            {//处于等待状态
3153   4              DTimeState |= bWaitCommAckDTime;
3154   4      
3155   4            }   
3156   3          }
3157   2        }
3158   1        
3159   1        if(stLocalControl.byWaitRS485AckDTime)
3160   1        {
3161   2          if(--stLocalControl.byWaitRS485AckDTime ==0)
3162   2          {
3163   3            DTimeState |= bWaitRS485AckDTime;
3164   3            
3165   3            
3166   3          }
3167   2        }
3168   1      
3169   1      
3170   1      
3171   1        if(stLocalControl.byWaitAckTimeLanding)
3172   1        {
3173   2          if(--stLocalControl.byWaitAckTimeLanding== 0x00)
3174   2          { //上电登记等待应答超时
3175   3            DTimeState |= bWaitAckTimeLand;
3176   3      
3177   3          }
3178   2        }
3179   1      
3180   1        
3181   1        if(stLocalControl.uiDetectPcTime)
3182   1        { //每10分钟检测PC机一次
3183   2          if((--stLocalControl.uiDetectPcTime) == 0x00)
3184   2          {
3185   3            DTimeState |= bDetectPcTime;
3186   3      
3187   3          }
3188   2        }
3189   1      
3190   1      
3191   1        if(stLocalControl.byUsart1SdResultDTime)
3192   1        {
3193   2          if(--stLocalControl.byUsart1SdResultDTime==0)
3194   2          {
3195   3            DTimeState |= bUsart1SdResultDTime;
3196   3          }
3197   2        }
3198   1        return;
3199   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  11935    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 14:56:43 PAGE 53  

   XDATA SIZE       =    135      44
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     28    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
