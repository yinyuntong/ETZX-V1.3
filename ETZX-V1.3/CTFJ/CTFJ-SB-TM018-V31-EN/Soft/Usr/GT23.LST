C51 COMPILER V9.00   GT23                                                                  02/18/2019 14:13:09 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE GT23
OBJECT MODULE PLACED IN GT23.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE GT23.C LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*
   2          ************************Copyright(c)************************
   3          *                                  湖南一特电子股份有限公司
   4          *                               All Rights Reserved
   5          *                                        
   6          *
   7          *-----------------------文件信息---------------------------
   8          *文件名称               :HZ.c
   9          *文件描述               :汉字识别、汉字字库驱动
  10          *创建人                 :尹运同
  11          *创建日期               :2008-9-22
  12          *版本号                 :V1.0
  13          *注释                        :
  14          *----------------------------------------------------------
  15          *修改人                         :
  16          *修改日期                       :
  17          *版本号                 :
  18          *注释                   :
  19          ***********************************************************
  20          */
  21          #define _IN_GT23_
  22          #include "config.h"
  23          
  24          uint8   xdata  GT23_Rec_Data[128];
  25          uint8   xdata  GT23_Rec_Length=0;
  26          uint16  xdata  GT23_16LAddress;
  27          uint16  xdata  GT23_16HAddress;
  28          uint32  xdata  GT23_32Address; 
  29          
  30          void Get_GT23_Data(uint8 highbyte,uint8 lowbyte,uint8 word_size);
  31          void Get_GT23_Data1(uint8 *word,uint8  word_size);
  32          void GT23_TEST(void);
  33          uint8 Rec_GT23_Data(void);
  34          
  35          /*---------------------------------------------------------------------------
  36          函数原型: uint8 Rec_GT23_Data(void)
  37          参数说明: 无
  38          返 回 值: 字库芯片的返回值
  39          函数功能：获取字库芯片的点阵数据
  40          ----------------------------------------------------------------------------*/
  41          /*uint8 Rec_GT23_Data(void)
  42           {
  43              uint8 i,j;
  44                  for(i=0;i<8;i++)
  45                    { 
  46                      j <<= 1;
  47                  SCLK=1;
  48                          _nop_();
  49                 if(MISO)
  50                 j |= 0x01;        
  51                 SCLK=0;
  52                          _nop_();
  53                    }
  54                  return j;
  55           }*/
C51 COMPILER V9.00   GT23                                                                  02/18/2019 14:13:09 PAGE 2   

  56          
  57           uint8 Rec_GT23_Data(void)
  58            {
  59   1              SPI_WriteByte(0xf0);
  60   1              return SPDAT;
  61   1        }
  62           /*-------------------------------------------------------------------------------------------------------
             -----------------------------
  63          函数原型: void Get_GT23_Data(uint8 highbyte,uint8 lowbyte,uint8 word_size)
  64          参数说明: highbyte--汉字国标码的高字节,lowbyte--汉字国标码的低字节,word_size--获取点阵汉字的字体大小 
  65          
  66          1为15*16点阵汉字或者8*16点阵ASCII
  67          2为24*24点阵汉字或者16*24点阵ASCII
  68          3为32*32点阵汉字或者16*32点阵ASCII
  69          
  70          15*16
  71          BaseAdd=0x2C9D0;
  72          if(MSB >=0xA1 && MSB <= 0Xa9 && LSB >=0xA1)
  73          Address =( (MSB - 0xA1) * 94 + (LSB - 0xA1))*32+ BaseAdd;
  74          else if(MSB >=0xB0 && MSB <= 0xF7 && LSB >=0xA1)
  75          Address = ((MSB - 0xB0) * 94 + (LSB - 0xA1)+ 846)*32+ BaseAdd;
  76          
  77          24*24
  78          BaseAdd=0x68190;
  79          if(MSB >=0xA1 && MSB <= 0Xa9 && LSB >=0xA1)
  80          Address =( (MSB - 0xA1) * 94 + (LSB - 0xA1))*72+ BaseAdd;       
  81          else if(MSB >=0xB0 && MSB <= 0xF7 && LSB >=0xA1)
  82          Address = ((MSB - 0xB0) * 94 + (LSB - 0xA1)+ 846)*72+ BaseAdd;
  83          
  84          32*32
  85          BaseAdd=0XEDF00;
  86          if(MSB >=0xA1 && MSB <= 0Xa9 && LSB >=0xA1)
  87          Address =( (MSB - 0xA1) * 94 + (LSB - 0xA1))*128+ BaseAdd;
  88          else if(MSB >=0xB0 && MSB <= 0xF7 && LSB >=0xA1)
  89          Address = ((MSB - 0xB0) * 94 + (LSB - 0xA1)+ 846)*128+ BaseAdd;
  90          
  91          返 回 值: 无
  92          函数功能：通过发送汉字的国标码来获取该汉字的点阵数据
  93          ----------------------------------------------------------------------------------------------------------
             -----------------------------*/
  94          void Get_GT23_Data(uint8 highbyte,uint8 lowbyte,uint8 word_size)
  95          {
  96   1          uint32  xdata address1,address2,address3,address4;
  97   1              SpiNormalMode();
  98   1      
  99   1              if(highbyte==0x00&&lowbyte<0x7f&&lowbyte>=0x20) // 0x21~0x7e  是ASCII字符
 100   1              {
 101   2                      switch(word_size)
 102   2                      {
 103   3      
 104   3                       case 1: //16*8
 105   3                       default:
 106   3                               address1 = (lowbyte-0x20)*16; 
 107   3                               address3 = address1+A8BaseAdd; 
 108   3                               Read_Cont(GT23_Rec_Data,address3,16);
 109   3                               break; 
 110   3                               
 111   3                       case 2: //24x12
 112   3                               address1 = (lowbyte-0x20)*48; 
 113   3                               address3 = address1+A12BaseAdd; 
 114   3                               Read_Cont(GT23_Rec_Data,address3,48);
 115   3                               break;                                  
C51 COMPILER V9.00   GT23                                                                  02/18/2019 14:13:09 PAGE 3   

 116   3                       
 117   3                       case 3:        //32X16
 118   3                               address1 = (lowbyte-0x20)*64; 
 119   3                               address3 = address1+A16BaseAdd; 
 120   3                               Read_Cont(GT23_Rec_Data,address3,64);
 121   3                               break;                                  
 122   3                              
 123   3                      }               
 124   2              }
 125   1              else if(highbyte >=0x81&&highbyte<=0xfe&&lowbyte>=0x40&&lowbyte<=0xfe)    //GBK内码 32X32
 126   1              {
 127   2                      switch(word_size)
 128   2                      {
 129   3                              case 1:
 130   3                              default:
 131   3                                       address1 = (highbyte-0x81)*191; 
 132   3                                       address2 = (lowbyte-0x40)+address1;
 133   3                                       address3 = address2*32;                                 //每个汉字占用32字节
 134   3                                       address4 = address3+C16BaseAdd; 
 135   3                                       Read_Cont(GT23_Rec_Data,address4,32);
 136   3                                       break;
 137   3                              case 3:
 138   3                                       address1 = (highbyte-0x81)*191; 
 139   3                                       address2 = (lowbyte-0x40)+address1;
 140   3                                       address3 = address2*128;                                //每个汉字占用128字节
 141   3                                       address4 = address3+C32BaseAdd; 
 142   3                                       Read_Cont(GT23_Rec_Data,address4,128);
 143   3                                       break;                          
 144   3                      }
 145   2      
 146   2              }
 147   1      
 148   1              SpiLcdMode();
 149   1      }
 150          
 151          
 152          
 153           /*-------------------------------------------------------------------------------------------------------
             -----------------------------
 154          函数原型: void Get_GT23_Data(uint8 highbyte,uint8 lowbyte,uint8 word_size)
 155          参数说明: highbyte--汉字国标码的高字节,lowbyte--汉字国标码的低字节,word_size--获取点阵汉字的字体大小 
 156                            1为15*16点阵汉字或者8*16点阵ASCII
 157                            2为24*24点阵汉字或者16*24点阵ASCII
 158                            3为32*32点阵汉字或者16*32点阵ASCII
 159          
 160          返 回 值: 无
 161          函数功能：通过发送汉字的国标码来获取该汉字的点阵数据
 162          ----------------------------------------------------------------------------------------------------------
             -----------------------------*/
 163          void Get_GT23_Data1(uint8 *word,uint8 word_size)
 164          {
 165   1          uint32  xdata address1,address2,address3,address4;
 166   1              uint8 xdata highbyte,lowbyte;
 167   1              SpiNormalMode();
 168   1      
 169   1              
 170   1              highbyte=*word;
 171   1              word++;
 172   1              lowbyte= *word;
 173   1              if(highbyte<0x7f&&highbyte>=0x20) //   0x21~0x7e  是ASCII字符
 174   1              {
 175   2                      switch(word_size)
C51 COMPILER V9.00   GT23                                                                  02/18/2019 14:13:09 PAGE 4   

 176   2                      {
 177   3      
 178   3                       case 1: //16*8
 179   3                       default:
 180   3                               address1 = (highbyte-0x20)*16; 
 181   3                               address3 = address1+A8BaseAdd; 
 182   3                               Read_Cont(GT23_Rec_Data,address3,16);
 183   3                               break; 
 184   3                               
 185   3                       case 2: //24x12
 186   3                               address1 = (highbyte-0x20)*48; 
 187   3                               address3 = address1+A12BaseAdd; 
 188   3                               Read_Cont(GT23_Rec_Data,address3,48);
 189   3                               break;                                  
 190   3                       
 191   3                       case 3:        //32X16
 192   3                               address1 = (highbyte-0x20)*64; 
 193   3                               address3 = address1+A16BaseAdd; 
 194   3                               Read_Cont(GT23_Rec_Data,address3,64);
 195   3                               break;                                  
 196   3                                      
 197   3                      }               
 198   2              }
 199   1              else if(highbyte >=0x81&&highbyte<=0xfe&&lowbyte>=0x40&&lowbyte<=0xfe)    //GBK内码 32X32
 200   1              {
 201   2                      switch(word_size)
 202   2                      {
 203   3                              case 1:
 204   3                              default:
 205   3                                       address1 = (highbyte-0x81)*191; 
 206   3                                       address2 = (lowbyte-0x40)+address1;
 207   3                                       address3 = address2*32;                                 //每个汉字占用32字节
 208   3                                       address4 = address3+C16BaseAdd; 
 209   3                                       Read_Cont(GT23_Rec_Data,address4,32);
 210   3                                       break;
 211   3                              case 3:
 212   3                                       address1 = (highbyte-0x81)*191; 
 213   3                                       address2 = (lowbyte-0x40)+address1;
 214   3                                       address3 = address2*128;                                //每个汉字占用128字节
 215   3                                       address4 = address3+C32BaseAdd; 
 216   3                                       Read_Cont(GT23_Rec_Data,address4,128);
 217   3                                       break;                          
 218   3                      }
 219   2      
 220   2              }
 221   1      
 222   1          
 223   1              SpiLcdMode();
 224   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1366    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    137      41
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
