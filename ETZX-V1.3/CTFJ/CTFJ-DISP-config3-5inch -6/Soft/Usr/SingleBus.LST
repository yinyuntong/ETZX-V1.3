C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SINGLEBUS
OBJECT MODULE PLACED IN SingleBus.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE SingleBus.c LARGE BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*
   2          ************************Copyright(c)************************
   3          *            湖南一特电子股份有限公司
   4          *             All Rights Reserved
   5          *              
   6          *
   7          *-----------------------文件信息---------------------------
   8          *文件名称         :SingleBus.c
   9          *文件描述       :单总线程序
  10          *创建人         :尹运同
  11          *创建日期       :2008-9-22
  12          *版本号           :V1.0
  13          *注释         :         
  14          *----------------------------------------------------------
  15          *修改人       :
  16          *修改日期       :
  17          *版本号           :
  18          *注释         :
  19          ***********************************************************
  20          */
  21          #define _IN_SINGLE_BUS_
  22          #include "config.h"
  23          
  24          extern unsigned char code ParameterData[];
  25          
  26          //总线0变量定义
  27          uint8 bdata byBus0State0  = 0;              //单总线0状态字1
  28          sbit  bBus0StartRec     = byBus0State0^0;       //单总线0开始接收起始位标志
  29          sbit  bBus0OnRec      = byBus0State0^1;       //单总线0开始接收数据位标志
  30          sbit  bBus0Enable     = byBus0State0^2;       //单总线0允许发送标志
  31          sbit  bBus0ReqSend      = byBus0State0^3;       //单总线0请求发送标志
  32          sbit  bBus0OnSendBit    = byBus0State0^4;       //单总线0正在发送一个数据位标志
  33          sbit  bBus0OnSendFreq   = byBus0State0^5;       //单总线0正在发送一个数据帧标志
  34          sbit  bBus0SendError    = byBus0State0^6;       //单总线0发送错误标志
  35          sbit  bBus0Error      = byBus0State0^7;       //单总线0故障标志
  36          uint8 bdata byBus0State1  = 0;                //单总线0状态字2
  37          sbit  bBus0RecFinish    = byBus0State1^0;       //单总线0接收完成标志
  38          sbit  bBus0RecBit9      = byBus0State1^1;       //单总线0接收字节数据的第9位
  39          sbit  bBus0SendFinish   = byBus0State1^2;       //单总线0发送完成标志
  40          sbit  bBus0Disable      = byBus0State1^3;       //单总线0禁止发送标志
  41          sbit  bBus0SendBit      = byBus0State1^4;       //单总线0正在发送的数据位
  42          sbit  bBus0RecBit     = byBus0State1^5;         //单总线0正在接收的数据位
  43          uint8 data byBus0RecCount = 0;                //高4位是总线0接收定时中断计数，低4位是接收到的位计数
  44          uint8 data byBus0RecBuf;                  //总线0接收缓冲单元
  45          uint8 data byBus0SendBuf;                 //总线0发送缓冲单元 
  46          uint8 data byBus0RecData[BUS0_FREQ_SIZE];         //总线0接收缓冲区
  47          uint8 data byBus0SendData[BUS0_FREQ_SIZE];          //总线0发送缓冲区
  48          uint8 data byBus0SendCount = 0;               //高4位是总线0发送定时中断计数，低4位是发送的位计数
  49          uint8 data byBus0RecSendCount = 0;              //高4位是总线0接收到的字节计数，低4位是总线0发送完的字节计数
  50          uint8 data byBus0SendStopCount;               //总线0停止时间计数
  51          uint8 data byBus0RecTimeOut = 0;              //总线0接收超时计数
  52          uint8 data byBus0DisableCount = 0;              //总线0禁止计数  
  53          uint8 data byBus0TxQ[BUS0_TX_Q_ZISE];           //总线0发送队列             
  54          uint8 data byBus0TxHead = 0;                //单总线0发送队列头指针
  55          uint8 data byBus0TxTail = 0;                //单总线0发送队列尾指针
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 2   

  56          #define IncBus0TxPtr(addr)    {addr=(addr+1)%BUS0_TX_Q_ZISE;}
  57          #define Bus0TxBuffLen()       ((byBus0TxTail+BUS0_TX_Q_ZISE-byBus0TxHead)%BUS0_TX_Q_ZISE) 
  58          
  59          
  60          sbit  Bus0RecPin  = P3^3;                 //单总线0接收引脚定义
  61          sbit  Bus0SendPin = P3^4;                 //单总线0发送引脚定义
  62          
  63          
  64          
  65          void UsartSendSBNextFrame(void);  
  66          /**********************************************************
  67          *函数名称     :SingleBusInit  
  68          *函数描述         :单总线初始化
  69          *输入参数       :
  70          *返回值       :   
  71          *全局变量     :
  72          *调用模块       :
  73          ***********************************************************
  74          *创建人           :尹运同
  75          *创建日期     :2008-9-22
  76          ***********************************************************
  77          *修改人         :
  78          *修改日期       :
  79          *注释           :
  80          **********************************************************/
  81          void SingleBusInit(void)
  82          {
  83   1        //STC12C54/56系列M0=0,M1=0:准双向，M0=0,M1=1:推挽，M0=1,M1=0:高阻，M0=1,M1=1:开漏
  84   1        //总线0发送脚设置为推挽输出，接收脚设置为高阻输入:
  85   1      
  86   1      
  87   1        //STC12C52/5A系列:M0=0,M1=0:准双向，M0=0,M1=1:高阻，M0=1,M1=0:推挽，M0=1,M1=1:开漏
  88   1        //总线0接收脚设置为高阻输入:发送脚设置为推挽输出，
  89   1      
  90   1        
  91   1        //P3^3,高阻输入
  92   1        P3M0 &= (~Bin(0,0,0,0,1,0,0,0));
  93   1        P3M1 |=   Bin(0,0,0,0,1,0,0,0);
  94   1      
  95   1        //,P3^4开漏输出
  96   1        P3M0 |=   Bin(0,0,0,1,0,0,0,0);
  97   1        P3M1 |=   Bin(0,0,0,1,0,0,0,0);
  98   1      
  99   1        //总线电平设置
 100   1        Bus0SendPin = 1;
 101   1        Bus0RecPin = 1;  
 102   1        
 103   1        
 104   1      
 105   1        TMOD &= 0xf0;   //  ;t1作波特率发生器(不变)，
 106   1        TMOD |= 0X01; //t0作方式1（16位)定时器
 107   1      
 108   1        TL0 = TIMER0_L;
 109   1        TH0 = TIMER0_H;
 110   1        TF0 = 0;                        //清除中断标志
 111   1        AUXR &= (~T0x12);                   //传统12分频速度  
 112   1          ET0 = 1;                        //允许定时器0中断 
 113   1        TR0 = 1;                        //启动定时器
 114   1        //其它控制设置
 115   1        byBus0SendStopCount = 240;                //上电总线0禁止发送时间设置   
 116   1        IE1 = 0;                        //清除中断标志
 117   1        IT1 = 1;                        //外部中断1为下降沿触发模式         
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 3   

 118   1        if(Bus0RecPin)
 119   1        { //如果总线正常,开中断 
 120   2          EX1 = 1;
 121   2        }
 122   1        else
 123   1        { //如果总线不正常,置总线故障标志         
 124   2          bBus0Error = 1;
 125   2        }   
 126   1      }
 127          /**********************************************************
 128          *函数名称     :Bus0RecInt 
 129          *函数描述         :外部中断0函数,单总线0接收中断
 130          *输入参数       :
 131          *返回值       :   
 132          *全局变量     :
 133          *调用模块       :
 134          ***********************************************************
 135          *创建人           :尹运同
 136          *创建日期     :2008-9-22
 137          ***********************************************************
 138          *修改人         :
 139          *修改日期       :
 140          *注释           :
 141          **********************************************************/
 142          #pragma disable
 143          void Bus0RecInt(void) interrupt X1_INTNO
 144          {   
 145   1        DisableBus0RecInt();                  //禁止再次下降沿中断
 146   1        bBus0StartRec = 1;                    //启动起始位沿检测
 147   1        bBus0Enable = 0;                    //禁止总线发送              
 148   1        byBus0RecCount = 0;                   //清接收寄存器    
 149   1      }
 150          /**********************************************************
 151          *函数名称     :Timer0Int  
 152          *函数描述         :定时器0溢出中断,定时器每500us中断一次
 153                     程序间隔检查总线0与总线1的接收和发送
 154          *输入参数       :
 155          *返回值       :   
 156          *全局变量     :
 157          *调用模块       :
 158          ***********************************************************
 159          *创建人           :陈卫国
 160          *创建日期     :2008-9-22
 161          ***********************************************************
 162          *修改人         :
 163          *修改日期       :
 164          *注释           :
 165          **********************************************************/
 166          #pragma disable
 167          void Timer0Int(void) interrupt T0_INTNO
 168          { 
 169   1        TR0=0;
 170   1        TH0=TIMER0_H;
 171   1        TL0=TIMER0_L;
 172   1        TR0=1;
 173   1        bBus0RecBit = Bus0RecPin; 
 174   1        /*******************************总线0接收处理***********************************/
 175   1        if(bBus0StartRec)                   //判断总线所处的状态，接收到起始位
 176   1        {     
 177   2          byBus0RecCount += 0x10;               //增加定时中断计数次数
 178   2          if(0x50 == (byBus0RecCount & 0xf0))         //到总线起始位检测时间
 179   2          {     
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 4   

 180   3            bBus0StartRec = 0;
 181   3            byBus0RecCount = 0x00;              //重新开始计数      
 182   3            if(bBus0RecBit)     
 183   3            {   //无效起始位                                    
 184   4              if((!bBus0SendError)&&bBus0OnSendFreq)
 185   4              { //没有发生过总线发送错误,且有一帧数据正在发送,停止帧数据发送,置发送错误标志           
 186   5                byBus0State0 &= (~BUS0_SEND_CON);
 187   5                bBus0SendError = 1;
 188   5                Bus0SendPin = 1;            //释放总线          
 189   5              }       
 190   4              byBus0SendStopCount = 240;          
 191   4              byBus0RecSendCount = 0x00;          //接收出错,重置接收发送计数值
 192   4              EnableBus0RecInt();       
 193   4            }
 194   3            else                
 195   3            { //有效起始位
 196   4              bBus0OnRec = 1;               //开始接收数据位                      
 197   4            }
 198   3          }
 199   2        }
 200   1        else if(bBus0OnRec)
 201   1        {   
 202   2          byBus0RecCount += 0x10;               //增加定时中断计数次数      
 203   2          if(0xa0 == (byBus0RecCount & 0xf0))
 204   2          {
 205   3            byBus0RecCount &= 0x0f;             //清除定时中断计数次数
 206   3            byBus0RecCount += 0x01;
 207   3            if(0x0a == (byBus0RecCount & 0x0f)) 
 208   3            { //收到第10位,结束位           
 209   4              bBus0OnRec = 0;               //停止数据接收          
 210   4              if(bBus0RecBit)
 211   4              { //有效的结束位              
 212   5                if(((bit)(byBus0RecSendCount & 0xf0) == bBus0RecBit9)) 
 213   5                { //数据桢错误
 214   6                  byBus0RecTimeOut = 0;
 215   6                  byBus0RecSendCount &= 0x0f;                     
 216   6                }
 217   5                else 
 218   5                { //数据桢正确          
 219   6                  byBus0RecTimeOut = 230;       //设置下一个字节数据接收超时时间
 220   6                  byBus0RecData[byBus0RecSendCount>>4] = byBus0RecBuf;
 221   6                  byBus0RecSendCount += 0x10;                                         
 222   6                  if((byBus0RecSendCount & 0xf0) >= BUS0_FREQ_SIZE_HI)
 223   6                  {                                           
 224   7                    byBus0RecSendCount &= 0x0f;             
 225   7                    if(!((bBus0OnSendFreq == 1)&&(bBus0ReqSend == 0)))
 226   7                    { //如果接收到的这帧数据是自己发送的不置标志              
 227   8                      bBus0RecFinish = 1;                                                                             
 228   8                    }                                     
 229   7                    byBus0RecTimeOut = 0;
 230   7                    byBus0DisableCount = 10;
 231   7                    bBus0Disable = 1;       //禁止总线使用              
 232   7                  } 
 233   6                }       
 234   5                byBus0SendStopCount = 240;
 235   5                EnableBus0RecInt();           
 236   5              }
 237   4              else              
 238   4              { //无效结束位
 239   5                bBus0Error = 1;                   
 240   5                if((!bBus0SendError) && bBus0OnSendFreq)
 241   5                { //没有发生过总线发送错误,且有一帧数据正在发送,停止帧数据发送,置发送错误标志
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 5   

 242   6                  byBus0State0 &= (~BUS0_SEND_CON);
 243   6                  bBus0SendError = 1;             
 244   6                  Bus0SendPin = 1;          //释放总线
 245   6                }
 246   5                byBus0RecSendCount = 0x00;        //接收出错,重置接收发送计数值         
 247   5              }
 248   4            }
 249   3            else if(0x09 == (byBus0RecCount & 0x0f))
 250   3            { //第9位数据
 251   4              bBus0RecBit9 = bBus0RecBit;         
 252   4            }
 253   3            else                      
 254   3            {   //有效数据位
 255   4              byBus0RecBuf >>= 1;
 256   4              if(bBus0RecBit)
 257   4              { //为高电平
 258   5                byBus0RecBuf |= 0x80;
 259   5              } 
 260   4            }
 261   3          }
 262   2        }
 263   1        /*******************************总线0发送处理***********************************/
 264   1        if((byBus0State0 & BUS0_CAN_SEND) == BUS0_CAN_SEND)
 265   1        { //总线0上有数据发送请求,且总线允许发送    
 266   2          if(bBus0RecBit)
 267   2          { //总线正常,可以发送
 268   3            Bus0SendPin = 0;
 269   3            bBus0SendBit = 0;               //发送起始位数据      
 270   3            byBus0SendCount = 0;
 271   3            byBus0State0 &= (~BUS0_CAN_SEND);
 272   3            byBus0SendBuf = byBus0SendData[byBus0RecSendCount & 0x0f];
 273   3            bBus0OnSendBit = 1;               //取出待发送的数据并置正在发送标志    
 274   3          }
 275   2          else
 276   2          { //总线不正常,停止发送
 277   3            byBus0State0 &= (~BUS0_SEND_CON);
 278   3            bBus0SendError = 1;     
 279   3            byBus0RecSendCount &= 0xf0;
 280   3            Bus0SendPin = 1;
 281   3            byBus0SendStopCount = 240;
 282   3          }
 283   2        }
 284   1        else if(bBus0OnSendBit)
 285   1        {   //有数据位正在发送,首先发送的是起始位     
 286   2          if(bBus0SendBit == bBus0RecBit)       
 287   2          { //发送的数据和接收的数据相同
 288   3            byBus0SendCount += 0x10;
 289   3            if(0xa0 == (byBus0SendCount & 0xf0))
 290   3            { //一位数据发送完毕,首先发送的是起始位
 291   4              byBus0SendCount &= 0x0f;
 292   4              byBus0SendCount += 0x01;        
 293   4              if(0x09 == (byBus0SendCount & 0x0f))
 294   4              { //发送到第9位了
 295   5                bBus0SendBit = !(bit)(byBus0RecSendCount & 0x0f);
 296   5                Bus0SendPin = bBus0SendBit;           
 297   5              }
 298   4              else if(0x0a == (byBus0SendCount & 0x0f))
 299   4              { //发送到结束位了
 300   5                bBus0SendBit = 1;
 301   5                Bus0SendPin = 1;  
 302   5              }
 303   4              else if(0x0b == (byBus0SendCount & 0x0f))
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 6   

 304   4              { //已经发送完结束位了
 305   5                bBus0OnSendBit = 0;           
 306   5                byBus0RecSendCount += 0x01;                 
 307   5                if((byBus0RecSendCount & 0x0f) >= BUS0_FREQ_SIZE)
 308   5                { //发送完一帧数据                        
 309   6                  byBus0RecSendCount &= 0xf0;     //重新进入数据帧的发送阶段
 310   6                  byBus0State0 &= (~BUS0_SEND_CON);
 311   6                  byBus0SendStopCount = 240;
 312   6                  byBus0State1 |= BUS0_SEND_FINISH;               
 313   6                  byBus0DisableCount = 10;            
 314   6                }
 315   5                else
 316   5                {             
 317   6                  byBus0SendStopCount = 10;
 318   6                  bBus0ReqSend = 1;
 319   6                }
 320   5                EnableBus0RecInt();           //再次使能接收中断
 321   5              }
 322   4              else
 323   4              {
 324   5                if(byBus0SendBuf & 0x01)
 325   5                { //发送高电平
 326   6                  bBus0SendBit = 1;
 327   6                  Bus0SendPin = 1;          
 328   6                }
 329   5                else
 330   5                { //发送低电平
 331   6                  bBus0SendBit = 0;
 332   6                  Bus0SendPin = 0;
 333   6                }
 334   5                byBus0SendBuf >>= 1;          //发送数据位移位操作
 335   5              }
 336   4            }
 337   3          }
 338   2          else
 339   2          { //不相同,发送失败               
 340   3            byBus0State0 &= ~BUS0_SEND_CON;
 341   3            byBus0RecSendCount &= 0xf0;
 342   3            bBus0SendError = 1;         
 343   3            Bus0SendPin = 1; 
 344   3            byBus0SendStopCount = 240;
 345   3          }
 346   2        }   
 347   1        /*******************************总线0控制处理***********************************/
 348   1        if(0 == (byBus0State0 & BUS0_ON_REC))
 349   1        { 
 350   2          if(byBus0SendStopCount != 0)
 351   2          {
 352   3            if((--byBus0SendStopCount) == 0)
 353   3            {       
 354   4              bBus0Enable = 1;                
 355   4            }
 356   3          }   
 357   2          if(bBus0Error)
 358   2          {               
 359   3            bBus0Enable = 0;      
 360   3            if(bBus0RecBit)
 361   3            {       
 362   4              bBus0Error = 0;
 363   4              EnableBus0RecInt();
 364   4              byBus0SendStopCount = 240;
 365   4            }
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 7   

 366   3          }
 367   2        }   
 368   1        /*******************************总线0超时处理***********************************/
 369   1        if(byBus0RecTimeOut != 0)
 370   1        {
 371   2          if(--byBus0RecTimeOut == 0)             
 372   2          { //接收超时到
 373   3            byBus0RecSendCount &= 0x0f;     
 374   3          }
 375   2        }
 376   1        if(byBus0DisableCount != 0)
 377   1        {
 378   2          if(--byBus0DisableCount == 0)           
 379   2          { //禁止超时到    
 380   3            bBus0Disable = 0;
 381   3          }
 382   2        } 
 383   1        /***********总线0自动发送管理**********/   
 384   1        if((byBus0State0 & BUS0_ON_WORK) == 0x00)       
 385   1        { //总线0没有工作       
 386   2          if(bBus0SendError)            
 387   2          { //产生了发送错误,自动重发               
 388   3            bBus0SendError = 0;       
 389   3            byBus0State0 |= BUS0_REQ_SEND;    
 390   3          }
 391   2          else                  
 392   2          { //总线0无发送错误   
 393   3            if(!(bBus0SendFinish|bBus0Disable))
 394   3            { //总线0没有禁止使用,且发送结束处理已经完成
 395   4              if(Bus0TxBuffLen() >= BUS0_FREQ_SIZE)
 396   4              {   //有一帧完整的数据在发送队列中                                    
 397   5                byBus0SendData[0] = byBus0TxQ[byBus0TxHead];
 398   5                IncBus0TxPtr(byBus0TxHead);
 399   5                byBus0SendData[1] = byBus0TxQ[byBus0TxHead];
 400   5                IncBus0TxPtr(byBus0TxHead);
 401   5                byBus0SendData[2] = byBus0TxQ[byBus0TxHead];
 402   5                IncBus0TxPtr(byBus0TxHead);
 403   5                byBus0SendData[3] = byBus0TxQ[byBus0TxHead];
 404   5                IncBus0TxPtr(byBus0TxHead);
 405   5                byBus0SendData[4] = byBus0TxQ[byBus0TxHead];
 406   5                IncBus0TxPtr(byBus0TxHead);
 407   5                byBus0SendData[5] = byBus0TxQ[byBus0TxHead];
 408   5                IncBus0TxPtr(byBus0TxHead);
 409   5                byBus0SendData[6] = byBus0TxQ[byBus0TxHead];
 410   5                IncBus0TxPtr(byBus0TxHead); 
 411   5                byBus0State0 |= BUS0_REQ_SEND;            
 412   5              }
 413   4              else
 414   4              { //没有一帧完整的数据在发送队列中了
 415   5                byBus0TxHead = byBus0TxTail = 0;
 416   5              }               
 417   4            }
 418   3          }
 419   2        } 
 420   1      }
 421          
 422          /**********************************************************
 423          *函数名称     :Bus0OutputData 
 424          *函数描述         :单总线0将待发送数据放入缓冲区
 425          *输入参数       :pbyData:待发送的数据指针
 426          *返回值       :TRUE:发送成功,FALSE:队列满,发送失败  
 427          *全局变量     :
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 8   

 428          *调用模块       :
 429          ***********************************************************
 430          *创建人           :尹运同
 431          *创建日期     :2008-9-22
 432          ***********************************************************
 433          *修改人         :
 434          *修改日期       :
 435          *注释           :
 436          **********************************************************/
 437          uint8 Bus0OutputData(uint8* pbyData)
 438          {
 439   1        uint8 byTemp = BUS0_FREQ_SIZE;
 440   1      
 441   1        OS_ENTER_CRITICAL();
 442   1        if(Bus0TxBuffLen() >= (BUS0_TX_Q_ZISE - 1))
 443   1        { //没有空间存储了,失败 
 444   2          OS_EXIT_CRITICAL();
 445   2          return(FALSE);
 446   2        } 
 447   1        while(byTemp--)
 448   1        { //数据入发送队列
 449   2          byBus0TxQ[byBus0TxTail] = *pbyData++;
 450   2          IncBus0TxPtr(byBus0TxTail);
 451   2        }
 452   1        OS_EXIT_CRITICAL(); 
 453   1        return(TRUE); 
 454   1      }
 455          
 456          /**********************************************************
 457          *函数名称     :BcdToHex 
 458          *函数描述         :BCD转换成十六进制
 459          *输入参数       :byData:待转换的BCD码数据
 460          *返回值       :
 461          *全局变量     :
 462          *调用模块       :
 463          ***********************************************************
 464          *创建人           :陈卫国
 465          *创建日期     :2008-9-22
 466          ***********************************************************
 467          *修改人         :
 468          *修改日期       :
 469          *注释           :
 470          **********************************************************/ 
 471          uint8 BcdToHex(uint8 byData)
 472          {
 473   1        uint8 xdata byRet;
 474   1      
 475   1        byRet = byData >> 4;
 476   1        byRet *= 10;
 477   1        byData &= 0x0f;
 478   1        byRet += byData;
 479   1        return(byRet);
 480   1      }
 481          
 482          /**********************************************************
 483          *函数名称     :AddrCompare  
 484          *函数描述         :比较地址(含广播地址)
 485          *输入参数       :pstBusFreq:待比较的数据帧指针
 486          *返回值       :1:发送到本机的数据,0:不是发送到本机的数据  
 487          *全局变量     :
 488          *调用模块       :
 489          ***********************************************************
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 9   

 490          *创建人           :尹运同
 491          *创建日期     :2008-9-22
 492          ***********************************************************
 493          *修改人         :
 494          *修改日期       :
 495          *注释           :
 496          **********************************************************/
 497          bit AddrCompare(pSTBusFreq pstBusFreq)
 498          {
 499   1        if((pstBusFreq->byRecSecAddr != 0xff) && (pstBusFreq->byRecSecAddr != stLocalControl.stEepromCfgData.bySe
             -lfSecAddr))
 500   1        { 
 501   2          return(0);
 502   2        } 
 503   1        if((pstBusFreq->byRecRoomAddr != 0xff) && (pstBusFreq->byRecRoomAddr != stLocalControl.stEepromCfgData.by
             -SelfRoomAddr))
 504   1        { 
 505   2          return(0);
 506   2        }
 507   1        if((pstBusFreq->byRecBedAddr != 0xff) && (pstBusFreq->byRecBedAddr != stLocalControl.stEepromCfgData.bySe
             -lfBedAddr))
 508   1        { 
 509   2          return(0);
 510   2        }
 511   1        return(1); 
 512   1      
 513   1      /*  if((pstBusFreq->byRecSecAddr  == 0xff)&&
 514   1           (pstBusFreq->byRecRoomAddr == 0xff)&&
 515   1           (pstBusFreq->byRecBedAddr  == 0xff))
 516   1          return(1);
 517   1        else if((pstBusFreq->byRecSecAddr == stLocalControl.stEepromCfgData.bySelfSecAddr)&&
 518   1             (pstBusFreq->byRecRoomAddr== stLocalControl.stEepromCfgData.bySelfRoomAddr)&&
 519   1             (pstBusFreq->byRecBedAddr == stLocalControl.stEepromCfgData.bySelfBedAddr))
 520   1             return(1);
 521   1        else return(0);
 522   1      */
 523   1      }
 524          /**********************************************************
 525          *函数名称     :DirAddrCompare 
 526          *函数描述         :绝对比较地址
 527          *输入参数       :pstBusFreq:待比较的数据帧指针
 528          *返回值       :1:发送到本机的数据,0:不是发送到本机的数据  
 529          *全局变量     :
 530          *调用模块       :
 531          ***********************************************************
 532          *创建人           :尹运同
 533          *创建日期     :2008-9-22
 534          ***********************************************************
 535          *修改人         :
 536          *修改日期       :
 537          *注释           :
 538          **********************************************************/
 539          bit DirAddrCompare(pSTBusFreq pstBusFreq)
 540          {
 541   1        if(pstBusFreq->byRecSecAddr != stLocalControl.stEepromCfgData.bySelfSecAddr)
 542   1        { 
 543   2          return(0);
 544   2        } 
 545   1        if(pstBusFreq->byRecRoomAddr != stLocalControl.stEepromCfgData.bySelfRoomAddr)
 546   1        { 
 547   2          return(0);
 548   2        }
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 10  

 549   1        if(pstBusFreq->byRecBedAddr != stLocalControl.stEepromCfgData.bySelfBedAddr)
 550   1        { 
 551   2          return(0);
 552   2        }
 553   1        return(1); 
 554   1      }
 555          /**********************************************************
 556          *函数名称     :MakeCH0TimerOut  
 557          *函数描述         :设置通道0超时参数
 558          *输入参数       :byTimerOut:超时时间,byTimerOutCount:超时次数
 559          *返回值       :
 560          *全局变量     :stLocalControl
 561          *调用模块       :
 562          ***********************************************************
 563          *创建人           :尹运同
 564          *创建日期     :2008-9-22
 565          ***********************************************************
 566          *修改人         :
 567          *修改日期       :
 568          *注释           :
 569          **********************************************************/  
 570          void MakeCH0TimerOut(uint8 byTimerOut, uint8 byTimerOutCount)
 571          {
 572   1        stLocalControl.stCH0TimerOut.byTimerOutSet = byTimerOut;
 573   1        stLocalControl.stCH0TimerOut.byTimerOut = byTimerOut;
 574   1        stLocalControl.stCH0TimerOut.byTimerOutCount = byTimerOutCount; 
 575   1      }
 576          
 577          /**********************************************************
 578          *函数名称     :SysReset 
 579          *函数描述         :系统复位,该函数仅仅将通道0复位,将通道0
 580                     恢复到空闲状态
 581          *输入参数       :
 582          *返回值       :
 583          *全局变量     :
 584          *调用模块       :
 585          ***********************************************************
 586          *创建人           :尹运同
 587          *创建日期     :2008-9-22
 588          ***********************************************************
 589          *修改人         :
 590          *修改日期       :
 591          *注释           :
 592          **********************************************************/
 593          void SysReset(void)
 594          { 
 595   1      
 596   1      }
 597          /**********************************************************
 598          *函数名称     :SaveParameter  
 599          *函数描述         :存储配置参数,存储参数前先擦除整个扇区,
 600                     然后将所有参数重新写入扇区
 601          *输入参数       :
 602          *返回值       :
 603          *全局变量     :stLocalControl
 604          *调用模块       :EnableIAP,IapErase,IapWriteByte,DisableIAP
 605          ***********************************************************
 606          *创建人           :尹运同
 607          *创建日期     :2008-9-22
 608          ***********************************************************
 609          *修改人         :
 610          *修改日期       :
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 11  

 611          *注释           :
 612          **********************************************************/
 613          void SaveParameter(uint16 addr)
 614          {  
 615   1        uint8 i;
 616   1        uint8 *pbyData=&(stLocalControl.stEepromCfgData.byInitFlag);
 617   1        addr  = IAP_ADDR;
 618   1        
 619   1        EnableIAP(IAP_ERASE);
 620   1        IapErase(IAP_ADDR);   
 621   1        EnableIAP(IAP_WRITE); 
 622   1      
 623   1        for(i=0;i<sizeof(STEepromCfgData);i++)
 624   1        {
 625   2          IapWriteByte(addr,*pbyData);
 626   2          pbyData++;
 627   2          addr++;
 628   2        }
 629   1        //再写每二份拷贝
 630   1        pbyData = &(stLocalControl.stEepromCfgData.byInitFlag);
 631   1      
 632   1        for(i=0;i<sizeof(STEepromCfgData);i++)
 633   1        {
 634   2          IapWriteByte(addr,*pbyData);
 635   2          pbyData++;
 636   2          addr++;
 637   2        }
 638   1        DisableIAP();
 639   1      
 640   1      }
 641          
 642          /**********************************************************
 643          *函数名称     :ReadParameter  
 644          *函数描述         :将Flash中的配置数据读入到内存中
 645          *输入参数       :
 646          *返回值       :
 647          *全局变量     :stLocalControl
 648          *调用模块       :EnableIAP,IapReadByte,DisableIAP
 649          ***********************************************************
 650          *创建人           :尹运同
 651          *创建日期     :2008-9-22
 652          ***********************************************************
 653          *修改人         :
 654          *修改日期       :
 655          *注释           :
 656          **********************************************************/
 657          void ReadParameter(uint16 addr)
 658          {
 659   1      
 660   1        uint8 i=0;
 661   1        uint8 *pbyData = &(stLocalControl.stEepromCfgData.byInitFlag);
 662   1        
 663   1        EnableIAP(IAP_READ); 
 664   1        for(i=0;i<sizeof(STEepromCfgData);i++)
 665   1        {
 666   2          *pbyData = IapReadByte(addr);
 667   2          pbyData++;
 668   2          addr++;
 669   2        }
 670   1        DisableIAP();
 671   1      
 672   1      }
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 12  

 673          
 674          
 675          uint8 ParaCrcCheck(uint16 addr)
 676          {
 677   1        uint8 crcResult=0;
 678   1        uint8 crcData =0;
 679   1        uint8 i;
 680   1        uint8 paraData;
 681   1        EnableIAP(IAP_READ);
 682   1        for(i=0;i<sizeof(STEepromCfgData)-1;i++)
 683   1        {
 684   2          paraData = IapReadByte(addr);
 685   2          crcResult +=paraData; /*IapReadByte(addr)*/;
 686   2          addr++;
 687   2        }
 688   1        crcData = IapReadByte(addr);
 689   1        DisableIAP();
 690   1        
 691   1        if(crcData == crcResult) return 1;
 692   1        else return 0;
 693   1      }
 694          
 695          
 696          
 697          uint8 CalcParaCrc(void)
 698          {
 699   1        uint8 crcResult=0;
 700   1        uint8 i;
 701   1        uint8 *addr= &(stLocalControl.stEepromCfgData.byInitFlag);
 702   1        EnableIAP(IAP_READ);
 703   1        for(i=0;i<sizeof(STEepromCfgData)-1;i++)
 704   1        {
 705   2          crcResult += *addr;
 706   2          addr++;
 707   2        }
 708   1        DisableIAP();
 709   1        return crcResult;
 710   1      }
 711          
 712          
 713          
 714          /**********************************************************
 715          *函数名称     :InitParameter  
 716          *函数描述         :初始化Flash中的配置数据
 717          *输入参数       :
 718          *返回值       :
 719          *全局变量     :stLocalControl
 720          *调用模块       :EnableIAP,IapReadByte,DisableIAP
 721          ***********************************************************
 722          *创建人           :尹运同
 723          *创建日期     :2008-9-22
 724          ***********************************************************
 725          *修改人         :
 726          *修改日期       :
 727          *注释           :
 728          **********************************************************/
 729          void InitParameter(void)
 730          {
 731   1        uint8 flagData;
 732   1        if(ParaCrcCheck(IAP_ADDR) ==1)
 733   1        {//第一块校验和正确 
 734   2          EnableIAP(IAP_READ);
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 13  

 735   2          flagData = IapReadByte(IAP_ADDR);
 736   2          DisableIAP();
 737   2          
 738   2          if(flagData == ParameterData[0])
 739   2          {//数据已经初始化完毕了,读取数据参数
 740   3            ReadParameter(IAP_ADDR);
 741   3            SaveParameter(IAP_ADDR);
 742   3          }
 743   2          else  goto InitParaVal; 
 744   2        }
 745   1        else if(ParaCrcCheck(IAP_ADDR+sizeof(STEepromCfgData)) == 1)
 746   1        {
 747   2          EnableIAP(IAP_READ);
 748   2          flagData = IapReadByte(IAP_ADDR+sizeof(STEepromCfgData));
 749   2          DisableIAP();
 750   2          
 751   2          if(flagData == ParameterData[0])
 752   2          {//数据已经初始化完毕了,从第二块读取数据参数
 753   3            ReadParameter(IAP_ADDR+sizeof(STEepromCfgData));
 754   3            SaveParameter(IAP_ADDR);
 755   3          }
 756   2          else  goto InitParaVal;     
 757   2        }
 758   1        else
 759   1        {//两块都不正确，调用默认值
 760   2      InitParaVal:
 761   2          stLocalControl.stEepromCfgData.byInitFlag = ParameterData[0];
 762   2          stLocalControl.stEepromCfgData.bySelfSecAddr = ParameterData[1];
 763   2          stLocalControl.stEepromCfgData.bySelfRoomAddr = ParameterData[2];
 764   2          stLocalControl.stEepromCfgData.bySelfBedAddr = ParameterData[3];
 765   2          stLocalControl.stEepromCfgData.bySerialNum1= ParameterData[4];
 766   2          stLocalControl.stEepromCfgData.bySerialNum2= ParameterData[5];
 767   2          stLocalControl.stEepromCfgData.bySerialNum3= ParameterData[6];
 768   2          stLocalControl.stEepromCfgData.byVersionHi = ParameterData[7];
 769   2          stLocalControl.stEepromCfgData.byVersionLo= ParameterData[8];
 770   2          stLocalControl.stEepromCfgData.stSupplyOxTotalTime.uiHour=0x00;
 771   2          stLocalControl.stEepromCfgData.stSupplyOxTotalTime.byMin=0x00;
 772   2          stLocalControl.stEepromCfgData.byRFSerialNum1=ParameterData[12];
 773   2          stLocalControl.stEepromCfgData.byRFSerialNum2=ParameterData[13];  
 774   2          stLocalControl.stEepromCfgData.byRFSerialNum3=ParameterData[14];
 775   2          stLocalControl.stEepromCfgData.byRFSerialNum4=ParameterData[15];
 776   2          stLocalControl.stEepromCfgData.byRFSerialNum5=ParameterData[16];
 777   2          stLocalControl.stEepromCfgData.byRFSerialNum6=ParameterData[17];
 778   2          stLocalControl.stEepromCfgData.uiRs485Brt  = (ParameterData[18]<<8)+ParameterData[19];
 779   2          stLocalControl.stEepromCfgData.byRs485SecRoom= ParameterData[20];
 780   2          stLocalControl.stEepromCfgData.byCrc =       ParameterData[21];
 781   2          SaveParameter(IAP_ADDR);
 782   2        }
 783   1      
 784   1      }
 785          
 786          
 787          void UsartSendSBNextFrame(void)
 788          {
 789   1        uint8 xdata i=1000;
 790   1        STUartFreq *xdata pstDataFreq = byUsart0SndBuf; 
 791   1      
 792   1        if(stLocalControl.uiSendSBTotalDataLen==0)
 793   1        {
 794   2          memset(byUsart0SndBuf,0x00,UART0_TX_BUF_SIZE);
 795   2          stLocalControl.bySendSBTimes =0;
 796   2          stLocalControl.byUsart1SdDelayTime =0;
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 14  

 797   2          return;
 798   2        }
 799   1      
 800   1        
 801   1        while(stUsartCfg.uiSndLen)
 802   1        {
 803   2          delay_nms(1);
 804   2          if(--i ==0) break;
 805   2        }
 806   1        WDT_CONTR = 0x3e; //喂狗  
 807   1        switch(pstDataFreq->byData[1])  //信息类型
 808   1        {//之前信息类型
 809   2          case DIET_TYPE:
 810   2            if(stLocalControl.uiSendSBTotalDataLen<=UART0_TX_BUF_SIZE-EXT_SIZE-5)
 811   2            {//一帧可以发送完成
 812   3              Read_Cont(&(byUsart0SndBuf[15]),DIET_DATA_START_ADDR+stLocalControl.uiSendedDataLen,stLocalControl.uiS
             -endSBTotalDataLen);
 813   3              pstDataFreq->uiLen = stLocalControl.uiSendSBTotalDataLen+5;
 814   3              pstDataFreq->byData[4] =1;  //结束标志
 815   3              stLocalControl.uiSendSBTotalDataLen =0;
 816   3            }
 817   2            else 
 818   2            {
 819   3              Read_Cont(&(byUsart0SndBuf[15]),DIET_DATA_START_ADDR+stLocalControl.uiSendedDataLen,UART0_TX_BUF_SIZE-
             -EXT_SIZE-5);
 820   3              pstDataFreq->uiLen = UART0_TX_BUF_SIZE-EXT_SIZE;
 821   3              stLocalControl.uiSendSBTotalDataLen -= (UART0_TX_BUF_SIZE-EXT_SIZE-5);  
 822   3              pstDataFreq->byData[4] =0;  //非结束
 823   3            }
 824   2            //pstDataFreq->byData[1] = DIET_TYPE; 
 825   2            break;
 826   2          case PRESCRIPTION_TYPE:
 827   2        
 828   2            if(stLocalControl.uiSendSBTotalDataLen<=UART0_TX_BUF_SIZE-EXT_SIZE-5)
 829   2            {
 830   3              Read_Cont(&(byUsart0SndBuf[15]),PRESCRIPTION_DATA_START_ADDR+stLocalControl.uiSendedDataLen,stLocalCon
             -trol.uiSendSBTotalDataLen);
 831   3              pstDataFreq->uiLen = stLocalControl.uiSendSBTotalDataLen+5;
 832   3              pstDataFreq->byData[4] =1;  //结束标志
 833   3              stLocalControl.uiSendSBTotalDataLen =0;
 834   3            }
 835   2            else 
 836   2            {
 837   3              Read_Cont(&(byUsart0SndBuf[15]),PRESCRIPTION_DATA_START_ADDR+stLocalControl.uiSendedDataLen,UART0_TX_B
             -UF_SIZE-EXT_SIZE-5);
 838   3              pstDataFreq->uiLen = UART0_TX_BUF_SIZE-EXT_SIZE;
 839   3              stLocalControl.uiSendSBTotalDataLen -= (UART0_TX_BUF_SIZE-EXT_SIZE-5);  
 840   3              pstDataFreq->byData[4] =0;  //非结束
 841   3            }
 842   2            //pstDataFreq->byData[1] = PRESCRIPTION_TYPE; 
 843   2            break;
 844   2          case PROMPT_INFO_TYPE:            
 845   2            if(stLocalControl.uiSendSBTotalDataLen<=UART0_TX_BUF_SIZE-EXT_SIZE-5)
 846   2            {
 847   3              Read_Cont(&(byUsart0SndBuf[15]),PROMPT_DATA_START_ADDR+stLocalControl.uiSendedDataLen,stLocalControl.u
             -iSendSBTotalDataLen);
 848   3              pstDataFreq->uiLen = stLocalControl.uiSendSBTotalDataLen+5;
 849   3              pstDataFreq->byData[4] =1;  //结束标志
 850   3              stLocalControl.uiSendSBTotalDataLen =0;
 851   3            }
 852   2            else 
 853   2            {
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 15  

 854   3              Read_Cont(&(byUsart0SndBuf[15]),PROMPT_DATA_START_ADDR+stLocalControl.uiSendedDataLen,UART0_TX_BUF_SIZ
             -E-EXT_SIZE-5);
 855   3              pstDataFreq->uiLen = UART0_TX_BUF_SIZE-EXT_SIZE;
 856   3              stLocalControl.uiSendSBTotalDataLen -= (UART0_TX_BUF_SIZE-EXT_SIZE-5);  
 857   3              pstDataFreq->byData[4] =0;  //非结束
 858   3            }
 859   2            //pstDataFreq->byData[1] = PROMPT_INFO_TYPE;
 860   2            break;
 861   2          default:
 862   2            return;
 863   2        }
 864   1        
 865   1        stLocalControl.bySendSBTimes =3;
 866   1        stLocalControl.byUsart1SdDelayTime =150;
 867   1        stLocalControl.uiSendedDataLen += (pstDataFreq->uiLen-5);
 868   1        
 869   1        pstDataFreq->byStartByte1 = START_BYTE1;
 870   1        //源地址忽略
 871   1        pstDataFreq->bySndSecAddr = 0x00;
 872   1        pstDataFreq->bySndRoomAddr= 0x00;
 873   1        pstDataFreq->bySndBedAddr =0x00;
 874   1        
 875   1        pstDataFreq->byRecSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
 876   1        pstDataFreq->byRecRoomAddr= stLocalControl.stEepromCfgData.bySelfRoomAddr;
 877   1        pstDataFreq->byRecBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
 878   1        
 879   1        pstDataFreq->byCmd= CMD_SB_LCD_DISPLAY_DATA;
 880   1        pstDataFreq->byData[0] = 0x00;
 881   1        
 882   1        pstDataFreq->byData[2] ++;  //帧号加1
 883   1        //pstDataFreq->byData[3] = 0x01;  //屏号，未用
 884   1        
 885   1        pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
 886   1        pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE;
 887   1        
 888   1        
 889   1        stUsartCfg.uiSndLen = pstDataFreq->uiLen+EXT_SIZE;
 890   1        stUsartCfg.uiSndPos = 0;  //从数据帧头部开始发送数据
 891   1        stUsartCfg.pbySndBuf = byUsart0SndBuf;
 892   1        
 893   1        TI=0;
 894   1        SBUF= byUsart0SndBuf[0];  
 895   1      
 896   1      }
 897          /**********************************************************
 898          *函数名称     :Bus0RecDeal  
 899          *函数描述         :单总线0收到一帧数据处理函数,该函数首先
 900                     取出收到的数据,针对每条命令执行对应的控
 901                     制动作
 902          *输入参数       :
 903          *返回值       :
 904          *全局变量     :stLocalControl
 905          *调用模块       :
 906          ***********************************************************
 907          *创建人           :尹运同
 908          *创建日期     :2008-9-22
 909          ***********************************************************
 910          *修改人         :
 911          *修改日期       :
 912          *注释           :
 913          **********************************************************/
 914          void Bus0RecDeal(void)
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 16  

 915          {
 916   1        uint8 xdata i;
 917   1        STUartFreq *xdata pstDataFreq = byUsart0SndBuf; 
 918   1        //取出收到的数据帧      
 919   1        OS_ENTER_CRITICAL();
 920   1        memcpy(&(stLocalControl.stBusDealFreq), byBus0RecData, sizeof(STBusFreq));
 921   1        bBus0RecFinish = 0;
 922   1        OS_EXIT_CRITICAL(); 
 923   1      
 924   1      //以下仅供测试用
 925   1      //  Send_Data((uint8 *)&(stLocalControl.stBusDealFreq),7);
 926   1      
 927   1      /////////////////////////////////////////////////////////////////////////////////////
 928   1      
 929   1      
 930   1      
 931   1      /*  if(bLanding && (stLocalControl.stBusDealFreq.byCmd != CMD_ENTER))
 932   1        { //如果是登记状态,收到的命令不是登记确认命令,不作处理
 933   1          return;
 934   1        }
 935   1      */
 936   1      
 937   1        switch(stLocalControl.stBusDealFreq.byCmd)
 938   1        {
 939   2          case CMD_ENTER:                   //确认登记命令        
 940   2            if(bLanding)
 941   2            {         
 942   3              bLanding =0;
 943   3              MakeCH0TimerOut(0, 0);
 944   3              if( (stLocalControl.stEepromCfgData.bySelfSecAddr != stLocalControl.stBusDealFreq.bySndSecAddr)||
 945   3                (stLocalControl.stEepromCfgData.bySelfRoomAddr != stLocalControl.stBusDealFreq.bySndRoomAddr)||
 946   3                (stLocalControl.stEepromCfgData.bySelfBedAddr != stLocalControl.stBusDealFreq.bySndBedAddr))
 947   3              {
 948   4                stLocalControl.stEepromCfgData.bySelfSecAddr= stLocalControl.stBusDealFreq.bySndSecAddr;
 949   4                stLocalControl.stEepromCfgData.bySelfRoomAddr= stLocalControl.stBusDealFreq.bySndRoomAddr;
 950   4                stLocalControl.stEepromCfgData.bySelfBedAddr= stLocalControl.stBusDealFreq.bySndBedAddr;
 951   4                
 952   4                stLocalControl.stEepromCfgData.byCrc = CalcParaCrc();
 953   4                SaveParameter(IAP_ADDR);
 954   4      
 955   4                page=0;
 956   4                ShowItem(BED_NUMBER);
 957   4                if(stLocalControl.byDisplayFace == BED_INFO_FACE)  Set_VisualPage();
 958   4              }
 959   3      
 960   3              if(stLocalControl.bySlaveState != stLocalControl.stBusDealFreq.byRecSecAddr)
 961   3              {
 962   4                stLocalControl.bySlaveState = stLocalControl.stBusDealFreq.byRecSecAddr;
 963   4                
 964   4                if( stLocalControl.bySlaveState &PATIENT_DISCHARGE)
 965   4                {//bit0==1:表示病人出院 
 966   5                  BL_OFF();//关背光 
 967   5                }
 968   4      
 969   4                if(stLocalControl.bySlaveState &LCD_ON)
 970   4                {//bit1==1:表示显示屏背光打开
 971   5                  if(!(stLocalControl.bySlaveState&PATIENT_DISCHARGE))
 972   5                  {//有病人
 973   6                    BL_ON();
 974   6                  }
 975   5                  else   BL_OFF();
 976   5        
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 17  

 977   5                }
 978   4                else 
 979   4                {
 980   5                  BL_OFF();
 981   5                }         
 982   4              } 
 983   3      
 984   3      
 985   3              page=0;
 986   3              Set_VisualPage();
 987   3              pDispData = NULL;
 988   3              Length =0;
 989   3              ShowItem(MESSAGE2);     
 990   3            }
 991   2            break;
 992   2      
 993   2            
 994   2          case CMD_QUEST:                   //查询命令
 995   2            if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
 996   2            {
 997   3              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
 998   3              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
 999   3              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1000   3              stLocalControl.stBusDealFreq.byCmd = CMD_QUEST_ANSWER; 
1001   3              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1002   3            }
1003   2            break;
1004   2      
1005   2          case CMD_DATE_SEND:                 //收到校时命令
1006   2            //stLocalControl.stTime.bySec = BcdToHex(stLocalControl.stBusDealFreq.bySndSecAddr & 0x7f);
1007   2            stLocalControl.stTime.byMin = BcdToHex(stLocalControl.stBusDealFreq.bySndRoomAddr & 0x7f);
1008   2            stLocalControl.stTime.byHour = BcdToHex(stLocalControl.stBusDealFreq.bySndBedAddr & 0x3f);
1009   2            stLocalControl.stTime.byDay = BcdToHex(stLocalControl.stBusDealFreq.byRecSecAddr & 0x3f);
1010   2            stLocalControl.stTime.byMonth = BcdToHex(stLocalControl.stBusDealFreq.byRecRoomAddr & 0x1f);
1011   2            stLocalControl.stTime.byYear = BcdToHex(stLocalControl.stBusDealFreq.byRecBedAddr);   
1012   2            stLocalControl.byMSecond = 0x00;
1013   2            stLocalControl.stTime.bySec=0x00;
1014   2            break;
1015   2            
1016   2          case CMD_CALL_LISTEN:               //接听命令
1017   2            if((stLocalControl.stBusDealFreq.bySndSecAddr == stLocalControl.stEepromCfgData.bySelfSecAddr) &&
1018   2               (stLocalControl.stBusDealFreq.bySndRoomAddr == stLocalControl.stEepromCfgData.bySelfRoomAddr) &&
1019   2               (stLocalControl.stBusDealFreq.bySndBedAddr == stLocalControl.stEepromCfgData.bySelfBedAddr))
1020   2            { //这条命令是本机发送的
1021   3      
1022   3              ShowTalkFace(stLocalControl.stBusDealFreq.byRecRoomAddr, stLocalControl.stBusDealFreq.byRecBedAddr);
1023   3            }
1024   2      //      else
1025   2      //      { //这条命令是其他分机发送的
1026   2      //        ShowTalkFace(stLocalControl.stBusDealFreq.bySndRoomAddr, stLocalControl.stBusDealFreq.bySndBedAddr,0
             -);
1027   2      //      }
1028   2            break;
1029   2      
1030   2          case CMD_BROADCAST1:
1031   2          case CMD_BROADCAST2:
1032   2          case CMD_BROADCAST3:
1033   2            if((stLocalControl.stBusDealFreq.bySndSecAddr == stLocalControl.stEepromCfgData.bySelfSecAddr) &&
1034   2               (stLocalControl.stBusDealFreq.bySndRoomAddr == stLocalControl.stEepromCfgData.bySelfRoomAddr) &&
1035   2               (stLocalControl.stBusDealFreq.bySndBedAddr == stLocalControl.stEepromCfgData.bySelfBedAddr))
1036   2            { //这条命令是本机发送的
1037   3      
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 18  

1038   3              ShowBroadFace(stLocalControl.stBusDealFreq.bySndRoomAddr, stLocalControl.stBusDealFreq.bySndBedAddr, 1
             -);
1039   3            }
1040   2            else
1041   2            { //这条命令是其他分机发送的
1042   3      
1043   3              ShowBroadFace(stLocalControl.stBusDealFreq.bySndRoomAddr, stLocalControl.stBusDealFreq.bySndBedAddr, 0
             -);
1044   3            }
1045   2            break;
1046   2          case CMD_INFO_INDICATION:             //屏显示呼叫信息
1047   2          
1048   2            if(stLocalControl.stBusDealFreq.bySndRoomAddr == 250 )
1049   2            {
1050   3      
1051   3              ShowAddBedCallFace(stLocalControl.stBusDealFreq.bySndBedAddr);
1052   3            }
1053   2            else 
1054   2            {
1055   3      
1056   3              ShowCallFace(stLocalControl.stBusDealFreq.bySndRoomAddr&0x7f, stLocalControl.stBusDealFreq.bySndBedAdd
             -r, 
1057   3                   stLocalControl.stBusDealFreq.byRecSecAddr & 0x1f); 
1058   3            }
1059   2            break;
1060   2          case CMD_STOP_INDICATION:             //屏关闭呼叫信息显示 
1061   2          case CMD_SYSTERM_RESET:
1062   2            page=0;
1063   2            Set_VisualPage();
1064   2            stLocalControl.byDisplayFace=BED_INFO_FACE; 
1065   2            pDispData = NULL;
1066   2            Length =0;
1067   2            ShowItem(MESSAGE2);     
1068   2            break;
1069   2      
1070   2          case CMD_CLEAR_LCD:                 //清除液晶命令
1071   2            if(AddrCompare(&(stLocalControl.stBusDealFreq)))
1072   2            { 
1073   3              stLocalControl.uiBedFaceDataLen=0;
1074   3              Write_Cont(BED_FACE_DATA_LENGTH_ADDR,&(stLocalControl.uiBedFaceDataLen),2);
*** WARNING C182 IN LINE 1074 OF SINGLEBUS.C: pointer to different objects
1075   3              Write_Cont(BED_FACE_DATA_BAK,&(stLocalControl.uiBedFaceDataLen),2);
*** WARNING C182 IN LINE 1075 OF SINGLEBUS.C: pointer to different objects
1076   3      
1077   3              memset(&(stLocalControl.stSupplyOxStartTime.byYear),0x00,6);
1078   3              memset(&(stLocalControl.stSupplyOxEndTime.byYear),0x00,6);
1079   3              memset(&(stLocalControl.stSupplyOxSubtotalTime.uiHour),0x00,4);
1080   3              memset(&(stLocalControl.stSupplyOxTotalTime.uiHour),0x00,4);
1081   3              
1082   3              stLocalControl.stEepromCfgData.stSupplyOxTotalTime.uiHour=0x00;
1083   3              stLocalControl.stEepromCfgData.stSupplyOxTotalTime.byMin=0x00;  
1084   3              ShowBedFace();
1085   3              
1086   3              stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS;
1087   3              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1088   3              //SaveParameter();
1089   3      
1090   3              stLocalControl.bySlaveState |= PATIENT_DISCHARGE; //病人出院
1091   3              BL_OFF();  //关闭显示屏背光
1092   3      
1093   3            }
1094   2            break;
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 19  

1095   2            
1096   2          case CMD_NUMBER_SET:                //修改本机房号，床号
1097   2            if(stLocalControl.stBusDealFreq.byRecSecAddr==0x01)
1098   2            { 
1099   3              ShowStartNumSet();
1100   3              stLocalControl.uiLcdDisplayTime = 500;  //如果黑时亮10S
1101   3              BL_ON();
1102   3              break;
1103   3            }
1104   2            if(stLocalControl.stBusDealFreq.byRecSecAddr==0x02)
1105   2            { 
1106   3              stLocalControl.byDispNumSetOkTime=50;   //显示一秒
1107   3              if((stLocalControl.stEepromCfgData.bySelfSecAddr != stLocalControl.stBusDealFreq.bySndSecAddr)||
1108   3                 (stLocalControl.stEepromCfgData.bySelfRoomAddr != stLocalControl.stBusDealFreq.bySndRoomAddr)||
1109   3                 (stLocalControl.stEepromCfgData.bySelfBedAddr != stLocalControl.stBusDealFreq.bySndBedAddr))
1110   3              {
1111   4              //保存地址
1112   4                stLocalControl.stEepromCfgData.bySelfSecAddr = stLocalControl.stBusDealFreq.bySndSecAddr;
1113   4                stLocalControl.stEepromCfgData.bySelfRoomAddr = stLocalControl.stBusDealFreq.bySndRoomAddr;
1114   4                stLocalControl.stEepromCfgData.bySelfBedAddr = stLocalControl.stBusDealFreq.bySndBedAddr;
1115   4                
1116   4                stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS;
1117   4                Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1118   4              }       
1119   3              ShowNumSetOk(); 
1120   3              break;
1121   3            }
1122   2            if(stLocalControl.stBusDealFreq.byRecSecAddr==0x00) //编号超时
1123   2            {
1124   3              
1125   3              page=0;
1126   3              Set_VisualPage();
1127   3              stLocalControl.byDisplayFace=BED_INFO_FACE;
1128   3              pDispData = NULL;
1129   3              Length =0;
1130   3              ShowItem(MESSAGE2);         
1131   3              break;
1132   3            }
1133   2            break;
1134   2          case CMD_SYSTEM_SEC_SET:              //系统区号设置
1135   2            stLocalControl.stEepromCfgData.bySelfSecAddr = stLocalControl.stBusDealFreq.byRecSecAddr;
1136   2            stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS;
1137   2            Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));     
1138   2            break;
1139   2            
1140   2          case CMD_POWER_ON:                    //本机重新热启动
1141   2            if(AddrCompare(&(stLocalControl.stBusDealFreq)))
1142   2            { 
1143   3              OS_ENTER_CRITICAL();            
1144   3              //关闭所有中断
1145   3              CCAPM0 = 0;
1146   3              ET0 = 0;
1147   3              TR0 = 0;
1148   3              EX1 = 0;
1149   3              ISP_CONTR = 0x20;       
1150   3            }
1151   2            break;      
1152   2          case CMD_INFUSION_CALL:             //输液呼叫     
1153   2          case CMD_SERVICE_CALL:              //服务呼叫       
1154   2          case CMD_EMERGENCY_CALL:            //紧急呼叫
1155   2          case CMD_HELP_CALL:               //求援呼叫
1156   2             break;
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 20  

1157   2          case CMD_INFUSION_ENTER:                //输液呼叫确认命令
1158   2          case CMD_SERVICE_ENTER:                 //服务呼叫确认命令
1159   2          case CMD_HELP_ENTER:                  //求援呼叫确认命令
1160   2          case CMD_EMERGENCY_ENTER:               //紧急呼叫确认命令
1161   2             ShowCallSuccess();
1162   2             stLocalControl.uiLcdDisplayTime = 250; //如果黑时亮5S
1163   2             //BL_SW=1; 
1164   2             BL_ON();
1165   2             break;
1166   2             
1167   2           case CMD_SERVICE_CLEAR:                 //服务呼叫清除命令 
1168   2           case CMD_CHANNEL_CLOSE:                 //通道关闭
1169   2            #if CONFIG_CC1101==1
                      memcpy(&(byWireLessSndBuff[1]),&(stLocalControl.stEepromCfgData.byRFSerialNum1),6);
                      byWireLessSndBuff[7]= CMD_INFUSION_CLEAR;
              
                      halRfSendPacket(byWireLessSndBuff,8); //发送数据
                      Delayms(1000);
                      halRfSendPacket(byWireLessSndBuff,8); //发送数据
                      Delayms(1000);            
                        halSpiStrobe(CCxxx0_SRX); //允许接收
                        CCAPM1 |= PCA1_ECCF;  //开启中断
                      #endif
1180   2            
1181   2                page=0;
1182   2                Set_VisualPage();       
1183   2              stLocalControl.byDisplayFace=BED_INFO_FACE; 
1184   2              pDispData = NULL;
1185   2              Length =0;
1186   2              ShowItem(MESSAGE2);         
1187   2              break;         
1188   2           case CMD_INFUSION_CLEAR:                //输液呼叫清除命令
1189   2           case CMD_HELP_CLEAR:                  //求援呼叫清除命令
1190   2           case CMD_EMERGENCY_CLEAR:                 //紧急呼叫清除命令   
1191   2              page=0;
1192   2              Set_VisualPage();
1193   2              stLocalControl.byDisplayFace=BED_INFO_FACE;
1194   2              pDispData = NULL;
1195   2              Length =0;
1196   2              ShowItem(MESSAGE2);         
1197   2              break;
1198   2          case CMD_INFUSION_ANSWER:             //处理输液呼叫命令
1199   2          case CMD_SERVICE_ANSWER:              //处理服务呼叫命令
1200   2          case CMD_EMERGENCY_ANSWER:              //处理紧急呼叫命令
1201   2          case CMD_HELP_ANSWER :
1202   2             page=0;
1203   2             Set_VisualPage();
1204   2             stLocalControl.byDisplayFace=BED_INFO_FACE;
1205   2              pDispData = NULL;
1206   2              Length =0;
1207   2              ShowItem(MESSAGE2);        
1208   2              break;  
1209   2      
1210   2          case CMD_CHANNEL_CHANGE:
1211   2            ShowTalkFace(stLocalControl.stBusDealFreq.byRecRoomAddr, stLocalControl.stBusDealFreq.byRecBedAddr);
1212   2            break;  
1213   2          case CMD_BUS_ANSWER:
1214   2             break;
1215   2          case CMD_SUPPLY_OX_START:
1216   2            bEnableOxTimer=1;
1217   2             memcpy(&(stLocalControl.stSupplyOxStartTime.byYear),&(stLocalControl.stTime.byYear),6);
1218   2      
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 21  

1219   2             ShowItem(OX_START);
1220   2      
1221   2             memset(&(stLocalControl.stSupplyOxEndTime.byYear),0x00,sizeof(STTime));
1222   2             ShowItem(OX_END);
1223   2              
1224   2      
1225   2             memset(&(stLocalControl.stSupplyOxSubtotalTime.uiHour),0x00,sizeof(STOXTime)); //本次时间区域清0
1226   2             ShowItem(OX_SUBTOTAL);
1227   2                
1228   2            stLocalControl.uiLcdDisplayTime = 250; //如果黑时亮5S
1229   2            //BL_SW=1;
1230   2            BL_ON();
1231   2            break;
1232   2          case CMD_SUPPLY_OX_END:
1233   2            if(bEnableOxTimer==1)
1234   2            {
1235   3              bEnableOxTimer=0;
1236   3               memcpy(&(stLocalControl.stSupplyOxEndTime.byYear),&(stLocalControl.stTime.byYear),6);
1237   3      
1238   3              //计算单次时间
1239   3              stLocalControl.stSupplyOxSubtotalTime=timeInterval(stLocalControl.stSupplyOxEndTime,stLocalControl.stS
             -upplyOxStartTime);
1240   3              //如果时间大于3秒,将算1分钟
1241   3              if(stLocalControl.stSupplyOxSubtotalTime.bySec>3)
1242   3              {
1243   4                stLocalControl.stSupplyOxSubtotalTime.byMin++;
1244   4                if(stLocalControl.stSupplyOxSubtotalTime.byMin==60)
1245   4                {
1246   5                  if(stLocalControl.stSupplyOxSubtotalTime.uiHour<=9998) stLocalControl.stSupplyOxSubtotalTime.uiHour+
             -+;
1247   5                }
1248   4              }
1249   3              //发送单次时间数据给主控模块
1250   3              stLocalControl.stBusDealFreq.bySndSecAddr =  stLocalControl.stEepromCfgData.bySelfSecAddr;
1251   3              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1252   3              stLocalControl.stBusDealFreq.bySndBedAddr =  stLocalControl.stEepromCfgData.bySelfBedAddr;
1253   3              stLocalControl.stBusDealFreq.byCmd = CMD_SUPPLY_OX_END;
1254   3              stLocalControl.stBusDealFreq.byRecSecAddr =  (stLocalControl.stSupplyOxSubtotalTime.uiHour>>8);
1255   3              stLocalControl.stBusDealFreq.byRecRoomAddr = (uint8)stLocalControl.stSupplyOxSubtotalTime.uiHour;
1256   3              stLocalControl.stBusDealFreq.byRecBedAddr =  stLocalControl.stSupplyOxSubtotalTime.byMin;
1257   3              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1258   3              
1259   3              //计算累次时间
1260   3              stLocalControl.stSupplyOxTotalTime.byMin += stLocalControl.stSupplyOxSubtotalTime.byMin;
1261   3              stLocalControl.stSupplyOxTotalTime.uiHour+= stLocalControl.stSupplyOxSubtotalTime.uiHour;
1262   3              if(stLocalControl.stSupplyOxTotalTime.byMin>=60)
1263   3              {
1264   4                stLocalControl.stSupplyOxTotalTime.byMin = stLocalControl.stSupplyOxTotalTime.byMin-60;
1265   4                stLocalControl.stSupplyOxTotalTime.uiHour++;
1266   4              } 
1267   3      
1268   3              
1269   3              memset(&(stLocalControl.stSupplyOxStartTime.byYear),0x00,sizeof(STTime)); //开始时间清0
1270   3              ShowItem(OX_START);
1271   3              ShowItem(OX_END); //显示供氧结束时间
1272   3              ShowItem(OX_SUBTOTAL);  //显示本次供氧时间
1273   3              ShowItem(OX_TOTAL);    //显示累次时间
1274   3              
1275   3              stLocalControl.stEepromCfgData.stSupplyOxTotalTime.uiHour=stLocalControl.stSupplyOxTotalTime.uiHour;
1276   3              stLocalControl.stEepromCfgData.stSupplyOxTotalTime.byMin=stLocalControl.stSupplyOxTotalTime.byMin;
1277   3      
1278   3              stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS;
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 22  

1279   3              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));       
1280   3              //SaveParameter();
1281   3      
1282   3              stLocalControl.uiLcdDisplayTime = 250;  //如果黑时亮5S
1283   3               BL_ON();
1284   3            }
1285   2            break;  
1286   2      
1287   2          case CMD_RF_NUMSET_START:
1288   2            ShowStartRfNumSet();
1289   2             stLocalControl.uiLcdDisplayTime = 250; //如果黑时亮5S
1290   2             //BL_SW=1; 
1291   2             BL_ON();
1292   2            break;
1293   2          case CMD_RF_NUMSET_OK:
1294   2             stLocalControl.uiLcdDisplayTime = 250; //如果黑时亮5S
1295   2             //BL_SW=1; 
1296   2             BL_ON();
1297   2            ShowRfNumSetOk(); 
1298   2            stLocalControl.byDispNumSetOkTime=50;   //显示一秒
1299   2            //保存输液报警器序列号
1300   2            if( (stLocalControl.stEepromCfgData.byRFSerialNum1!= stLocalControl.stBusDealFreq.bySndSecAddr)||
1301   2              (stLocalControl.stEepromCfgData.byRFSerialNum2!= stLocalControl.stBusDealFreq.bySndRoomAddr)||
1302   2              (stLocalControl.stEepromCfgData.byRFSerialNum3!= stLocalControl.stBusDealFreq.bySndBedAddr)||
1303   2              (stLocalControl.stEepromCfgData.byRFSerialNum4!= stLocalControl.stBusDealFreq.byRecSecAddr)||
1304   2              (stLocalControl.stEepromCfgData.byRFSerialNum5!= stLocalControl.stBusDealFreq.byRecRoomAddr)||
1305   2              (stLocalControl.stEepromCfgData.byRFSerialNum6!= stLocalControl.stBusDealFreq.byRecBedAddr))
1306   2            {
1307   3              memcpy(&(stLocalControl.stEepromCfgData.byRFSerialNum1),&(stLocalControl.stBusDealFreq.bySndSecAddr),3
             -);
1308   3              memcpy(&(stLocalControl.stEepromCfgData.byRFSerialNum4),&(stLocalControl.stBusDealFreq.byRecSecAddr),3
             -);
1309   3      
1310   3              stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS;
1311   3              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));     
1312   3            //SaveParameter();
1313   3            }   
1314   2            break;
1315   2          case CMD_RF_NUMSET_END:
1316   2            page=0;
1317   2            Set_VisualPage();
1318   2            stLocalControl.byDisplayFace=BED_INFO_FACE;
1319   2              pDispData = NULL;
1320   2              Length =0;
1321   2              ShowItem(MESSAGE2);       
1322   2            break;  
1323   2            case CMD_TELL_RF_NUM:
1324   2            if( (stLocalControl.stEepromCfgData.byRFSerialNum1!= stLocalControl.stBusDealFreq.bySndSecAddr)||
1325   2              (stLocalControl.stEepromCfgData.byRFSerialNum2!= stLocalControl.stBusDealFreq.bySndRoomAddr)||
1326   2              (stLocalControl.stEepromCfgData.byRFSerialNum3!= stLocalControl.stBusDealFreq.bySndBedAddr)||
1327   2              (stLocalControl.stEepromCfgData.byRFSerialNum4!= stLocalControl.stBusDealFreq.byRecSecAddr)||
1328   2              (stLocalControl.stEepromCfgData.byRFSerialNum5!= stLocalControl.stBusDealFreq.byRecRoomAddr)||
1329   2              (stLocalControl.stEepromCfgData.byRFSerialNum6!= stLocalControl.stBusDealFreq.byRecBedAddr))
1330   2            {
1331   3              memcpy(&(stLocalControl.stEepromCfgData.byRFSerialNum1),&(stLocalControl.stBusDealFreq.bySndSecAddr),3
             -);
1332   3              memcpy(&(stLocalControl.stEepromCfgData.byRFSerialNum4),&(stLocalControl.stBusDealFreq.byRecSecAddr),3
             -);
1333   3      
1334   3              stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS;
1335   3              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));     
1336   3              //SaveParameter();  
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 23  

1337   3            }   
1338   2            break;
1339   2            
1340   2          case CMD_OPEN_LCD:
1341   2            if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
1342   2            {//绝对地址
1343   3              stLocalControl.bySlaveState |= LCD_ON;
1344   3              BL_ON();
1345   3            }
1346   2            else if(AddrCompare(&(stLocalControl.stBusDealFreq)))
1347   2            {//广播打开
1348   3              stLocalControl.bySlaveState |= LCD_ON;
1349   3              if(!(stLocalControl.bySlaveState &PATIENT_DISCHARGE))
1350   3              {//此床位有病人
1351   4                BL_ON();
1352   4              }
1353   3            }
1354   2            break;
1355   2            
1356   2          case CMD_CLOSE_LCD:
1357   2            stLocalControl.bySlaveState &= ~LCD_ON;
1358   2            BL_OFF();
1359   2            break;  
1360   2            
1361   2          case CMD_NURSE_IN:
1362   2            if( !(stLocalControl.bySlaveState &LCD_ON) || (stLocalControl.bySlaveState&PATIENT_DISCHARGE)) //黑屏的
             -情况下  
1363   2            {
1364   3              BL_ON();
1365   3            }
1366   2            break;
1367   2            
1368   2          case CMD_NURSE_OUT:
1369   2            if( !(stLocalControl.bySlaveState &LCD_ON) || (stLocalControl.bySlaveState&PATIENT_DISCHARGE)) //黑屏的
             -情况下  
1370   2            {
1371   3              BL_OFF();
1372   3            }
1373   2            break;
1374   2            
1375   2          case CMD_PC_OPEN:
1376   2            stLocalControl.stBusDealFreq.bySndSecAddr =  stLocalControl.stEepromCfgData.bySelfSecAddr;
1377   2            stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1378   2            stLocalControl.stBusDealFreq.bySndBedAddr =  stLocalControl.stEepromCfgData.bySelfBedAddr;      
1379   2            stLocalControl.stBusDealFreq.byCmd = CMD_SUPPLY_OX_TOTAL;     
1380   2            stLocalControl.stBusDealFreq.byRecSecAddr = (stLocalControl.stSupplyOxTotalTime.uiHour>>8);
1381   2            stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stSupplyOxTotalTime.uiHour;
1382   2            stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stSupplyOxTotalTime.byMin;
1383   2            Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1384   2            break;
1385   2            
1386   2          case CMD_OPEN_485BUS_IN:      
1387   2            stLocalControl.bySlaveState &= ~PATIENT_DISCHARGE;  //病人入院
1388   2            BL_ON();
1389   2            stLocalControl.uiLcdDisplayTime= 500; //亮10秒钟
1390   2            break;
1391   2      
1392   2      
1393   2          case CMD_BUS1_TEST:
1394   2            stLocalControl.stBusDealFreq.byCmd = CMD_BUS1_TEST_ANSWER;
1395   2            Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1396   2            if( (stLocalControl.stEepromCfgData.bySelfSecAddr != stLocalControl.stBusDealFreq.byRecSecAddr)||
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 24  

1397   2              (stLocalControl.stEepromCfgData.bySelfRoomAddr != stLocalControl.stBusDealFreq.byRecRoomAddr)||
1398   2              (stLocalControl.stEepromCfgData.bySelfBedAddr != stLocalControl.stBusDealFreq.byRecBedAddr))
1399   2            {
1400   3              stLocalControl.stEepromCfgData.bySelfSecAddr= stLocalControl.stBusDealFreq.byRecSecAddr;
1401   3              stLocalControl.stEepromCfgData.bySelfRoomAddr= stLocalControl.stBusDealFreq.byRecRoomAddr;
1402   3              stLocalControl.stEepromCfgData.bySelfBedAddr= stLocalControl.stBusDealFreq.byRecBedAddr;
1403   3              
1404   3              stLocalControl.stEepromCfgData.byCrc = CalcParaCrc();
1405   3              SaveParameter(IAP_ADDR);
1406   3      
1407   3              ShowItem(BED_NUMBER);
1408   3              if(stLocalControl.byDisplayFace == BED_INFO_FACE) Set_VisualPage();       
1409   3            }
1410   2      
1411   2            break;
1412   2      
1413   2          case CMD_SEND_PIN_BUG:
1414   2            if(stLocalControl.stBusDealFreq.byRecSecAddr ==0x00)
1415   2            {
1416   3              DisSendPinBugFace();
1417   3            }
1418   2            else if(stLocalControl.stBusDealFreq.byRecSecAddr ==0x01)
1419   2            {
1420   3              pDispData = NULL;
1421   3              Length =0;
1422   3              ShowItem(MESSAGE2); 
1423   3      
1424   3            }
1425   2            break;
1426   2          case CMD_SB_DATA_ANSWER:
1427   2      
1428   2            if(stLocalControl.stBusDealFreq.byRecSecAddr == 0x01)
1429   2            {//收到回应答,发送余下信息
1430   3              UsartSendSBNextFrame();
1431   3            }
1432   2            else
1433   2            {//重发
1434   3              if(--stLocalControl.bySendSBTimes !=0x00)
1435   3              {
1436   4                i=1000;
1437   4                while(stUsartCfg.uiSndLen)
1438   4                {
1439   5                  delay_nms(1);
1440   5                  if(--i ==0) break;
1441   5                }
1442   4                WDT_CONTR = 0x3e; //喂狗
1443   4                stLocalControl.byUsart1SdDelayTime =150;
1444   4                stUsartCfg.uiSndLen = pstDataFreq->uiLen+EXT_SIZE;
1445   4                stUsartCfg.uiSndPos = 0;  //从数据帧头部开始发送数据
1446   4                stUsartCfg.pbySndBuf = byUsart0SndBuf;
1447   4                
1448   4                TI=0;
1449   4                SBUF= byUsart0SndBuf[0];
1450   4              }
1451   3              else UsartSendSBNextFrame();
1452   3            }
1453   2            break;
1454   2          case CMD_RS485_BRT_SET:
1455   2            switch(stLocalControl.stBusDealFreq.byRecSecAddr)
1456   2            {
1457   3              case 1:
1458   3                stLocalControl.stEepromCfgData.uiRs485Brt =1200;
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 25  

1459   3                break;
1460   3              case 2:
1461   3                stLocalControl.stEepromCfgData.uiRs485Brt = 2400;
1462   3                break;
1463   3              case 3:
1464   3                stLocalControl.stEepromCfgData.uiRs485Brt = 4800;
1465   3                break;
1466   3              case 4:
1467   3                stLocalControl.stEepromCfgData.uiRs485Brt = 9600;
1468   3                break;
1469   3              case 5:
1470   3                stLocalControl.stEepromCfgData.uiRs485Brt = 14400;
1471   3                break;
1472   3              case 6:
1473   3                stLocalControl.stEepromCfgData.uiRs485Brt = 19200;
1474   3                break;
1475   3              case 7:
1476   3                stLocalControl.stEepromCfgData.uiRs485Brt = 28800;
1477   3                break;
1478   3              case 8:
1479   3                stLocalControl.stEepromCfgData.uiRs485Brt = 38400;
1480   3                break;
1481   3              case 9:
1482   3                stLocalControl.stEepromCfgData.uiRs485Brt = 57600;
1483   3                break;
1484   3              default:
1485   3                return;   //其它无效，退出
1486   3                
1487   3            }
1488   2            UsartInit();
1489   2            stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS;
1490   2            Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1491   2            break;
1492   2      
1493   2          case CMD_RS485_INFO_SEC_ROOM:
1494   2            if(stLocalControl.stBusDealFreq.byRecSecAddr==0 ||stLocalControl.stBusDealFreq.byRecSecAddr==1)
1495   2            {
1496   3              stLocalControl.stEepromCfgData.byRs485SecRoom =  stLocalControl.stBusDealFreq.byRecSecAddr;
1497   3              stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS;
1498   3              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));       
1499   3            }
1500   2            break;
1501   2          case CMD_DISP_MODE:
1502   2            break;
1503   2      
1504   2          case CMD_COLOR_CLEAR:
1505   2      
1506   2            break;
1507   2            
1508   2          default:
1509   2            break;
1510   2      
1511   2        } 
1512   1      }
1513          /**********************************************************
1514          *函数名称     :Bus0SendDeal 
1515          *函数描述         :单总线0发送完一帧数据处理函数,该函数首先
1516                     取出收到的数据,针对每条命令执行对应的控
1517                     制动作
1518          *输入参数       :
1519          *返回值       :
1520          *全局变量     :stLocalControl
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 26  

1521          *调用模块       :
1522          ***********************************************************
1523          *创建人           :尹运同
1524          *创建日期     :2008-9-22
1525          ***********************************************************
1526          *修改人         :
1527          *修改日期       :
1528          *注释           :
1529          **********************************************************/
1530          void Bus0SendDeal(void)
1531          { 
1532   1        STUartFreq *xdata pstDataFreq = byUsart0SndBuf; 
1533   1        uint8 xdata i;
1534   1        //取出发送完成的数据帧
1535   1        OS_ENTER_CRITICAL();
1536   1        memcpy(&(stLocalControl.stBusDealFreq), byBus0SendData, sizeof(STBusFreq));   
1537   1        bBus0SendFinish = 0;
1538   1        OS_EXIT_CRITICAL(); 
1539   1      
1540   1        //以下仅供测试用
1541   1      //  Send_Data((uint8 *)&(stLocalControl.stBusDealFreq),7);
1542   1        /////////////////////////////////////////////////////////////////////////////////////
1543   1      
1544   1        switch(stLocalControl.stBusDealFreq.byCmd)
1545   1        {
1546   2          case CMD_LANDING:                   //登记命令
1547   2            if(bLanding)
1548   2            { //本机确实处在登记状态,设置等待确认超时
1549   3              MakeCH0TimerOut(150, 0);        
1550   3            } 
1551   2            break;
1552   2      
1553   2          case CMD_GET_BUS:                 //占用总线
1554   2            Bus0SendPin = 0;                //制造总线故障
1555   2            stLocalControl.stEepromCfgData.byCrc = CalcParaCrc();
1556   2            SaveParameter(IAP_ADDR);
1557   2            Bus0SendPin = 1;                //释放总线        
1558   2            break;
1559   2      
1560   2          case CMD_OPEN_485BUS_IN:
1561   2            i=1000;
1562   2            while(stUsartCfg.uiSndLen)
1563   2            {
1564   3              delay_nms(1);
1565   3              if(--i ==0) break;
1566   3            }     
1567   2            WDT_CONTR = 0x3e; //喂狗
1568   2            //一类信息的第一帧
1569   2            
1570   2            switch(stLocalControl.stBusDealFreq.byRecSecAddr)
1571   2            {
1572   3              case DIET_TYPE:
1573   3                 Read_Cont((uint8 *)(&(stLocalControl.uiSendSBTotalDataLen)),DIET_LENGTH_ADDR,2);
1574   3                if(stLocalControl.uiSendSBTotalDataLen <=UART0_TX_BUF_SIZE-EXT_SIZE-5)
1575   3                {//一帧可以发送完成
1576   4                  Read_Cont(&(byUsart0SndBuf[15]),DIET_DATA_START_ADDR,stLocalControl.uiSendSBTotalDataLen);
1577   4                  pstDataFreq->uiLen = stLocalControl.uiSendSBTotalDataLen+5;
1578   4                  pstDataFreq->byData[4] =1;  //结束标志
1579   4                  stLocalControl.uiSendSBTotalDataLen =0;
1580   4                }
1581   3                else 
1582   3                {
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 27  

1583   4                  Read_Cont(&(byUsart0SndBuf[15]),DIET_DATA_START_ADDR,UART0_TX_BUF_SIZE-EXT_SIZE-5);
1584   4                  pstDataFreq->uiLen = UART0_TX_BUF_SIZE-EXT_SIZE;
1585   4                  stLocalControl.uiSendSBTotalDataLen -= (UART0_TX_BUF_SIZE-EXT_SIZE-5);  
1586   4                  pstDataFreq->byData[4] =0;  //非结束
1587   4                }
1588   3                pstDataFreq->byData[1] = DIET_TYPE;
1589   3                break;
1590   3              case PRESCRIPTION_TYPE:
1591   3                Read_Cont((uint8 *)(&(stLocalControl.uiSendSBTotalDataLen)),PRESCRIPTION_LENGTH_ADDR,2);
1592   3                if(stLocalControl.uiSendSBTotalDataLen<=UART0_TX_BUF_SIZE-EXT_SIZE-5)
1593   3                {
1594   4                  Read_Cont(&(byUsart0SndBuf[15]),PRESCRIPTION_DATA_START_ADDR,stLocalControl.uiSendSBTotalDataLen);
1595   4                  pstDataFreq->uiLen = stLocalControl.uiSendSBTotalDataLen+5;
1596   4                  pstDataFreq->byData[4] =1;  //结束标志
1597   4                  stLocalControl.uiSendSBTotalDataLen =0;
1598   4                }
1599   3                else 
1600   3                {
1601   4                  Read_Cont(&(byUsart0SndBuf[15]),PRESCRIPTION_DATA_START_ADDR,UART0_TX_BUF_SIZE-EXT_SIZE-5);
1602   4                  pstDataFreq->uiLen = UART0_TX_BUF_SIZE-EXT_SIZE;
1603   4                  stLocalControl.uiSendSBTotalDataLen -= (UART0_TX_BUF_SIZE-EXT_SIZE-5);  
1604   4                  pstDataFreq->byData[4] =0;  //非结束
1605   4                }
1606   3                pstDataFreq->byData[1] = PRESCRIPTION_TYPE;
1607   3                break;
1608   3              case PROMPT_INFO_TYPE:
1609   3                Read_Cont((uint8 *)(&(stLocalControl.uiSendSBTotalDataLen)),PROMPT_LENGTH_ADDR,2);
1610   3                if(stLocalControl.uiSendSBTotalDataLen<=UART0_TX_BUF_SIZE-EXT_SIZE-5)
1611   3                {
1612   4                  Read_Cont(&(byUsart0SndBuf[15]),PROMPT_DATA_START_ADDR,stLocalControl.uiSendSBTotalDataLen);
1613   4                  pstDataFreq->uiLen = stLocalControl.uiSendSBTotalDataLen+5;
1614   4                  pstDataFreq->byData[4] =1;  //结束标志
1615   4                  stLocalControl.uiSendSBTotalDataLen =0;
1616   4                }
1617   3                else 
1618   3                {
1619   4                  Read_Cont(&(byUsart0SndBuf[15]),PROMPT_DATA_START_ADDR,UART0_TX_BUF_SIZE-EXT_SIZE-5);
1620   4                  pstDataFreq->uiLen = UART0_TX_BUF_SIZE-EXT_SIZE;
1621   4                  stLocalControl.uiSendSBTotalDataLen -= (UART0_TX_BUF_SIZE-EXT_SIZE-5);  
1622   4                  pstDataFreq->byData[4] =0;  //非结束
1623   4                }
1624   3                pstDataFreq->byData[1] = PROMPT_INFO_TYPE;
1625   3                break;
1626   3              default:
1627   3                return; //返回
1628   3            }
1629   2      
1630   2      
1631   2            stLocalControl.bySendSBTimes=3; //重发次数
1632   2            stLocalControl.byUsart1SdDelayTime =150;
1633   2            stLocalControl.uiSendedDataLen = pstDataFreq->uiLen-5;
1634   2            
1635   2            pstDataFreq->byStartByte1 = START_BYTE1;
1636   2            //源地址忽略
1637   2            pstDataFreq->bySndSecAddr = 0x00;
1638   2            pstDataFreq->bySndRoomAddr= 0x00;
1639   2            pstDataFreq->bySndBedAddr =0x00;
1640   2            
1641   2            pstDataFreq->byRecSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1642   2            pstDataFreq->byRecRoomAddr= stLocalControl.stEepromCfgData.bySelfRoomAddr;
1643   2            pstDataFreq->byRecBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1644   2      
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 28  

1645   2            pstDataFreq->byCmd= CMD_SB_LCD_DISPLAY_DATA;
1646   2            pstDataFreq->byData[0] = 0x00;  //数据关型，都不为点阵码数据
1647   2            pstDataFreq->byData[2] = 0x01;  //起始帧
1648   2            pstDataFreq->byData[3] = 0x01;  //屏号，未用
1649   2      
1650   2            pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
1651   2            pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE;
1652   2            
1653   2            
1654   2            stUsartCfg.uiSndLen = pstDataFreq->uiLen+EXT_SIZE;
1655   2            stUsartCfg.uiSndPos = 0;  //从数据帧头部开始发送数据
1656   2            stUsartCfg.pbySndBuf = byUsart0SndBuf;
1657   2            
1658   2            TI=0;
1659   2            SBUF= byUsart0SndBuf[0];      
1660   2            break;
1661   2            
1662   2          default:
1663   2            break;
1664   2      
1665   2        } 
1666   1      }
1667          /**********************************************************
1668          *函数名称     :Bus0Manage 
1669          *函数描述         :单总线0管理线程
1670          *输入参数       :
1671          *返回值       :
1672          *全局变量     :byMainCmdQ
1673          *调用模块       :OSQPost
1674          ***********************************************************
1675          *创建人           :尹运同
1676          *创建日期     :2008-9-22
1677          ***********************************************************
1678          *修改人         :
1679          *修改日期       :
1680          *注释           :
1681          **********************************************************/
1682          void Bus0Manage(void)
1683          {   
1684   1        while(TRUE)
1685   1        {   
1686   2          if(bBus0RecFinish)                  //总线0收到数据
1687   2          {   
1688   3            OSQPost(byMainCmdQ, BUS0_REC);        
1689   3          }
1690   2          if(bBus0SendFinish)                 //总线0发送完数据帧
1691   2          {
1692   3            OSQPost(byMainCmdQ, BUS0_SND);      
1693   3          } 
1694   2          OSWait(K_TMO, 1); 
1695   2          WDT_CONTR = 0x3e; //喂狗
1696   2        }
1697   1      }
1698          /**********************************************************
1699          *函数名称     :TimerOutDeal 
1700          *函数描述         :超时处理函数
1701          *输入参数       :
1702          *返回值       :
1703          *全局变量     :stLocalControl
1704          *调用模块       :Bus0OutputData,Bus1OutputData,VoiceChannelCtx,
1705                     LedControl,SetHandLedState
1706          ***********************************************************
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 29  

1707          *创建人           :尹运同
1708          *创建日期     :2008-9-22
1709          ***********************************************************
1710          *修改人         :
1711          *修改日期       :
1712          *注释           :
1713          **********************************************************/
1714          void TimerOutDeal(void)
1715          { 
1716   1        uint8 xdata i;
1717   1        STUartFreq *xdata pstDataFreq = byUsart0SndBuf;
1718   1        if(stLocalControl.stCH0TimerOut.byTimerOut != 0)
1719   1        { //有超时设置存在
1720   2          stLocalControl.stCH0TimerOut.byTimerOut--;
1721   2          if(stLocalControl.stCH0TimerOut.byTimerOut == 0)
1722   2          { //超时一次到了 
1723   3            if(stLocalControl.stCH0TimerOut.byTimerOutCount == 0x00)
1724   3            {   //所有超时完成
1725   4              goto TIMER0OUTDEAL;
1726   4            }
1727   3            else
1728   3            { //超时次数没有完
1729   4              stLocalControl.stCH0TimerOut.byTimerOutCount--;
1730   4              if(stLocalControl.stCH0TimerOut.byTimerOutCount == 0x00)
1731   4              {   //所有超时完成
1732   5      TIMER0OUTDEAL:
1733   5                if(bLanding)
1734   5                { //上电状态
1735   6                  stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1736   6                  stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1737   6                  stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1738   6                  stLocalControl.stBusDealFreq.byCmd = CMD_LANDING;
1739   6                  stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.bySerialNum1;
1740   6                  stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stEepromCfgData.bySerialNum2;
1741   6                  stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stEepromCfgData.bySerialNum3;
1742   6                  Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1743   6      
1744   6      //            halRfSendPacket(byWireLessSndBuff,8);   //发送之后仍能够接收
1745   6      //            halSpiStrobe(CCxxx0_SRX);       //测试成功
1746   6                }
1747   5              }
1748   4              else
1749   4              {   //超时次数没有完成，重新加载单位超时时间        
1750   5                stLocalControl.stCH0TimerOut.byTimerOut = stLocalControl.stCH0TimerOut.byTimerOutSet;
1751   5              }
1752   4            }     
1753   3          }
1754   2        }
1755   1        if(stLocalControl.byDispNumSetOkTime)
1756   1        {
1757   2          if(--stLocalControl.byDispNumSetOkTime==0)
1758   2          {
1759   3            page=0;
1760   3            Set_VisualPage();
1761   3            stLocalControl.byDisplayFace = BED_INFO_FACE;
1762   3          }
1763   2        }
1764   1      
1765   1        if(++stLocalControl.byMSecond==50)
1766   1        {
1767   2          stLocalControl.byMSecond=0;
1768   2          stLocalControl.stTime.bySec++;
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 30  

1769   2          if(stLocalControl.stTime.bySec==60)
1770   2          {
1771   3            stLocalControl.stTime.bySec=0;
1772   3          }
1773   2        }
1774   1        
1775   1        if(stLocalControl.uiLcdDisplayTime)
1776   1        {
1777   2          if(--stLocalControl.uiLcdDisplayTime==0)  //LCD在显示常关的情况下显示时间已到
1778   2          {
1779   3            if( !(stLocalControl.bySlaveState&LCD_ON) || (stLocalControl.bySlaveState &PATIENT_DISCHARGE))
1780   3            {//此床没病人
1781   4              BL_OFF();
1782   4            }
1783   3          }
1784   2        }
1785   1      
1786   1      #if CONFIG_CC1101==1
                if(stLocalControl.uiCC1101ReReadTime) //CC1101每隔5分钟读取1次接收缓冲区
                {
                  stLocalControl.uiCC1101ReReadTime--;
                  if(stLocalControl.uiCC1101ReReadTime==0)
                  {
                    if(bWireLessRec==0)
                    {
                      byWireLessRecLen=8; //要读取数据的最大长度
                      halRfReceivePacket(byWireLessRecBuff,&byWireLessRecLen);  //清洗掉接收缓冲区
                      halSpiStrobe(CCxxx0_SRX); //允许接收
                    }
                    stLocalControl.uiCC1101ReReadTime = CC1101_REREAD_TIME;   //重新赋时
                  }
                }
              #endif  
1802   1      
1803   1        if(stLocalControl.byUsart1SdDelayTime)
1804   1        {
1805   2          if(--stLocalControl.byUsart1SdDelayTime ==0)
1806   2          {//时间到
1807   3            if(stLocalControl.bySendSBTimes)
1808   3            {//有次数定时
1809   4              if(--stLocalControl.bySendSBTimes !=0)
1810   4              {
1811   5                //重发数据
1812   5                i=1000;
1813   5                while(stUsartCfg.uiSndLen)
1814   5                {
1815   6                  delay_nms(1);
1816   6                  if(--i ==0) break;
1817   6                }
1818   5                WDT_CONTR = 0x3e; //喂狗
1819   5      
1820   5                stLocalControl.byUsart1SdDelayTime =150;
1821   5                stUsartCfg.uiSndLen = pstDataFreq->uiLen+EXT_SIZE;
1822   5                stUsartCfg.uiSndPos = 0;  //从数据帧头部开始发送数据
1823   5                stUsartCfg.pbySndBuf = byUsart0SndBuf;
1824   5                
1825   5                TI=0;
1826   5                SBUF= byUsart0SndBuf[0];
1827   5              }
1828   4              else UsartSendSBNextFrame();
1829   4            }
1830   3          }
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 31  

1831   2        }
1832   1        else
1833   1        {
1834   2          if(stLocalControl.byDisplayFace !=TALK_FACE)
1835   2          {//非通话状态
1836   3            if(bUsartRecedDietData == 1)
1837   3            {
1838   4              if(stUsartCfg.uiSndLen==0)
1839   4              {//没有串口信息正在发送
1840   5                stLocalControl.stBusDealFreq.byCmd = CMD_OPEN_485BUS_IN;
1841   5                stLocalControl.stBusDealFreq.byRecSecAddr = DIET_TYPE;
1842   5                Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); 
1843   5                bUsartRecedDietData=0;
1844   5                stLocalControl.byUsart1SdDelayTime =150;
1845   5              }
1846   4            }
1847   3            
1848   3            else if(bUsartRecedPrescriptionData == 1)
1849   3            {
1850   4              if(stUsartCfg.uiSndLen == 0)
1851   4              {//没有其它信息正在发送
1852   5                stLocalControl.stBusDealFreq.byCmd = CMD_OPEN_485BUS_IN;
1853   5                stLocalControl.stBusDealFreq.byRecSecAddr = PRESCRIPTION_TYPE;
1854   5                Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); 
1855   5                bUsartRecedPrescriptionData=0;  
1856   5                stLocalControl.byUsart1SdDelayTime =150;
1857   5              }
1858   4                
1859   4            }
1860   3      
1861   3            else if(bUsartRecedPromptData ==1)
1862   3            {
1863   4              if(stUsartCfg.uiSndLen == 0)
1864   4              {//没有其它信息正在发送
1865   5                stLocalControl.stBusDealFreq.byCmd = CMD_OPEN_485BUS_IN;
1866   5                stLocalControl.stBusDealFreq.byRecSecAddr = PROMPT_INFO_TYPE;
1867   5                Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1868   5                bUsartRecedPromptData=0;
1869   5                stLocalControl.byUsart1SdDelayTime =150;
1870   5              }
1871   4            }
1872   3          }
1873   2        }
1874   1      
1875   1      }
1876          /**********************************************************
1877          *函数名称     :TimerOutManager  
1878          *函数描述         :超时管理线程
1879          *输入参数       :
1880          *返回值       :
1881          *全局变量     :stLocalControl,byMainCmdQ
1882          *调用模块       :OSQPost        
1883          ***********************************************************
1884          *创建人           :尹运同
1885          *创建日期     :2008-9-22
1886          ***********************************************************
1887          *修改人         :
1888          *修改日期       :
1889          *注释           :
1890          **********************************************************/ 
1891          void TimerOutManager(void)   
1892          {   
C51 COMPILER V9.00   SINGLEBUS                                                             02/15/2019 10:08:08 PAGE 32  

1893   1        while(1)
1894   1        {   
1895   2          OSWait(K_TMO, 4);                 //设置20ms超时  
1896   2          if(stLocalControl.stCH0TimerOut.byTimerOut)
1897   2          { 
1898   3            OSQPost(byMainCmdQ, TIMER_OUT);       
1899   3          }
1900   2          else
1901   2          {   
1902   3            OSQPost(byMainCmdQ, TIMER_OUT); 
1903   3          }
1904   2          WDT_CONTR = 0x3e; //喂狗
1905   2        }
1906   1      } 
1907                


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6356    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      42
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     67    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
