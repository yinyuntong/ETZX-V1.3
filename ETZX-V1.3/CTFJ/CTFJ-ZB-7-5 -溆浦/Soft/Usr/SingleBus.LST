C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SINGLEBUS
OBJECT MODULE PLACED IN SingleBus.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE SingleBus.c LARGE BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*
   2          ************************Copyright(c)************************
   3          *            湖南一特电子股份有限公司
   4          *             All Rights Reserved
   5          *              
   6          *
   7          *-----------------------文件信息---------------------------
   8          *文件名称         :SingleBus.c
   9          *文件描述       :单总线程序
  10          *创建人         :尹运同
  11          *创建日期       :2008-9-22
  12          *版本号           :V1.0
  13          *注释         :         
  14          *----------------------------------------------------------
  15          *修改人       :
  16          *修改日期       :
  17          *版本号           :
  18          *注释         :
  19          ***********************************************************
  20          */
  21          #define _IN_SINGLE_BUS_
  22          #include "config.h"
  23          
  24          
  25          
  26          
  27          //总线0变量定义  总线0用于与外部设备通信
  28          uint8 bdata byBus0State0  = 0;              //单总线0状态字1
  29          sbit  bBus0StartRec     = byBus0State0^0;       //单总线0开始接收起始位标志
  30          sbit  bBus0OnRec      = byBus0State0^1;       //单总线0开始接收数据位标志
  31          sbit  bBus0Enable     = byBus0State0^2;       //单总线0允许发送标志
  32          sbit  bBus0ReqSend      = byBus0State0^3;       //单总线0请求发送标志
  33          sbit  bBus0OnSendBit    = byBus0State0^4;       //单总线0正在发送一个数据位标志
  34          sbit  bBus0OnSendFreq   = byBus0State0^5;       //单总线0正在发送一个数据帧标志
  35          sbit  bBus0SendError    = byBus0State0^6;       //单总线0发送错误标志
  36          sbit  bBus0Error      = byBus0State0^7;       //单总线0故障标志
  37          uint8 bdata byBus0State1  = 0;                //单总线0状态字2
  38          sbit  bBus0RecFinish    = byBus0State1^0;       //单总线0接收完成标志
  39          sbit  bBus0RecBit9      = byBus0State1^1;       //单总线0接收字节数据的第9位
  40          sbit  bBus0SendFinish   = byBus0State1^2;       //单总线0发送完成标志
  41          sbit  bBus0Disable      = byBus0State1^3;       //单总线0禁止发送标志
  42          sbit  bBus0SendBit      = byBus0State1^4;       //单总线0正在发送的数据位
  43          sbit  bBus0RecBit     = byBus0State1^5;         //单总线0正在接收的数据位
  44          uint8 data byBus0RecCount = 0;                //高4位是总线0接收定时中断计数，低4位是接收到的位计数
  45          uint8 data byBus0RecBuf;                  //总线0接收缓冲单元
  46          uint8 data byBus0SendBuf;                 //总线0发送缓冲单元 
  47          uint8 xdata byBus0RecData[BUS0_FREQ_SIZE];          //总线0接收缓冲区
  48          uint8 xdata byBus0SendData[BUS0_FREQ_SIZE];         //总线0发送缓冲区
  49          uint8 data byBus0SendCount = 0;               //高4位是总线0发送定时中断计数，低4位是发送的位计数
  50          uint8 data byBus0RecSendCount = 0;              //高4位是总线0接收到的字节计数，低4位是总线0发送完的字节计数
  51          uint8 data byBus0SendStopCount;               //总线0停止时间计数
  52          uint8 data byBus0RecTimeOut = 0;              //总线0接收超时计数
  53          uint8 data byBus0DisableCount = 0;              //总线0禁止计数  
  54          uint8 xdata byBus0TxQ[BUS0_TX_Q_ZISE];            //总线0发送队列             
  55          uint8 data byBus0TxHead = 0;                //单总线0发送队列头指针
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 2   

  56          uint8 data byBus0TxTail = 0;                //单总线0发送队列尾指针
  57          #define IncBus0TxPtr(addr)    {addr=(addr+1)%BUS0_TX_Q_ZISE;}
  58          #define Bus0TxBuffLen()       ((byBus0TxTail+BUS0_TX_Q_ZISE-byBus0TxHead)%BUS0_TX_Q_ZISE)  
  59          sbit  Bus0RecPin  = P3^2;                 //单总线0接收引脚定义
  60          sbit  Bus0SendPin = P1^7;                 //单总线0发送引脚定义
  61          
  62          
  63          
  64          //总线1变量定义    总线1用于与内部模块通信
  65          uint8 bdata byBus1State0  = 0;              //单总线1状态字1
  66          sbit  bBus1StartRec     = byBus1State0^0;       //单总线1开始接收起始位标志
  67          sbit  bBus1OnRec      = byBus1State0^1;       //单总线1开始接收数据位标志
  68          sbit  bBus1Enable     = byBus1State0^2;       //单总线1允许发送标志
  69          sbit  bBus1ReqSend      = byBus1State0^3;       //单总线1请求发送标志
  70          sbit  bBus1OnSendBit    = byBus1State0^4;       //单总线1正在发送一个数据位标志
  71          sbit  bBus1OnSendFreq   = byBus1State0^5;       //单总线1正在发送一个数据帧标志
  72          sbit  bBus1SendError    = byBus1State0^6;       //单总线1发送错误标志
  73          sbit  bBus1Error      = byBus1State0^7;       //单总线1故障标志
  74          uint8 bdata byBus1State1  = 0;                //单总线1状态字2
  75          sbit  bBus1RecFinish    = byBus1State1^0;       //单总线1接收完成标志
  76          sbit  bBus1RecBit9      = byBus1State1^1;       //单总线1接收字节数据的第9位
  77          sbit  bBus1SendFinish   = byBus1State1^2;       //单总线1发送完成标志
  78          sbit  bBus1Disable      = byBus1State1^3;       //单总线1禁止发送标志
  79          sbit  bBus1SendBit      = byBus1State1^4;       //单总线1正在发送的数据位
  80          sbit  bBus1RecBit     = byBus1State1^5;         //单总线1正在接收的数据位
  81          uint8 data byBus1RecCount = 0;                //高4位是总线1接收定时中断计数，低4位是接收到的位计数
  82          uint8 data byBus1RecBuf;                  //总线1接收缓冲单元
  83          uint8 data byBus1SendBuf;                 //总线1发送缓冲单元 
  84          uint8 xdata byBus1RecData[BUS1_FREQ_SIZE];          //总线1接收缓冲区
  85          uint8 xdata byBus1SendData[BUS1_FREQ_SIZE];         //总线1发送缓冲区
  86          uint8 data byBus1SendCount = 0;               //高4位是总线1发送定时中断计数，低4位是发送的位计数
  87          uint8 data byBus1RecSendCount = 0;              //高4位是总线1接收到的字节计数，低4位是总线1发送完的字节计数
  88          uint8 data byBus1SendStopCount;               //总线1停止时间计数
  89          uint8 data byBus1RecTimeOut = 0;              //总线1接收超时计数
  90          uint8 data byBus1DisableCount = 0;              //总线1禁止计数  
  91          uint8 xdata byBus1TxQ[BUS1_TX_Q_ZISE];            //总线1发送队列             
  92          uint8 data byBus1TxHead = 0;                //单总线1发送队列头指针
  93          uint8 data byBus1TxTail = 0;                //单总线1发送队列尾指针
  94          #define IncBus1TxPtr(addr)    {addr=(addr+1)%BUS1_TX_Q_ZISE;}
  95          #define Bus1TxBuffLen()       ((byBus1TxTail+BUS1_TX_Q_ZISE-byBus1TxHead)%BUS1_TX_Q_ZISE)  
  96          sbit  Bus1RecPin  = P3^3;                 //单总线1接收引脚定义
  97          sbit  Bus1SendPin = P3^4;                   //单总线1发送引脚定义
  98          
  99          
 100          uint8 xdata byIrDARecBuff[8], byIrDADealBuff[6];    //红外接收区、处理缓冲区
 101          
 102          uint8 xdata MoveFjNum;  //移动分机号
 103          //变量定义   
 104          extern uint8  OS_Q_MEM_SEL  byMainCmdQ[]; 
 105          extern STLocalControl   xdata stLocalControl; 
 106          extern uint8  xdata byUsart0SndDealBuf[];  
 107          
 108          extern unsigned char code ParameterData[];
 109          
 110          
 111          bit bBus0SndBitOk=0;
 112          //bit bBus1SndBitOk=0;
 113          
 114          /**********************************************************
 115          *函数名称     :SingleBusInit  
 116          *函数描述         :单总线初始化
 117          *输入参数       :
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 3   

 118          *返回值       :   
 119          *全局变量     :
 120          *调用模块       :
 121          ***********************************************************
 122          *创建人           :尹运同
 123          *创建日期     :2008-9-22
 124          ***********************************************************
 125          *修改人         :
 126          *修改日期       :
 127          *注释           :
 128          **********************************************************/
 129          void SingleBusInit(void)
 130          {
 131   1      
 132   1        //STC12C56系列::M0=0,M1=0:准双向，M0=0,M1=1:推挽，M0=1,M1=0:高阻，M0=1,M1=1:开漏
 133   1        //总线0发送脚设置为推挽输出，接收脚设置为准双向
 134   1        //P3^2,准双向,P1^7,推挽
 135   1        P3M0 &= (~Bin(0,0,0,0,0,1,0,0));
 136   1        P3M1 &= (~Bin(0,0,0,0,0,1,0,0));
 137   1        P1M0 &= (~Bin(1,0,0,0,0,0,0,0));
 138   1        P1M1 |=   Bin(1,0,0,0,0,0,0,0);
 139   1      
 140   1        
 141   1        //总线1发送脚设置为开漏输出，接收脚设置为高阻输入
 142   1        //P3^3,高阻输入
 143   1        P3M0 |= ( Bin(0,0,0,0,1,0,0,0));
 144   1        P3M1 &= (~Bin(0,0,0,0,1,0,0,0));
 145   1      
 146   1      
 147   1        //P3^4,开漏输出
 148   1        P3M0 |=  (Bin(0,0,0,1,0,0,0,0));
 149   1        P3M1 |=  (Bin(0,0,0,1,0,0,0,0));
 150   1      
 151   1      
 152   1        //总线电平设置
 153   1        Bus0SendPin = 0;
 154   1        Bus0RecPin = 1; 
 155   1        Bus1SendPin = 1;
 156   1        Bus1RecPin = 1;    
 157   1        
 158   1        
 159   1        //定时器0初始化:自动重载方式,定时93.75us   
 160   1        TMOD &= 0xf0;   //  ;t1作波特率发生器(不变)，
 161   1        TMOD |= 0X01; //t0作方式1（16位)定时器
 162   1      
 163   1        TL0 = TIMER0_L;
 164   1        TH0 = TIMER0_H;
 165   1        TF0 = 0;                        //清除中断标志
 166   1        AUXR &= (~T0x12);                   //传统12分频速度  
 167   1          ET0 = 1;                        //允许定时器0中断 
 168   1        TR0 = 1;                        //启动定时器
 169   1        //其它控制设置
 170   1        byBus0SendStopCount = 240;                //上电总线0禁止发送时间设置
 171   1        byBus1SendStopCount = 240;                //上电总线1禁止发送时间设置
 172   1        IE0 = 0;                        //清除外部中断0标志
 173   1        IT0 = 1;                        //外部中断0为下降沿触发模式  
 174   1        IE1 = 0;                        //清除外部中断1标志
 175   1        IT1 = 1;                        //外部中断1为下降沿触发模式       
 176   1        if(Bus0RecPin)
 177   1        { //如果总线正常,开中断   
 178   2          EX0 = 1;
 179   2          
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 4   

 180   2        }
 181   1        else
 182   1        { //如果总线不正常,置总线故障标志       
 183   2          bBus0Error = 1;
 184   2        } 
 185   1        if(Bus1RecPin)
 186   1        { //如果总线正常,开中断   
 187   2          EX1 = 1;
 188   2        }
 189   1        else
 190   1        { //如果总线不正常,置总线故障标志       
 191   2          bBus1Error = 1;
 192   2        }   
 193   1      
 194   1      }
 195          /**********************************************************
 196          *函数名称     :Bus0RecInt 
 197          *函数描述         :外部中断0函数,单总线0接收中断
 198          *输入参数       :
 199          *返回值       :   
 200          *全局变量     :
 201          *调用模块       :
 202          ***********************************************************
 203          *创建人           :尹运同
 204          *创建日期     :2008-9-22
 205          ***********************************************************
 206          *修改人         :
 207          *修改日期       :
 208          *注释           :
 209          **********************************************************/
 210          #pragma disable
 211          void Bus0RecInt(void) interrupt X0_INTNO
 212          {   
 213   1        DisableBus0RecInt();                  //禁止再次下降沿中断
 214   1        bBus0StartRec = 1;                    //启动起始位沿检测
 215   1        bBus0Enable = 0;                    //禁止总线发送              
 216   1        byBus0RecCount = 0;                   //清接收寄存器  
 217   1      
 218   1        if(bBus0ReqSend ==1)
 219   1        {//请求发送状态
 220   2          byBus0SendStopCount = 240;
 221   2        }
 222   1      
 223   1      }
 224          /**********************************************************
 225          *函数名称     :Bus1RecInt 
 226          *函数描述         :外部中断1函数,单总线1接收中断
 227          *输入参数       :
 228          *返回值       :   
 229          *全局变量     :
 230          *调用模块       :
 231          ***********************************************************
 232          *创建人           :陈卫国
 233          *创建日期     :2008-9-22
 234          ***********************************************************
 235          *修改人         :
 236          *修改日期       :
 237          *注释           :
 238          **********************************************************/
 239          #pragma disable
 240          void Bus1RecInt(void) interrupt X1_INTNO
 241          {   
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 5   

 242   1        DisableBus1RecInt();                  //禁止再次下降沿中断
 243   1        bBus1StartRec = 1;                    //启动起始位沿检测
 244   1        bBus1Enable = 0;                    //禁止总线发送              
 245   1        byBus1RecCount = 0;                   //清接收寄存器  
 246   1      }
 247          /**********************************************************
 248          *函数名称     :Timer0Int  
 249          *函数描述         :定时器0溢出中断,定时器每93.75us中断一次
 250                     程序间隔检查总线0与总线1的接收和发送
 251          *输入参数       :
 252          *返回值       :   
 253          *全局变量     :
 254          *调用模块       :
 255          ***********************************************************
 256          *创建人           :陈卫国
 257          *创建日期     :2008-9-22
 258          ***********************************************************
 259          *修改人         :
 260          *修改日期       :
 261          *注释           :
 262          **********************************************************/
 263          #pragma disable
 264          void Timer0Int(void) interrupt T0_INTNO
 265          { 
 266   1      
 267   1        TR0=0;
 268   1        TH0=TIMER0_H;
 269   1        TL0=TIMER0_L;
 270   1        TR0=1;
 271   1      
 272   1      
 273   1      //  TXD =!TXD;
 274   1      
 275   1        bBus0RecBit = Bus0RecPin; 
 276   1        bBus1RecBit = Bus1RecPin;                 //保存总线0、1接收引脚状态            
 277   1        /*******************************总线0接收处理***********************************/
 278   1        if(bBus0StartRec)                   //判断总线所处的状态，接收到起始位
 279   1        {     
 280   2          byBus0RecCount += 0x10;               //增加定时中断计数次数
 281   2          if(0x50 == (byBus0RecCount & 0xf0))         //到总线起始位检测时间
 282   2          {     
 283   3            bBus0StartRec = 0;
 284   3            byBus0RecCount = 0x00;              //重新开始计数      
 285   3            if(bBus0RecBit)     
 286   3            {   //无效起始位                                    
 287   4              if((!bBus0SendError)&&bBus0OnSendFreq)
 288   4              { //没有发生过总线发送错误,且有一帧数据正在发送,停止帧数据发送,置发送错误标志           
 289   5                byBus0State0 &= (~BUS0_SEND_CON);
 290   5                bBus0SendError = 1;
 291   5                Bus0SendPin = 0;            //释放总线          
 292   5              }       
 293   4              byBus0SendStopCount = 240;          
 294   4              byBus0RecSendCount = 0x00;          //接收出错,重置接收发送计数值
 295   4              EnableBus0RecInt();
 296   4              MUT = bMUTState;                //恢复语音功放的控制引脚
 297   4            }
 298   3            else                
 299   3            { //有效起始位
 300   4              bBus0OnRec = 1;               //开始接收数据位  
 301   4            }
 302   3          }
 303   2        }
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 6   

 304   1        else if(bBus0OnRec)
 305   1        {   
 306   2          byBus0RecCount += 0x10;               //增加定时中断计数次数      
 307   2          if(0xa0 == (byBus0RecCount & 0xf0))
 308   2          {
 309   3            byBus0RecCount &= 0x0f;             //清除定时中断计数次数
 310   3            byBus0RecCount += 0x01;
 311   3            if(0x0a == (byBus0RecCount & 0x0f)) 
 312   3            { //收到第10位,结束位           
 313   4              bBus0OnRec = 0;               //停止数据接收          
 314   4              if(bBus0RecBit)
 315   4              { //有效的结束位              
 316   5                if(((bit)(byBus0RecSendCount & 0xf0) == bBus0RecBit9)) 
 317   5                { //数据桢错误
 318   6                  byBus0RecTimeOut = 0;
 319   6                  byBus0RecSendCount &= 0x0f;                     
 320   6                }
 321   5                else 
 322   5                { //数据桢正确          
 323   6                  byBus0RecTimeOut = 230;       //设置下一个字节数据接收超时时间
 324   6                  byBus0RecData[byBus0RecSendCount>>4] = byBus0RecBuf;
 325   6                  byBus0RecSendCount += 0x10;                                         
 326   6                  if((byBus0RecSendCount & 0xf0) >= BUS0_FREQ_SIZE_HI)
 327   6                  {                                           
 328   7                    byBus0RecSendCount &= 0x0f;             
 329   7                    if(!((bBus0OnSendFreq == 1)&&(bBus0ReqSend == 0)))
 330   7                    { //如果接收到的这帧数据是自己发送的不置标志              
 331   8                      bBus0RecFinish = 1;                                                                             
 332   8                    }                                     
 333   7                    byBus0RecTimeOut = 0;
 334   7                    byBus0DisableCount = 10;
 335   7                    bBus0Disable = 1;       //禁止总线使用
 336   7                    MUT = bMUTState;          //恢复语音功放的控制引脚
 337   7                  } 
 338   6                }       
 339   5                byBus0SendStopCount = 240;
 340   5                EnableBus0RecInt();           
 341   5              }
 342   4              else              
 343   4              { //无效结束位
 344   5                bBus0Error = 1;                   
 345   5                if((!bBus0SendError) && bBus0OnSendFreq)
 346   5                { //没有发生过总线发送错误,且有一帧数据正在发送,停止帧数据发送,置发送错误标志
 347   6                  byBus0State0 &= (~BUS0_SEND_CON);
 348   6                  bBus0SendError = 1;             
 349   6                  Bus0SendPin = 0;          //释放总线
 350   6                }
 351   5                byBus0RecSendCount = 0x00;        //接收出错,重置接收发送计数值
 352   5                MUT = bMUTState;              //恢复语音功放的控制引脚
 353   5              }
 354   4            }
 355   3            else if(0x09 == (byBus0RecCount & 0x0f))
 356   3            { //第9位数据
 357   4              bBus0RecBit9 = bBus0RecBit;         
 358   4            }
 359   3            else                      
 360   3            {   //有效数据位
 361   4              byBus0RecBuf >>= 1;
 362   4              if(bBus0RecBit)
 363   4              { //为高电平
 364   5                byBus0RecBuf |= 0x80;
 365   5              } 
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 7   

 366   4            }
 367   3          }
 368   2        }
 369   1        /*******************************总线1接收处理***********************************/
 370   1        if(bBus1StartRec)                   //判断总线所处的状态,接收到起始位
 371   1        {     
 372   2          byBus1RecCount += 0x10;               //增加定时中断计数次数
 373   2          if(0x50 == (byBus1RecCount & 0xf0))         //到总线起始位检测时间
 374   2          {     
 375   3            bBus1StartRec = 0;
 376   3            byBus1RecCount = 0x00;              //重新开始计数      
 377   3            if(bBus1RecBit)     
 378   3            {   //无效起始位                                    
 379   4              if((!bBus1SendError)&&bBus1OnSendFreq)
 380   4              { //没有发生过总线发送错误,且有一帧数据正在发送,停止帧数据发送,置发送错误标志         
 381   5                byBus1State0 &= (~BUS1_SEND_CON);
 382   5                bBus1SendError = 1;
 383   5                Bus1SendPin = 1;            //释放总线          
 384   5              }       
 385   4              byBus1SendStopCount = 240;          
 386   4              byBus1RecSendCount = 0x00;          //接收出错，重置接收发送计数值
 387   4              EnableBus1RecInt();
 388   4            }
 389   3            else                      //有效起始位
 390   3            {
 391   4              bBus1OnRec = 1;               //开始接收数据位                      
 392   4            }
 393   3          }
 394   2        }
 395   1        else if(bBus1OnRec)
 396   1        {   
 397   2          byBus1RecCount += 0x10;               //增加定时中断计数次数      
 398   2          if(0xa0 == (byBus1RecCount & 0xf0))
 399   2          {
 400   3            byBus1RecCount &= 0x0f;             //清除定时中断计数次数
 401   3            byBus1RecCount += 0x01;
 402   3            if(0x0a == (byBus1RecCount & 0x0f)) 
 403   3            { //收到第10位,结束位           
 404   4              bBus1OnRec = 0;               //停止数据接收          
 405   4              if(bBus1RecBit)
 406   4              { //有效的结束位              
 407   5                if(((bit)(byBus1RecSendCount & 0xf0) == bBus1RecBit9)) 
 408   5                { //数据桢错误
 409   6                  byBus1RecTimeOut = 0;
 410   6                  byBus1RecSendCount &= 0x0f;                     
 411   6                }
 412   5                else 
 413   5                { //数据桢正确          
 414   6                  byBus1RecTimeOut = 230;
 415   6                  byBus1RecData[byBus1RecSendCount>>4] = byBus1RecBuf;
 416   6                  byBus1RecSendCount += 0x10;                                         
 417   6                  if((byBus1RecSendCount & 0xf0) >= BUS1_FREQ_SIZE_HI)
 418   6                  {                                           
 419   7                    byBus1RecSendCount &= 0x0f; 
 420   7                    if(!((bBus1OnSendFreq == 1)&&(bBus1ReqSend==0)))
 421   7                    { //如果接收到的这帧数据是自己发送的不置标志            
 422   8                      bBus1RecFinish = 1;                                                                             
 423   8                    }                                     
 424   7                    byBus1RecTimeOut = 0;
 425   7                    byBus1DisableCount = 10;
 426   7                    bBus1Disable = 1;       //禁止总线使用              
 427   7                  } 
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 8   

 428   6                }       
 429   5                byBus1SendStopCount = 240;
 430   5                EnableBus1RecInt();           
 431   5              }
 432   4              else              
 433   4              { //无效结束位
 434   5                bBus1Error = 1;                   
 435   5                if((!bBus1SendError) && bBus1OnSendFreq)
 436   5                { //没有发生过总线发送错误,且有一帧数据正在发送,停止帧数据发送,置发送错误标志
 437   6                  byBus1State0 &= (~BUS1_SEND_CON);
 438   6                  bBus1SendError = 1;             
 439   6                  Bus1SendPin = 1;          //释放总线
 440   6                }
 441   5                byBus1RecSendCount = 0x00;        //接收出错,重置接收发送计数值
 442   5              }
 443   4            }
 444   3            else if(0x09 == (byBus1RecCount & 0x0f))
 445   3            { //第9位数据
 446   4              bBus1RecBit9 = bBus1RecBit;         
 447   4            }
 448   3            else                      //有效数据位
 449   3            { 
 450   4              byBus1RecBuf >>= 1;
 451   4              if(bBus1RecBit)
 452   4              { //为高电平
 453   5                byBus1RecBuf |= 0x80;
 454   5              } 
 455   4            }
 456   3          }
 457   2        } 
 458   1        /*******************************总线0发送处理***********************************/
 459   1        if((byBus0State0 & BUS0_CAN_SEND) == BUS0_CAN_SEND)
 460   1        { //总线0上有数据发送请求,且总线允许发送    
 461   2          if(bBus0RecBit)
 462   2          { //总线正常,可以发送
 463   3            Bus0SendPin = 1;
 464   3            bBus0SendBit = 0;               //发送起始位数据      
 465   3            byBus0SendCount = 0;
 466   3            byBus0State0 &= (~BUS0_CAN_SEND);
 467   3            byBus0SendBuf = byBus0SendData[byBus0RecSendCount & 0x0f];
 468   3            bBus0OnSendBit = 1;               //取出待发送的数据并置正在发送标志    
 469   3          }
 470   2          else
 471   2          { //总线不正常,停止发送
 472   3            byBus0State0 &= (~BUS0_SEND_CON);
 473   3            bBus0SendError = 1;     
 474   3            byBus0RecSendCount &= 0xf0;
 475   3            Bus0SendPin = 0;
 476   3            byBus0SendStopCount = 240;      
 477   3          }
 478   2        }
 479   1        else if(bBus0OnSendBit)
 480   1        {   //有数据位正在发送,首先发送的是起始位 
 481   2          byBus0SendCount += 0x10;
 482   2          if(0x50 == (byBus0SendCount & 0xf0))
 483   2          {//处于一个数据位的中间
 484   3            if(bBus0SendBit == bBus0RecBit)  bBus0SndBitOk =1;
 485   3            else
 486   3            { //不相同,发送失败               
 487   4              byBus0State0 &= ~BUS0_SEND_CON;
 488   4              byBus0RecSendCount &= 0xf0;
 489   4              bBus0SendError = 1;         
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 9   

 490   4              Bus0SendPin = 0; 
 491   4              byBus0SendStopCount = 240;
 492   4              bBus0SndBitOk =0;
 493   4            }     
 494   3          }
 495   2          
 496   2          //if(bBus0SendBit == bBus0RecBit)   
 497   2          else if(bBus0SndBitOk==1)
 498   2          { //发送的数据和接收的数据相同
 499   3          //  byBus0SendCount += 0x10;
 500   3            if(0xa0 == (byBus0SendCount & 0xf0))
 501   3            { //一位数据发送完毕,首先发送的是起始位
 502   4              bBus0SndBitOk=0;
 503   4            
 504   4              byBus0SendCount &= 0x0f;
 505   4              byBus0SendCount += 0x01;        
 506   4              if(0x09 == (byBus0SendCount & 0x0f))
 507   4              { //发送到第9位了
 508   5                bBus0SendBit = !(bit)(byBus0RecSendCount & 0x0f);
 509   5                Bus0SendPin = !bBus0SendBit;            
 510   5              }
 511   4              else if(0x0a == (byBus0SendCount & 0x0f))
 512   4              { //发送到结束位了
 513   5                bBus0SendBit = 1;
 514   5                Bus0SendPin = 0;  
 515   5              }
 516   4              else if(0x0b == (byBus0SendCount & 0x0f))
 517   4              { //已经发送完结束位了
 518   5                bBus0OnSendBit = 0;           
 519   5                byBus0RecSendCount += 0x01;                 
 520   5                if((byBus0RecSendCount & 0x0f) >= BUS0_FREQ_SIZE)
 521   5                { //发送完一帧数据                        
 522   6                  byBus0RecSendCount &= 0xf0;     //重新进入数据帧的发送阶段
 523   6                  byBus0State0 &= (~BUS0_SEND_CON);
 524   6                  byBus0SendStopCount = 240;
 525   6                  byBus0State1 |= BUS0_SEND_FINISH;               
 526   6                  byBus0DisableCount = 10; 
 527   6                }
 528   5                else
 529   5                {             
 530   6                  byBus0SendStopCount = 10;
 531   6                  bBus0ReqSend = 1;
 532   6                }
 533   5                EnableBus0RecInt();           //再次使能接收中断
 534   5              }
 535   4              else
 536   4              {
 537   5                if(byBus0SendBuf & 0x01)
 538   5                { //发送高电平
 539   6                  bBus0SendBit = 1;
 540   6                  Bus0SendPin = 0;          
 541   6                }
 542   5                else
 543   5                { //发送低电平
 544   6                  bBus0SendBit = 0;
 545   6                  Bus0SendPin = 1;
 546   6                }
 547   5                byBus0SendBuf >>= 1;          //发送数据位移位操作
 548   5              }
 549   4            }
 550   3          }
 551   2      /*    else
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 10  

 552   2          { //不相同,发送失败               
 553   2            byBus0State0 &= ~BUS0_SEND_CON;
 554   2            byBus0RecSendCount &= 0xf0;
 555   2            bBus0SendError = 1;         
 556   2            Bus0SendPin = 0; 
 557   2            byBus0SendStopCount = 240;
 558   2          }*/
 559   2        }   
 560   1        /*******************************总线1发送处理***********************************/
 561   1        if((byBus1State0 & BUS1_CAN_SEND) == BUS1_CAN_SEND)
 562   1        { //总线0上有数据发送请求,且总线允许发送    
 563   2          if(bBus1RecBit)
 564   2          { //总线正常,可以发送
 565   3            Bus1SendPin = 0;
 566   3            bBus1SendBit = 0;       
 567   3            byBus1SendCount = 0;
 568   3            byBus1State0 &= (~BUS1_CAN_SEND);
 569   3            byBus1SendBuf = byBus1SendData[byBus1RecSendCount & 0x0f];
 570   3            bBus1OnSendBit = 1;     
 571   3          }
 572   2          else
 573   2          { //总线不正常,停止发送
 574   3            byBus1State0 &= (~BUS1_SEND_CON);
 575   3            bBus1SendError = 1;     
 576   3            byBus1RecSendCount &= 0xf0;
 577   3            Bus1SendPin = 1;
 578   3            byBus1SendStopCount = 240;
 579   3          }
 580   2        }
 581   1        else if(bBus1OnSendBit)
 582   1        {   //有数据位正在发送,首先发送的是起始位     
 583   2          if(bBus1SendBit == bBus1RecBit)       
 584   2          { //发送的数据和接收的数据相同
 585   3            byBus1SendCount += 0x10;
 586   3            if(0xa0 == (byBus1SendCount & 0xf0))
 587   3            { //一位数据发送完毕,首先发送的是起始位
 588   4              byBus1SendCount &= 0x0f;
 589   4              byBus1SendCount += 0x01;        
 590   4              if(0x09 == (byBus1SendCount & 0x0f))
 591   4              { //发送到第9位了
 592   5                bBus1SendBit = !(bit)(byBus1RecSendCount & 0x0f);
 593   5                Bus1SendPin = bBus1SendBit;           
 594   5              }
 595   4              else if(0x0a == (byBus1SendCount & 0x0f))
 596   4              { //发送到结束位了
 597   5                bBus1SendBit = 1;
 598   5                Bus1SendPin = 1;  
 599   5              }
 600   4              else if(0x0b == (byBus1SendCount & 0x0f))
 601   4              { //已经发送完结束位了
 602   5                bBus1OnSendBit = 0;           
 603   5                byBus1RecSendCount += 0x01;                 
 604   5                if((byBus1RecSendCount & 0x0f) >= BUS1_FREQ_SIZE)
 605   5                { //发送完一帧数据                        
 606   6                  byBus1RecSendCount &= 0xf0;     //重新进入数据帧的发送阶段
 607   6                  byBus1State0 &= (~BUS1_SEND_CON);
 608   6                  byBus1SendStopCount = 240;
 609   6                  byBus1State1 |= BUS1_SEND_FINISH;               
 610   6                  byBus1DisableCount = 10;                
 611   6                }
 612   5                else
 613   5                {             
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 11  

 614   6                  byBus1SendStopCount = 10;
 615   6                  bBus1ReqSend = 1;
 616   6                }
 617   5                EnableBus1RecInt();           //再次使能接收中断
 618   5              }
 619   4              else
 620   4              {
 621   5                if(byBus1SendBuf & 0x01)
 622   5                { //发送高电平
 623   6                  bBus1SendBit = 1;
 624   6                  Bus1SendPin = 1;          
 625   6                }
 626   5                else
 627   5                { //发送低电平
 628   6                  bBus1SendBit = 0;
 629   6                  Bus1SendPin = 0;
 630   6                }
 631   5                byBus1SendBuf >>= 1;          //发送数据位移位操作
 632   5              }
 633   4            }
 634   3          }
 635   2          else
 636   2          { //不相同,发送失败               
 637   3            byBus1State0 &= ~BUS1_SEND_CON;
 638   3            byBus1RecSendCount &= 0xf0;
 639   3            bBus1SendError = 1;         
 640   3            Bus1SendPin = 1; 
 641   3            byBus1SendStopCount = 240;
 642   3          }
 643   2        }   
 644   1        /*******************************总线0控制处理***********************************/
 645   1        if(0 == (byBus0State0 & BUS0_ON_REC))
 646   1        { 
 647   2          if(byBus0SendStopCount != 0)
 648   2          {
 649   3            if((--byBus0SendStopCount) == 0)
 650   3            {       
 651   4              bBus0Enable = 1;  
 652   4            }
 653   3          }   
 654   2          if(bBus0Error)
 655   2          {               
 656   3            bBus0Enable = 0;      
 657   3            if(bBus0RecBit)
 658   3            {       
 659   4              bBus0Error = 0;
 660   4              EnableBus0RecInt();
 661   4              byBus0SendStopCount = 240;
 662   4            }
 663   3          }
 664   2        }  
 665   1        /*******************************总线1控制处理***********************************/
 666   1        if(0 == (byBus1State0 & BUS1_ON_REC))
 667   1        {
 668   2          if(byBus1SendStopCount != 0)
 669   2          {
 670   3            if((--byBus1SendStopCount) == 0)
 671   3            {       
 672   4              bBus1Enable = 1;                
 673   4            }
 674   3          }   
 675   2          if(bBus1Error)
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 12  

 676   2          {               
 677   3            bBus1Enable = 0;      
 678   3            if(bBus1RecBit)
 679   3            {       
 680   4              bBus1Error = 0;
 681   4              EnableBus1RecInt();
 682   4              byBus1SendStopCount = 240;
 683   4            }
 684   3          }
 685   2        }   
 686   1        /*******************************总线0超时处理***********************************/
 687   1        if(byBus0RecTimeOut != 0)
 688   1        {
 689   2          if(--byBus0RecTimeOut == 0)             
 690   2          { //接收超时到
 691   3            byBus0RecSendCount &= 0x0f;
 692   3            MUT = bMUTState;                  //恢复语音功放的控制引脚
 693   3          }
 694   2        }
 695   1        if(byBus0DisableCount != 0)
 696   1        {
 697   2          if(--byBus0DisableCount == 0)           
 698   2          { //禁止超时到    
 699   3            bBus0Disable = 0;
 700   3          }
 701   2        } 
 702   1        /*******************************总线1超时处理***********************************/
 703   1        if(byBus1RecTimeOut != 0)
 704   1        {
 705   2          if(--byBus1RecTimeOut == 0)             
 706   2          { //接收超时到
 707   3            byBus1RecSendCount &= 0x0f;
 708   3          }
 709   2        }
 710   1        if(byBus1DisableCount != 0)
 711   1        {
 712   2          if(--byBus1DisableCount == 0)           
 713   2          { //禁止超时到    
 714   3            bBus1Disable = 0;
 715   3          }
 716   2        } 
 717   1        /***********总线0自动发送管理**********/   
 718   1        if((byBus0State0 & BUS0_ON_WORK) == 0x00)       
 719   1        { //总线0没有工作       
 720   2          if(bBus0SendError)            
 721   2          { //产生了发送错误,自动重发               
 722   3            bBus0SendError = 0;       
 723   3            byBus0State0 |= BUS0_REQ_SEND;    
 724   3          }
 725   2          else                  
 726   2          { //总线0无发送错误   
 727   3            if(!(bBus0SendFinish|bBus0Disable))
 728   3            { //总线0没有禁止使用,且发送结束处理已经完成
 729   4              if(Bus0TxBuffLen() >= BUS0_FREQ_SIZE)
 730   4              {   //有一帧完整的数据在发送队列中                                    
 731   5                byBus0SendData[0] = byBus0TxQ[byBus0TxHead];
 732   5                IncBus0TxPtr(byBus0TxHead);
 733   5                byBus0SendData[1] = byBus0TxQ[byBus0TxHead];
 734   5                IncBus0TxPtr(byBus0TxHead);
 735   5                byBus0SendData[2] = byBus0TxQ[byBus0TxHead];
 736   5                IncBus0TxPtr(byBus0TxHead);
 737   5                byBus0SendData[3] = byBus0TxQ[byBus0TxHead];
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 13  

 738   5                IncBus0TxPtr(byBus0TxHead);
 739   5                byBus0SendData[4] = byBus0TxQ[byBus0TxHead];
 740   5                IncBus0TxPtr(byBus0TxHead);
 741   5                byBus0SendData[5] = byBus0TxQ[byBus0TxHead];
 742   5                IncBus0TxPtr(byBus0TxHead);
 743   5                byBus0SendData[6] = byBus0TxQ[byBus0TxHead];
 744   5                IncBus0TxPtr(byBus0TxHead); 
 745   5                byBus0State0 |= BUS0_REQ_SEND;            
 746   5              }
 747   4              else
 748   4              { //没有一帧完整的数据在发送队列中了
 749   5                byBus0TxHead = byBus0TxTail = 0;
 750   5              }               
 751   4            }
 752   3          }
 753   2        } 
 754   1        /***********总线1自动发送管理**********/   
 755   1        if((byBus1State0 & BUS1_ON_WORK) == 0x00) 
 756   1        { //总线1没有工作       
 757   2          if(bBus1SendError)            
 758   2          { //产生了发送错误,自动重发               
 759   3            bBus1SendError = 0;       
 760   3            byBus1State0 |= BUS1_REQ_SEND;    
 761   3          }
 762   2          else                  
 763   2          { //总线1无发送错误   
 764   3            if(!(bBus1SendFinish|bBus1Disable))
 765   3            { //总线0没有禁止使用,且发送结束处理已经完成
 766   4              if(Bus1TxBuffLen() >= BUS1_FREQ_SIZE)
 767   4              { //有一帧完整的数据在发送队列中                                      
 768   5                byBus1SendData[0] = byBus1TxQ[byBus1TxHead];
 769   5                IncBus1TxPtr(byBus1TxHead);
 770   5                byBus1SendData[1] = byBus1TxQ[byBus1TxHead];
 771   5                IncBus1TxPtr(byBus1TxHead);
 772   5                byBus1SendData[2] = byBus1TxQ[byBus1TxHead];
 773   5                IncBus1TxPtr(byBus1TxHead);
 774   5                byBus1SendData[3] = byBus1TxQ[byBus1TxHead];
 775   5                IncBus1TxPtr(byBus1TxHead);
 776   5                byBus1SendData[4] = byBus1TxQ[byBus1TxHead];
 777   5                IncBus1TxPtr(byBus1TxHead);
 778   5                byBus1SendData[5] = byBus1TxQ[byBus1TxHead];
 779   5                IncBus1TxPtr(byBus1TxHead);
 780   5                byBus1SendData[6] = byBus1TxQ[byBus1TxHead];
 781   5                IncBus1TxPtr(byBus1TxHead); 
 782   5                byBus1State0 |= BUS1_REQ_SEND;            
 783   5              }
 784   4              else
 785   4              { //没有一帧完整的数据在发送队列中了
 786   5                byBus1TxHead = byBus1TxTail = 0;
 787   5              }               
 788   4            }
 789   3          }
 790   2        }   
 791   1      } 
 792          /**********************************************************
 793          *函数名称     :BcdToHex 
 794          *函数描述         :BCD转换成十六进制
 795          *输入参数       :byData:待转换的BCD码数据
 796          *返回值       :
 797          *全局变量     :
 798          *调用模块       :
 799          ***********************************************************
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 14  

 800          *创建人           :陈卫国
 801          *创建日期     :2008-9-22
 802          ***********************************************************
 803          *修改人         :
 804          *修改日期       :
 805          *注释           :
 806          **********************************************************/ 
 807          uint8 BcdToHex(uint8 byData)
 808          {
 809   1        uint8 xdata byRet;
 810   1      
 811   1        byRet = byData >> 4;
 812   1        byRet *= 10;
 813   1        byData &= 0x0f;
 814   1        byRet += byData;
 815   1        return(byRet);
 816   1      }
 817          
 818          /**********************************************************
 819          *函数名称     :Bus0OutputData 
 820          *函数描述         :单总线0将待发送数据放入缓冲区
 821          *输入参数       :pbyData:待发送的数据指针
 822          *返回值       :TRUE:发送成功,FALSE:队列满,发送失败  
 823          *全局变量     :
 824          *调用模块       :
 825          ***********************************************************
 826          *创建人           :尹运同
 827          *创建日期     :2008-9-22
 828          ***********************************************************
 829          *修改人         :
 830          *修改日期       :
 831          *注释           :
 832          **********************************************************/
 833          uint8 Bus0OutputData(uint8* pbyData)
 834          {
 835   1        uint8 byTemp = BUS0_FREQ_SIZE;
 836   1      
 837   1        OS_ENTER_CRITICAL();
 838   1        if(Bus0TxBuffLen() >= (BUS0_TX_Q_ZISE - 1))
 839   1        { //没有空间存储了,失败 
 840   2          OS_EXIT_CRITICAL();
 841   2          return(FALSE);
 842   2        } 
 843   1        while(byTemp--)
 844   1        { //数据入发送队列
 845   2          byBus0TxQ[byBus0TxTail] = *pbyData++;
 846   2          IncBus0TxPtr(byBus0TxTail);
 847   2        }
 848   1        OS_EXIT_CRITICAL(); 
 849   1        return(TRUE); 
 850   1      }
 851          /**********************************************************
 852          *函数名称     :Bus1OutputData 
 853          *函数描述         :单总线1将待发送数据放入缓冲区
 854          *输入参数       :pbyData:待发送的数据指针
 855          *返回值       :TRUE:发送成功,FALSE:队列满,发送失败  
 856          *全局变量     :
 857          *调用模块       :
 858          ***********************************************************
 859          *创建人           :陈卫国
 860          *创建日期     :2008-9-22
 861          ***********************************************************
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 15  

 862          *修改人         :
 863          *修改日期       :
 864          *注释           :
 865          **********************************************************/
 866          uint8 Bus1OutputData(uint8* pbyData)
 867          {
 868   1        uint8 byTemp = BUS1_FREQ_SIZE;
 869   1      
 870   1        OS_ENTER_CRITICAL();
 871   1        if(Bus1TxBuffLen() >= (BUS1_TX_Q_ZISE - 1))
 872   1        { //没有空间存储了,失败 
 873   2          OS_EXIT_CRITICAL();
 874   2          return(FALSE);
 875   2        }  
 876   1        while(byTemp--)
 877   1        { //数据入发送队列
 878   2          byBus1TxQ[byBus1TxTail] = *pbyData++;
 879   2          IncBus1TxPtr(byBus1TxTail);
 880   2        }
 881   1        OS_EXIT_CRITICAL(); 
 882   1        return(TRUE); 
 883   1      }
 884          
 885          
 886          /**********************************************************
 887          *函数名称     :AddrCompare  
 888          *函数描述         :比较地址(含广播地址)
 889          *输入参数       :pstBusFreq:待比较的数据帧指针
 890          *返回值       :1:发送到本机的数据,0:不是发送到本机的数据  
 891          *全局变量     :
 892          *调用模块       :
 893          ***********************************************************
 894          *创建人           :尹运同
 895          *创建日期     :2008-9-22
 896          ***********************************************************
 897          *修改人         :
 898          *修改日期       :
 899          *注释           :
 900          **********************************************************/
 901          bit AddrCompare(pSTBusFreq pstBusFreq)
 902          {
 903   1        if((pstBusFreq->byRecSecAddr != 0xff) && (pstBusFreq->byRecSecAddr != stLocalControl.stEepromCfgData.bySe
             -lfSecAddr))
 904   1        { 
 905   2          return(0);
 906   2        } 
 907   1        if((pstBusFreq->byRecRoomAddr != 0xff) && (pstBusFreq->byRecRoomAddr != stLocalControl.stEepromCfgData.by
             -SelfRoomAddr))
 908   1        { 
 909   2          return(0);
 910   2        }
 911   1        if((pstBusFreq->byRecBedAddr != 0xff) && (pstBusFreq->byRecBedAddr != stLocalControl.stEepromCfgData.bySe
             -lfBedAddr))
 912   1        { 
 913   2          return(0);
 914   2        }
 915   1        return(1); 
 916   1      
 917   1      /*  if((pstBusFreq->byRecSecAddr  == 0xff)&&
 918   1           (pstBusFreq->byRecRoomAddr == 0xff)&&
 919   1           (pstBusFreq->byRecBedAddr  == 0xff))
 920   1          return(1);
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 16  

 921   1        else if((pstBusFreq->byRecSecAddr == stLocalControl.stEepromCfgData.bySelfSecAddr)&&
 922   1             (pstBusFreq->byRecRoomAddr== stLocalControl.stEepromCfgData.bySelfRoomAddr)&&
 923   1             (pstBusFreq->byRecBedAddr == stLocalControl.stEepromCfgData.bySelfBedAddr))
 924   1             return(1);
 925   1        else return(0);*/ 
 926   1      }
 927          /**********************************************************
 928          *函数名称     :DirAddrCompare 
 929          *函数描述         :绝对比较地址
 930          *输入参数       :pstBusFreq:待比较的数据帧指针
 931          *返回值       :1:发送到本机的数据,0:不是发送到本机的数据  
 932          *全局变量     :
 933          *调用模块       :
 934          ***********************************************************
 935          *创建人           :尹运同
 936          *创建日期     :2008-9-22
 937          ***********************************************************
 938          *修改人         :
 939          *修改日期       :
 940          *注释           :
 941          **********************************************************/
 942          bit DirAddrCompare(pSTBusFreq pstBusFreq)
 943          {
 944   1        if(pstBusFreq->byRecSecAddr != stLocalControl.stEepromCfgData.bySelfSecAddr)
 945   1        { 
 946   2          return(0);
 947   2        } 
 948   1        if(pstBusFreq->byRecRoomAddr != stLocalControl.stEepromCfgData.bySelfRoomAddr)
 949   1        { 
 950   2          return(0);
 951   2        }
 952   1        if(pstBusFreq->byRecBedAddr != stLocalControl.stEepromCfgData.bySelfBedAddr)
 953   1        { 
 954   2          return(0);
 955   2        }
 956   1        return(1); 
 957   1      }
 958          
 959          
 960          
 961          uint8 DirRFSerialCompare()  //序列号最高位忽略
 962          {
 963   1        if(stLocalControl.stEepromCfgData.byRFSerialNum1!= stLocalControl.stBusDealFreq.bySndSecAddr)
 964   1        { 
 965   2          return(0);
 966   2        } 
 967   1        if(stLocalControl.stEepromCfgData.byRFSerialNum2!= stLocalControl.stBusDealFreq.bySndRoomAddr)
 968   1        { 
 969   2          return(0);
 970   2        }
 971   1        if(stLocalControl.stEepromCfgData.byRFSerialNum3!= stLocalControl.stBusDealFreq.bySndBedAddr)
 972   1        { 
 973   2          return(0);
 974   2        }
 975   1        if(stLocalControl.stEepromCfgData.byRFSerialNum4!= stLocalControl.stBusDealFreq.byRecSecAddr)
 976   1        { 
 977   2          return(0);
 978   2        } 
 979   1        if(stLocalControl.stEepromCfgData.byRFSerialNum5!= stLocalControl.stBusDealFreq.byRecRoomAddr)
 980   1        { 
 981   2          return(0);
 982   2        }
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 17  

 983   1        if(stLocalControl.stEepromCfgData.byRFSerialNum6!= stLocalControl.stBusDealFreq.byRecBedAddr)
 984   1        { 
 985   2          return(0);
 986   2        }
 987   1        
 988   1        return(1);  
 989   1      }
 990          
 991          /**********************************************************
 992          *函数名称     :MakeCH0TimerOut  
 993          *函数描述         :设置通道0超时参数
 994          *输入参数       :byTimerOut:超时时间,byTimerOutCount:超时次数
 995          *返回值       :
 996          *全局变量     :stLocalControl
 997          *调用模块       :
 998          ***********************************************************
 999          *创建人           :尹运同
1000          *创建日期     :2008-9-22
1001          ***********************************************************
1002          *修改人         :
1003          *修改日期       :
1004          *注释           :
1005          **********************************************************/  
1006          void MakeCH0TimerOut(uint8 byTimerOut, uint8 byTimerOutCount)
1007          {
1008   1        stLocalControl.stCH0TimerOut.byTimerOutSet = byTimerOut;
1009   1        stLocalControl.stCH0TimerOut.byTimerOut = byTimerOut;
1010   1        stLocalControl.stCH0TimerOut.byTimerOutCount = byTimerOutCount; 
1011   1      }
1012          /**********************************************************
1013          *函数名称     :MakeCH1TimerOut  
1014          *函数描述         :设置通道1超时参数
1015          *输入参数       :byTimerOut:超时时间,byTimerOutCount:超时次数
1016          *返回值       :
1017          *全局变量     :stLocalControl
1018          *调用模块       :
1019          ***********************************************************
1020          *创建人           :尹运同
1021          *创建日期     :2008-9-22
1022          ***********************************************************
1023          *修改人         :
1024          *修改日期       :
1025          *注释           :
1026          **********************************************************/   
1027          void MakeCH1TimerOut(uint8 byTimerOut, uint8 byTimerOutCount)
1028          {
1029   1        stLocalControl.stCH1Timerout.byTimerOutSet = byTimerOut;
1030   1        stLocalControl.stCH1Timerout.byTimerOut = byTimerOut;
1031   1        stLocalControl.stCH1Timerout.byTimerOutCount = byTimerOutCount; 
1032   1      } 
1033          /**********************************************************
1034          *函数名称     :SaveIndicationData 
1035          *函数描述         :保存信息指示数据内容
1036          *输入参数       :pstBus0SendFreq:待保存的数据帧指针
1037          *返回值       :
1038          *全局变量     :stLocalControl
1039          *调用模块       :
1040          ***********************************************************
1041          *创建人           :尹运同
1042          *创建日期     :2008-9-22
1043          ***********************************************************
1044          *修改人         :
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 18  

1045          *修改日期       :
1046          *注释           :
1047          **********************************************************/
1048          void SaveIndicationData(pSTBusFreq pstBus0SendFreq)
1049          {   
1050   1        stLocalControl.stIndicationData.stAddr.bySndSecAddr = pstBus0SendFreq->bySndSecAddr;
1051   1        stLocalControl.stIndicationData.stAddr.bySndRoomAddr = pstBus0SendFreq->bySndRoomAddr;
1052   1        stLocalControl.stIndicationData.stAddr.bySndBedAddr = pstBus0SendFreq->bySndBedAddr;
1053   1        stLocalControl.stIndicationData.byCallCmd = pstBus0SendFreq->byRecSecAddr; 
1054   1      //  stLocalControl.stIndicationData.byCallCmd = pstBus0SendFreq->byCmd;
1055   1      
1056   1      }
1057          /**********************************************************
1058          *函数名称     :SaveCallAddr 
1059          *函数描述         :保存主动通话方地址
1060          *输入参数       :pstBus0SendFreq:待保存的数据帧指针
1061          *返回值       :
1062          *全局变量     :stLocalControl
1063          *调用模块       :
1064          ***********************************************************
1065          *创建人           :尹运同
1066          *创建日期     :2008-9-22
1067          ***********************************************************
1068          *修改人         :
1069          *修改日期       :
1070          *注释           :
1071          **********************************************************/
1072          void SaveCallAddr(pSTBusFreq pstBusFreq)
1073          {   
1074   1        stLocalControl.stCallAddr.bySndSecAddr = pstBusFreq->bySndSecAddr;
1075   1        stLocalControl.stCallAddr.bySndRoomAddr = pstBusFreq->bySndRoomAddr;
1076   1        stLocalControl.stCallAddr.bySndBedAddr = pstBusFreq->bySndBedAddr;
1077   1      
1078   1        stLocalControl.stCallAddr.byRecSecAddr = pstBusFreq->byRecSecAddr;
1079   1        stLocalControl.stCallAddr.byRecRoomAddr = pstBusFreq->byRecRoomAddr;
1080   1        stLocalControl.stCallAddr.byRecBedAddr = pstBusFreq->byRecBedAddr;  
1081   1      }
1082          /**********************************************************
1083          *函数名称     :VoiceChannelCtx  
1084          *函数描述         :语音通道切换处理函数
1085          *输入参数       :
1086          *返回值       :
1087          *全局变量     :
1088          *调用模块       :
1089          ***********************************************************
1090          *创建人           :尹运同
1091          *创建日期     :2008-9-22
1092          ***********************************************************
1093          *修改人         :
1094          *修改日期       :
1095          *注释           :
1096          **********************************************************/ 
1097          void VoiceChannelCtx(void)  
1098          { 
1099   1      
1100   1        if(bChannel1Talked)
1101   1        { //通道1被动通话
1102   2          CCAP1H = stLocalControl.stEepromCfgData.byCH1TalkedVol;
1103   2          CloseCGB();
1104   2          OpenCBD();
1105   2          XTD = 0;
1106   2          XTA = 1;
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 19  

1107   2          bMUTState = MUT = 0;      
1108   2        }
1109   1        else if(bChannel1Talk)
1110   1        {   //通道1主动通话
1111   2          CCAP1H = stLocalControl.stEepromCfgData.byCH1TalkVol;
1112   2          CloseCGB();
1113   2          OpenCBD();
1114   2          XTD = 0;
1115   2          XTA = 1;
1116   2          bMUTState = MUT = 0;  
1117   2        } 
1118   1        else if((bSickRoomBroad|bOfficeBroad|bAllBroad))
1119   1        { //广播状态
1120   2          CCAP1H = stLocalControl.stEepromCfgData.byBroadVol;
1121   2          CloseCBD();
1122   2          OpenCGB();
1123   2          XTA = XTD = 0;
1124   2          bMUTState = MUT = 0;    
1125   2        }
1126   1        else if(bChannel0Talked)
1127   1        { //通道0被叫通话状态
1128   2          CCAP1H = stLocalControl.stEepromCfgData.byCH0TalkedVol;
1129   2          CloseCBD();
1130   2          OpenCGB();
1131   2          XTA = 0;
1132   2          XTD = 1;
1133   2          bMUTState = MUT = 0;    
1134   2        }
1135   1        else if(bChannel0Talk)
1136   1        { //通道0主动通话状态
1137   2          CCAP1H = stLocalControl.stEepromCfgData.byCH0TalkVol;
1138   2          CloseCBD();
1139   2          OpenCGB();
1140   2          XTA = 0;
1141   2          XTD = 1;
1142   2          bMUTState = MUT = 0;      
1143   2        } 
1144   1        else if(bSelfBroad)
1145   1        { //主动广播状态
1146   2          CloseCGB();
1147   2          CloseCBD();
1148   2          XTA = 0;
1149   2          XTD = 1;
1150   2          bMUTState = MUT = 1;
1151   2        }
1152   1        else if((bCalledRing|bWaitListen))
1153   1        { //被呼叫振铃或者等待接听
1154   2          CCAP1H = stLocalControl.stEepromCfgData.bySelfRingVol;
1155   2          CloseCBD();
1156   2          OpenCGB();
1157   2          XTA = XTD = 0;
1158   2          bMUTState = MUT = 0;    
1159   2        }
1160   1        else if((bEnSoundNote&bNurseIn&bIndicatingOther))
1161   1        { //正在指示其它分机且护士到位
1162   2          CCAP1H = stLocalControl.stEepromCfgData.byRingVol;
1163   2          CloseCBD();
1164   2          OpenCGB();
1165   2          XTA = XTD = 0;
1166   2          bMUTState = MUT = 0;    
1167   2        }
1168   1        else if(bMusicPlaying)
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 20  

1169   1        { //背景音乐播放状态
1170   2          CCAP1H = stLocalControl.stEepromCfgData.byMusicVol;
1171   2          CloseCGB();
1172   2          OpenCBD();
1173   2          XTA = XTD = 0;
1174   2          bMUTState = MUT = 0;        
1175   2        }
1176   1        else if(bVoiceNoting)
1177   1        { //语音提示
1178   2          CCAP1H = stLocalControl.stEepromCfgData.byNoteVol;
1179   2          CloseCGB();
1180   2          OpenCBD();
1181   2          XTA = XTD = 0;
1182   2          bMUTState = MUT = 0;
1183   2        }
1184   1        else
1185   1        { //没有任何语音状态存在    
1186   2          CCAP1H = 10;
1187   2          CloseCGB();
1188   2          CloseCBD();
1189   2          XTA = XTD =0;
1190   2          bMUTState =MUT = 1;   
1191   2        } 
1192   1      }
1193          /**********************************************************
1194          *函数名称     :LedControl 
1195          *函数描述         :指示灯显示状态控制
1196          *输入参数       :
1197          *返回值       :
1198          *全局变量     :
1199          *调用模块       :SetLedDealState,SetLedSetState
1200          ***********************************************************
1201          *创建人           :尹运同
1202          *创建日期     :2008-9-22
1203          ***********************************************************
1204          *修改人         :
1205          *修改日期       :
1206          *注释           :
1207          **********************************************************/ 
1208          void LedControl(void)
1209          {
1210   1      
1211   1      }
1212          /**********************************************************
1213          *函数名称     :SysReset 
1214          *函数描述         :系统复位,该函数仅仅将通道0复位,将通道0
1215                     恢复到空闲状态
1216          *输入参数       :
1217          *返回值       :
1218          *全局变量     :
1219          *调用模块       :
1220          ***********************************************************
1221          *创建人           :尹运同
1222          *创建日期     :2008-9-22
1223          ***********************************************************
1224          *修改人         :
1225          *修改日期       :
1226          *注释           :
1227          **********************************************************/
1228          void SysReset(void)
1229          {
1230   1        //清除对应标志
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 21  

1231   1        if(!(bChannel1Talk|bChannel1Talked))
1232   1        {//通道1空闲
1233   2          Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1234   2        }   
1235   1        bBusy = bWaitAck = bWaitListen = bCalledRing = 
1236   1        bChannel0Talked = bChannel0Talk = 
1237   1        bSickRoomBroad = bOfficeBroad = bAllBroad = bSelfBroad = 
1238   1        bConfusionNoting = bServiceNoting = bHelpNoting = bEmergencyNoting=
1239   1        bIndicatingOther=0;   
1240   1        MakeCH0TimerOut(0, 0);  
1241   1        VoiceChannelCtx();
1242   1        
1243   1      /*  if(!(bChannel1Talk|bChannel1Talked))
1244   1        {
1245   1          if(bIndicatingOther)
1246   1          { 
1247   1            stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stIndicationData.stAddr.bySecAddr;
1248   1            stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stIndicationData.stAddr.byRoomAddr;
1249   1            stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stIndicationData.stAddr.byBedAddr;
1250   1            stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stIndicationData.byCallCmd;
1251   1            stLocalControl.stBusDealFreq.byCmd = CMD_INFO_INDICATION;
1252   1            Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1253   1          }
1254   1          else
1255   1          {
1256   1            stLocalControl.stBusDealFreq.byCmd = CMD_STOP_INDICATION;
1257   1            Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1258   1          } 
1259   1        } */  
1260   1      }
1261          
1262          /**********************************************************
1263          *函数名称     :SaveParameter  
1264          *函数描述         :存储配置参数,存储参数前先擦除整个扇区,
1265                     然后将所有参数重新写入扇区
1266          *输入参数       :
1267          *返回值       :
1268          *全局变量     :stLocalControl
1269          *调用模块       :EnableIAP,IapErase,IapWriteByte,DisableIAP
1270          ***********************************************************
1271          *创建人           :尹运同
1272          *创建日期     :2008-9-22
1273          ***********************************************************
1274          *修改人         :
1275          *修改日期       :
1276          *注释           :
1277          **********************************************************/
1278          void SaveParameter(void)
1279          {  
1280   1        stLocalControl.uiShortType = IAP_ADDR;  
1281   1        stLocalControl.pbyData = &(stLocalControl.stEepromCfgData.byInitFlag);
1282   1        stLocalControl.byChar1 = sizeof(STEepromCfgData);
1283   1        EnableIAP(IAP_ERASE);
1284   1        IapErase(IAP_ADDR);   
1285   1        EnableIAP(IAP_WRITE); 
1286   1        while(stLocalControl.byChar1--)
1287   1        {
1288   2          IapWriteByte(stLocalControl.uiShortType++, *stLocalControl.pbyData++);
1289   2        }
1290   1        DisableIAP();
1291   1        //如果是在写参数命令中调用该函数,重新加载使能数据
1292   1        byEnable1 = stLocalControl.stEepromCfgData.byEnable1;
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 22  

1293   1        byEnable2 = stLocalControl.stEepromCfgData.byEnable2;
1294   1      }
1295          
1296          
1297          //保存输液报警器序列号
1298          /*void SaveRFSerial(void)
1299          {  
1300            stLocalControl.uiShortType = RF_SERIAL_ADDR;  //EEPROM中起始地址  
1301            stLocalControl.pbyData = RFSerial;        //被保存的数据
1302            stLocalControl.byChar1 = 6;           //6个字节
1303            EnableIAP(IAP_ERASE);
1304            IapErase(IAP_ADDR);   
1305            EnableIAP(IAP_WRITE); 
1306            while(stLocalControl.byChar1--)
1307            {
1308              IapWriteByte(stLocalControl.uiShortType++, *stLocalControl.pbyData++);
1309            }
1310            DisableIAP();
1311          } */
1312          /**********************************************************
1313          *函数名称     :ReadParameter  
1314          *函数描述         :将Flash中的配置数据读入到内存中
1315          *输入参数       :
1316          *返回值       :
1317          *全局变量     :stLocalControl
1318          *调用模块       :EnableIAP,IapReadByte,DisableIAP
1319          ***********************************************************
1320          *创建人           :尹运同
1321          *创建日期     :2008-9-22
1322          ***********************************************************
1323          *修改人         :
1324          *修改日期       :
1325          *注释           :
1326          **********************************************************/
1327          void ReadParameter(void)
1328          {
1329   1      
1330   1        stLocalControl.uiShortType = IAP_ADDR;  
1331   1        stLocalControl.pbyData = &(stLocalControl.stEepromCfgData.byInitFlag);
1332   1        stLocalControl.byChar1 = sizeof(STEepromCfgData);
1333   1        
1334   1        EnableIAP(IAP_READ); 
1335   1        while(stLocalControl.byChar1--)
1336   1        {   
1337   2          *stLocalControl.pbyData++ = IapReadByte(stLocalControl.uiShortType++);    
1338   2        }
1339   1        DisableIAP();
1340   1        //如果是在读参数命令中调用该函数,重新加载使能数据
1341   1        byEnable1 = stLocalControl.stEepromCfgData.byEnable1;
1342   1        byEnable2 = stLocalControl.stEepromCfgData.byEnable2;
1343   1        
1344   1      }
1345          
1346          
1347          /*void ReadRFSerial(void)
1348          {
1349          
1350            stLocalControl.uiShortType = RF_SERIAL_ADDR;  //EEPROM中起始地址  
1351            stLocalControl.pbyData = RFSerial;        //被保存的数据
1352            stLocalControl.byChar1 = 6;           //6个字节
1353          
1354            
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 23  

1355            EnableIAP(IAP_READ); 
1356            while(stLocalControl.byChar1--)
1357            {   
1358              *stLocalControl.pbyData++ = IapReadByte(stLocalControl.uiShortType++);    
1359            }
1360            DisableIAP();
1361          }
1362           */
1363          /**********************************************************
1364          *函数名称     :InitParameter  
1365          *函数描述         :初始化Flash中的配置数据
1366          *输入参数       :
1367          *返回值       :
1368          *全局变量     :stLocalControl
1369          *调用模块       :EnableIAP,IapReadByte,DisableIAP
1370          ***********************************************************
1371          *创建人           :尹运同
1372          *创建日期     :2008-9-22
1373          ***********************************************************
1374          *修改人         :
1375          *修改日期       :
1376          *注释           :
1377          **********************************************************/
1378          void InitParameter(void)
1379          {
1380   1        EnableIAP(IAP_READ);
1381   1        if(IapReadByte(IAP_ADDR) == ParameterData[0])
1382   1        {//数据已经初始化完毕了,读取数据参数
1383   2          ReadParameter();
1384   2      
1385   2        }
1386   1        else
1387   1        { //没有初始化,初始化参数
1388   2          stLocalControl.stEepromCfgData.byInitFlag = ParameterData[0];
1389   2          stLocalControl.stEepromCfgData.bySelfSecAddr = ParameterData[1];
1390   2          stLocalControl.stEepromCfgData.bySelfRoomAddr = ParameterData[2];
1391   2          stLocalControl.stEepromCfgData.bySelfBedAddr = ParameterData[3];
1392   2          stLocalControl.stEepromCfgData.byEnable1 = ParameterData[4];
1393   2          stLocalControl.stEepromCfgData.byEnable2 = ParameterData[5];
1394   2          stLocalControl.stEepromCfgData.byPrio = ParameterData[6];
1395   2          stLocalControl.stEepromCfgData.byRingTime = ParameterData[7];
1396   2          stLocalControl.stEepromCfgData.byTalkTime = ParameterData[8];
1397   2          stLocalControl.stEepromCfgData.byBroadTime = ParameterData[9];  
1398   2          stLocalControl.stEepromCfgData.byListenDelay = ParameterData[10];
1399   2          stLocalControl.stEepromCfgData.byVolumStep = ParameterData[11];
1400   2          stLocalControl.stEepromCfgData.byRingVol = ParameterData[12];
1401   2          stLocalControl.stEepromCfgData.byCH0TalkedVol = ParameterData[13];
1402   2          stLocalControl.stEepromCfgData.byCH1TalkedVol = ParameterData[14];
1403   2          stLocalControl.stEepromCfgData.byBroadVol = ParameterData[15];
1404   2          stLocalControl.stEepromCfgData.byNoteVol = ParameterData[16];
1405   2          stLocalControl.stEepromCfgData.byMusicVol = ParameterData[17];
1406   2          stLocalControl.stEepromCfgData.byCH0TalkVol = ParameterData[18];
1407   2          stLocalControl.stEepromCfgData.byCH1TalkVol = ParameterData[19];
1408   2          stLocalControl.stEepromCfgData.bySelfRingVol = ParameterData[20];
1409   2          stLocalControl.stEepromCfgData.byMaxVol = ParameterData[21];
1410   2          stLocalControl.stEepromCfgData.byMinVol = ParameterData[22];
1411   2          stLocalControl.stEepromCfgData.byReserve1 = ParameterData[23];
1412   2          stLocalControl.stEepromCfgData.byReserve2 = ParameterData[24];
1413   2          stLocalControl.stEepromCfgData.byReserve3 = ParameterData[25];
1414   2          stLocalControl.stEepromCfgData.bySerialNum1= ParameterData[26];
1415   2          stLocalControl.stEepromCfgData.bySerialNum2= ParameterData[27];
1416   2          stLocalControl.stEepromCfgData.bySerialNum3= ParameterData[28];
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 24  

1417   2          stLocalControl.stEepromCfgData.byVersionHi = ParameterData[29];
1418   2          stLocalControl.stEepromCfgData.byVersionLo= ParameterData[30];
1419   2          stLocalControl.stEepromCfgData.byRFSerialNum1= ParameterData[31];
1420   2          stLocalControl.stEepromCfgData.byRFSerialNum2= ParameterData[32]; 
1421   2          stLocalControl.stEepromCfgData.byRFSerialNum3= ParameterData[33];
1422   2          stLocalControl.stEepromCfgData.byRFSerialNum4= ParameterData[34];
1423   2          stLocalControl.stEepromCfgData.byRFSerialNum5= ParameterData[35];
1424   2          stLocalControl.stEepromCfgData.byRFSerialNum6= ParameterData[36];
1425   2          stLocalControl.stEepromCfgData.byBedFjFlag = ParameterData[37];
1426   2        
1427   2          SaveParameter();
1428   2        }
1429   1      }
1430          /**********************************************************
1431          *函数名称     :Bus0RecDeal  
1432          *函数描述         :单总线0收到一帧数据处理函数,该函数首先
1433                     取出收到的数据,针对每条命令执行对应的控
1434                     制动作
1435          *输入参数       :
1436          *返回值       :
1437          *全局变量     :stLocalControl
1438          *调用模块       :
1439          ***********************************************************
1440          *创建人           :尹运同
1441          *创建日期     :2008-9-22
1442          ***********************************************************
1443          *修改人         :
1444          *修改日期       :
1445          *注释           :
1446          **********************************************************/
1447          void Bus0RecDeal(void)
1448          {
1449   1        //取出收到的数据帧      
1450   1        OS_ENTER_CRITICAL();
1451   1        memcpy(&(stLocalControl.stBusDealFreq), byBus0RecData, sizeof(STBusFreq));
1452   1        bBus0RecFinish = 0;
1453   1        OS_EXIT_CRITICAL(); 
1454   1      
1455   1      //以下仅供测试用
1456   1      #if DEBUG==1
1457   1      //   Send_Data(&(stLocalControl.stBusDealFreq.bySndSecAddr),7);
1458   1      #endif
1459   1      /////////////////////////////////////////////////////////////////////////////////////
1460   1      
1461   1      
1462   1      
1463   1      /*  if(bLanding && (stLocalControl.stBusDealFreq.byCmd != CMD_ENTER))
1464   1        { //如果是登记状态,收到的命令不是登记确认命令,不作处理
1465   1          return;
1466   1        }
1467   1      */
1468   1        switch(stLocalControl.stBusDealFreq.byCmd)
1469   1        {
1470   2          case CMD_ENTER:                   //确认登记命令        
1471   2            if(bLanding)
1472   2            { 
1473   3              if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
1474   3              {   //发送到本机,关闭指示灯显示,取出系统状态  
1475   4                bLanding=0;
1476   4                byDevState1 = stLocalControl.stBusDealFreq.bySndSecAddr & 0x80;       
1477   4                MakeCH0TimerOut(0, 0); 
1478   4                if(stLocalControl.stBusDealFreq.bySndSecAddr & 0x40)  //PC机打开
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 25  

1479   4                {
1480   5                  stLocalControl.stBusDealFreq.byCmd = CMD_PC_OPEN;
1481   5                  Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1482   5                }         
1483   4              }
1484   3            }     
1485   2            break;
1486   2          case CMD_QUEST:                   //查询命令
1487   2            if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
1488   2            {
1489   3              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1490   3              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1491   3              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1492   3              stLocalControl.stBusDealFreq.byCmd = CMD_QUEST_ANSWER; 
1493   3              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.byPrio;
1494   3              stLocalControl.stBusDealFreq.byRecRoomAddr = byDevState1; //设备状态信息1
1495   3              stLocalControl.stBusDealFreq.byRecBedAddr = byDevState2;  //设备状态信息2
1496   3              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1497   3            }
1498   2            break;
1499   2      /*    case CMD_NURSE_IN:              //护士到位命令      
1500   2            if((stLocalControl.stBusDealFreq.byRecSecAddr == stLocalControl.stEepromCfgData.bySelfSecAddr) &&
1501   2              ((stLocalControl.stBusDealFreq.byRecRoomAddr&0x7f) == (stLocalControl.stEepromCfgData.bySelfRoomAddr&0
             -x7f)))
1502   2            { //如确认的设备是本房的,表明护士到达本房,置到位标志  
1503   2              bNurseIn = 1; 
1504   2              VoiceChannelCtx();                
1505   2            }
1506   2            break;*/
1507   2      /*    case CMD_NURSE_OUT:             //护士离开命令
1508   2            if((stLocalControl.stBusDealFreq.byRecSecAddr == stLocalControl.stEepromCfgData.bySelfSecAddr) &&
1509   2              ((stLocalControl.stBusDealFreq.byRecRoomAddr&0x7f) == (stLocalControl.stEepromCfgData.bySelfRoomAddr&0
             -x7f)))
1510   2            { //表明护士离开本房,清到位标志
1511   2              bNurseIn = 0;         
1512   2              LedControl();
1513   2              VoiceChannelCtx();        
1514   2            }
1515   2            break;*/          
1516   2          case CMD_COMM_CALL:                 //普通呼叫命令
1517   2            if(!bBusy)
1518   2            { //通道0空闲       
1519   3              bBusy = 1;
1520   3              if(bIndicatingOther)
1521   3              { //如果正在指示其他分机,停止指示
1522   4                bIndicatingOther = 0;           
1523   4                LedControl();
1524   4                if(bNurseIn)
1525   4                {
1526   5                  VoiceChannelCtx();            
1527   5                }
1528   4              }
1529   3              //保存主动呼叫方地址
1530   3              SaveCallAddr(&(stLocalControl.stBusDealFreq));
1531   3              //设置超时5s        
1532   3              MakeCH0TimerOut(250, 0);
1533   3              if(AddrCompare(&(stLocalControl.stBusDealFreq)))
1534   3              { //呼叫本机设备
1535   4                if(!(bChannel1Talk|bChannel1Talked))
1536   4                { //通道1空闲,则本机为空闲状态,返回应答命令 
1537   5                  stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1538   5                  stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 26  

1539   5                  stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1540   5                  stLocalControl.stBusDealFreq.byCmd = CMD_COMM_ANSWER;
1541   5                  stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stCallAddr.bySndSecAddr;
1542   5                  stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stCallAddr.bySndRoomAddr;
1543   5                  stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stCallAddr.bySndBedAddr;
1544   5                  Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); 
1545   5                }       
1546   4              }
1547   3            }
1548   2            break;
1549   2          case CMD_COMM_ANSWER:                 //普通应答命令      
1550   2            bBusy = 1; 
1551   2            //设置振铃超时      
1552   2            MakeCH0TimerOut(50, stLocalControl.stEepromCfgData.byRingTime);
1553   2            if(AddrCompare(&(stLocalControl.stBusDealFreq)))
1554   2            { //应答本机,清等待应答,进入等待接听状态
1555   3              bWaitAck = 0;       
1556   3              bWaitListen = 1;                      
1557   3              if((bChannel1Talk|bChannel1Talked)||(!bDealKeyDown))
1558   3              { //如果通道1忙,或者本机主动通话条件不存在了,缩短超时时间       
1559   4                MakeCH0TimerOut(5, 0);
1560   4                break;
1561   4              }
1562   3              VoiceChannelCtx();
1563   3              LedControl();         
1564   3            }
1565   2            break;
1566   2          case CMD_CALL_LISTEN:                 //接听命令        
1567   2            bBusy = 1;
1568   2            //设置通话超时
1569   2            MakeCH0TimerOut(50, stLocalControl.stEepromCfgData.byTalkTime);
1570   2            if(AddrCompare(&(stLocalControl.stBusDealFreq)))
1571   2            { //接听本机,清等待接听,进入通道0主动通话状态       
1572   3              bWaitListen = 0;      
1573   3              bChannel0Talk = 1;                
1574   3              if((bChannel1Talk|bChannel1Talked)||(!bDealKeyDown))
1575   3              { //如果通道1忙,或者本机主动通话条件不存在了,缩短超时时间         
1576   4                MakeCH0TimerOut(5, 0);
1577   4                break;
1578   4              }
1579   3              VoiceChannelCtx();
1580   3              LedControl();
1581   3              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1582   3            }
1583   2            break;      
1584   2          case CMD_BROADCAST1:                //收到病区广播命令
1585   2          case CMD_BROADCAST2:                //收到办公区广播命令
1586   2          case CMD_BROADCAST3:                //收到全区广播命令
1587   2            if(!bBusy)
1588   2            { //通道0空闲       
1589   3              bBusy = 1;
1590   3              //暂存命令        
1591   3              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stBusDealFreq.byCmd;       
1592   3              //设置广播超时
1593   3              MakeCH0TimerOut(50, stLocalControl.stEepromCfgData.byBroadTime); 
1594   3              //保存主动呼叫方地址        
1595   3              SaveCallAddr(&(stLocalControl.stBusDealFreq));
1596   3              if(bIndicatingOther)
1597   3              { //如果正在指示其他分机,停止指示 
1598   4                bIndicatingOther = 0;       
1599   4                LedControl(); 
1600   4                if(bNurseIn)
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 27  

1601   4                { 
1602   5                  VoiceChannelCtx();          
1603   5                }
1604   4              }     
1605   3              if((bChannel1Talk|bChannel1Talked))
1606   3              { //通道1忙,不作处理  
1607   4                break;
1608   4              }     
1609   3              switch(stLocalControl.stBusDealFreq.byRecSecAddr)
1610   3              { //针对具体命令,看本机是否允许相应的广播
1611   4                case CMD_BROADCAST1:
1612   4                  bSickRoomBroad = bEnSickRoomBroad;
1613   4                  if(bSickRoomBroad) Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1614   4                  break;
1615   4                case CMD_BROADCAST2:
1616   4                  bOfficeBroad = bEnOfficeBroad;
1617   4                  if(bOfficeBroad) Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1618   4                  break;
1619   4                case CMD_BROADCAST3:
1620   4                  bAllBroad = bEnAllBroad; 
1621   4                  if(bAllBroad) Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1622   4                  break;
1623   4              }
1624   3              VoiceChannelCtx();
1625   3              LedControl();
1626   3            }
1627   2            break;      
1628   2          case CMD_INFUSION_ENTER:                //输液呼叫确认命令
1629   2          case CMD_SERVICE_ENTER:                 //服务呼叫确认命令
1630   2          case CMD_HELP_ENTER:                  //求援呼叫确认命令
1631   2          case CMD_EMERGENCY_ENTER:               //紧急呼叫确认命令      
1632   2            if(AddrCompare(&(stLocalControl.stBusDealFreq)))
1633   2            { //确认本机的呼叫命令
1634   3              switch(stLocalControl.stBusDealFreq.byCmd)
1635   3              {
1636   4                case CMD_INFUSION_ENTER:
1637   4                  bConfusionNoting = 1;             
1638   4                  break;
1639   4                case CMD_SERVICE_ENTER:
1640   4                  bServiceNoting = 1;               
1641   4                  break;
1642   4                case CMD_HELP_ENTER:
1643   4                  bHelpNoting = 1;              
1644   4                  break;
1645   4                case CMD_EMERGENCY_ENTER:
1646   4                  bEmergencyNoting = 1;             
1647   4                  break;
1648   4              }       
1649   3              if(bIndicatingOther)
1650   3              { //如果正在指示其他分机,清指示其他分机             
1651   4                bIndicatingOther = 0;
1652   4                if(bNurseIn)
1653   4                {           
1654   5                  VoiceChannelCtx();              
1655   5                }     
1656   4              }         
1657   3              LedControl();
1658   3              //命令还是原来的命令
1659   3              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1660   3            }
1661   2            break;      
1662   2          case CMD_INFO_INDICATION:               //收到呼叫指示命令 
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 28  

1663   2            if((stLocalControl.stBusDealFreq.bySndSecAddr == stLocalControl.stEepromCfgData.bySelfSecAddr) &&
1664   2              ((stLocalControl.stBusDealFreq.bySndRoomAddr&0x7f) == (stLocalControl.stEepromCfgData.bySelfRoomAddr&0
             -x7f)))
1665   2            { //如果收到的是本房的呼叫指示,不需要作处理,清除上次的呼叫指示  
1666   3              if(bIndicatingOther)
1667   3              { 
1668   4                bIndicatingOther = 0;
1669   4                if(bNurseIn)
1670   4                {             
1671   5                  VoiceChannelCtx();
1672   5                  LedControl();
1673   5                }
1674   4              }
1675   3              if(stLocalControl.stBusDealFreq.bySndBedAddr==stLocalControl.stEepromCfgData.bySelfBedAddr)
1676   3              {//是本床头分机,在屏上显示
1677   4                //命令还是原来的命令
1678   4                Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1679   4                bIndicatingOther =1;
1680   4      
1681   4                if(stLocalControl.stEepromCfgData.byBedFjFlag & BedVoicePlay)
1682   4                {
1683   5                  CloseCBD();
1684   5                  OpenCGB();    //打开SD 通道上的本机语言报号音
1685   5                  XTA = XTD = 0;
1686   5                  bMUTState = MUT = 0;
1687   5                }
1688   4      
1689   4              }
1690   3            }
1691   2            else
1692   2            {
1693   3      #if 0     
                      //收到的不是本房的呼叫指示,判断是否本机能够处理
                      if(!(bBusy|bConfusionNoting|bServiceNoting|bHelpNoting|bEmergencyNoting))
                      { //本机通道0处于空闲状态,可以指示其他分机的呼叫命令了
                        switch(stLocalControl.stBusDealFreq.byRecSecAddr & 0x1f)
                        {
                          case CMD_INFUSION_CALL:           //输液呼叫
                            if(!bEnInfusionDeal)
                            {
                              return;                         
                            }             
                            break;
                          case CMD_SERVICE_CALL:          //服务呼叫
                            if(!bEnServiceDeal)
                            {
                              return;             
                            }           
                            break;
                          case CMD_HELP_CALL:           //求援呼叫
                            if(!bEnHelpDeal)
                            {
                              return;             
                            }             
                            break;
                          case CMD_EMERGENCY_CALL:        //紧急呼叫
                            if(!bEnEmergencyDeal)
                            {
                              return;           
                            }             
                            break;
                          default:
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 29  

                            return;
                        }
              //          SaveIndicationData(&(stLocalControl.stBusDealFreq));                        
              //          bIndicatingOther = 1;
                        if((bChannel1Talked|bChannel1Talk))
                        { //如果通道1处于通话状态,不作处理
                          return;
                        }           
                        if(bNurseIn)
                        { //护士在位,指示其他分机
                          SaveIndicationData(&(stLocalControl.stBusDealFreq));                        
                          bIndicatingOther = 1;         
                          VoiceChannelCtx();
                          LedControl(); 
                          //命令还是原来的命令
                          Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));           
                        } 
                      }
              #endif
1743   3            } 
1744   2      
1745   2      /*//测试时用
1746   2            CloseCBD();
1747   2            OpenCGB();
1748   2            XTA = XTD = 0;
1749   2            bMUTState = MUT = 0;  
1750   2      */
1751   2            break;
1752   2          case CMD_INFUSION_ANSWER:             //处理输液呼叫命令
1753   2          case CMD_SERVICE_ANSWER:              //处理服务呼叫命令
1754   2          case CMD_EMERGENCY_ANSWER:              //处理紧急呼叫命令
1755   2          case CMD_HELP_ANSWER:               //处理求援呼叫命令
1756   2            if(!bBusy)
1757   2            { //通道0不忙       
1758   3              bBusy = 1;  
1759   3              //保存主动呼叫方地址  
1760   3              SaveCallAddr(&(stLocalControl.stBusDealFreq));  
1761   3              //设置通道0超时         
1762   3              MakeCH0TimerOut(250, 0);
1763   3              if(AddrCompare(&(stLocalControl.stBusDealFreq)))
1764   3              {   //处理本机的呼叫命令,清相应的标志   
1765   4                if(stLocalControl.stBusDealFreq.byCmd == CMD_INFUSION_ANSWER)
1766   4                {           
1767   5                  bConfusionNoting = 0;
1768   5                }
1769   4                else if(stLocalControl.stBusDealFreq.byCmd == CMD_SERVICE_ANSWER)
1770   4                {              
1771   5                  bServiceNoting = 0;
1772   5                }
1773   4                else if(stLocalControl.stBusDealFreq.byCmd == CMD_EMERGENCY_ANSWER)
1774   4                {           
1775   5                  bEmergencyNoting = 0;
1776   5                }
1777   4                else if(stLocalControl.stBusDealFreq.byCmd == CMD_HELP_ANSWER)
1778   4                {               
1779   5                  bHelpNoting = 0;
1780   5                }           
1781   4                VoiceChannelCtx();        
1782   4                LedControl();
1783   4                bCalledRing = 1;
1784   4                if(!(bChannel1Talk|bChannel1Talked))
1785   4                { //如果通道1不处于通话状态,返回应答命令
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 30  

1786   5                  stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1787   5                  stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1788   5                  stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1789   5                  stLocalControl.stBusDealFreq.byCmd = CMD_COMM_ANSWER;
1790   5                  stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stCallAddr.bySndSecAddr;
1791   5                  stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stCallAddr.bySndRoomAddr;
1792   5                  stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stCallAddr.bySndBedAddr;
1793   5                  Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); 
1794   5                }
1795   4                break;        
1796   4              }
1797   3              if(bIndicatingOther)
1798   3              { //正在指示其他分机,清除标志           
1799   4                bIndicatingOther = 0;
1800   4                if(bNurseIn)
1801   4                {           
1802   5                  VoiceChannelCtx();            
1803   5                  LedControl(); 
1804   5                  //命令还是原来的命令
1805   5                  Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1806   5      
1807   5                }     
1808   4              } 
1809   3            }
1810   2            break;
1811   2          case CMD_STOP_INDICATION:             //停止指示命令
1812   2            if(bIndicatingOther)
1813   2            {
1814   3              bIndicatingOther = 0;
1815   3              if((stLocalControl.stBusDealFreq.bySndSecAddr == stLocalControl.stEepromCfgData.bySelfSecAddr) &&
1816   3                ((stLocalControl.stBusDealFreq.bySndRoomAddr) == (stLocalControl.stEepromCfgData.bySelfRoomAddr))&&
1817   3                (stLocalControl.stBusDealFreq.bySndBedAddr == stLocalControl.stEepromCfgData.bySelfBedAddr))
1818   3              {//是本机
1819   4                CloseCGB();
1820   4                CloseCBD();
1821   4                XTA = XTD =0;
1822   4                bMUTState =MUT = 1;           
1823   4              }
1824   3              else
1825   3              {
1826   4                if(bNurseIn)
1827   4                {
1828   5                  VoiceChannelCtx();
1829   5                  LedControl();           
1830   5                }
1831   4              }
1832   3              //命令还是原来的命令
1833   3              //Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));     //不再向单总线1发送 
1834   3            
1835   3            }
1836   2            break;
1837   2          case CMD_INFUSION_CLEAR:              //清除输液呼叫命令
1838   2          case CMD_SERVICE_CLEAR:               //清除服务呼叫命令
1839   2          case CMD_HELP_CLEAR:                //清除求援呼叫命令
1840   2          case CMD_EMERGENCY_CLEAR:               //清除紧急呼叫命令
1841   2            if(AddrCompare(&(stLocalControl.stBusDealFreq)))
1842   2            { //清除本机的呼叫,清除相应的标志
1843   3              switch(stLocalControl.stBusDealFreq.byCmd-0x0a) //查询对应的呼叫命令
1844   3              {
1845   4                case CMD_INFUSION_CALL:
1846   4                  bConfusionNoting = 0;
1847   4                  break;
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 31  

1848   4                case CMD_SERVICE_CALL:
1849   4                  bServiceNoting = 0;
1850   4                  break;
1851   4                case CMD_HELP_CALL:
1852   4                  bHelpNoting = 0;
1853   4                  break;
1854   4                case CMD_EMERGENCY_CALL:
1855   4                  bEmergencyNoting = 0;
1856   4                  break;
1857   4              }
1858   3              SysReset();
1859   3              //VoiceChannelCtx();
1860   3              //LedControl();               
1861   3            }
1862   2            else
1863   2            { //将命令恢复成相应的呼叫命令  
1864   3              //stLocalControl.stBusDealFreq.byCmd -= 0x0a; 
1865   3              if(bIndicatingOther &&
1866   3                (stLocalControl.stBusDealFreq.byRecSecAddr == stLocalControl.stIndicationData.stAddr.bySndSecAddr) &&
1867   3                (stLocalControl.stBusDealFreq.byRecRoomAddr == stLocalControl.stIndicationData.stAddr.bySndRoomAddr) 
             -&&
1868   3                (stLocalControl.stBusDealFreq.byRecBedAddr == stLocalControl.stIndicationData.stAddr.bySndBedAddr) &&
1869   3                ((stLocalControl.stBusDealFreq.byCmd-0x0a) == (stLocalControl.stIndicationData.byCallCmd & 0x1f)))
1870   3              {   //清除本机正在指示的呼叫信息          
1871   4                bIndicatingOther = 0;
1872   4                Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1873   4      
1874   4      
1875   4              
1876   4                if(bNurseIn)
1877   4                {
1878   5                  VoiceChannelCtx();
1879   5                  LedControl();         
1880   5                }                 
1881   4              }
1882   3            }
1883   2            break;      
1884   2          case CMD_SYSTERM_RESET:               //系统复位命令
1885   2            SysReset();
1886   2            break; 
1887   2      
1888   2          case CMD_SYSTERM_RESTART:
1889   2            bBusy = bWaitAck = bWaitListen = bCalledRing = 
1890   2            bChannel0Talked = bChannel0Talk = 
1891   2            bChannel1Talked = bChannel1Talk = 
1892   2            bSickRoomBroad = bOfficeBroad = bAllBroad = bSelfBroad = 
1893   2            bConfusionNoting = bServiceNoting = bHelpNoting = bEmergencyNoting=
1894   2            bIndicatingOther=0;   
1895   2            MakeCH0TimerOut(0, 0);
1896   2            MakeCH1TimerOut(0, 0);
1897   2            VoiceChannelCtx();
1898   2            break;
1899   2        
1900   2          case CMD_START_VOICE:               //启动播音命令
1901   2            if(AddrCompare(&(stLocalControl.stBusDealFreq)))
1902   2            { 
1903   3              if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
1904   3              {
1905   4                stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1906   4                stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1907   4                stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1908   4                stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER;
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 32  

1909   4                stLocalControl.stBusDealFreq.byRecSecAddr = CMD_START_VOICE;
1910   4                Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1911   4              }
1912   3              bChannel1Talked = bChannel1Talk = 0;        
1913   3              MakeCH1TimerOut(0, 0);        
1914   3              bVoiceNoting = bEnVoiceNote;        
1915   3              VoiceChannelCtx();
1916   3              LedControl();
1917   3            }
1918   2            break;
1919   2          case CMD_MUSIC_PLAY:                //背景音乐播放
1920   2            if(AddrCompare(&(stLocalControl.stBusDealFreq)))
1921   2            {
1922   3              if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
1923   3              {
1924   4                stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1925   4                stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1926   4                stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1927   4                stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER;
1928   4                stLocalControl.stBusDealFreq.byRecSecAddr = CMD_MUSIC_PLAY;
1929   4                Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1930   4              }     
1931   3              bChannel1Talked = bChannel1Talk = 0;
1932   3              MakeCH1TimerOut(0, 0);        
1933   3              bMusicPlaying = bEnMusicplay;         
1934   3              VoiceChannelCtx();
1935   3              LedControl();         
1936   3            }
1937   2            break;  
1938   2          case CMD_STOP_VOICE:                //停止所有音乐播放
1939   2            if(AddrCompare(&(stLocalControl.stBusDealFreq)))
1940   2            {
1941   3              if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
1942   3              {
1943   4                stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1944   4                stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1945   4                stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1946   4                stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER;
1947   4                stLocalControl.stBusDealFreq.byRecSecAddr = CMD_STOP_VOICE;
1948   4                Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1949   4              }   
1950   3              bVoiceNoting = bMusicPlaying = 0;
1951   3              VoiceChannelCtx();          
1952   3            }
1953   2            break; 
1954   2          case CMD_CHANNEL_CHANGE:              //通道切换命令
1955   2            //将通道0的状态切换到通道1上,同时清除通道0的通话状态
1956   2            bBusy = bWaitAck = bWaitListen = bCalledRing =  
1957   2              bSickRoomBroad = bOfficeBroad = bAllBroad = bSelfBroad = 0;     
1958   2            MakeCH0TimerOut(0, 0);                  
1959   2            if((bChannel0Talked|bChannel0Talk))
1960   2            {         
1961   3              bChannel1Talked = bChannel0Talked;
1962   3              bChannel1Talk = bChannel0Talk;
1963   3              bChannel0Talked = bChannel0Talk = 0;        
1964   3              //设置通道1通话超时           
1965   3              MakeCH1TimerOut(50, stLocalControl.stEepromCfgData.byTalkTime);
1966   3              if(bChannel1Talk&&(!bDealKeyDown))
1967   3              { //本机主动通话条件不存在了,缩短超时时间                     
1968   4                MakeCH1TimerOut(5, 0);
1969   4                break;      
1970   4              }
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 33  

1971   3              VoiceChannelCtx();
1972   3              LedControl(); 
1973   3              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1974   3            }             
1975   2            break;
1976   2          case CMD_CHANNEL_CLOSE:               //关闭通道切换命令
1977   2            //清除通道1所有状态     
1978   2            //bChannel1Talked = bChannel1Talk = bConfusionNoting =0; 
1979   2            bChannel1Talked = bChannel1Talk  =0;
1980   2            MakeCH1TimerOut(0, 0);  
1981   2            VoiceChannelCtx();
1982   2            LedControl();
1983   2            if(AddrCompare(&(stLocalControl.stBusDealFreq)))
1984   2            {
1985   3              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1986   3            }
1987   2            break;
1988   2            
1989   2          case CMD_NUMBER_SET:                //在线编房号，床号命令
1990   2      /*      if(stLocalControl.stBusDealFreq.byRecSecAddr != stLocalControl.stEepromCfgData.bySerialNum1)
1991   2            {
1992   2              return;
1993   2            }
1994   2            if(stLocalControl.stBusDealFreq.byRecRoomAddr != stLocalControl.stEepromCfgData.bySerialNum2)
1995   2            {
1996   2              return;
1997   2            }
1998   2            if(stLocalControl.stBusDealFreq.byRecBedAddr != stLocalControl.stEepromCfgData.bySerialNum3)
1999   2            {
2000   2              return;
2001   2            }
2002   2            Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2003   2            
2004   2            //序列号正确,保存新的地址数据           
2005   2            stLocalControl.stEepromCfgData.bySelfSecAddr = stLocalControl.stBusDealFreq.bySndSecAddr;
2006   2            stLocalControl.stEepromCfgData.bySelfRoomAddr = stLocalControl.stBusDealFreq.bySndRoomAddr;
2007   2            stLocalControl.stEepromCfgData.bySelfBedAddr = stLocalControl.stBusDealFreq.bySndBedAddr;         
2008   2      
2009   2            stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stBusDealFreq.byRecSecAddr;
2010   2            stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stBusDealFreq.byRecRoomAddr;
2011   2            stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stBusDealFreq.byRecBedAddr;
2012   2            stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER;
2013   2            stLocalControl.stBusDealFreq.byRecSecAddr = CMD_SET_BY_SERIAL;      
2014   2            Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));*/
2015   2      
2016   2            if((stLocalControl.stBusDealFreq.bySndRoomAddr >=250)||
2017   2               (stLocalControl.stBusDealFreq.bySndBedAddr ==0x00) )
2018   2            {//不是床头分机的地址范围
2019   3              break;
2020   3            }
2021   2      
2022   2      
2023   2            //暂存主呼方地址数据中
2024   2            stLocalControl.stCallAddr.bySndSecAddr=stLocalControl.stBusDealFreq.bySndSecAddr;
2025   2            stLocalControl.stCallAddr.bySndRoomAddr=stLocalControl.stBusDealFreq.bySndRoomAddr;
2026   2            stLocalControl.stCallAddr.bySndBedAddr =stLocalControl.stBusDealFreq.bySndBedAddr;
2027   2            bNumSeting=1;
2028   2            stLocalControl.byNumSetTime=250;      //编号5秒内有效
2029   2            stLocalControl.stBusDealFreq.byRecSecAddr=0x01; //开始编号
2030   2            Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); //显示开始编号
2031   2            break;
2032   2            
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 34  

2033   2          case CMD_SYSTEM_SEC_SET:
2034   2            stLocalControl.stEepromCfgData.bySelfSecAddr = stLocalControl.stBusDealFreq.byRecSecAddr;
2035   2            
2036   2            stLocalControl.stBusDealFreq.bySndSecAddr   = stLocalControl.stEepromCfgData.bySelfSecAddr;
2037   2            stLocalControl.stBusDealFreq.bySndRoomAddr  = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2038   2            stLocalControl.stBusDealFreq.bySndBedAddr   = stLocalControl.stEepromCfgData.bySelfBedAddr;
2039   2            Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); //先送显示，手柄等子模块
2040   2            
2041   2      //      stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS;       
2042   2      //      Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); 
2043   2            break;  
2044   2            
2045   2          case CMD_POWER_ON:                      //本机重新热启动    
2046   2            if(AddrCompare(&(stLocalControl.stBusDealFreq)))
2047   2            {//比较地址(含广播地址)
2048   3              if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
2049   3              {//绝对地址
2050   4                stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2051   4                stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2052   4                stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2053   4                stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stBusDealFreq.byCmd;//原命令
2054   4                stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER;
2055   4                Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2056   4              }
2057   3              else
2058   3              {//广播地址
2059   4                if((bOxSupplyState==1)/*&&(bEnableOxTimer==1)*/)
2060   4                {//如果正处于供氧计时状态
2061   5                
2062   5                  memcpy(&(stLocalControl.stBusDealFreq.bySndSecAddr),&(stLocalControl.stEepromCfgData.bySelfSecAddr),
             -3);
2063   5                  stLocalControl.stBusDealFreq.byCmd= CMD_SUPPLY_OX_END;        
2064   5                  memcpy(&(stLocalControl.stBusDealFreq.byRecSecAddr),&(stLocalControl.stEepromCfgData.bySelfSecAddr),
             -3);
2065   5                  Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2066   5                }
2067   4                OSWait(K_TMO,200);
2068   4                stLocalControl.stBusDealFreq.byCmd = CMD_POWER_ON;
2069   4                Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));       
2070   4              }
2071   3              
2072   3            }       
2073   2            break;
2074   2      
2075   2            
2076   2      /*    case CMD_OPEN_485BUS_IN:
2077   2            if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
2078   2            {
2079   2              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2080   2              
2081   2              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2082   2              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2083   2              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2084   2              stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER;  
2085   2              stLocalControl.stBusDealFreq.byRecSecAddr = CMD_OPEN_485BUS_IN;
2086   2              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2087   2              KDR=0;
2088   2            }
2089   2            break;*/
2090   2            
2091   2          /*case CMD_CLOSE_485BUS:
2092   2            if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 35  

2093   2            {
2094   2              if(stLocalControl.stBusDealFreq.bySndSecAddr==CMD_SB_DISPLAY_DATA)
2095   2              {//是发送到床头分机手柄上的数据
2096   2                Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2097   2              }
2098   2            }     
2099   2            //关闭所有
2100   2            KDR=1;
2101   2            break;*/
2102   2          case CMD_OPEN_LCD:
2103   2            if(AddrCompare(&(stLocalControl.stBusDealFreq)))
2104   2            {//比较地址(含广播地址)
2105   3      
2106   3              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2107   3              
2108   3              if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
2109   3              {//绝对地址
2110   4                stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2111   4                stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2112   4                stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2113   4                stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stBusDealFreq.byCmd;//原命令
2114   4                stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER;
2115   4                Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2116   4              }       
2117   3            }
2118   2            break;
2119   2            
2120   2          case CMD_CLOSE_LCD:
2121   2            if(AddrCompare(&(stLocalControl.stBusDealFreq)))
2122   2            {//比较地址(含广播地址)
2123   3      
2124   3              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2125   3              
2126   3              if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
2127   3              {//绝对地址
2128   4                stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2129   4                stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2130   4                stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2131   4                stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stBusDealFreq.byCmd;//原命令
2132   4                stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER;
2133   4                Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2134   4              }       
2135   3            }
2136   2            break;
2137   2            
2138   2          case CMD_CLEAR_LCD:           
2139   2          case CMD_CLEAR_HANDLE_LCD:   
2140   2            if(stLocalControl.stEepromCfgData.byBedFjFlag & bSecRoom) //需判断区号、房号
2141   2            {
2142   3              if(AddrCompare(&(stLocalControl.stBusDealFreq)))
2143   3              {//比较地址(含广播地址)     
2144   4                Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2145   4                
2146   4                if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
2147   4                {//绝对地址
2148   5                  stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2149   5                  stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2150   5                  stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2151   5                  stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stBusDealFreq.byCmd;//原命令
2152   5                  stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER;
2153   5                  Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2154   5                }
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 36  

2155   4                
2156   4              }
2157   3            }
2158   2            else if(stLocalControl.stBusDealFreq.byRecBedAddr == stLocalControl.stEepromCfgData.bySelfBedAddr)  //床
             -号相等
2159   2            {
2160   3              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2161   3              stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;     
2162   3              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2163   3              
2164   3              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2165   3              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2166   3              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2167   3              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stBusDealFreq.byCmd;//原命令
2168   3              stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER;
2169   3              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));       
2170   3            }
2171   2            break;
2172   2          case CMD_DATE_SEND:
2173   2            bEnableOxTimer=1; //开始允许供氧统计
2174   2            
2175   2            Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2176   2            stLocalControl.stTime.bySec = BcdToHex(stLocalControl.stBusDealFreq.bySndSecAddr & 0x7f);
2177   2            stLocalControl.stTime.byMin = BcdToHex(stLocalControl.stBusDealFreq.bySndRoomAddr & 0x7f);
2178   2            stLocalControl.stTime.byHour = BcdToHex(stLocalControl.stBusDealFreq.bySndBedAddr & 0x3f);
2179   2            stLocalControl.stTime.byDay = BcdToHex(stLocalControl.stBusDealFreq.byRecSecAddr & 0x3f);
2180   2            stLocalControl.stTime.byMonth = BcdToHex(stLocalControl.stBusDealFreq.byRecRoomAddr & 0x1f);
2181   2            stLocalControl.stTime.byYear = BcdToHex(stLocalControl.stBusDealFreq.byRecBedAddr);
2182   2      
2183   2            if(bWillSndOxSupplyStart==1)
2184   2            {//上电(或者没收到时间数据之前)就处于供氧状态
2185   3              memcpy(&(stLocalControl.stBusDealFreq.bySndSecAddr),&(stLocalControl.stEepromCfgData.bySelfSecAddr),3)
             -;
2186   3              stLocalControl.stBusDealFreq.byCmd= CMD_SUPPLY_OX_START;
2187   3              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2188   3              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2189   3              bWillSndOxSupplyStart=0;
2190   3              bOxSupplyState=1;
2191   3            }
2192   2            break;
2193   2            
2194   2          case CMD_RF_NUMSET_OK:    //此输液报警器的序列号已被别人占用
2195   2            if(DirRFSerialCompare())
2196   2            {
2197   3      
2198   3              memset(&(stLocalControl.stEepromCfgData.byRFSerialNum1),0x00,6);
2199   3              WDT_CONTR = 0x3d;   //喂狗
2200   3              EA=0;
2201   3              SaveParameter();
2202   3              EA=1;
2203   3              stLocalControl.stBusDealFreq.bySndSecAddr = 0x00;
2204   3              stLocalControl.stBusDealFreq.bySndRoomAddr=0x00;
2205   3              stLocalControl.stBusDealFreq.bySndBedAddr =0x00;
2206   3              stLocalControl.stBusDealFreq.byCmd= CMD_TELL_RF_NUM;
2207   3              stLocalControl.stBusDealFreq.byRecSecAddr = 0x00;
2208   3              stLocalControl.stBusDealFreq.byRecRoomAddr=0x00;
2209   3              stLocalControl.stBusDealFreq.byRecBedAddr =0x00;
2210   3              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2211   3            }
2212   2            break;
2213   2            
2214   2          case CMD_BUS_ANSWER:
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 37  

2215   2              if(( stLocalControl.stBusDealFreq.bySndSecAddr ==stLocalControl.stEepromCfgData.bySelfSecAddr)&&
2216   2              (stLocalControl.stBusDealFreq.bySndRoomAddr==stLocalControl.stEepromCfgData.bySelfRoomAddr)&&
2217   2              (stLocalControl.stBusDealFreq.bySndBedAddr ==stLocalControl.stEepromCfgData.bySelfBedAddr))
2218   2              {//是本机应答信号
2219   3                if(stLocalControl.uiWaitAckTimeSupplyOxEnd)
2220   3                {
2221   4                  if(stLocalControl.stBusDealFreq.byRecSecAddr == CMD_SUPPLY_OX_END)
2222   4                {
2223   5                  stLocalControl.uiWaitAckTimeSupplyOxEnd =0; //停止计时
2224   5                  //bWillSndTotalOx =0;
2225   5                }
2226   4                }
2227   3                if(stLocalControl.uiWaitAckTimeSupplyOxTotal)
2228   3                {
2229   4                  if(stLocalControl.stBusDealFreq.byRecSecAddr == CMD_SUPPLY_OX_TOTAL)
2230   4                {
2231   5                  stLocalControl.uiWaitAckTimeSupplyOxTotal =0; //停止计时
2232   5                  //bWillSndTotalOx =0;
2233   5                }
2234   4                }
2235   3              
2236   3              }
2237   2            break;
2238   2          case CMD_PC_OPEN:
2239   2            if(AddrCompare(&(stLocalControl.stBusDealFreq)))
2240   2            {
2241   3              if(bWillSndTotalOx)
2242   3              {
2243   4                stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2244   4                stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2245   4                stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2246   4                Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2247   4      
2248   4              }
2249   3            }
2250   2            break;
2251   2          case CMD_PC_CLOSE:
2252   2            if(AddrCompare(&(stLocalControl.stBusDealFreq)))
2253   2            {
2254   3              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2255   3              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2256   3              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;     
2257   3              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2258   3            }
2259   2            break;
2260   2          case CMD_BUS0_CHECK:                  //外部总线测试命令
2261   2            MUS=0;  //SD、SA通道正常
2262   2            
2263   2            stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER; 
2264   2            stLocalControl.stBusDealFreq.byRecSecAddr = CMD_BUS0_CHECK;
2265   2            Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2266   2            break;  
2267   2            
2268   2      /*    case CMD_SD_MS_TEST_START:  //SD通道主到从测试开始
2269   2            stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER; 
2270   2            stLocalControl.stBusDealFreq.byRecSecAddr = CMD_SD_MS_TEST_START;
2271   2            Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2272   2            XTD=0;
2273   2            OpenCGB();
2274   2            MUT =0; //打开功放34119
2275   2            break;
2276   2      
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 38  

2277   2          case CMD_SD_SM_TEST_START:  //SD通道从到主测试开始
2278   2            stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER; 
2279   2            stLocalControl.stBusDealFreq.byRecSecAddr = CMD_SD_SM_TEST_START;
2280   2            Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2281   2            XTD=1;
2282   2            CloseCGB();
2283   2            MUT =1; //关闭功放34119
2284   2            break;
2285   2            
2286   2          case CMD_SD_TEST_END: //SD通道测试结束
2287   2            stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER; 
2288   2            stLocalControl.stBusDealFreq.byRecSecAddr = CMD_SD_TEST_END;
2289   2            Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2290   2            XTD=0;
2291   2            CloseCGB();
2292   2            MUT =1; //关闭功放34119
2293   2            break;
2294   2      
2295   2          case CMD_SA_MS_TEST_START:  //SA通道主到从测试开始
2296   2            stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER; 
2297   2            stLocalControl.stBusDealFreq.byRecSecAddr = CMD_SA_MS_TEST_START;
2298   2            Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2299   2            XTA = 0;
2300   2            OpenCBD();
2301   2            MUT =0; //打开功放34119
2302   2            break;
2303   2      
2304   2          case CMD_SA_SM_TEST_START:  //SA通道从到主测试开始
2305   2            stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER; 
2306   2            stLocalControl.stBusDealFreq.byRecSecAddr = CMD_SA_SM_TEST_START;
2307   2            Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2308   2            XTA = 1;
2309   2            CloseCBD();
2310   2            MUT =1; //关闭功放34119
2311   2            break;
2312   2            
2313   2          case CMD_SA_TEST_END: //SA通道测试结束
2314   2            stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER; 
2315   2            stLocalControl.stBusDealFreq.byRecSecAddr = CMD_SA_TEST_END;
2316   2            Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2317   2            XTA = 0;
2318   2            CloseCBD();
2319   2            MUT =1; //关闭功放34119
2320   2            break;
2321   2      */  
2322   2          case CMD_SD_TAL_VOL_CHECK:
2323   2            MUS=0;  //SD通道正常
2324   2            
2325   2            stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER; 
2326   2            stLocalControl.stBusDealFreq.byRecSecAddr = CMD_SD_TAL_VOL_CHECK;
2327   2            Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2328   2            XTD=1;
2329   2            OpenCGB();
2330   2            MUT =0; //打开功放34119
2331   2            break;
2332   2          case CMD_SD_TAL_VOL_CHECK_END:
2333   2            MUS=0;  //SD通道正常
2334   2            
2335   2            stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER; 
2336   2            stLocalControl.stBusDealFreq.byRecSecAddr = CMD_SD_TAL_VOL_CHECK_END;
2337   2            Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));     
2338   2            break;
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 39  

2339   2      
2340   2          case CMD_SA_TAL_VOL_CHECK:
2341   2            MUS=0;  //SD通道正常
2342   2            
2343   2            stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER; 
2344   2            stLocalControl.stBusDealFreq.byRecSecAddr = CMD_SA_TAL_VOL_CHECK;
2345   2            Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2346   2            XTA = 1;
2347   2            OpenCBD();
2348   2            MUT =0; //打开功放34119
2349   2            break;
2350   2      
2351   2          case CMD_SA_TAL_VOL_CHECK_END:
2352   2            MUS=0;  //SD通道正常
2353   2            
2354   2            stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER; 
2355   2            stLocalControl.stBusDealFreq.byRecSecAddr = CMD_SA_TAL_VOL_CHECK_END;
2356   2            Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2357   2            XTA = 0;
2358   2            CloseCBD();
2359   2            MUT =1; //关闭功放34119
2360   2            break;      
2361   2          case CMD_RS485_BRT_SET:
2362   2            Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));     
2363   2            break;  
2364   2      
2365   2          case CMD_RS485_INFO_SEC_ROOM:
2366   2            Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));     
2367   2            break;  
2368   2            
2369   2          case CMD_BED_VOICE_PLAY:
2370   2            if(stLocalControl.stBusDealFreq.byRecSecAddr)
2371   2              stLocalControl.stEepromCfgData.byBedFjFlag |= BedVoicePlay;
2372   2            else stLocalControl.stEepromCfgData.byBedFjFlag &= ~BedVoicePlay;
2373   2            SaveParameter();
2374   2            break;
2375   2      
2376   2          case CMD_DISP_MODE:
2377   2            Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));           
2378   2            break;
2379   2      
2380   2          case CMD_COLOR_CLEAR:
2381   2            if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
2382   2            {
2383   3              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2384   3      
2385   3              stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER; 
2386   3              stLocalControl.stBusDealFreq.byRecSecAddr = CMD_COLOR_CLEAR;
2387   3              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2388   3            }
2389   2            break;
2390   2            
2391   2          default:
2392   2            break;
2393   2      
2394   2        } 
2395   1      }
2396          
2397          /**********************************************************
2398          *函数名称     :Bus0SendDeal 
2399          *函数描述         :单总线0发送完一帧数据处理函数,该函数首先
2400                     取出收到的数据,针对每条命令执行对应的控
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 40  

2401                     制动作
2402          *输入参数       :
2403          *返回值       :
2404          *全局变量     :stLocalControl
2405          *调用模块       :
2406          ***********************************************************
2407          *创建人           :尹运同
2408          *创建日期     :2008-9-22
2409          ***********************************************************
2410          *修改人         :
2411          *修改日期       :
2412          *注释           :
2413          **********************************************************/
2414          void Bus0SendDeal(void)
2415          { 
2416   1        //取出发送完成的数据帧
2417   1        OS_ENTER_CRITICAL();
2418   1        memcpy(&(stLocalControl.stBusDealFreq), byBus0SendData, sizeof(STBusFreq));   
2419   1        bBus0SendFinish = 0;
2420   1        OS_EXIT_CRITICAL(); 
2421   1      
2422   1        //以下仅供测试用
2423   1        //调试用
2424   1      #if DEBUG==1  
2425   1      //    Send_Data(&(stLocalControl.stBusDealFreq.bySndSecAddr),7);
2426   1      #endif
2427   1        /////////////////////////////////////////////////////////////////////////////////////
2428   1      
2429   1        switch(stLocalControl.stBusDealFreq.byCmd)
2430   1        {
2431   2          case CMD_LANDING:                   //登记命令
2432   2            if(bLanding)
2433   2            { //本机确实处在登记状态,设置等待确认超时
2434   3              MakeCH0TimerOut(150, 0);        
2435   3            }     
2436   2            break;
2437   2          case CMD_INFUSION_CALL:
2438   2          case CMD_SERVICE_CALL:
2439   2          case CMD_EMERGENCY_CALL:
2440   2          case CMD_HELP_CALL:
2441   2            //命令还是原命令不变
2442   2            Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2443   2            break;
2444   2          case CMD_COMM_CALL:                 //普通呼叫命令              
2445   2          case CMD_INFUSION_ANSWER:             //处理输液呼叫
2446   2          case CMD_SERVICE_ANSWER:              //处理服务呼叫
2447   2          case CMD_EMERGENCY_ANSWER:              //处理紧急呼叫
2448   2          case CMD_HELP_ANSWER:               //处理求援呼叫
2449   2            //停止正在指示的呼叫
2450   2            if(bIndicatingOther)
2451   2            { 
2452   3              bIndicatingOther = 0; 
2453   3              if(bNurseIn)
2454   3              {         
2455   4                VoiceChannelCtx();
2456   4                LedControl();       
2457   4              }     
2458   3            }
2459   2            if(!bBusy)
2460   2            { //不忙,进入等待应答状态,保存主叫方地址,设置超时
2461   3              bBusy = bWaitAck = 1;
2462   3              SaveCallAddr(&(stLocalControl.stBusDealFreq));        
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 41  

2463   3              MakeCH0TimerOut(250, 0);            
2464   3            }       
2465   2            break;  
2466   2          case CMD_COMM_ANSWER:                 //普通应答命令
2467   2            if(bBusy)
2468   2            {
2469   3      
2470   3              bCalledRing = 1;  
2471   3              if((bChannel1Talk|bChannel1Talked))
2472   3              { //本机已经处于通话状态了,缩短超时,退出            
2473   4                MakeCH0TimerOut(5, 0);
2474   4                break;
2475   4              } 
2476   3              
2477   3              MakeCH0TimerOut(50, stLocalControl.stEepromCfgData.byRingTime);         
2478   3              //VoiceChannelCtx();
2479   3              LedControl();
2480   3              if(bEnAutoListen)
2481   3              { //自动接听
2482   4                OSWait(K_TMO,50); //此处延时1000ms,以避免主机会莫名收不到CMD_CALL_LISTEN命令
2483   4                stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2484   4                stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2485   4                stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2486   4                stLocalControl.stBusDealFreq.byCmd = CMD_CALL_LISTEN;
2487   4                stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stCallAddr.bySndSecAddr;
2488   4                stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stCallAddr.bySndRoomAddr;
2489   4                stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stCallAddr.bySndBedAddr;
2490   4                Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2491   4                
2492   4              }             
2493   3            }
2494   2            break;
2495   2          case CMD_CALL_LISTEN:               //接听命令
2496   2            if(bBusy)
2497   2            {
2498   3              bCalledRing = 0;
2499   3              bChannel0Talked = 1;              
2500   3              if((bChannel1Talk|bChannel1Talked))
2501   3              {   //本机已经处于通话状态了,缩短超时,退出            
2502   4                MakeCH0TimerOut(5, 0);
2503   4                break;
2504   4              }
2505   3              //设置通话超时
2506   3              MakeCH0TimerOut(50, stLocalControl.stEepromCfgData.byTalkTime);                     
2507   3              VoiceChannelCtx();
2508   3              LedControl();
2509   3              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2510   3            }
2511   2            break;
2512   2          case CMD_BROADCAST1:
2513   2          case CMD_BROADCAST2:
2514   2          case CMD_BROADCAST3:                      //广播命令
2515   2            //停止正在指示的呼叫
2516   2            if(bIndicatingOther)
2517   2            { 
2518   3              bIndicatingOther = 0;
2519   3              if(bNurseIn)
2520   3              {
2521   4                VoiceChannelCtx();
2522   4                LedControl();           
2523   4              }
2524   3            }
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 42  

2525   2            if(!bBusy)
2526   2            { 
2527   3              bBusy = 1;  
2528   3              //保存主动呼叫方地址(本机地址)        
2529   3              SaveCallAddr(&(stLocalControl.stBusDealFreq));
2530   3              bSelfBroad = 1;
2531   3              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2532   3              if((bChannel1Talk|bChannel1Talked)||(!bDealKeyDown))
2533   3              { //本机广播条件不存在了,缩短超时,退出        
2534   4                MakeCH0TimerOut(5, 0);
2535   4                break;
2536   4              }
2537   3              //设置广播超时
2538   3              MakeCH0TimerOut(50, stLocalControl.stEepromCfgData.byBroadTime);
2539   3              VoiceChannelCtx();
2540   3              LedControl();
2541   3            }
2542   2            break;
2543   2          case CMD_INFUSION_CLEAR:              //清除输液呼叫
2544   2          case CMD_SERVICE_CLEAR:               //清除服务呼叫
2545   2          case CMD_HELP_CLEAR:                //清除求援呼叫
2546   2          case CMD_EMERGENCY_CLEAR:             //清除紧急呼叫
2547   2            if(AddrCompare(&(stLocalControl.stBusDealFreq)))
2548   2            { //清除自己的呼叫,清除相应标志
2549   3      
2550   3              if(stLocalControl.stBusDealFreq.byCmd == CMD_INFUSION_CLEAR)
2551   3              {       
2552   4                bConfusionNoting = 0;
2553   4              }
2554   3              else if(stLocalControl.stBusDealFreq.byCmd == CMD_SERVICE_CLEAR)
2555   3              {
2556   4                bServiceNoting = 0;
2557   4              }
2558   3              else if(stLocalControl.stBusDealFreq.byCmd == CMD_HELP_CLEAR)
2559   3              {
2560   4                bHelpNoting = 0;
2561   4              }
2562   3              else
2563   3              {
2564   4                bEmergencyNoting = 0;
2565   4              } 
2566   3              SysReset();
2567   3              //VoiceChannelCtx();
2568   3              //LedControl();         
2569   3            }
2570   2            else if(bIndicatingOther &&
2571   2              (stLocalControl.stBusDealFreq.byRecSecAddr == stLocalControl.stIndicationData.stAddr.bySndSecAddr) &&
2572   2              (stLocalControl.stBusDealFreq.byRecRoomAddr == stLocalControl.stIndicationData.stAddr.bySndRoomAddr) &
             -&
2573   2              (stLocalControl.stBusDealFreq.byRecBedAddr == stLocalControl.stIndicationData.stAddr.bySndBedAddr) &&
2574   2              ((stLocalControl.stBusDealFreq.byCmd - 0x0a) == (stLocalControl.stIndicationData.byCallCmd & 0x1f)))//
             -对应的呼叫命令
2575   2            { //清除本机正在指示的呼叫            
2576   3              bIndicatingOther = 0;
2577   3              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));       
2578   3              if(bNurseIn)
2579   3              {
2580   4                VoiceChannelCtx();
2581   4                LedControl();         
2582   4              }                 
2583   3            }       
2584   2            break;  
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 43  

2585   2      
2586   2          case CMD_CHANNEL_CLOSE:               //关闭语音通道命令
2587   2            bChannel1Talk = bChannel1Talked = 0;      
2588   2            MakeCH1TimerOut(0, 0);
2589   2            VoiceChannelCtx();
2590   2            LedControl();
2591   2            Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2592   2            break;  
2593   2          case CMD_GET_BUS:                 //占用总线
2594   2            Bus0SendPin = 1;                //制造总线故障
2595   2            SaveParameter();
2596   2            Bus0SendPin = 0;                //释放总线
2597   2            MUT = bMUTState;        
2598   2            break;
2599   2          case CMD_SYSTERM_RESET:               //系统复位命令
2600   2            SysReset();
2601   2            break; 
2602   2          case CMD_BUS_ANSWER:
2603   2            switch(stLocalControl.stBusDealFreq.byRecSecAddr)
2604   2            {
2605   3              case CMD_NUMBER_SET:
2606   3              //发送占用总线命令
2607   3                stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS;     
2608   3                Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2609   3                break;
2610   3              case CMD_POWER_ON:
2611   3                if((bOxSupplyState==1)/*&&(bEnableOxTimer==1)*/)
2612   3                {//如果正处于供氧计时状态
2613   4                  memcpy(&(stLocalControl.stBusDealFreq.bySndSecAddr),&(stLocalControl.stEepromCfgData.bySelfSecAddr),
             -3);
2614   4                  stLocalControl.stBusDealFreq.byCmd= CMD_SUPPLY_OX_END;        
2615   4                  memcpy(&(stLocalControl.stBusDealFreq.byRecSecAddr),&(stLocalControl.stEepromCfgData.bySelfSecAddr),
             -3);
2616   4                  Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2617   4                }
2618   3                OSWait(K_TMO,200);
2619   3                stLocalControl.stBusDealFreq.byCmd = CMD_POWER_ON;
2620   3                Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); 
2621   3                break; 
2622   3                
2623   3      /*        case CMD_OPEN_485BUS_IN:
2624   3                stLocalControl.stBusDealFreq.byCmd = CMD_OPEN_485BUS_IN;
2625   3                Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2626   3                break;          
2627   3      */  
2628   3      
2629   3              case CMD_SD_TAL_VOL_CHECK_END:
2630   3                XTD=0;
2631   3                CloseCGB();
2632   3                MUT =1; //关闭功放34119
2633   3                break;
2634   3      
2635   3              case CMD_SD_TAL_VOL_CHECK:
2636   3      //          LED_DEAL = bLedDealState=1; //灯亮
2637   3                break;
2638   3      
2639   3              case CMD_SA_TAL_VOL_CHECK:
2640   3                LED_DEAL = bLedDealState=1; //灯亮
2641   3                break;
2642   3            }
2643   2            break;
2644   2          case CMD_SUPPLY_OX_TOTAL:
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 44  

2645   2            bWillSndTotalOx=0;
2646   2            break;
2647   2            
2648   2          default:
2649   2            break;      
2650   2      
2651   2        } 
2652   1      }
2653          
2654          
2655          /**********************************************************
2656          *函数名称     :BusManage  
2657          *函数描述         :单总线0管理线程
2658          *输入参数       :
2659          *返回值       :
2660          *全局变量     :byMainCmdQ
2661          *调用模块       :OSQPost
2662          ***********************************************************
2663          *创建人           :尹运同
2664          *创建日期     :2008-9-22
2665          ***********************************************************
2666          *修改人         :
2667          *修改日期       :
2668          *注释           :
2669          **********************************************************/
2670          void BusManage(void)
2671          {   
2672   1        while(TRUE)
2673   1        {   
2674   2          if(bBus0RecFinish)                  //总线0收到数据
2675   2          {   
2676   3            OSQPost(byMainCmdQ, BUS0_REC);        
2677   3          }
2678   2          if(bBus0SendFinish)                 //总线0发送完数据帧
2679   2          {
2680   3            OSQPost(byMainCmdQ, BUS0_SND);      
2681   3          }
2682   2          if(bBus1RecFinish)                  //总线1收到数据
2683   2          {       
2684   3            OSQPost(byMainCmdQ, BUS1_REC);        
2685   3          }
2686   2          if(bBus1SendFinish)                 //总线1发送完数据帧
2687   2          {
2688   3            OSQPost(byMainCmdQ, BUS1_SND);      
2689   3          }   
2690   2          OSWait(K_TMO, 1); 
2691   2          WDT_CONTR = 0x3d;   //@20MHz,1.25s
2692   2        }
2693   1      }
2694          
2695          
2696          
2697          /**********************************************************
2698          *函数名称     :Bus0Manage 
2699          *函数描述         :单总线0管理线程
2700          *输入参数       :
2701          *返回值       :
2702          *全局变量     :byMainCmdQ
2703          *调用模块       :OSQPost
2704          ***********************************************************
2705          *创建人           :尹运同
2706          *创建日期     :2008-9-22
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 45  

2707          ***********************************************************
2708          *修改人         :
2709          *修改日期       :
2710          *注释           :
2711          **********************************************************/
2712          /*void Bus0Manage(void)
2713          {   
2714            while(TRUE)
2715            {   
2716              if(bBus0RecFinish)                  //总线0收到数据
2717              {   
2718                OSQPost(byMainCmdQ, BUS0_REC);        
2719              }
2720              if(bBus0SendFinish)                 //总线0发送完数据帧
2721              {
2722                OSQPost(byMainCmdQ, BUS0_SND);      
2723              } 
2724              OSWait(K_TMO, 1);         
2725            }
2726          }
2727           */
2728          /**********************************************************
2729          *函数名称     :Bus1RecDeal  
2730          *函数描述         :单总线1收到一帧数据处理函数,该函数首先
2731                     取出收到的数据,针对每条命令执行对应的控
2732                     制动作
2733          *输入参数       :
2734          *返回值       :
2735          *全局变量     :
2736          *调用模块       :
2737          ***********************************************************
2738          *创建人           :陈卫国
2739          *创建日期     :2008-9-22
2740          ***********************************************************
2741          *修改人         :
2742          *修改日期       :
2743          *注释           :
2744          **********************************************************/
2745          void Bus1RecDeal(void)
2746          {
2747   1        //取出单总线1收到的数据帧 
2748   1        OS_ENTER_CRITICAL();
2749   1        memcpy(&(stLocalControl.stBusDealFreq), byBus1RecData, sizeof(STBusFreq));  
2750   1        bBus1RecFinish = 0;
2751   1        OS_EXIT_CRITICAL();
2752   1      #if DEBUG==1  
2753   1      //  Send_Data((uint8 *)&(stLocalControl.stBusDealFreq),7);
2754   1      #endif
2755   1      
2756   1       
2757   1      //  if(bLanding) return;  //上电状态
2758   1        
2759   1        switch(stLocalControl.stBusDealFreq.byCmd)
2760   1        {
2761   2          case CMD_LANDING:                   //登记命令  
2762   2            if(bLanding == 0)
2763   2            {//已经上电登记成功   
2764   3              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2765   3              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2766   3              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2767   3              stLocalControl.stBusDealFreq.byCmd = CMD_ENTER;
2768   3              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.byBedFjFlag;
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 46  

2769   3              stLocalControl.stBusDealFreq.byRecRoomAddr = 0x00;
2770   3              stLocalControl.stBusDealFreq.byRecBedAddr = 0x00;     
2771   3              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2772   3            }
2773   2            break;  
2774   2      
2775   2      
2776   2          case CALL_KEY_DOWN:
2777   2            if(bLanding == 0)
2778   2            {//已经上电登记成功
2779   3              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2780   3              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2781   3              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2782   3              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stBusDealFreq.bySndSecAddr;
2783   3              stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stBusDealFreq.bySndRoomAddr;
2784   3              stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stBusDealFreq.bySndBedAddr;        
2785   3              if(!(bChannel1Talk|bChannel1Talked|bConfusionNoting|bServiceNoting|
2786   3                bChannel0Talk|bChannel0Talked|bCalledRing))   
2787   3              { //设备空闲状态
2788   4                stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.byPrio;
2789   4                stLocalControl.stBusDealFreq.byCmd = CMD_INFUSION_CALL;
2790   4                Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));       
2791   4              }
2792   3              else if((bConfusionNoting&&bEnHandDown))
2793   3              { //设备正在呼叫中,且允许手柄挂断呼叫   
2794   4                stLocalControl.stBusDealFreq.byCmd = CMD_INFUSION_CLEAR;        
2795   4                Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));       
2796   4              }
2797   3              
2798   3              else if((bServiceNoting&&bEnHandDown))
2799   3              { //设备正在服务呼叫中,且允许手柄挂断呼叫   
2800   4                stLocalControl.stBusDealFreq.byCmd = CMD_SERVICE_CLEAR;       
2801   4                Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));       
2802   4              }       
2803   3              else if(bChannel1Talked&&bEnHandDown)
2804   3              { //设备正中通道1中被动对讲,且允许手柄挂断            
2805   4                stLocalControl.stBusDealFreq.byCmd = CMD_CHANNEL_CLOSE; 
2806   4      /*          stLocalControl.stBusDealFreq.byRecSecAddr = 0xff;
2807   4                stLocalControl.stBusDealFreq.byRecRoomAddr = 0xff;
2808   4                stLocalControl.stBusDealFreq.byRecBedAddr = 0xff;
2809   4      */
2810   4                stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stCallAddr.bySndSecAddr;
2811   4                stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stCallAddr.bySndRoomAddr;;
2812   4                stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stCallAddr.bySndBedAddr;
2813   4                Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));     
2814   4              }
2815   3              else if(bChannel0Talked&&bEnHandDown)
2816   3              {   //设备正中通道0中被动对讲,且允许手柄挂断
2817   4                stLocalControl.stBusDealFreq.byCmd = CMD_SYSTERM_RESET;
2818   4                stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stCallAddr.bySndSecAddr;
2819   4                stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stCallAddr.bySndRoomAddr;
2820   4                stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stCallAddr.bySndBedAddr;
2821   4                Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));       
2822   4              }
2823   3            }
2824   2            break;
2825   2      
2826   2            
2827   2          case CALL_KEY_UP:
2828   2          case CALL_KEY_ALWAYS:
2829   2            break;
2830   2            
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 47  

2831   2          case CMD_DATA_ERROR:
2832   2            Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2833   2            break;
2834   2          case CMD_BUS_ANSWER:
2835   2            Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2836   2            if(stLocalControl.stBusDealFreq.byRecSecAddr == CMD_DISPLAY_DATA /*||stLocalControl.stBusDealFreq.byRec
             -SecAddr == CMD_SB_DISPLAY_DATA*/)
2837   2            {//只有床头信息才保存数据
2838   3              //bit0=0:该床位有病人
2839   3              stLocalControl.stEepromCfgData.byBedFjFlag &= 0xfe;     
2840   3              stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS;
2841   3              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2842   3            }     
2843   2            break;  
2844   2      
2845   2      
2846   2          case CMD_INFUSION_CALL:     //从输液报警器上无线传过来的信号
2847   2            if(bLanding == 0)
2848   2            {//已经上电登记成功
2849   3              if(!(bChannel1Talk|bChannel1Talked|bConfusionNoting|
2850   3                bChannel0Talk|bChannel0Talked|bCalledRing))   
2851   3              { //设备空闲状态
2852   4                stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2853   4                stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2854   4                stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2855   4        //        stLocalControl.stBusDealFreq.byCmd = CMD_INFUSION_CALL;
2856   4                stLocalControl.stBusDealFreq.byCmd = CMD_SERVICE_CALL;
2857   4                stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.byPrio;
2858   4                stLocalControl.stBusDealFreq.byRecRoomAddr =0x00;
2859   4                stLocalControl.stBusDealFreq.byRecBedAddr =0x00;
2860   4                Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));       
2861   4              }
2862   3            }
2863   2            break;
2864   2            case CMD_RF_NUMSET_START:
2865   2            if(!(bChannel1Talk|bChannel1Talked|bConfusionNoting|
2866   2              bChannel0Talk|bChannel0Talked|bCalledRing|bRFNumSeting))  
2867   2            {//设备空闲状态 且没在输液报警器对码状态
2868   3              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); //返回显示模块使其显示
2869   3              memcpy(RFSerial,&(stLocalControl.stBusDealFreq.bySndSecAddr),3);
2870   3              memcpy(&(RFSerial[3]),&(stLocalControl.stBusDealFreq.byRecSecAddr),3);
2871   3              bRFNumSeting=1;
2872   3              stLocalControl.uiRFNumSetTime=250;      //编号10秒内有效        
2873   3            }
2874   2            break;
2875   2          case CMD_SUPPLY_OX_END:
2876   2            Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2877   2            stLocalControl.uiWaitAckTimeSupplyOxEnd=250;    //5S内收到供氧结束信号的应答命令
2878   2            break;
2879   2            
2880   2          case CMD_SUPPLY_OX_TOTAL:
2881   2            Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2882   2            stLocalControl.uiWaitAckTimeSupplyOxTotal=250;    //5S内收到供氧总计信号的应答命令
2883   2            break;  
2884   2      
2885   2          case CMD_BUS1_TEST_ANSWER:  //来自显示模块的确认命令
2886   2            bBus1Answer =1;
2887   2            break;
2888   2      
2889   2          case CMD_BUS1_CHECK:       //单总线1检测命令
2890   2            stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2891   2            stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 48  

2892   2            stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2893   2            stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER;
2894   2            stLocalControl.stBusDealFreq.byRecSecAddr = CMD_BUS1_CHECK;
2895   2            stLocalControl.stBusDealFreq.byRecRoomAddr = 0x00;
2896   2            stLocalControl.stBusDealFreq.byRecBedAddr = 0x00;     
2897   2            Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2898   2            break; 
2899   2      
2900   2          case CMD_NURSE_IN:
2901   2            stLocalControl.uiNurseInTime=NURSE_IN_TIME;       //如果5秒内未收到护士到位命令，即认为护士离开
2902   2            if(bNurseIn==0)
2903   2            {   
2904   3              MoveFjNum = stLocalControl.stBusDealFreq.bySndBedAddr;
2905   3              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));     
2906   3            }
2907   2            bNurseIn=1; 
2908   2            VoiceChannelCtx();
2909   2            break;
2910   2      
2911   2          case CMD_INSPECTOR_CALL:      //护士查房命令  
2912   2            stLocalControl.uiNurseInTime=NURSE_IN_TIME;
2913   2            MoveFjNum = stLocalControl.stBusDealFreq.bySndBedAddr;
2914   2            Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2915   2            break;
2916   2            
2917   2          default:
2918   2            break;      
2919   2        }   
2920   1      
2921   1      }
2922          
2923          
2924          
2925          void IrDATreat(void)  //数据处理函数
2926          {
2927   1      
2928   1        OS_ENTER_CRITICAL();
2929   1        memcpy(byIrDADealBuff,byIrDARecBuff,4);       //把数据从接收区复制到缓冲区
2930   1        memset(byIrDARecBuff,0x00,4);           //将接收缓冲区清0
2931   1        OS_EXIT_CRITICAL();
2932   1        if(byIrDADealBuff[3]==(uint8)(byIrDADealBuff[0]+byIrDADealBuff[1]+byIrDADealBuff[2]))
2933   1        {//校验和正确
2934   2          switch(byIrDADealBuff[2])
2935   2          {
2936   3          case IrDA_CMD_NURSE_IN:
2937   3            bSetKeyDown = 1;                //保存设置键的状态
2938   3            stLocalControl.uiNurseInTime=NURSE_IN_TIME;       //如果5秒内未收到护士到位命令，即认为护士离开
2939   3            if(bNurseIn==0)
2940   3            {
2941   4              MoveFjNum = byIrDADealBuff[1];//移动分机号
2942   4              
2943   4              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2944   4              stLocalControl.stBusDealFreq.bySndRoomAddr= MOVE_FJ;
2945   4              stLocalControl.stBusDealFreq.bySndBedAddr= byIrDADealBuff[1];//移动分机号
2946   4              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2947   4              stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2948   4              stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;   
2949   4              stLocalControl.stBusDealFreq.byCmd = CMD_NURSE_IN;
2950   4              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2951   4              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2952   4            }
2953   3            bNurseIn=1; 
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 49  

2954   3            VoiceChannelCtx();
2955   3            break;
2956   3          case IrDA_CMD_INSPECTION:     //护士查房命令  
2957   3            if((stLocalControl.stEepromCfgData.byBedFjFlag & bDispMode)==0)
2958   3            {//供氧信息显示模式
2959   4                    //将查房操作视供氧计时开始与结束
2960   4      
2961   4              if(stLocalControl.stEepromCfgData.byBedFjFlag&OX_SUPPLY_STATE) //处于供氧状态
2962   4              {//停止供氧计时
2963   5                stLocalControl.stEepromCfgData.byBedFjFlag &= (~OX_SUPPLY_STATE);   //标志清0
2964   5                SaveParameter();
2965   5                bWillSndOxSupplyStart=0;
2966   5                  
2967   5                
2968   5                if(bEnableOxTimer==1) //已接收到时间数据
2969   5                {         
2970   6                  
2971   6                  memcpy(&(stLocalControl.stBusDealFreq.bySndSecAddr),&(stLocalControl.stEepromCfgData.bySelfSecAddr),
             -3);
2972   6                  stLocalControl.stBusDealFreq.byCmd= CMD_SUPPLY_OX_END;        
2973   6                  memcpy(&(stLocalControl.stBusDealFreq.byRecSecAddr),&(stLocalControl.stEepromCfgData.bySelfSecAddr),
             -3);
2974   6                  Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); 
2975   6                  bOxSupplyState=0;
2976   6      //            bWillSndOxSupplyEnd =0;
2977   6                }
2978   5      //          else bWillSndOxSupplyEnd =1;
2979   5              }
2980   4              
2981   4              else//处于未供氧状态
2982   4              {//开始计时 
2983   5                stLocalControl.stEepromCfgData.byBedFjFlag |= (OX_SUPPLY_STATE);   //标志置1
2984   5                SaveParameter();
2985   5      //          bWillSndOxSupplyEnd =0;
2986   5                
2987   5                if(bEnableOxTimer==1) //已接收到时间数据
2988   5                {
2989   6                  memcpy(&(stLocalControl.stBusDealFreq.bySndSecAddr),&(stLocalControl.stEepromCfgData.bySelfSecAddr),
             -3);
2990   6                  stLocalControl.stBusDealFreq.byCmd= CMD_SUPPLY_OX_START;
2991   6                  Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2992   6                  Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2993   6                  bWillSndOxSupplyStart=0;
2994   6                  bOxSupplyState=1;
2995   6            
2996   6                }
2997   5                else bWillSndOxSupplyStart=1;
2998   5              }
2999   4      
3000   4      
3001   4      
3002   4      //不再执行查房操作
3003   4      /*        stLocalControl.uiNurseInTime=NURSE_IN_TIME;
3004   4              MoveFjNum = byIrDADealBuff[1];//移动分机号
3005   4              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
3006   4              stLocalControl.stBusDealFreq.bySndRoomAddr= MOVE_FJ;
3007   4              stLocalControl.stBusDealFreq.bySndBedAddr= byIrDADealBuff[1];//移动分机号 
3008   4              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;;
3009   4              stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
3010   4              stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;   
3011   4              stLocalControl.stBusDealFreq.byCmd = CMD_INSPECTOR_CALL;
3012   4              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));*/
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 50  

3013   4            }
3014   3            else 
3015   3            {//色块模式
3016   4      
3017   4              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;;
3018   4              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
3019   4              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
3020   4              stLocalControl.stBusDealFreq.byCmd = CMD_COLOR_CLEAR;
3021   4              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3022   4              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3023   4            }
3024   3            break;
3025   3            
3026   3          }
3027   2        }
3028   1      }
3029          
3030          
3031          
3032          void IrDANumberSet(void)  //数据处理函数
3033          {
3034   1      
3035   1        OS_ENTER_CRITICAL();
3036   1        memcpy(byIrDADealBuff,byIrDARecBuff,6);       //把数据从接收区复制到缓冲区
3037   1        memset(byIrDARecBuff,0x00,6);           //将接收缓冲区清0
3038   1        OS_EXIT_CRITICAL();
3039   1      
3040   1        switch(byIrDADealBuff[4])
3041   1        {
3042   2          case 0x5a:
3043   2            //暂存主呼方地址数据中
3044   2            stLocalControl.stBusDealFreq.bySndSecAddr = byIrDADealBuff[1];
3045   2            stLocalControl.stBusDealFreq.bySndRoomAddr = byIrDADealBuff[2];
3046   2            stLocalControl.stBusDealFreq.bySndBedAddr = byIrDADealBuff[3];
3047   2            stLocalControl.stBusDealFreq.byCmd    =   0x5a;
3048   2              
3049   2            stLocalControl.stCallAddr.bySndSecAddr=stLocalControl.stBusDealFreq.bySndSecAddr;
3050   2            stLocalControl.stCallAddr.bySndRoomAddr=stLocalControl.stBusDealFreq.bySndRoomAddr;
3051   2            stLocalControl.stCallAddr.bySndBedAddr =stLocalControl.stBusDealFreq.bySndBedAddr;
3052   2            bNumSeting=1;
3053   2            stLocalControl.byNumSetTime=250;      //编号5秒内有效
3054   2            stLocalControl.stBusDealFreq.byRecSecAddr=0x01; //开始编号
3055   2            Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); //显示开始编号
3056   2            break;
3057   2          default:
3058   2            break;
3059   2        }
3060   1      }
3061          
3062          /**********************************************************
3063          *函数名称     :Bus1SendDeal 
3064          *函数描述         :单总线1发送完一帧数据处理函数,该函数首先
3065                     取出收到的数据,针对每条命令执行对应的控
3066                     制动作
3067          *输入参数       :
3068          *返回值       :
3069          *全局变量     :
3070          *调用模块       :
3071          ***********************************************************
3072          *创建人           :陈卫国
3073          *创建日期     :2008-9-22
3074          ***********************************************************
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 51  

3075          *修改人         :
3076          *修改日期       :
3077          *注释           :
3078          **********************************************************/
3079          void Bus1SendDeal(void)
3080          { 
3081   1        //取出数据帧
3082   1        OS_ENTER_CRITICAL();
3083   1        memcpy(&(stLocalControl.stBusDealFreq), byBus1SendData, sizeof(STBusFreq)); 
3084   1        bBus1SendFinish = 0;
3085   1        OS_EXIT_CRITICAL();
3086   1        
3087   1      #if DEBUG==1
3088   1      //  Send_Data(byBus1SendData,7);
3089   1      #endif
3090   1      
3091   1        switch(stLocalControl.stBusDealFreq.byCmd)
3092   1        {
3093   2      /*    case CMD_ENTER: 
3094   2            OS_ENTER_CRITICAL();
3095   2            memcpy(&(stLocalControl.stBusDealFreq.bySndSecAddr),&(stLocalControl.stEepromCfgData.byRFSerialNum1),3)
             -;
3096   2            stLocalControl.stBusDealFreq.byCmd = CMD_TELL_RF_NUM;
3097   2            memcpy(&(stLocalControl.stBusDealFreq.byRecSecAddr),&(stLocalControl.stEepromCfgData.byRFSerialNum4),3)
             -;
3098   2      
3099   2            Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3100   2            OS_EXIT_CRITICAL();     
3101   2            break;
3102   2      */
3103   2          case CMD_POWER_ON:
3104   2            OS_ENTER_CRITICAL();
3105   2            //关闭所有打开的中断
3106   2            CCAPM0 = 0x00;
3107   2            ET0 = 0;
3108   2            TR0 = 0;
3109   2            EX0 = 0;
3110   2            ISP_CONTR = 0x20; 
3111   2            break;
3112   2          case CMD_OPEN_LCD:
3113   2            //bit1=1:显示屏背光打开
3114   2            stLocalControl.stEepromCfgData.byBedFjFlag |= 0x02;
3115   2            if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
3116   2            {//绝对地址
3117   3              stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS;
3118   3              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3119   3            }
3120   2            else 
3121   2            {//广播地址
3122   3              Bus0SendPin = 1;                //制造总线故障
3123   3              SaveParameter();
3124   3              Bus0SendPin = 0;                //释放总线            
3125   3            }
3126   2            break;
3127   2            
3128   2          case CMD_CLOSE_LCD:
3129   2            //bit1=0:显示屏背光关闭
3130   2            stLocalControl.stEepromCfgData.byBedFjFlag &= 0xfd;
3131   2            if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
3132   2            {//绝对地址
3133   3              stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS;
3134   3              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 52  

3135   3            }
3136   2            else 
3137   2            {//广播地址
3138   3              Bus0SendPin = 1;                //制造总线故障
3139   3              SaveParameter();
3140   3              Bus0SendPin = 0;                //释放总线            
3141   3            }
3142   2            break;
3143   2      
3144   2          case CMD_OPEN_485BUS_IN:
3145   2            //bit0=0:该床位有病人
3146   2      //      stLocalControl.stEepromCfgData.byBedFjFlag &= 0xfe;
3147   2      //      SaveParameter();
3148   2            break;
3149   2            
3150   2          case CMD_CLEAR_LCD:
3151   2            //bit0=1:该床位病人出院
3152   2            stLocalControl.stEepromCfgData.byBedFjFlag |= 0x01;
3153   2            if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
3154   2            {//绝对地址
3155   3              stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS;
3156   3              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3157   3            }
3158   2            else 
3159   2            {//广播地址
3160   3              Bus0SendPin = 1;                //制造总线故障
3161   3              SaveParameter();
3162   3              Bus0SendPin = 0;                //释放总线            
3163   3            }
3164   2            break;
3165   2          case CMD_SYSTEM_SEC_SET:
3166   2            stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS;     //为保存数据作准备    
3167   2            Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); 
3168   2            break;
3169   2            
3170   2          case CMD_DISP_MODE:
3171   2            if(stLocalControl.stBusDealFreq.byRecSecAddr)  stLocalControl.stEepromCfgData.byBedFjFlag |= bDispMode;
3172   2            else stLocalControl.stEepromCfgData.byBedFjFlag &= ~bDispMode;
3173   2            
3174   2            //保存显示模式
3175   2            WDT_CONTR = 0x3d;   //喂狗
3176   2            EA=0;
3177   2            SaveParameter();
3178   2            EA=1;
3179   2            break;  
3180   2      
3181   2          case CMD_RS485_INFO_SEC_ROOM:
3182   2            if(stLocalControl.stBusDealFreq.byRecSecAddr)  stLocalControl.stEepromCfgData.byBedFjFlag |= bSecRoom;
3183   2            else stLocalControl.stEepromCfgData.byBedFjFlag &= ~bSecRoom;
3184   2            
3185   2            //保存是否判断区号房号
3186   2            WDT_CONTR = 0x3d;   //喂狗
3187   2            EA=0;
3188   2            SaveParameter();
3189   2            EA=1;
3190   2            break;      
3191   2      
3192   2      //    case CMD_COLOR_CLEAR:
3193   2      //      bColorSet=0;
3194   2      //      break;
3195   2            
3196   2          default:
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 53  

3197   2            break;
3198   2      
3199   2      
3200   2        }
3201   1      }
3202          /**********************************************************
3203          *函数名称     :Bus1Manage 
3204          *函数描述         :单总线1管理线程
3205          *输入参数       :
3206          *返回值       :
3207          *全局变量     :
3208          *调用模块       :
3209          ***********************************************************
3210          *创建人           :陈卫国
3211          *创建日期     :2008-9-22
3212          ***********************************************************
3213          *修改人         :
3214          *修改日期       :
3215          *注释           :
3216          **********************************************************/
3217          /*void Bus1Manage(void)
3218          {   
3219            while(TRUE)
3220            {   
3221              if(bBus1RecFinish)                  //总线1收到数据
3222              {       
3223                OSQPost(byMainCmdQ, BUS1_REC);        
3224              }
3225              if(bBus1SendFinish)                 //总线1发送完数据帧
3226              {
3227                OSQPost(byMainCmdQ, BUS1_SND);      
3228              } 
3229              OSWait(K_TMO, 1);         
3230            }
3231          } */
3232          
3233          
3234          
3235          /**********************************************************
3236          
3237          
3238          
3239          
3240          /**********************************************************
3241          *函数名称     :TimerOutDeal 
3242          *函数描述         :超时处理函数
3243          *输入参数       :
3244          *返回值       :
3245          *全局变量     :stLocalControl
3246          *调用模块       :Bus0OutputData,Bus1OutputData,VoiceChannelCtx,
3247                     LedControl,SetHandLedState
3248          ***********************************************************
3249          *创建人           :尹运同
3250          *创建日期     :2008-9-22
3251          ***********************************************************
3252          *修改人         :
3253          *修改日期       :
3254          *注释           :
3255          **********************************************************/
3256          void TimerOutDeal(void)
3257          { 
3258   1        if(stLocalControl.stCH0TimerOut.byTimerOut != 0)
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 54  

3259   1        { //有超时设置存在
3260   2          stLocalControl.stCH0TimerOut.byTimerOut--;
3261   2          if(stLocalControl.stCH0TimerOut.byTimerOut == 0)
3262   2          { //超时一次到了 
3263   3            if(stLocalControl.stCH0TimerOut.byTimerOutCount == 0x00)
3264   3            {   //所有超时完成
3265   4              goto TIMER0OUTDEAL;
3266   4            }
3267   3            else
3268   3            { //超时次数没有完
3269   4              stLocalControl.stCH0TimerOut.byTimerOutCount--;
3270   4              if(stLocalControl.stCH0TimerOut.byTimerOutCount == 0x00)
3271   4              {   //所有超时完成
3272   5      TIMER0OUTDEAL:
3273   5                if(bLanding)
3274   5                { //上电状态
3275   6                  stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
3276   6                  stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
3277   6                  stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
3278   6                  stLocalControl.stBusDealFreq.byCmd = CMD_LANDING;
3279   6                  stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.bySerialNum1;
3280   6                  stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stEepromCfgData.bySerialNum2;
3281   6                  stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stEepromCfgData.bySerialNum3;
3282   6                  Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));           
3283   6                }
3284   5                else if((bWaitAck|bWaitListen|bChannel0Talk|bSelfBroad))
3285   5                { //等待应答，等待接听，主动通话，主动广播状态        
3286   6                  stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
3287   6                  stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
3288   6                  stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
3289   6                  stLocalControl.stBusDealFreq.byCmd = CMD_SYSTERM_RESET;
3290   6                  stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stCallAddr.byRecSecAddr;
3291   6                  stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stCallAddr.byRecRoomAddr;
3292   6                  stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stCallAddr.byRecBedAddr;
3293   6                  Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3294   6                }               
3295   5                else
3296   5                {
3297   6                  bBusy = bCalledRing = bChannel0Talked = bSickRoomBroad = bOfficeBroad = bAllBroad = 0;
3298   6                  VoiceChannelCtx();
3299   6                  LedControl();           
3300   6                }
3301   5              }
3302   4              else
3303   4              {   //超时次数没有完成，重新加载单位超时时间        
3304   5                stLocalControl.stCH0TimerOut.byTimerOut = stLocalControl.stCH0TimerOut.byTimerOutSet;
3305   5              }
3306   4            }     
3307   3          }
3308   2        }
3309   1        //通道1超时处理
3310   1        if(stLocalControl.stCH1Timerout.byTimerOut != 0)
3311   1        { //有超时设置存在
3312   2          stLocalControl.stCH1Timerout.byTimerOut--;
3313   2          if(stLocalControl.stCH1Timerout.byTimerOut == 0)
3314   2          { //超时一次到了 
3315   3            if(stLocalControl.stCH1Timerout.byTimerOutCount == 0x00)
3316   3            {   //所有超时完成
3317   4              goto TIMER1OUTDEAL;
3318   4            }
3319   3            else
3320   3            { //超时次数没有完
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 55  

3321   4              stLocalControl.stCH1Timerout.byTimerOutCount--;
3322   4              if(stLocalControl.stCH1Timerout.byTimerOutCount == 0x00)
3323   4              {   //所有超时完成
3324   5      TIMER1OUTDEAL:
3325   5                if(bChannel1Talk)
3326   5                { //主动通话状态，发送切换命令            
3327   6                  stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
3328   6                  stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
3329   6                  stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;           
3330   6                  stLocalControl.stBusDealFreq.byCmd = CMD_CHANNEL_CLOSE; 
3331   6      /*            
3332   6                  stLocalControl.stBusDealFreq.byRecSecAddr = 0xff;
3333   6                  stLocalControl.stBusDealFreq.byRecRoomAddr = 0xff;
3334   6                  stLocalControl.stBusDealFreq.byRecBedAddr = 0xff; 
3335   6      */
3336   6                  stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stCallAddr.byRecSecAddr;
3337   6                  stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stCallAddr.byRecRoomAddr;;
3338   6                  stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stCallAddr.byRecBedAddr;
3339   6                  Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); 
3340   6                }
3341   5                else if(bChannel1Talked)
3342   5                { //被动通话状态，自己复位
3343   6                  bChannel1Talked = 0;              
3344   6                  VoiceChannelCtx();
3345   6                  LedControl();
3346   6                }
3347   5              }
3348   4              else
3349   4              {   //超时次数没有完成，重新加载单位超时时间        
3350   5                stLocalControl.stCH1Timerout.byTimerOut = stLocalControl.stCH1Timerout.byTimerOutSet;
3351   5              }
3352   4            }     
3353   3          }
3354   2        } 
3355   1        if(stLocalControl.uiNurseInTime)
3356   1        {
3357   2          if(--stLocalControl.uiNurseInTime == 0x00)  
3358   2          { //检测护士到位的定时时间到  定为5S
3359   3            stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;;
3360   3            stLocalControl.stBusDealFreq.bySndRoomAddr= MOVE_FJ;
3361   3            stLocalControl.stBusDealFreq.bySndBedAddr= MoveFjNum;//移动分机号
3362   3            stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
3363   3            stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
3364   3            stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;   
3365   3            stLocalControl.stBusDealFreq.byCmd = CMD_NURSE_OUT;
3366   3            Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3367   3            Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3368   3            bNurseIn=0;
3369   3      
3370   3      
3371   3            if(bIndicatingOther)
3372   3            {
3373   4      
3374   4              if((stLocalControl.stIndicationData.stAddr.bySndSecAddr == stLocalControl.stEepromCfgData.bySelfSecAdd
             -r) &&
3375   4                ((stLocalControl.stIndicationData.stAddr.bySndRoomAddr) == (stLocalControl.stEepromCfgData.bySelfRoom
             -Addr))&&
3376   4                (stLocalControl.stIndicationData.stAddr.bySndBedAddr == stLocalControl.stEepromCfgData.bySelfBedAddr)
             -)
3377   4              {//是本机
3378   5                
3379   5              }
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 56  

3380   4              else
3381   4              {//信息指示分机不是本机
3382   5                if(bServiceNoting || bConfusionNoting || bHelpNoting ||bEmergencyNoting||bChannel0Talk||bChannel1Talk
             -||bChannel0Talked||bChannel1Talked)
3383   5                {//分机呼叫状态
3384   6                }
3385   5      
3386   5                else
3387   5                {
3388   6                  bIndicatingOther = 0;       
3389   6      
3390   6                  //VoiceChannelCtx();
3391   6                  LedControl(); 
3392   6      
3393   6                  stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stIndicationData.stAddr.bySndSecAddr;
3394   6                  stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stIndicationData.stAddr.bySndRoomAddr;
3395   6                  stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stIndicationData.stAddr.bySndBedAddr;
3396   6                  stLocalControl.stBusDealFreq.byCmd = CMD_STOP_INDICATION; 
3397   6                  stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
3398   6                  stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
3399   6                  stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
3400   6      
3401   6                  Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3402   6                }
3403   5                
3404   5              }
3405   4        
3406   4            }
3407   3      
3408   3            VoiceChannelCtx();
3409   3          }
3410   2        }
3411   1        //灯状态控制
3412   1        if(--stLocalControl.byLedFlashTime == 0x00)
3413   1        {
3414   2          stLocalControl.byLedFlashTime = stLocalControl.byLedTimeSet;
3415   2          if((stLocalControl.byLedState & 0x0f) == LED_FLASH)
3416   2          {   //红灯闪烁状态
3417   3            bLedDealState = !bLedDealState;
3418   3            LED_DEAL = bLedDealState;
3419   3          } 
3420   2        }
3421   1        if(stLocalControl.byIrDataIntervalTimer)
3422   1        {
3423   2          if(--stLocalControl.byIrDataIntervalTimer==0x00)  //间隔时间到
3424   2          {
3425   3            if(IrDataPosit==4)  
3426   3            {
3427   4              if(byIrDARecBuff[3]==(uint8)(byIrDARecBuff[0]+byIrDARecBuff[1]+byIrDARecBuff[2]))
3428   4              {
3429   5                bFourByteRec=1;
3430   5      
3431   5              }
3432   4            }
3433   3      
3434   3            else if(IrDataPosit==6)
3435   3            {
3436   4              if(byIrDARecBuff[5]==(uint8)(byIrDARecBuff[0]+byIrDARecBuff[1]+byIrDARecBuff[2]+byIrDARecBuff[3]+byIrD
             -ARecBuff[4]))
3437   4              {
3438   5      
3439   5                bSixByteRec =1;
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 57  

3440   5              }
3441   4      
3442   4            }
3443   3            
3444   3            IrDataPosit=0x00;
3445   3            
3446   3          }
3447   2        }
3448   1      
3449   1      
3450   1        if(stLocalControl.byNumSetTime)
3451   1        {
3452   2          if(--stLocalControl.byNumSetTime==0)        //编号时间到
3453   2          {
3454   3            bNumSeting=0;
3455   3            stLocalControl.stBusDealFreq.byCmd =CMD_NUMBER_SET;
3456   3            stLocalControl.stBusDealFreq.byRecSecAddr =0x00;  //退出编号
3457   3            Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3458   3          }
3459   2        }
3460   1        if(stLocalControl.uiRFNumSetTime)
3461   1        {
3462   2          if(--stLocalControl.uiRFNumSetTime==0)        //编号时间到
3463   2          {
3464   3            bRFNumSeting=0;
3465   3            stLocalControl.stBusDealFreq.byCmd =CMD_RF_NUMSET_END;
3466   3            Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3467   3          }
3468   2        }
3469   1        
3470   1      /*  if(stLocalControl.uiWaitAckTimeSupplyOxEnd)
3471   1        {
3472   1          if(--stLocalControl.uiWaitAckTimeSupplyOxEnd==0)
3473   1          {//供氧计时结束的等待应答时间到
3474   1            bWillSndTotalOx =1;
3475   1          }
3476   1        }
3477   1      
3478   1        if(stLocalControl.uiWaitAckTimeSupplyOxTotal)
3479   1        {
3480   1          if(--stLocalControl.uiWaitAckTimeSupplyOxTotal==0)
3481   1          {//供氧计时总计的等待应答时间到
3482   1            bWillSndTotalOx =1;
3483   1          }
3484   1        }
3485   1      */
3486   1      
3487   1        stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
3488   1        stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
3489   1        stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
3490   1        if(stLocalControl.uiBus1TestTime)
3491   1        {
3492   2          if(--stLocalControl.uiBus1TestTime==0)
3493   2          {//总线1测试间隔时间到
3494   3            stLocalControl.stBusDealFreq.byCmd = CMD_BUS1_TEST;
3495   3            Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3496   3            stLocalControl.uiBus1TestTime = BUS1_TEST_TIME;
3497   3            stLocalControl.byBus1AnswerTime = 250;
3498   3          }
3499   2        }
3500   1      
3501   1        if(stLocalControl.byBus1AnswerTime)
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 58  

3502   1        {
3503   2          if(--stLocalControl.byBus1AnswerTime==0)
3504   2          {//总线1测试应答时间到
3505   3            if(bBus1Answer)
3506   3            {
3507   4              bBus1Answer = 0;
3508   4            }
3509   3            else
3510   3            {
3511   4              if((bOxSupplyState==1)/*&&(bEnableOxTimer==1)*/)
3512   4              {//如果正处于供氧计时状态
3513   5                memcpy(&(stLocalControl.stBusDealFreq.bySndSecAddr),&(stLocalControl.stEepromCfgData.bySelfSecAddr),3
             -);
3514   5                stLocalControl.stBusDealFreq.byCmd= CMD_SUPPLY_OX_END;        
3515   5                memcpy(&(stLocalControl.stBusDealFreq.byRecSecAddr),&(stLocalControl.stEepromCfgData.bySelfSecAddr),3
             -);
3516   5                Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3517   5              }
3518   4              OSWait(K_TMO,200);      
3519   4              stLocalControl.stBusDealFreq.byCmd = CMD_POWER_ON;
3520   4              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3521   4            }
3522   3          }
3523   2        }
3524   1      
3525   1      
3526   1        
3527   1        if(Bus0RecPin ==1)  //总线正常
3528   1        {
3529   2          BusLowDTime = 100;  //20ms*100=2s   
3530   2        }
3531   1        else
3532   1        {//Bus0RecPin =0
3533   2          if(BusLowDTime)
3534   2          {
3535   3            if(--BusLowDTime ==0)
3536   3            {
3537   4              MUS =1; //断开SD到总线
3538   4              Bus0SendPin =0; //使SD为高电平
3539   4              OSWait(K_TMO,100);
3540   4              WDT_CONTR = 0x3d;
3541   4              if(Bus0RecPin ==0)
3542   4              {//本机有故障
3543   5                stLocalControl.stBusDealFreq.byCmd = CMD_SEND_PIN_BUG;
3544   5                stLocalControl.stBusDealFreq.byRecSecAddr = 0x00;
3545   5                Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3546   5                while(Bus0RecPin==0)  //一直等待为高
3547   5                {
3548   6                  if(bBus1RecFinish)
3549   6                  {
3550   7                    memcpy(&(stLocalControl.stBusDealFreq), byBus1RecData, sizeof(STBusFreq));  
3551   7                    bBus1RecFinish = 0; 
3552   7                    if(stLocalControl.stBusDealFreq.byCmd==CMD_LANDING)
3553   7                    {
3554   8                      stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
3555   8                      stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
3556   8                      stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
3557   8                      stLocalControl.stBusDealFreq.byCmd = CMD_ENTER;
3558   8                      stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.byBedFjFlag;
3559   8                      stLocalControl.stBusDealFreq.byRecRoomAddr = 0x00;
3560   8                      stLocalControl.stBusDealFreq.byRecBedAddr = 0x00;     
3561   8                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));             
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 59  

3562   8                    }
3563   7                    
3564   7                  }
3565   6                  Bus0SendPin =0; //使SD为高电平
3566   6                  MUS =1; //断开SD到总线
3567   6      
3568   6                  OSWait(K_TMO,50); //延时200ms－－－－快闪
3569   6                  bLedDealState = !bLedDealState;
3570   6                  LED_DEAL = bLedDealState;
3571   6                  WDT_CONTR = 0x3d;   //@20MHz,1.25s
3572   6                }         
3573   5                MUS = 0;  //使SD线路连通
3574   5                Bus0SendPin =0; //使SD为高电平
3575   5                bLedDealState = 0;
3576   5                LED_DEAL = 0;
3577   5      
3578   5                BusLowDTime = 100;
3579   5                stLocalControl.stBusDealFreq.byCmd = CMD_SEND_PIN_BUG;
3580   5                stLocalControl.stBusDealFreq.byRecSecAddr = 0x01;
3581   5                Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));         
3582   5              }
3583   4      
3584   4              
3585   4              else 
3586   4              {//是外部总线引起
3587   5                //总线故障
3588   5                stLocalControl.stBusDealFreq.byCmd = CMD_SEND_PIN_BUG;
3589   5                stLocalControl.stBusDealFreq.byRecSecAddr = 0x02;
3590   5                Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3591   5      
3592   5      
3593   5              
3594   5                MUS = 0;  //使SD线路连通
3595   5                Bus0SendPin=0;
3596   5                OSWait(K_TMO,100);
3597   5                WDT_CONTR = 0x3d;
3598   5                
3599   5                do
3600   5                {
3601   6                  MUS = 0;  //使SD线路连通
3602   6                  Bus0SendPin=0;
3603   6      
3604   6      
3605   6                  OSWait(K_TMO,150);  //延时600ms－－－－慢闪
3606   6                  bLedDealState = !bLedDealState;
3607   6                  LED_DEAL = bLedDealState;
3608   6                  WDT_CONTR = 0x3d;   //@20MHz,1.25s
3609   6              
3610   6                  
3611   6                  if(bBus1RecFinish)
3612   6                  {
3613   7                    memcpy(&(stLocalControl.stBusDealFreq), byBus1RecData, sizeof(STBusFreq));  
3614   7                    bBus1RecFinish = 0; 
3615   7                    if(stLocalControl.stBusDealFreq.byCmd==CMD_LANDING)
3616   7                    {
3617   8                      stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
3618   8                      stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
3619   8                      stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
3620   8                      stLocalControl.stBusDealFreq.byCmd = CMD_ENTER;
3621   8                      stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.byBedFjFlag;
3622   8                      stLocalControl.stBusDealFreq.byRecRoomAddr = 0x00;
3623   8                      stLocalControl.stBusDealFreq.byRecBedAddr = 0x00;     
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 60  

3624   8                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));             
3625   8                    }
3626   7                    
3627   7                  }           
3628   6                }while(Bus0RecPin==0);  //等待SD线路一直为高
3629   5                
3630   5                bLedDealState = 0;
3631   5                LED_DEAL = 0;
3632   5      
3633   5                stLocalControl.stBusDealFreq.byCmd = CMD_SEND_PIN_BUG;
3634   5                stLocalControl.stBusDealFreq.byRecSecAddr = 0x03;
3635   5                Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3636   5      Bus0BugRet:         
3637   5                MUS = 0;  //使SD线路连通          
3638   5                BusLowDTime = 100;
3639   5              }       
3640   4            }
3641   3          }
3642   2        } 
3643   1      }
*** WARNING C280 IN LINE 3636 OF SINGLEBUS.C: 'Bus0BugRet': unreferenced label
3644          /**********************************************************
3645          *函数名称     :TimerOutManager  
3646          *函数描述         :超时管理线程
3647          *输入参数       :
3648          *返回值       :
3649          *全局变量     :stLocalControl,byMainCmdQ
3650          *调用模块       :OSQPost        
3651          ***********************************************************
3652          *创建人           :尹运同
3653          *创建日期     :2008-9-22
3654          ***********************************************************
3655          *修改人         :
3656          *修改日期       :
3657          *注释           :
3658          **********************************************************/ 
3659          void TimerOutManager(void)   
3660          {   
3661   1        while(1)
3662   1        {   
3663   2          OSWait(K_TMO, 4);                 //设置20ms超时
3664   2          WDT_CONTR = 0x3d;   //@20MHz,1.25s
3665   2          if(stLocalControl.stCH0TimerOut.byTimerOut)
3666   2          { 
3667   3            OSQPost(byMainCmdQ, TIMER_OUT);       
3668   3          }
3669   2          else
3670   2          {   
3671   3            OSQPost(byMainCmdQ, TIMER_OUT); 
3672   3          }     
3673   2        }
3674   1      }     


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8706    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    199       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     29    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
C51 COMPILER V9.00   SINGLEBUS                                                             01/08/2019 09:35:52 PAGE 61  

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
