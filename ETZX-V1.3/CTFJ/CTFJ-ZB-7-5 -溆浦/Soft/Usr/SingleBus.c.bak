/*
************************Copyright(c)************************
*	  			   湖南熙旺达科技有限公司
*			       	All Rights Reserved
*			     		 
*
*-----------------------文件信息---------------------------
*文件名称     		:SingleBus.c
*文件描述    		:单总线程序
*创建人     		:陈卫国
*创建日期   		:2008-9-22
*版本号       		:V1.0
*注释	     		:					
*----------------------------------------------------------
*修改人  			:
*修改日期  			:
*版本号        		:
*注释	     		:
***********************************************************
*/
#define _IN_SINGLE_BUS_
#include "config.h"

//总线0变量定义
uint8 bdata byBus0State0 	= 0;							//单总线0状态字1
sbit  bBus0StartRec			= byBus0State0^0;				//单总线0开始接收起始位标志
sbit  bBus0OnRec			= byBus0State0^1;				//单总线0开始接收数据位标志
sbit  bBus0Enable			= byBus0State0^2;				//单总线0允许发送标志
sbit  bBus0ReqSend			= byBus0State0^3;				//单总线0请求发送标志
sbit  bBus0OnSendBit		= byBus0State0^4;				//单总线0正在发送一个数据位标志
sbit  bBus0OnSendFreq		= byBus0State0^5;				//单总线0正在发送一个数据帧标志
sbit  bBus0SendError		= byBus0State0^6;				//单总线0发送错误标志
sbit  bBus0Error			= byBus0State0^7;				//单总线0故障标志
uint8 bdata byBus0State1 	= 0;  							//单总线0状态字2
sbit  bBus0RecFinish		= byBus0State1^0;				//单总线0接收完成标志
sbit  bBus0RecBit9			= byBus0State1^1;				//单总线0接收字节数据的第9位
sbit  bBus0SendFinish		= byBus0State1^2;				//单总线0发送完成标志
sbit  bBus0Disable			= byBus0State1^3;				//单总线0禁止发送标志
sbit  bBus0SendBit			= byBus0State1^4;				//单总线0正在发送的数据位
sbit  bBus0RecBit			= byBus0State1^5; 				//单总线0正在接收的数据位
uint8 data byBus0RecCount = 0;								//高4位是总线0接收定时中断计数，低4位是接收到的位计数
uint8 data byBus0RecBuf;									//总线0接收缓冲单元
uint8 data byBus0SendBuf;									//总线0发送缓冲单元	
uint8 data byBus0RecData[BUS0_FREQ_SIZE];					//总线0接收缓冲区
uint8 data byBus0SendData[BUS0_FREQ_SIZE];					//总线0发送缓冲区
uint8 data byBus0SendCount = 0;								//高4位是总线0发送定时中断计数，低4位是发送的位计数
uint8 data byBus0RecSendCount = 0;							//高4位是总线0接收到的字节计数，低4位是总线0发送完的字节计数
uint8 data byBus0SendStopCount;								//总线0停止时间计数
uint8 data byBus0RecTimeOut = 0;							//总线0接收超时计数
uint8 data byBus0DisableCount = 0;							//总线0禁止计数	 
uint8 xdata byBus0TxQ[BUS0_TX_Q_ZISE];						//总线0发送队列							
uint8 data byBus0TxHead = 0;								//单总线0发送队列头指针
uint8 data byBus0TxTail = 0; 								//单总线0发送队列尾指针
#define IncBus0TxPtr(addr)    {addr=(addr+1)%BUS0_TX_Q_ZISE;}
#define Bus0TxBuffLen()	      ((byBus0TxTail+BUS0_TX_Q_ZISE-byBus0TxHead)%BUS0_TX_Q_ZISE) 
sbit  Bus0RecPin	= P3^2;									//单总线0接收引脚定义
sbit  Bus0SendPin	= P1^2;									//单总线0发送引脚定义
//变量定义   
extern uint8	OS_Q_MEM_SEL	byMainCmdQ[]; 
extern STLocalControl 	xdata stLocalControl; 
	 
/**********************************************************
*函数名称			:SingleBusInit	
*函数描述        	:单总线初始化
*输入参数   		:
*返回值				: 	
*全局变量			:
*调用模块  			:
***********************************************************
*创建人	      		:陈卫国
*创建日期	 		:2008-9-22
***********************************************************
*修改人	  			:
*修改日期    		:
*注释		      	:
**********************************************************/
void SingleBusInit(void)
{
	//总线0发送脚设置为推挽输出，接收脚设置为高阻输入:M0=0,M1=0:准双向，M0=0,M1=1:推挽，M0=1,M1=0:高阻，M0=1,M1=1:开漏
	//P3^2,高阻,P1^2,推挽
	P3M0 |= Bin(0,0,0,0,0,1,0,0);
	P3M1 &= (~Bin(0,0,0,0,0,1,0,0));
	P1M0 &= (~Bin(0,0,0,0,0,1,0,0));
	P1M1 |= Bin(0,0,0,0,0,1,0,0);
	//总线电平设置
	Bus0SendPin = 0;
	Bus0RecPin = 1;	 	
	//定时器0初始化:自动重载方式,定时93.75us   
    TMOD |= 0x02;
	TL0 = TIMER0_COUNT;
	TH0 = TIMER0_COUNT;
	TF0 = 0;												//清除中断标志
	AUXR &= 0x7f;											//传统12分频速度  
   	ET0 = 1;												//允许定时器0中断 
	TR0 = 1;												//启动定时器
	//其它控制设置
	byBus0SendStopCount = 240;								//上电总线0禁止发送时间设置		
	IE0 = 0;												//清除中断标志
	IT0 = 1;												//外部中断0为下降沿触发模式	 				
	if(Bus0RecPin)
	{	//如果总线正常,开中断	
		EX0 = 1;
	}
	else
	{	//如果总线不正常,置总线故障标志					
		bBus0Error = 1;
	} 	
}
/**********************************************************
*函数名称			:Bus0RecInt	
*函数描述        	:外部中断0函数,单总线0接收中断
*输入参数   		:
*返回值				: 	
*全局变量			:
*调用模块  			:
***********************************************************
*创建人	      		:陈卫国
*创建日期	 		:2008-9-22
***********************************************************
*修改人	  			:
*修改日期    		:
*注释		      	:
**********************************************************/
#pragma disable
void Bus0RecInt(void) interrupt 0
{ 	
	DisableBus0RecInt();					//禁止再次下降沿中断
	bBus0StartRec = 1;						//启动起始位沿检测
	bBus0Enable = 0;						//禁止总线发送							
	byBus0RecCount = 0;						//清接收寄存器 		
}
/**********************************************************
*函数名称			:Timer0Int	
*函数描述        	:定时器0溢出中断,定时器每93.75us中断一次
					 程序间隔检查总线0与总线1的接收和发送
*输入参数   		:
*返回值				: 	
*全局变量			:
*调用模块  			:
***********************************************************
*创建人	      		:陈卫国
*创建日期	 		:2008-9-22
***********************************************************
*修改人	  			:
*修改日期    		:
*注释		      	:
**********************************************************/
#pragma disable
void Timer0Int(void) interrupt 1
{ 	
	bBus0RecBit = Bus0RecPin; 	  	          
	/*******************************总线0接收处理***********************************/
	if(bBus0StartRec)										//判断总线所处的状态，接收到起始位
	{			
		byBus0RecCount += 0x10;								//增加定时中断计数次数
		if(0x50 == (byBus0RecCount & 0xf0))					//到总线起始位检测时间
		{			
			bBus0StartRec = 0;
			byBus0RecCount = 0x00;							//重新开始计数			
			if(bBus0RecBit)			
			{ 	//无效起始位																		
				if((!bBus0SendError)&&bBus0OnSendFreq)
				{	//没有发生过总线发送错误,且有一帧数据正在发送,停止帧数据发送,置发送错误标志						
					byBus0State0 &= (~BUS0_SEND_CON);
					bBus0SendError = 1;
					Bus0SendPin = 0;						//释放总线	 				
				}				
				byBus0SendStopCount = 240;					
				byBus0RecSendCount = 0x00;					//接收出错,重置接收发送计数值
				EnableBus0RecInt();
				PW = bPWState; 								//恢复语音功放的控制引脚
			}
			else								
			{	//有效起始位
				bBus0OnRec = 1;								//开始接收数据位 											
			}
		}
	}
	else if(bBus0OnRec)
	{		
		byBus0RecCount += 0x10;								//增加定时中断计数次数	 		
		if(0xa0 == (byBus0RecCount & 0xf0))
		{
			byBus0RecCount &= 0x0f;							//清除定时中断计数次数
			byBus0RecCount += 0x01;
			if(0x0a == (byBus0RecCount & 0x0f))	
			{	//收到第10位,结束位	  				
				bBus0OnRec = 0;								//停止数据接收					
				if(bBus0RecBit)
				{	//有效的结束位							
					if(((bit)(byBus0RecSendCount & 0xf0) == bBus0RecBit9)) 
					{	//数据桢错误
						byBus0RecTimeOut = 0;
						byBus0RecSendCount &= 0x0f;											
					}
					else 
					{	//数据桢正确					
						byBus0RecTimeOut = 230;				//设置下一个字节数据接收超时时间
						byBus0RecData[byBus0RecSendCount>>4] = byBus0RecBuf;
						byBus0RecSendCount += 0x10;																					
						if((byBus0RecSendCount & 0xf0) >= BUS0_FREQ_SIZE_HI)
						{																						
							byBus0RecSendCount &= 0x0f;							
							if(!((bBus0OnSendFreq == 1)&&(bBus0ReqSend == 0)))
							{	//如果接收到的这帧数据是自己发送的不置标志							
								bBus0RecFinish = 1;																  																						
							} 																		
							byBus0RecTimeOut = 0;
							byBus0DisableCount = 10;
							bBus0Disable = 1;				//禁止总线使用
							PW = bPWState;					//恢复语音功放的控制引脚
						}	
					}				
					byBus0SendStopCount = 240;
					EnableBus0RecInt();						
				}
				else							
				{	//无效结束位
					bBus0Error = 1;										
					if((!bBus0SendError) && bBus0OnSendFreq)
					{	//没有发生过总线发送错误,且有一帧数据正在发送,停止帧数据发送,置发送错误标志
						byBus0State0 &= (~BUS0_SEND_CON);
						bBus0SendError = 1;							
						Bus0SendPin = 0;					//释放总线
					}
					byBus0RecSendCount = 0x00;				//接收出错,重置接收发送计数值
					PW = bPWState;							//恢复语音功放的控制引脚
				}
			}
			else if(0x09 == (byBus0RecCount & 0x0f))
			{	//第9位数据
				bBus0RecBit9 = bBus0RecBit;					
			}
			else 											
			{ 	//有效数据位
				byBus0RecBuf >>= 1;
				if(bBus0RecBit)
				{	//为高电平
					byBus0RecBuf |= 0x80;
				}	
			}
		}
	}
	/*******************************总线0发送处理***********************************/
	if((byBus0State0 & BUS0_CAN_SEND) == BUS0_CAN_SEND)
	{	//总线0上有数据发送请求,且总线允许发送		
		if(bBus0RecBit)
		{	//总线正常,可以发送
			Bus0SendPin = 1;
			bBus0SendBit = 0;								//发送起始位数据 			
			byBus0SendCount = 0;
			byBus0State0 &= (~BUS0_CAN_SEND);
			byBus0SendBuf = byBus0SendData[byBus0RecSendCount & 0x0f];
			bBus0OnSendBit = 1;								//取出待发送的数据并置正在发送标志		
		}
		else
		{	//总线不正常,停止发送
			byBus0State0 &= (~BUS0_SEND_CON);
			bBus0SendError = 1;			
			byBus0RecSendCount &= 0xf0;
			Bus0SendPin = 0;
			byBus0SendStopCount = 240;
		}
	}
	else if(bBus0OnSendBit)
	{ 	//有数据位正在发送,首先发送的是起始位			
		if(bBus0SendBit == bBus0RecBit)   		
		{	//发送的数据和接收的数据相同
			byBus0SendCount += 0x10;
			if(0xa0 == (byBus0SendCount & 0xf0))
			{	//一位数据发送完毕,首先发送的是起始位
				byBus0SendCount &= 0x0f;
				byBus0SendCount += 0x01;				
				if(0x09 == (byBus0SendCount & 0x0f))
				{	//发送到第9位了
					bBus0SendBit = !(bit)(byBus0RecSendCount & 0x0f);
					Bus0SendPin = !bBus0SendBit;						
				}
				else if(0x0a == (byBus0SendCount & 0x0f))
				{	//发送到结束位了
					bBus0SendBit = 1;
					Bus0SendPin = 0;	
				}
				else if(0x0b == (byBus0SendCount & 0x0f))
				{	//已经发送完结束位了
					bBus0OnSendBit = 0;						
					byBus0RecSendCount += 0x01;									
					if((byBus0RecSendCount & 0x0f) >= BUS0_FREQ_SIZE)
					{	//发送完一帧数据												
						byBus0RecSendCount &= 0xf0;			//重新进入数据帧的发送阶段
						byBus0State0 &= (~BUS0_SEND_CON);
						byBus0SendStopCount = 240;
						byBus0State1 |= BUS0_SEND_FINISH;								
						byBus0DisableCount = 10; 						
					}
					else
					{  						
						byBus0SendStopCount = 10;
						bBus0ReqSend = 1;
					}
					EnableBus0RecInt();						//再次使能接收中断
				}
				else
				{
					if(byBus0SendBuf & 0x01)
					{	//发送高电平
						bBus0SendBit = 1;
						Bus0SendPin = 0;					
					}
					else
					{	//发送低电平
						bBus0SendBit = 0;
						Bus0SendPin = 1;
					}
					byBus0SendBuf >>= 1;					//发送数据位移位操作
				}
			}
		}
		else
		{	//不相同,发送失败								
			byBus0State0 &= ~BUS0_SEND_CON;
			byBus0RecSendCount &= 0xf0;
			bBus0SendError = 1;					
			Bus0SendPin = 0; 
			byBus0SendStopCount = 240;
		}
	} 	
	/*******************************总线0控制处理***********************************/
	if(0 == (byBus0State0 & BUS0_ON_REC))
	{	
		if(byBus0SendStopCount != 0)
		{
			if((--byBus0SendStopCount) == 0)
			{				
				bBus0Enable = 1;								
			}
		}		
		if(bBus0Error)
		{								
			bBus0Enable = 0;			
			if(bBus0RecBit)
			{				
				bBus0Error = 0;
				EnableBus0RecInt();
				byBus0SendStopCount = 240;
			}
		}
	}  
	/*******************************总线0超时处理***********************************/
	if(byBus0RecTimeOut != 0)
	{
		if(--byBus0RecTimeOut == 0)							
		{	//接收超时到
			byBus0RecSendCount &= 0x0f;
			PW = bPWState;
		}
	}
	if(byBus0DisableCount != 0)
	{
		if(--byBus0DisableCount == 0)						
		{	//禁止超时到		
			bBus0Disable = 0;
		}
	}	
	/***********总线0自动发送管理**********/	 
	if((byBus0State0 & BUS0_ON_WORK) == 0x00)				
	{	//总线0没有工作				
		if(bBus0SendError)						
		{	//产生了发送错误,自动重发								
			bBus0SendError = 0;				
			byBus0State0 |= BUS0_REQ_SEND;		
		}
		else									
		{	//总线0无发送错误		
			if(!(bBus0SendFinish|bBus0Disable))
			{	//总线0没有禁止使用,且发送结束处理已经完成
				if(Bus0TxBuffLen() >= BUS0_FREQ_SIZE)
				{ 	//有一帧完整的数据在发送队列中 																		
					byBus0SendData[0] = byBus0TxQ[byBus0TxHead];
					IncBus0TxPtr(byBus0TxHead);
					byBus0SendData[1] = byBus0TxQ[byBus0TxHead];
					IncBus0TxPtr(byBus0TxHead);
					byBus0SendData[2] = byBus0TxQ[byBus0TxHead];
					IncBus0TxPtr(byBus0TxHead);
					byBus0SendData[3] = byBus0TxQ[byBus0TxHead];
					IncBus0TxPtr(byBus0TxHead);
					byBus0SendData[4] = byBus0TxQ[byBus0TxHead];
					IncBus0TxPtr(byBus0TxHead);
					byBus0SendData[5] = byBus0TxQ[byBus0TxHead];
					IncBus0TxPtr(byBus0TxHead);
					byBus0SendData[6] = byBus0TxQ[byBus0TxHead];
					IncBus0TxPtr(byBus0TxHead);	
					byBus0State0 |= BUS0_REQ_SEND;						
				}
				else
				{	//没有一帧完整的数据在发送队列中了
					byBus0TxHead = byBus0TxTail = 0;
				}								
			}
		}
	} 
} 
/**********************************************************
*函数名称			:Bus0OutputData	
*函数描述        	:单总线0将待发送数据放入缓冲区
*输入参数   		:pbyData:待发送的数据指针
*返回值				:TRUE:发送成功,FALSE:队列满,发送失败 	
*全局变量			:
*调用模块  			:
***********************************************************
*创建人	      		:陈卫国
*创建日期	 		:2008-9-22
***********************************************************
*修改人	  			:
*修改日期    		:
*注释		      	:
**********************************************************/
uint8 Bus0OutputData(uint8* pbyData)
{
	uint8 byTemp = BUS0_FREQ_SIZE;

	OS_ENTER_CRITICAL();
	if(Bus0TxBuffLen() >= (BUS0_TX_Q_ZISE - 1))
	{	//没有空间存储了,失败	
		OS_EXIT_CRITICAL();
		return(FALSE);
	}	
	while(byTemp--)
	{	//数据入发送队列
		byBus0TxQ[byBus0TxTail] = *pbyData++;
		IncBus0TxPtr(byBus0TxTail);
	}
	OS_EXIT_CRITICAL();	
	return(TRUE);	
}
/**********************************************************
*函数名称			:AddrCompare	
*函数描述        	:比较地址(含广播地址)
*输入参数   		:pstBusFreq:待比较的数据帧指针
*返回值				:1:发送到本机的数据,0:不是发送到本机的数据	
*全局变量			:
*调用模块  			:
***********************************************************
*创建人	      		:陈卫国
*创建日期	 		:2008-9-22
***********************************************************
*修改人	  			:
*修改日期    		:
*注释		      	:
**********************************************************/
bit AddrCompare(pSTBusFreq pstBusFreq)
{
	if((pstBusFreq->byRecSecAddr != 0xff) && (pstBusFreq->byRecSecAddr != stLocalControl.stEepromCfgData.bySelfSecAddr))
	{	
		return(0);
	} 
	if((pstBusFreq->byRecRoomAddr != 0xff) && (pstBusFreq->byRecRoomAddr != stLocalControl.stEepromCfgData.bySelfRoomAddr))
	{	
		return(0);
	}
	if((pstBusFreq->byRecBedAddr != 0xff) && (pstBusFreq->byRecBedAddr != stLocalControl.stEepromCfgData.bySelfBedAddr))
	{	
		return(0);
	}
	return(1); 
}
/**********************************************************
*函数名称			:DirAddrCompare	
*函数描述        	:绝对比较地址
*输入参数   		:pstBusFreq:待比较的数据帧指针
*返回值				:1:发送到本机的数据,0:不是发送到本机的数据	
*全局变量			:
*调用模块  			:
***********************************************************
*创建人	      		:陈卫国
*创建日期	 		:2008-9-22
***********************************************************
*修改人	  			:
*修改日期    		:
*注释		      	:
**********************************************************/
bit DirAddrCompare(pSTBusFreq pstBusFreq)
{
	if(pstBusFreq->byRecSecAddr != stLocalControl.stEepromCfgData.bySelfSecAddr)
	{	
		return(0);
	} 
	if(pstBusFreq->byRecRoomAddr != stLocalControl.stEepromCfgData.bySelfRoomAddr)
	{	
		return(0);
	}
	if(pstBusFreq->byRecBedAddr != stLocalControl.stEepromCfgData.bySelfBedAddr)
	{	
		return(0);
	}
	return(1); 
}
/**********************************************************
*函数名称			:MakeCH0TimerOut	
*函数描述        	:设置通道0超时参数
*输入参数   		:byTimerOut:超时时间,byTimerOutCount:超时次数
*返回值				:
*全局变量			:stLocalControl
*调用模块  			:
***********************************************************
*创建人	      		:陈卫国
*创建日期	 		:2008-9-22
***********************************************************
*修改人	  			:
*修改日期    		:
*注释		      	:
**********************************************************/  
void MakeCH0TimerOut(uint8 byTimerOut, uint8 byTimerOutCount)
{
	stLocalControl.stCH0TimerOut.byTimerOutSet = byTimerOut;
	stLocalControl.stCH0TimerOut.byTimerOut = byTimerOut;
	stLocalControl.stCH0TimerOut.byTimerOutCount = byTimerOutCount;	
}
/**********************************************************
*函数名称			:MakeCH1TimerOut	
*函数描述        	:设置通道1超时参数
*输入参数   		:byTimerOut:超时时间,byTimerOutCount:超时次数
*返回值				:
*全局变量			:stLocalControl
*调用模块  			:
***********************************************************
*创建人	      		:陈卫国
*创建日期	 		:2008-9-22
***********************************************************
*修改人	  			:
*修改日期    		:
*注释		      	:
**********************************************************/   
void MakeCH1TimerOut(uint8 byTimerOut, uint8 byTimerOutCount)
{
	stLocalControl.stCH1Timerout.byTimerOutSet = byTimerOut;
	stLocalControl.stCH1Timerout.byTimerOut = byTimerOut;
	stLocalControl.stCH1Timerout.byTimerOutCount = byTimerOutCount;	
} 
/**********************************************************
*函数名称			:SaveIndicationData	
*函数描述        	:保存信息指示数据内容
*输入参数   		:pstBus0SendFreq:待保存的数据帧指针
*返回值				:
*全局变量			:stLocalControl
*调用模块  			:
***********************************************************
*创建人	      		:陈卫国
*创建日期	 		:2008-9-22
***********************************************************
*修改人	  			:
*修改日期    		:
*注释		      	:
**********************************************************/
void SaveIndicationData(pSTBusFreq pstBus0SendFreq)
{ 	
	stLocalControl.stIndicationData.stAddr.bySecAddr = pstBus0SendFreq->bySndSecAddr;
	stLocalControl.stIndicationData.stAddr.byRoomAddr = pstBus0SendFreq->bySndRoomAddr;
	stLocalControl.stIndicationData.stAddr.byBedAddr = pstBus0SendFreq->bySndBedAddr;
	stLocalControl.stIndicationData.byCallCmd = pstBus0SendFreq->byRecSecAddr; 
}
/**********************************************************
*函数名称			:SaveCallAddr	
*函数描述        	:保存主动通话方地址
*输入参数   		:pstBus0SendFreq:待保存的数据帧指针
*返回值				:
*全局变量			:stLocalControl
*调用模块  			:
***********************************************************
*创建人	      		:陈卫国
*创建日期	 		:2008-9-22
***********************************************************
*修改人	  			:
*修改日期    		:
*注释		      	:
**********************************************************/
void SaveCallAddr(pSTBusFreq pstBusFreq)
{ 	
	stLocalControl.stCallAddr.bySecAddr = pstBusFreq->bySndSecAddr;
	stLocalControl.stCallAddr.byRoomAddr = pstBusFreq->bySndRoomAddr;
	stLocalControl.stCallAddr.byBedAddr = pstBusFreq->bySndBedAddr;
}
/**********************************************************
*函数名称			:VoiceChannelCtx	
*函数描述        	:语音通道切换处理函数
*输入参数   		:
*返回值				:
*全局变量			:
*调用模块  			:
***********************************************************
*创建人	      		:陈卫国
*创建日期	 		:2008-9-22
***********************************************************
*修改人	  			:
*修改日期    		:
*注释		      	:
**********************************************************/ 
void VoiceChannelCtx(void)
{ 	
	if(bChannel1Talked)
	{	//通道1被动通话
		CCAP1H = stLocalControl.stEepromCfgData.byCH1TalkedVol;
		CloseCGB();
		OpenCBD();
		CTD = 0;
		bPWState = CTA = PW = 1;			
	}
	else if(bChannel1Talk)
	{ 	//通道1主动通话
		CCAP1H = stLocalControl.stEepromCfgData.byCH1TalkVol;
		CloseCGB();
		OpenCBD();
		CTD = 0;
		bPWState = CTA = PW = 1;	
	} 
	else if((bSickRoomBroad|bOfficeBroad|bAllBroad))
	{	//广播状态
		CCAP1H = stLocalControl.stEepromCfgData.byBroadVol;
		CloseCBD();
		OpenCGB();
		CTA = CTD = 0;
		bPWState = PW = 1;		
	}
	else if(bChannel0Talked)
	{	//通道0被叫通话状态
		CCAP1H = stLocalControl.stEepromCfgData.byCH0TalkedVol;
		CloseCBD();
		OpenCGB();
		CTA = 0;
		bPWState = CTD = PW = 1;		
	}
	else if(bChannel0Talk)
	{	//通道0主动通话状态
		CCAP1H = stLocalControl.stEepromCfgData.byCH0TalkVol;
		CloseCBD();
		OpenCGB();
		CTA = 0;
		bPWState = CTD = PW = 1;			
	}	
	else if(bSelfBroad)
	{	//主动广播状态
		CloseCGB();
		CloseCBD();
		bPWState = CTA = PW = 0;
		CTD = 1;			
	}
	else if((bCalledRing|bWaitListen))
	{	//被呼叫振铃或者等待接听
		CCAP1H = stLocalControl.stEepromCfgData.bySelfRingVol;
		CloseCBD();
		OpenCGB();
		CTA = CTD = 0;
		bPWState = PW = 1;		
	}
	else if((bEnSoundNote&bNurseIn&bIndicatingOther))
	{	//正在指示其它分机且护士到位
		CCAP1H = stLocalControl.stEepromCfgData.byRingVol;
		CloseCBD();
		OpenCGB();
		CTA = CTD = 0;
		bPWState = PW = 1;		
	}
	else if(bMusicPlaying)
	{	//背景音乐播放状态
		CCAP1H = stLocalControl.stEepromCfgData.byMusicVol;
		CloseCGB();
		OpenCBD();
		CTA = CTD = 0;
		bPWState = PW = 1;				
	}
	else if(bVoiceNoting)
	{	//语音提示
		CCAP1H = stLocalControl.stEepromCfgData.byNoteVol;
		CloseCGB();
		OpenCBD();
		CTA = CTD = 0;
		bPWState = PW = 1;
	}
	else
	{	//没有任何语音状态存在		
		CCAP1H = 10;
		CloseCGB();
		CloseCBD();
		bPWState = CTA = CTD = PW = 0;		
	} 	
}
/**********************************************************
*函数名称			:LedControl	
*函数描述        	:指示灯显示状态控制
*输入参数   		:
*返回值				:
*全局变量			:
*调用模块  			:SetLedDealState,SetLedSetState
***********************************************************
*创建人	      		:陈卫国
*创建日期	 		:2008-9-22
***********************************************************
*修改人	  			:
*修改日期    		:
*注释		      	:
**********************************************************/ 
void LedControl(void)
{
	if((bConfusionNoting|bServiceNoting|bHelpNoting|bEmergencyNoting))
	{	//本机有指示存在,设定处理灯慢闪
		stLocalControl.byLedTimeSet	= 50;
		SetLedDealState(LED_FLASH); 	
	}
	else if(bNurseIn&&bIndicatingOther)
	{	//正在指示其他分机,设定处理灯快闪
		stLocalControl.byLedTimeSet	= 25;
		SetLedDealState(LED_FLASH);
	}
	else if((bChannel1Talk|bChannel1Talked|bChannel0Talk|bChannel0Talked|bSelfBroad))
	{	//设备处于通话状态设定处理灯长亮
		SetLedDealState(LED_ON);	
	}
	else
	{	//处理灯灭
		SetLedDealState(LED_OFF);
	}
	if(bNurseIn)
	{ 	//护士到位,设置灯亮
		SetLedSetState(LED_ON);
	}
	else
	{	//设置灯灭
		SetLedSetState(LED_OFF);
	}	
}
/**********************************************************
*函数名称			:SysReset	
*函数描述        	:系统复位,该函数仅仅将通道0复位,将通道0
					 恢复到空闲状态
*输入参数   		:
*返回值				:
*全局变量			:
*调用模块  			:
***********************************************************
*创建人	      		:陈卫国
*创建日期	 		:2008-9-22
***********************************************************
*修改人	  			:
*修改日期    		:
*注释		      	:
**********************************************************/
void SysReset(void)
{	
	bBusy = bWaitAck = bWaitListen = bCalledRing = bChannel0Talked = bChannel0Talk = 
		bSickRoomBroad = bOfficeBroad = bAllBroad = bSelfBroad = 0;			
	MakeCH0TimerOut(0, 0);	
	VoiceChannelCtx();
	LedControl();	
}
/**********************************************************
*函数名称			:SaveParameter	
*函数描述        	:存储配置参数,存储参数前先擦除整个扇区,
					 然后将所有参数重新写入扇区
*输入参数   		:
*返回值				:
*全局变量			:stLocalControl
*调用模块  			:EnableIAP,IapErase,IapWriteByte,DisableIAP
***********************************************************
*创建人	      		:陈卫国
*创建日期	 		:2008-9-22
***********************************************************
*修改人	  			:
*修改日期    		:
*注释		      	:
**********************************************************/
void SaveParameter(void)
{  
	stLocalControl.uiShortType = IAP_ADDR;	
	stLocalControl.pbyData = &(stLocalControl.stEepromCfgData.bySelfSecAddr);
	stLocalControl.byChar1 = sizeof(STEepromCfgData);
	EnableIAP(IAP_ERASE);
	IapErase(IAP_ADDR); 	
	EnableIAP(IAP_WRITE); 
	while(stLocalControl.byChar1--)
	{
		IapWriteByte(stLocalControl.uiShortType++, *stLocalControl.pbyData++);
	}
	DisableIAP();
	//如果是在写参数命令中调用该函数,重新加载使能数据
	byEnable1 = stLocalControl.stEepromCfgData.byEnable1;
	byEnable2 = stLocalControl.stEepromCfgData.byEnable2;
}
/**********************************************************
*函数名称			:ReadParameter	
*函数描述        	:将Flash中的配置数据读入到内存中
*输入参数   		:
*返回值				:
*全局变量			:stLocalControl
*调用模块  			:EnableIAP,IapReadByte,DisableIAP
***********************************************************
*创建人	      		:陈卫国
*创建日期	 		:2008-9-22
***********************************************************
*修改人	  			:
*修改日期    		:
*注释		      	:
**********************************************************/
void ReadParameter(void)
{
	stLocalControl.uiShortType = IAP_ADDR;
	stLocalControl.pbyData = &(stLocalControl.stEepromCfgData.bySelfSecAddr);
	stLocalControl.byChar1 = sizeof(STEepromCfgData);
	EnableIAP(IAP_READ); 		
	while(stLocalControl.byChar1--)
	{ 		
		*stLocalControl.pbyData++ = IapReadByte(stLocalControl.uiShortType++);		
	}
	DisableIAP();
	//加载使能数据
	byEnable1 = stLocalControl.stEepromCfgData.byEnable1;
	byEnable2 = stLocalControl.stEepromCfgData.byEnable2;
}
/**********************************************************
*函数名称			:Bus0RecDeal	
*函数描述        	:单总线0收到一帧数据处理函数,该函数首先
					 取出收到的数据,针对每条命令执行对应的控
					 制动作
*输入参数   		:
*返回值				:
*全局变量			:stLocalControl
*调用模块  			:
***********************************************************
*创建人	      		:陈卫国
*创建日期	 		:2008-9-22
***********************************************************
*修改人	  			:
*修改日期    		:
*注释		      	:
**********************************************************/
void Bus0RecDeal(void)
{
	//取出收到的数据帧 	 		
	OS_ENTER_CRITICAL();
	memcpy(&(stLocalControl.stBusDealFreq), byBus0RecData, sizeof(STBusFreq));
	bBus0RecFinish = 0;	
	OS_EXIT_CRITICAL();	
	if(bLanding && (stLocalControl.stBusDealFreq.byCmd != CMD_ENTER))
	{	//如果是登记状态,收到的命令不是登记确认命令,不作处理
		return;
	}	
	switch(stLocalControl.stBusDealFreq.byCmd)
	{
		case CMD_ENTER:										//确认登记命令				
			if(bLanding)
			{	
				if(AddrCompare(&(stLocalControl.stBusDealFreq)))
				{ 	//发送到本机,关闭指示灯显示,取出系统状态					 					
					SetLedDealState(LED_OFF);
					SetLedSetState(LED_OFF); 									
					byDevState1 = stLocalControl.stBusDealFreq.byRecSecAddr & 0x80;				
					MakeCH0TimerOut(0, 0); 										
				}
			}			
			break;
		case CMD_QUEST:										//查询命令
			stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
			stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
			stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
			stLocalControl.stBusDealFreq.byCmd = CMD_ANSWER; 			
			Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));			
			break;				
		case CMD_COMM_CALL:	 								//普通呼叫命令
			if(!bBusy)
			{	//通道0空闲				
				bBusy = 1;
				if(bIndicatingOther)
				{	//如果正在指示其他分机,停止指示
					bIndicatingOther = 0; 					
					LedControl();
					if(bNurseIn)
					{
						VoiceChannelCtx(); 						
					}
				}
				//保存主动呼叫方地址
				SaveCallAddr(&(stLocalControl.stBusDealFreq));
				//设置超时5s				
				MakeCH0TimerOut(250, 0);
				if(AddrCompare(&(stLocalControl.stBusDealFreq)))
				{	//呼叫本机设备
					if(!(bChannel1Talk|bChannel1Talked))
					{	//通道1空闲,则本机为空闲状态,返回应答命令	
						stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
						stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
						stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
						stLocalControl.stBusDealFreq.byCmd = CMD_COMM_ANSWER;
						stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stCallAddr.bySecAddr;
						stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stCallAddr.byRoomAddr;
						stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stCallAddr.byBedAddr;
						Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); 
					}				
				}
			}
			break;
		case CMD_COMM_ANSWER: 								//普通应答命令			
			bBusy = 1; 
			//设置振铃超时			
			MakeCH0TimerOut(50, stLocalControl.stEepromCfgData.byRingTime);
			if(AddrCompare(&(stLocalControl.stBusDealFreq)))
			{	//应答本机,清等待应答,进入等待接听状态
				bWaitAck = 0;				
				bWaitListen = 1;  										
				if((bChannel1Talk|bChannel1Talked)||(!bDealKeyDown))
				{	//如果通道1忙,或者本机主动通话条件不存在了,缩短超时时间				
					MakeCH0TimerOut(5, 0);
					break;
				}
				VoiceChannelCtx();
				LedControl(); 				
			}
			break;
		case CMD_CALL_LISTEN:  								//接听命令				
			bBusy = 1;
			//设置通话超时
			MakeCH0TimerOut(50, stLocalControl.stEepromCfgData.byTalkTime);
			if(AddrCompare(&(stLocalControl.stBusDealFreq)))
			{	//接听本机,清等待接听,进入通道0主动通话状态 			
				bWaitListen = 0; 			
				bChannel0Talk = 1;								
				if((bChannel1Talk|bChannel1Talked)||(!bDealKeyDown))
				{	//如果通道1忙,或者本机主动通话条件不存在了,缩短超时时间					
					MakeCH0TimerOut(5, 0);
					break;
				}
				VoiceChannelCtx();
				LedControl();
			}
			break;			
		case CMD_BROADCAST1:								//收到病区广播命令
		case CMD_BROADCAST2:								//收到办公区广播命令
		case CMD_BROADCAST3: 								//收到全区广播命令
			if(!bBusy)
			{	//通道0空闲				
				bBusy = 1;
				//暂存命令				
				stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stBusDealFreq.byCmd;				
				//设置广播超时
				MakeCH0TimerOut(50, stLocalControl.stEepromCfgData.byBroadTime); 
				//保存主动呼叫方地址				
				SaveCallAddr(&(stLocalControl.stBusDealFreq));
				if(bIndicatingOther)
				{	//如果正在指示其他分机,停止指示	
					bIndicatingOther = 0;				
					LedControl(); 
					if(bNurseIn)
					{ 
						VoiceChannelCtx();					
					}
				}			
				if((bChannel1Talk|bChannel1Talked))
				{	//通道1忙,不作处理	
					break;
				}			
				switch(stLocalControl.stBusDealFreq.byRecSecAddr)
				{	//针对具体命令,看本机是否允许相应的广播
					case CMD_BROADCAST1:
						bSickRoomBroad = bEnSickRoomBroad;						
						break;
					case CMD_BROADCAST2:
						bOfficeBroad = bEnOfficeBroad;						
						break;
					case CMD_BROADCAST3:
						bAllBroad = bEnAllBroad; 						
						break;
				}
				VoiceChannelCtx();
				LedControl();
			}
			break;			
		case CMD_INFUSION_ENTER:								//输液呼叫确认命令
		case CMD_SERVICE_ENTER:									//服务呼叫确认命令
		case CMD_HELP_ENTER:									//求援呼叫确认命令
		case CMD_EMERGENCY_ENTER:								//紧急呼叫确认命令			
			if(AddrCompare(&(stLocalControl.stBusDealFreq)))
			{	//确认本房的呼叫命令
				switch(stLocalControl.stBusDealFreq.byCmd)
				{
					case CMD_INFUSION_ENTER:
						bConfusionNoting = 1;  						
						break;
					case CMD_SERVICE_ENTER:
						bServiceNoting = 1;								
						break;
					case CMD_HELP_ENTER:
						bHelpNoting = 1;  						
						break;
					case CMD_EMERGENCY_ENTER:
						bEmergencyNoting = 1; 						
						break;
				} 			
				if(bIndicatingOther)
				{	//如果正在指示其他分机,清指示其他分机 	 					
					bIndicatingOther = 0;
					if(bNurseIn)
					{						
						VoiceChannelCtx();							
					}			
				}  				
				LedControl();
			}
			break; 			
		case CMD_INFO_INDICATION:								//收到呼叫指示命令 	
			if((stLocalControl.stBusDealFreq.bySndSecAddr == stLocalControl.stEepromCfgData.bySelfSecAddr) &&
				((stLocalControl.stBusDealFreq.bySndRoomAddr&0x7f) == (stLocalControl.stEepromCfgData.bySelfRoomAddr&0x7f)))
			{	//如果收到的是本房的呼叫指示,不需要作处理,清除上次的呼叫指示	
				if(bIndicatingOther)
				{	
					bIndicatingOther = 0;
					if(bNurseIn)
					{						 	
						VoiceChannelCtx();
						LedControl();
					}
				}
			}
			else
			{	//收到的不是本房的呼叫指示,判断是否本机能够处理
				if(!(bBusy|bConfusionNoting|bServiceNoting|bHelpNoting|bEmergencyNoting))
				{	//本机通道0处于空闲状态,可以指示其他分机的呼叫命令了
					switch(stLocalControl.stBusDealFreq.byRecSecAddr & 0x1f)
					{
						case CMD_INFUSION_CALL:	   				//输液呼叫
							if(!bEnInfusionDeal)
							{
								return;													
							} 						
							break;
						case CMD_SERVICE_CALL:					//服务呼叫
							if(!bEnServiceDeal)
							{
								return;							
							}						
							break;
						case CMD_HELP_CALL:						//求援呼叫
							if(!bEnHelpDeal)
							{
								return;							
							} 						
							break;
						case CMD_EMERGENCY_CALL: 				//紧急呼叫
							if(!bEnEmergencyDeal)
							{
								return;						
							} 						
							break;
						default:
							return;
					}
					SaveIndicationData(&(stLocalControl.stBusDealFreq));												
					bIndicatingOther = 1;
					if((bChannel1Talked|bChannel1Talk))
					{	//如果通道1处于通话状态,不作处理
						return;
					}						
					if(bNurseIn)
					{	//护士在位,指示其他分机
						VoiceChannelCtx();
						LedControl();							
					}	
				}
			} 		
			break;
		case CMD_INFUSION_ANSWER:							//处理输液呼叫命令
		case CMD_SERVICE_ANSWER:							//处理服务呼叫命令
		case CMD_EMERGENCY_ANSWER:							//处理紧急呼叫命令
		case CMD_HELP_ANSWER:								//处理求援呼叫命令
			if(!bBusy)
			{	//通道0不忙				
				bBusy = 1;	
				//保存主动呼叫方地址	
				SaveCallAddr(&(stLocalControl.stBusDealFreq));	
				//设置通道0超时					
				MakeCH0TimerOut(250, 0);
				if(AddrCompare(&(stLocalControl.stBusDealFreq)))
				{ 	//处理本机的呼叫命令,置相应的标志 	
					if(stLocalControl.stBusDealFreq.byCmd == CMD_INFUSION_ANSWER)
					{  					
						bConfusionNoting = 0;
					}
					else if(stLocalControl.stBusDealFreq.byCmd == CMD_SERVICE_ANSWER)
					{  						 
						bServiceNoting = 0;
					}
					else if(stLocalControl.stBusDealFreq.byCmd == CMD_EMERGENCY_ANSWER)
					{  					
						bEmergencyNoting = 0;
					}
					else if(stLocalControl.stBusDealFreq.byCmd == CMD_HELP_ANSWER)
					{ 						  
						bHelpNoting = 0;
					} 					
					VoiceChannelCtx(); 				
					LedControl();
					bCalledRing = 1;
					if(!(bChannel1Talk|bChannel1Talked))
					{	//如果通道1不处于通话状态,返回应答命令
						stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
						stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
						stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
						stLocalControl.stBusDealFreq.byCmd = CMD_COMM_ANSWER;
						stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stCallAddr.bySecAddr;
						stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stCallAddr.byRoomAddr;
						stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stCallAddr.byBedAddr;
						Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); 
					}
					break;				
				}
				if(bIndicatingOther)
				{	//正在指示其他分机,清除标志	 					
					bIndicatingOther = 0;
					if(bNurseIn)
					{						
						VoiceChannelCtx();						
						LedControl(); 						
					}			
				} 
			}
			break;
		case CMD_STOP_INDICATION:							//停止指示命令
			if(bIndicatingOther)
			{
				bIndicatingOther = 0;
				if(bNurseIn)
				{
					VoiceChannelCtx();
					LedControl(); 					
				}
			}
			break;
		case CMD_INFUSION_CLEAR: 							//清除输液呼叫命令
		case CMD_SERVICE_CLEAR: 							//清除服务呼叫命令
		case CMD_HELP_CLEAR: 								//清除求援呼叫命令
		case CMD_EMERGENCY_CLEAR: 							//清除紧急呼叫命令 
			//将命令恢复成相应的呼叫命令		
			stLocalControl.stBusDealFreq.byCmd -= 0x0a;
			if(AddrCompare(&(stLocalControl.stBusDealFreq)))
			{	//清除本机的呼叫,清除相应的标志
				switch(stLocalControl.stBusDealFreq.byCmd)
				{
					case CMD_INFUSION_CALL:
						bConfusionNoting = 0;
						break;
					case CMD_SERVICE_CALL:
						bServiceNoting = 0;
						break;
					case CMD_HELP_CALL:
						bHelpNoting = 0;
						break;
					case CMD_EMERGENCY_CALL:
						bEmergencyNoting = 0;
						break;
				}							
				VoiceChannelCtx();
				LedControl();								
			}
			else if(bIndicatingOther &&
				(stLocalControl.stBusDealFreq.byRecSecAddr == stLocalControl.stIndicationData.stAddr.bySecAddr) &&
				(stLocalControl.stBusDealFreq.byRecRoomAddr == stLocalControl.stIndicationData.stAddr.byRoomAddr) &&
				(stLocalControl.stBusDealFreq.byRecBedAddr == stLocalControl.stIndicationData.stAddr.byBedAddr) &&
				(stLocalControl.stBusDealFreq.byCmd == (stLocalControl.stIndicationData.byCallCmd & 0x1f)))
			{ 	//清除本机正在指示的呼叫信息 					
				bIndicatingOther = 0;
				if(bNurseIn)
				{
					VoiceChannelCtx();
					LedControl(); 				
				}									
			}
			break; 			
		case CMD_SYSTERM_RESET:								//系统复位命令
			SysReset();
			break; 
		case CMD_START_VOICE:								//启动播音命令
			if(AddrCompare(&(stLocalControl.stBusDealFreq)))
			{				
				bChannel1Talked = bChannel1Talk = 0; 				
				MakeCH1TimerOut(0, 0);				
				bVoiceNoting = bEnVoiceNote;				
				VoiceChannelCtx();
				LedControl();								
			}
			break;
		case CMD_MUSIC_PLAY:								//背景音乐播放
			if(AddrCompare(&(stLocalControl.stBusDealFreq)))
			{			
				bChannel1Talked = bChannel1Talk = 0;
				MakeCH1TimerOut(0, 0);  			
				bMusicPlaying = bEnMusicplay;	 				
				VoiceChannelCtx();
				LedControl();					
			}
			break;	
		case CMD_STOP_VOICE:								//停止所有音乐播放
			if(AddrCompare(&(stLocalControl.stBusDealFreq)))
			{
				bVoiceNoting = bMusicPlaying = 0;
				VoiceChannelCtx();					
			}
			break; 
		case CMD_CHANNEL_CHANGE: 							//通道切换命令
			//将通道0的状态切换到通道1上,同时清除通道0的通话状态
			bBusy = bWaitAck = bWaitListen = bCalledRing =  
				bSickRoomBroad = bOfficeBroad = bAllBroad = bSelfBroad = 0;			
			MakeCH0TimerOut(0, 0);					 				
			if((bChannel0Talked|bChannel0Talk))
			{ 				
				bChannel1Talked = bChannel0Talked;
				bChannel1Talk = bChannel0Talk;
				bChannel0Talked = bChannel0Talk = 0; 				
				//设置通道1通话超时						
				MakeCH1TimerOut(50, stLocalControl.stEepromCfgData.byTalkTime);
				if(bChannel1Talk&&(!bDealKeyDown))
				{	//本机主动通话条件不存在了,缩短超时时间 	 									
					MakeCH1TimerOut(5, 0);
					break; 			
				}
				VoiceChannelCtx();
				LedControl(); 
			}							
			break;
		case CMD_CHANNEL_CLOSE: 							//关闭通道切换命令
			//清除通道1所有状态			
			bChannel1Talked = bChannel1Talk = 0; 					
			MakeCH1TimerOut(0, 0);	
			VoiceChannelCtx();
			LedControl();		
			break;		
		case CMD_NUMBER_SET:								//修改地址命令
			if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
			{
				//保存新的地址数据				
				stLocalControl.stEepromCfgData.bySelfSecAddr = stLocalControl.stBusDealFreq.bySndSecAddr;
				stLocalControl.stEepromCfgData.bySelfRoomAddr = stLocalControl.stBusDealFreq.bySndRoomAddr;
				stLocalControl.stEepromCfgData.bySelfBedAddr = stLocalControl.stBusDealFreq.bySndBedAddr;					
				//发送占用总线命令
				stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS; 			
				Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));			
			}
			break;
		case CMD_ONLINE_WRITE:								//在线写入命令
			if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
			{	
				if(stLocalControl.stBusDealFreq.bySndSecAddr >= sizeof(STEepromCfgData))
				{	//参数不正确
					break;
				}
				//存储数据
				stLocalControl.pbyData = &(stLocalControl.stEepromCfgData.bySelfSecAddr);
				stLocalControl.pbyData[stLocalControl.stBusDealFreq.bySndSecAddr] = stLocalControl.stBusDealFreq.bySndRoomAddr;				
				VoiceChannelCtx();
				//发送占用总线命令
				stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS; 			
				Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));			
			}
			break;
		case CMD_ONLIEN_READ: 								//在线读出命令
			if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
			{
				if(stLocalControl.stBusDealFreq.bySndSecAddr >= sizeof(STEepromCfgData))
				{	//参数不正确
					break;
				}			
				stLocalControl.uiShortType = IAP_ADDR + stLocalControl.stBusDealFreq.bySndSecAddr;
				EnableIAP(IAP_READ);	
				stLocalControl.stBusDealFreq.bySndRoomAddr = IapReadByte(stLocalControl.uiShortType);		
				DisableIAP();
				stLocalControl.stBusDealFreq.byCmd = CMD_ONLINE_OUTPUT;
				Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));	
			}		
			break;
		case CMD_WRITE_SERIAL:								//写入序列号命令
			if(stLocalControl.stBusDealFreq.byRecSecAddr != stLocalControl.stEepromCfgData.bySerialNum1)
			{
				return;
			}
			if(stLocalControl.stBusDealFreq.byRecRoomAddr != stLocalControl.stEepromCfgData.bySerialNum2)
			{
				return;
			}
			if(stLocalControl.stBusDealFreq.byRecBedAddr != stLocalControl.stEepromCfgData.bySerialNum3)
			{
				return;
			}
			//序列号正确,更改序列号
			stLocalControl.stEepromCfgData.bySerialNum1 = stLocalControl.stBusDealFreq.bySndSecAddr;
			stLocalControl.stEepromCfgData.bySerialNum2 = stLocalControl.stBusDealFreq.bySndRoomAddr;
			stLocalControl.stEepromCfgData.bySerialNum3 = stLocalControl.stBusDealFreq.bySndBedAddr;
			stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS;
			Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
			break; 
		case CMD_READ_SERIAL:								//读序列号命令
			stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySerialNum1;
			stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySerialNum2;
			stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySerialNum3;
			stLocalControl.stBusDealFreq.byCmd = CMD_OUT_SERIAL;
			Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
			break;
		case CMD_SET_BY_SERIAL:								//根据序列号写地址命令	
			if(stLocalControl.stBusDealFreq.byRecSecAddr != stLocalControl.stEepromCfgData.bySerialNum1)
			{
				return;
			}
			if(stLocalControl.stBusDealFreq.byRecRoomAddr != stLocalControl.stEepromCfgData.bySerialNum2)
			{
				return;
			}
			if(stLocalControl.stBusDealFreq.byRecBedAddr != stLocalControl.stEepromCfgData.bySerialNum3)
			{
				return;
			}
			//序列号正确,保存新的地址数据	
			stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
			stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
			stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;					
			stLocalControl.stEepromCfgData.bySelfSecAddr = stLocalControl.stBusDealFreq.bySndSecAddr;
			stLocalControl.stEepromCfgData.bySelfRoomAddr = stLocalControl.stBusDealFreq.bySndRoomAddr;
			stLocalControl.stEepromCfgData.bySelfBedAddr = stLocalControl.stBusDealFreq.bySndBedAddr;					
			//发送占用总线命令
			stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS; 			
			Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
			break;
		case CMD_READ_BY_SERIAL:
			if(stLocalControl.stBusDealFreq.byRecSecAddr != stLocalControl.stEepromCfgData.bySerialNum1)
			{
				return;
			}
			if(stLocalControl.stBusDealFreq.byRecRoomAddr != stLocalControl.stEepromCfgData.bySerialNum2)
			{
				return;
			}
			if(stLocalControl.stBusDealFreq.byRecBedAddr != stLocalControl.stEepromCfgData.bySerialNum3)
			{
				return;
			}
			//序列号正确,输出设备地址数据
			stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
			stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
			stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
			stLocalControl.stBusDealFreq.byCmd = CMD_OUT_BY_SERIAL; 			
			Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));	
			break;	
		case CMD_POWER_ON:	  									//本机重新热启动  			
			OS_ENTER_CRITICAL();
			//关闭所有打开的中断
			CCAPM0 = 0x00;
			ET0 = 0;
			TR0 = 0;
			EX0 = 0;
			ISP_CONTR = 0x20; 		
			break;		  			
	}	
}
/**********************************************************
*函数名称			:Bus0SendDeal	
*函数描述        	:单总线0发送完一帧数据处理函数,该函数首先
					 取出收到的数据,针对每条命令执行对应的控
					 制动作
*输入参数   		:
*返回值				:
*全局变量			:stLocalControl
*调用模块  			:
***********************************************************
*创建人	      		:陈卫国
*创建日期	 		:2008-9-22
***********************************************************
*修改人	  			:
*修改日期    		:
*注释		      	:
**********************************************************/
void Bus0SendDeal(void)
{ 
	//取出发送完成的数据帧
	OS_ENTER_CRITICAL();
	memcpy(&(stLocalControl.stBusDealFreq), byBus0SendData, sizeof(STBusFreq));		
	bBus0SendFinish = 0;										
	OS_EXIT_CRITICAL();	
	switch(stLocalControl.stBusDealFreq.byCmd)
	{
		case CMD_LANDING: 									//登记命令
			if(bLanding)
			{	//本机确实处在登记状态,设置等待确认超时
				MakeCH0TimerOut(150, 0);				
			}			
			break;			
		case CMD_COMM_CALL:	 								//普通呼叫命令 							
		case CMD_INFUSION_ANSWER:							//处理输液呼叫
		case CMD_SERVICE_ANSWER:							//处理服务呼叫
		case CMD_EMERGENCY_ANSWER:							//处理紧急呼叫
		case CMD_HELP_ANSWER:								//处理求援呼叫
			//停止正在指示的呼叫
			if(bIndicatingOther)
			{	
				bIndicatingOther = 0; 
				if(bNurseIn)
				{ 				
					VoiceChannelCtx();
					LedControl();				
				}			
			}
			if(!bBusy)
			{	//不忙,进入等待应答状态,保存主叫方地址,设置超时
				bBusy = bWaitAck = 1;
				SaveCallAddr(&(stLocalControl.stBusDealFreq)); 				
				MakeCH0TimerOut(250, 0); 						
			}			
			break;	
		case CMD_COMM_ANSWER:  								//普通应答命令
			if(bBusy)
			{
				bCalledRing = 1;  
				if((bChannel1Talk|bChannel1Talked))
				{	//本机已经处于通话状态了,缩短超时,退出						
					MakeCH0TimerOut(5, 0);
					break;
				} 				
				MakeCH0TimerOut(50, stLocalControl.stEepromCfgData.byRingTime); 				
				VoiceChannelCtx();
				LedControl();
				if(bEnAutoListen)
				{	//自动接听
					stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
					stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
					stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
					stLocalControl.stBusDealFreq.byCmd = CMD_CALL_LISTEN;
					stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stCallAddr.bySecAddr;
					stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stCallAddr.byRoomAddr;
					stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stCallAddr.byBedAddr;
					Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); 
				}		 					
			}
			break;
		case CMD_CALL_LISTEN:								//接听命令
			if(bBusy)
			{
				bCalledRing = 0;
				bChannel0Talked = 1;							
				if((bChannel1Talk|bChannel1Talked))
				{ 	//本机已经处于通话状态了,缩短超时,退出 						
					MakeCH0TimerOut(5, 0);
					break;
				}
				//设置通话超时
				MakeCH0TimerOut(50, stLocalControl.stEepromCfgData.byTalkTime);					 						
				VoiceChannelCtx();
				LedControl();
			}
			break;
		case CMD_BROADCAST1:
		case CMD_BROADCAST2:
		case CMD_BROADCAST3:   										//广播命令
			//停止正在指示的呼叫
			if(bIndicatingOther)
			{	
				bIndicatingOther = 0;
				if(bNurseIn)
				{
					VoiceChannelCtx();
					LedControl(); 					
				}
			}
			if(!bBusy)
			{ 
				bBusy = 1;	
				//保存主动呼叫方地址(本机地址)		  	
				SaveCallAddr(&(stLocalControl.stBusDealFreq));
				bSelfBroad = 1;
				if((bChannel1Talk|bChannel1Talked)||(!bDealKeyDown))
				{	//本机广播条件不存在了,缩短超时,退出				
					MakeCH0TimerOut(5, 0);
					break;
				}
				//设置广播超时
				MakeCH0TimerOut(50, stLocalControl.stEepromCfgData.byBroadTime);
				VoiceChannelCtx();
				LedControl();
			}
			break;
		case CMD_INFUSION_CLEAR:							//清除输液呼叫
		case CMD_SERVICE_CLEAR:								//清除服务呼叫
		case CMD_HELP_CLEAR:								//清除求援呼叫
		case CMD_EMERGENCY_CLEAR:							//清除紧急呼叫
			if(AddrCompare(&(stLocalControl.stBusDealFreq)))
			{	//清除自己的呼叫,清除相应标志
				if(stLocalControl.stBusDealFreq.byCmd == CMD_INFUSION_CLEAR)
				{
					bConfusionNoting = 0;
				}
				else if(stLocalControl.stBusDealFreq.byCmd == CMD_SERVICE_CLEAR)
				{
					bServiceNoting = 0;
				}
				else if(stLocalControl.stBusDealFreq.byCmd == CMD_HELP_CLEAR)
				{
					bHelpNoting = 0;
				}
				else
				{
					bEmergencyNoting = 0;
				} 				
				VoiceChannelCtx();
				LedControl();					
			}
			else if(bIndicatingOther &&
				(stLocalControl.stBusDealFreq.byRecSecAddr == stLocalControl.stIndicationData.stAddr.bySecAddr) &&
				(stLocalControl.stBusDealFreq.byRecRoomAddr == stLocalControl.stIndicationData.stAddr.byRoomAddr) &&
				(stLocalControl.stBusDealFreq.byRecBedAddr == stLocalControl.stIndicationData.stAddr.byBedAddr) &&
				((stLocalControl.stBusDealFreq.byCmd - 0x0a) == (stLocalControl.stIndicationData.byCallCmd & 0x1f)))
			{	//清除本机正在指示的呼叫  					
				bIndicatingOther = 0;
				if(bNurseIn)
				{
					VoiceChannelCtx();
					LedControl();					
				}									
			} 
			break; 	
		/*case CMD_CLEAR_INSPERCTOR:							//清除查房呼叫
			bNurseIn = 0; 
			LedControl();			
			if(bIndicatingOther)
			{				
				VoiceChannelCtx();	 				
			}			
			break;*/	
		case CMD_CHANNEL_CLOSE:								//关闭语音通道命令
			bChannel1Talk = bChannel1Talked = 0; 			
			MakeCH1TimerOut(0, 0);
			VoiceChannelCtx();
			LedControl();
			break;	
		case CMD_GET_BUS:									//占用总线
			Bus0SendPin = 1;								//制造总线故障
			SaveParameter();
			Bus0SendPin = 0;								//释放总线
			PW = bPWState; 			
			break;
		case CMD_SYSTERM_RESET:	 							//系统复位命令
			SysReset();
			break; 		
	}	
}
/**********************************************************
*函数名称			:Bus0Manage	
*函数描述        	:单总线0管理线程
*输入参数   		:
*返回值				:
*全局变量			:byMainCmdQ
*调用模块  			:OSQPost
***********************************************************
*创建人	      		:陈卫国
*创建日期	 		:2008-9-22
***********************************************************
*修改人	  			:
*修改日期    		:
*注释		      	:
**********************************************************/
void Bus0Manage(void)
{ 	
	while(TRUE)
	{		
		if(bBus0RecFinish)									//总线0收到数据
		{ 			
			OSQPost(byMainCmdQ, BUS0_REC);				
		}
		if(bBus0SendFinish)									//总线0发送完数据帧
		{
			OSQPost(byMainCmdQ, BUS0_SND);			
		} 
		OSWait(K_TMO, 1);			 		
	}
}
/**********************************************************
*函数名称			:TimerOutDeal	
*函数描述        	:超时处理函数
*输入参数   		:
*返回值				:
*全局变量			:stLocalControl
*调用模块  			:Bus0OutputData,Bus1OutputData,VoiceChannelCtx,
					 LedControl,SetHandLedState
***********************************************************
*创建人	      		:陈卫国
*创建日期	 		:2008-9-22
***********************************************************
*修改人	  			:
*修改日期    		:
*注释		      	:
**********************************************************/
void TimerOutDeal(void)
{ 	
	if(stLocalControl.stCH0TimerOut.byTimerOut != 0)
	{	//有超时设置存在
		stLocalControl.stCH0TimerOut.byTimerOut--;
		if(stLocalControl.stCH0TimerOut.byTimerOut == 0)
		{	//超时一次到了 
			if(stLocalControl.stCH0TimerOut.byTimerOutCount == 0x00)
			{ 	//所有超时完成
				if(bLanding)
				{	//上电状态
					stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
					stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
					stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
					stLocalControl.stBusDealFreq.byCmd = CMD_LANDING;
					stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.bySerialNum1;
					stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stEepromCfgData.bySerialNum2;
					stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stEepromCfgData.bySerialNum3;
					Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); 					
				}
				else if((bWaitAck|bWaitListen|bChannel0Talk|bSelfBroad))
				{	//等待应答，等待接听，主动通话，主动广播状态				
				 	stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
					stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
					stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
					stLocalControl.stBusDealFreq.byCmd = CMD_SYSTERM_RESET;
					stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stCallAddr.bySecAddr;
					stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stCallAddr.byRoomAddr;
					stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stCallAddr.byBedAddr;
					Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
				} 				
				else
				{
					bBusy = bCalledRing = bChannel0Talked = bSickRoomBroad = bOfficeBroad = bAllBroad = 0;
					VoiceChannelCtx();
					LedControl(); 									
				}
			}
			else
			{	//超时次数没有完
				stLocalControl.stCH0TimerOut.byTimerOutCount--;
				if(stLocalControl.stCH0TimerOut.byTimerOutCount == 0x00)
				{ 	//所有超时完成
					if(bLanding)
					{	//上电状态
						stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
						stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
						stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
						stLocalControl.stBusDealFreq.byCmd = CMD_LANDING;
						stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.bySerialNum1;
						stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stEepromCfgData.bySerialNum2;
						stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stEepromCfgData.bySerialNum3;
						Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));						
					}
					else if((bWaitAck|bWaitListen|bChannel0Talk|bSelfBroad))
					{	//等待应答，等待接听，主动通话，主动广播状态				
					 	stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
						stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
						stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
						stLocalControl.stBusDealFreq.byCmd = CMD_SYSTERM_RESET;
						stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stCallAddr.bySecAddr;
						stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stCallAddr.byRoomAddr;
						stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stCallAddr.byBedAddr;
						Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
					}								
					else
					{
						bBusy = bCalledRing = bChannel0Talked = bSickRoomBroad = bOfficeBroad = bAllBroad = 0;
						VoiceChannelCtx();
						LedControl();						
					}
				}
				else
				{ 	//超时次数没有完成，重新加载单位超时时间 				
					stLocalControl.stCH0TimerOut.byTimerOut = stLocalControl.stCH0TimerOut.byTimerOutSet;
				}
			}			
		}
	}
	//通道1超时处理
	if(stLocalControl.stCH1Timerout.byTimerOut != 0)
	{	//有超时设置存在
		stLocalControl.stCH1Timerout.byTimerOut--;
		if(stLocalControl.stCH1Timerout.byTimerOut == 0)
		{	//超时一次到了 
			if(stLocalControl.stCH1Timerout.byTimerOutCount == 0x00)
			{ 	//所有超时完成
				if(bChannel1Talk)
				{	//主动通话状态，发送切换命令						
					stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
					stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
					stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;						
					stLocalControl.stBusDealFreq.byCmd = CMD_CHANNEL_CLOSE;	
					stLocalControl.stBusDealFreq.byRecSecAddr = 0xff;
					stLocalControl.stBusDealFreq.byRecRoomAddr = 0xff;
					stLocalControl.stBusDealFreq.byRecBedAddr = 0xff;					
					Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));	
				}
				else if(bChannel1Talked)
				{ 	//被动通话状态，自己复位
					bChannel1Talked = 0;  					
					VoiceChannelCtx();
					LedControl();
				}	
			}
			else
			{	//超时次数没有完
				stLocalControl.stCH1Timerout.byTimerOutCount--;
				if(stLocalControl.stCH1Timerout.byTimerOutCount == 0x00)
				{ 	//所有超时完成
					if(bChannel1Talk)
					{	//主动通话状态，发送切换命令						
						stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
						stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
						stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;						
						stLocalControl.stBusDealFreq.byCmd = CMD_CHANNEL_CLOSE;	
						stLocalControl.stBusDealFreq.byRecSecAddr = 0xff;
						stLocalControl.stBusDealFreq.byRecRoomAddr = 0xff;
						stLocalControl.stBusDealFreq.byRecBedAddr = 0xff;						
						Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));	
					}
					else if(bChannel1Talked)
					{	//被动通话状态，自己复位
						bChannel1Talked = 0;  						
						VoiceChannelCtx();
						LedControl();
					}
				}
				else
				{ 	//超时次数没有完成，重新加载单位超时时间 				
					stLocalControl.stCH1Timerout.byTimerOut = stLocalControl.stCH1Timerout.byTimerOutSet;
				}
			}			
		}
	}
	//灯状态控制
	if(--stLocalControl.byLedFlashTime == 0x00)
	{
		stLocalControl.byLedFlashTime = stLocalControl.byLedTimeSet;
		if((stLocalControl.byLedState & 0x0f) == LED_FLASH)
		{ 	//红灯闪烁状态
			bLedDealState = !bLedDealState;
			LED_DEAL = bLedDealState;
		}
		if((stLocalControl.byLedState & 0xf0) == (LED_FLASH<<4)) 
		{	//绿灯闪烁状态
			bLedSetState = !bLedSetState;
			LED_SET = bLedSetState;
		}	
	}	
}
/**********************************************************
*函数名称			:TimerOutManager	
*函数描述        	:超时管理线程
*输入参数   		:
*返回值				:
*全局变量			:stLocalControl,byMainCmdQ
*调用模块  			:OSQPost				
***********************************************************
*创建人	      		:陈卫国
*创建日期	 		:2008-9-22
***********************************************************
*修改人	  			:
*修改日期    		:
*注释		      	:
**********************************************************/	
void TimerOutManager(void) 	 
{  	
	while(1)
	{ 	
		OSWait(K_TMO, 4);	 								//设置20ms超时	
		if(stLocalControl.stCH0TimerOut.byTimerOut)
		{	
			OSQPost(byMainCmdQ, TIMER_OUT);				
		}
		else
		{		
			OSQPost(byMainCmdQ, TIMER_OUT);	
		}			
	}
} 
	  