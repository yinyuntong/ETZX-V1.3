C51 COMPILER V9.00   KEY                                                                   02/14/2019 10:02:45 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN Key.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Key.c LARGE BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*
   2          ************************Copyright(c)************************
   3          *            湖南一特电子股份有限公司
   4          *             All Rights Reserved
   5          *              
   6          *
   7          *-----------------------文件信息---------------------------
   8          *文件名称         :Key.c
   9          *文件描述       :按键驱动程序
  10          *创建人         :尹运同
  11          *创建日期       :2008-9-22
  12          *版本号           :V1.0
  13          *注释         :采用按键与灯显示控制共用一个I/O口的方式          
  14          *----------------------------------------------------------
  15          *修改人       :
  16          *修改日期       :
  17          *版本号           :
  18          *注释         :
  19          ***********************************************************
  20          */
  21          #define _IN_KEY_
  22          #include "config.h"
  23          
  24          
  25          bit   bLedDealState;                    //处理灯状态        
  26                    
  27          extern uint8  OS_Q_MEM_SEL  byMainCmdQ[];   
  28          extern STLocalControl   xdata stLocalControl;
  29          
  30          /**********************************************************
  31          *函数名称     :SetLedDealState  
  32          *函数描述         :设置处理灯状态
  33          *输入参数       :byState:灯状态
  34          *返回值       :     
  35          *全局变量     :
  36          *调用模块       :
  37          ***********************************************************
  38          *创建人           :尹运同
  39          *创建日期     :2008-9-22
  40          ***********************************************************
  41          *修改人         :
  42          *修改日期       :
  43          *注释           :
  44          **********************************************************/
  45          void SetLedDealState(uint8 byState)
  46          {
  47   1        LED_DEAL = (bit)byState;
  48   1        bLedDealState = (bit)byState;
  49   1        stLocalControl.byLedState &= 0xf0;
  50   1        stLocalControl.byLedState |= byState;
  51   1      }
  52          
  53          /**********************************************************
  54          *函数名称     :KeyScan  
  55          *函数描述         :按键扫描函数
C51 COMPILER V9.00   KEY                                                                   02/14/2019 10:02:45 PAGE 2   

  56          *输入参数       :
  57          *返回值       :NO_KEY:无按键按下,SET_KEY:设置键按下
  58                     DEAL_KEY:处置键按下    
  59          *全局变量     :
  60          *调用模块       :
  61          ***********************************************************
  62          *创建人           :尹运同
  63          *创建日期     :2008-9-22
  64          ***********************************************************
  65          *修改人         :
  66          *修改日期       :
  67          *注释           :
  68          **********************************************************/
  69          uint8 KeyScan(void)
  70          {
  71   1        OS_ENTER_CRITICAL();    
  72   1        P1M1 &= 0xfb;                     //设置成弱上拉模式
  73   1        DealKey = 1;                  //置高电平
  74   1        _nop_();
  75   1        _nop_();
  76   1        _nop_(); 
  77   1        _nop_();            
  78   1        
  79   1        if(0 == DealKey)
  80   1        {     
  81   2          P1M1 |= 0x04;                   //还原成强上拉输出模式
  82   2          LED_DEAL = bLedDealState;                 //恢复指示灯的状态  
  83   2          OS_EXIT_CRITICAL();
  84   2          return(DEAL_KEY);
  85   2        } 
  86   1        
  87   1        P1M1 |= 0x04;                     //还原成强上拉输出模式
  88   1        LED_DEAL = bLedDealState;             //恢复指示灯的状态
  89   1        OS_EXIT_CRITICAL();
  90   1      
  91   1        return(NO_KEY); 
  92   1      } 
  93          /**********************************************************
  94          *函数名称     :KeyManager 
  95          *函数描述         :按键管理线程
  96          *输入参数       :
  97          *返回值       :   
  98          *全局变量     :byMainCmdQ
  99          *调用模块       :KeyScan,OSQPost
 100          ***********************************************************
 101          *创建人           :尹运同
 102          *创建日期     :2008-9-22
 103          ***********************************************************
 104          *修改人         :
 105          *修改日期       :
 106          *注释           :
 107          **********************************************************/
 108          void KeyManager(void)
 109          {   
 110   1        static uint8 byKeyValue;
 111   1        static uint8 byKeyDelay;
 112   1        
 113   1          while(TRUE)
 114   1          {
 115   2      
 116   2      //    OxTimerTreat();
 117   2      
C51 COMPILER V9.00   KEY                                                                   02/14/2019 10:02:45 PAGE 3   

 118   2          
 119   2              OSWait(K_TMO, OS_TICKS_PER_SEC/50);         //20ms延时                       
 120   2              byKeyValue = KeyScan();                   
 121   2              if(NO_KEY == byKeyValue)
 122   2              {             
 123   3                continue;
 124   3              }        
 125   2              OSWait(K_TMO, OS_TICKS_PER_SEC/50);           //20ms延时消抖                
 126   2              if(byKeyValue != KeyScan())
 127   2              {       
 128   3                  continue;
 129   3              }
 130   2              OSQPost(byMainCmdQ, KEY_DOWN|byKeyValue);
 131   2      //    Send_Data_Byte(KEY_DOWN|byKeyValue);
 132   2          byKeyDelay = KEY_DELAY;
 133   2          while(byKeyDelay--)
 134   2          {
 135   3            if(byKeyValue == KeyScan())
 136   3            { 
 137   4              OSWait(K_TMO, OS_TICKS_PER_SEC/50); 
 138   4            }
 139   3            else
 140   3            {   
 141   4              goto KeyUp;
 142   4            }
 143   3          }   
 144   2          OSQPost(byMainCmdQ, KEY_ALWAYS|byKeyValue);                                                     
 145   2              while(byKeyValue == KeyScan())
 146   2              { 
 147   3            OSWait(K_TMO, OS_TICKS_PER_SEC/20);              
 148   3              }
 149   2      KeyUp:
 150   2          OSQPost(byMainCmdQ, KEY_UP|byKeyValue); 
 151   2      //    Send_Data_Byte(KEY_UP|byKeyValue);
 152   2          WDT_CONTR = 0x3d;   //@20MHz,1.25s
 153   2      
 154   2          }
 155   1      }
 156          /**********************************************************
 157          *函数名称     :KeyDownDeal  
 158          *函数描述         :按键按下处理函数
 159          *输入参数       :byKey:按下键的键值
 160          *返回值       :   
 161          *全局变量     :stLocalControl
 162          *调用模块       :Bus0OutputData
 163          ***********************************************************
 164          *创建人           :尹运同
 165          *创建日期     :2008-9-22
 166          ***********************************************************
 167          *修改人         :
 168          *修改日期       :
 169          *注释           :
 170          **********************************************************/
 171          void KeyDownDeal(uint8 byKey)
 172          { 
 173   1        if(bLanding)
 174   1        { //登记状态,不处理 
 175   2          return;
 176   2        }
 177   1        stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
 178   1        stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
 179   1        stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
C51 COMPILER V9.00   KEY                                                                   02/14/2019 10:02:45 PAGE 4   

 180   1        stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
 181   1        stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
 182   1        stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr; 
 183   1        switch(byKey)
 184   1        {
 185   2      
 186   2          case DEAL_KEY:
 187   2            bLedDealState = LED_DEAL =1;
 188   2            bDealKeyDown = 1;               //保存处置键的状态
 189   2            stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
 190   2            stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
 191   2            stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;         
 192   2            if(bNumSeting)  //编号状态
 193   2            {
 194   3              bNumSeting=0;
 195   3              stLocalControl.byNumSetTime=0;
 196   3              stLocalControl.stBusDealFreq.bySndSecAddr=stLocalControl.stCallAddr.bySndSecAddr;
 197   3              stLocalControl.stBusDealFreq.bySndRoomAddr=stLocalControl.stCallAddr.bySndRoomAddr;
 198   3              stLocalControl.stBusDealFreq.bySndBedAddr=stLocalControl.stCallAddr.bySndBedAddr;
 199   3              stLocalControl.stBusDealFreq.byCmd= CMD_NUMBER_SET;
 200   3              stLocalControl.stBusDealFreq.byRecSecAddr=0x02;   //成功
 201   3              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
 202   3            
 203   3              //保存新的地址数据            
 204   3              stLocalControl.stEepromCfgData.bySelfSecAddr = stLocalControl.stBusDealFreq.bySndSecAddr;
 205   3              stLocalControl.stEepromCfgData.bySelfRoomAddr = stLocalControl.stBusDealFreq.bySndRoomAddr;
 206   3              stLocalControl.stEepromCfgData.bySelfBedAddr = stLocalControl.stBusDealFreq.bySndBedAddr;         
 207   3      
 208   3      //        stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER;
 209   3      //        stLocalControl.stBusDealFreq.byRecSecAddr = CMD_NUMBER_SET;     
 210   3              stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS;
 211   3              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
 212   3              return;
 213   3            }
 214   2      
 215   2            if(bRFNumSeting)  //输液报警器对码状态
 216   2            {
 217   3              bRFNumSeting=0;
 218   3              stLocalControl.uiRFNumSetTime=0;
 219   3              memcpy(&(stLocalControl.stBusDealFreq.bySndSecAddr),RFSerial,3);
 220   3              memcpy(&(stLocalControl.stBusDealFreq.byRecSecAddr),&(RFSerial[3]),3);
 221   3              stLocalControl.stBusDealFreq.byCmd= CMD_RF_NUMSET_OK; //成功  
 222   3              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
 223   3      
 224   3              memcpy(&(stLocalControl.stEepromCfgData.byRFSerialNum1),RFSerial,6);
 225   3              stLocalControl.stEepromCfgData.byCrc = CalcParaCrc();
 226   3              
 227   3              //保存输液报警器序列号
 228   3              WDT_CONTR = 0x3d;   //喂狗
 229   3              EA=0;
 230   3              SaveParameter(IAP0_ADDR);
 231   3              EA=1;
 232   3              memcpy(&(stLocalControl.stBusDealFreq.bySndSecAddr),RFSerial,3);
 233   3              stLocalControl.stBusDealFreq.byCmd = CMD_RF_NUMSET_OK;  //成功 
 234   3              memcpy(&(stLocalControl.stBusDealFreq.byRecSecAddr),&(RFSerial[3]),3);      
 235   3              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); 
 236   3              return;
 237   3            }
 238   2      
 239   2      
 240   2            //如果存在本机的呼叫,按下处置键,清除本机的呼叫  
 241   2            if(bConfusionNoting)
C51 COMPILER V9.00   KEY                                                                   02/14/2019 10:02:45 PAGE 5   

 242   2            {
 243   3              stLocalControl.stBusDealFreq.byCmd = CMD_INFUSION_CLEAR;
 244   3              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
 245   3              return;
 246   3            }
 247   2            if(bServiceNoting)
 248   2            {
 249   3              stLocalControl.stBusDealFreq.byCmd = CMD_SERVICE_CLEAR;
 250   3              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
 251   3              return;
 252   3            }
 253   2            if(bHelpNoting)
 254   2            {
 255   3              stLocalControl.stBusDealFreq.byCmd = CMD_HELP_CLEAR;
 256   3              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
 257   3              return;
 258   3            }
 259   2            if(bEmergencyNoting)
 260   2            {
 261   3              stLocalControl.stBusDealFreq.byCmd = CMD_EMERGENCY_CLEAR;
 262   3              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
 263   3              return;
 264   3            }
 265   2            //如果正在指示其他分机的呼叫,处理其他分机呼叫
 266   2            if((bNurseIn&bIndicatingOther))
 267   2            {
 268   3              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stIndicationData.stAddr.bySndSecAddr;
 269   3              stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stIndicationData.stAddr.bySndRoomAddr;
 270   3              stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stIndicationData.stAddr.bySndBedAddr;
 271   3              if(CMD_EMERGENCY_CALL == (stLocalControl.stIndicationData.byCallCmd & 0x1f))
 272   3              { //卫生间呼叫,不需要处理,直接清除
 273   4                stLocalControl.stBusDealFreq.byCmd = CMD_EMERGENCY_CLEAR;
 274   4              }
 275   3              else
 276   3              { //其他类型呼叫,处理
 277   4                if(/*stLocalControl.stIndicationData.stAddr.bySecAddr==WIRELESS_SEC&&*/
 278   4                   stLocalControl.stIndicationData.stAddr.bySndRoomAddr==ADD_BED_FJ)
 279   4                {//加床分机呼叫,不需要处理,直接清除
 280   5                  stLocalControl.stBusDealFreq.byCmd = CMD_INFUSION_CLEAR;
 281   5                }
 282   4                else
 283   4                {
 284   5                  stLocalControl.stBusDealFreq.byCmd = stLocalControl.stIndicationData.byCallCmd & 0x1f;
 285   5                  stLocalControl.stBusDealFreq.byCmd += 0x06;
 286   5                }
 287   4              }         
 288   3              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
 289   3              return;
 290   3            }
 291   2      
 292   2            if(bVoiceNoting || bMusicPlaying)
 293   2            {//语音提示状态或者背景音乐播放状态
 294   3              if(bCloseCGB)
 295   3              {//广播打开状态,接下来应关闭广播
 296   4                bCloseCGB=0;
 297   4                CloseCGB();
 298   4                bMUTState = MUT =1;
 299   4              }
 300   3              else
 301   3              {
 302   4                bCloseCGB=1;
 303   4                OpenCGB();
C51 COMPILER V9.00   KEY                                                                   02/14/2019 10:02:45 PAGE 6   

 304   4                bMUTState = MUT =0;         
 305   4              }
 306   3            }
 307   2            break;
 308   2      
 309   2          default:
 310   2            break;
 311   2        }   
 312   1      }
 313          /**********************************************************
 314          *函数名称     :KeyUpDeal  
 315          *函数描述         :按键弹起处理函数
 316          *输入参数       :byKey:弹起键的键值
 317          *返回值       :   
 318          *全局变量     :
 319          *调用模块       :MakeCH0TimerOut,MakeCH1TimerOut
 320          ***********************************************************
 321          *创建人           :尹运同
 322          *创建日期     :2008-9-22
 323          ***********************************************************
 324          *修改人         :
 325          *修改日期       :
 326          *注释           :
 327          **********************************************************/
 328          void KeyUpDeal(uint8 byKey)
 329          {
 330   1        if(bLanding)
 331   1        { //登记状态,不处理 
 332   2          return;
 333   2        } 
 334   1        switch(byKey)
 335   1        {
 336   2          case DEAL_KEY:
 337   2            bLedDealState = LED_DEAL =0;
 338   2            bDealKeyDown = 0;                 //保存处置键的状态          
 339   2            if((bWaitAck|bWaitListen|bChannel0Talk|bSelfBroad))
 340   2            { //通道0主动呼叫或者通话状态,减少该通道超时时间        
 341   3              MakeCH0TimerOut(5, 0);
 342   3            }
 343   2            else if(bChannel1Talk)
 344   2            { //通道1主动通话状态,减少该通道超时时间
 345   3              MakeCH1TimerOut(5, 0);
 346   3            }     
 347   2            break;
 348   2          default:
 349   2            break;
 350   2        }   
 351   1      }
 352          /**********************************************************
 353          *函数名称     :KeyAlwaysDeal  
 354          *函数描述         :按键长按下处理函数
 355          *输入参数       :byKey:长按键的键值
 356          *返回值       :   
 357          *全局变量     :stLocalControl
 358          *调用模块       :
 359          ***********************************************************
 360          *创建人           :尹运同
 361          *创建日期     :2008-9-22
 362          ***********************************************************
 363          *修改人         :
 364          *修改日期       :
 365          *注释           :
C51 COMPILER V9.00   KEY                                                                   02/14/2019 10:02:45 PAGE 7   

 366          **********************************************************/
 367          void KeyAlwaysDeal(uint8 byKey)
 368          {
 369   1        if(bLanding)
 370   1        { //登记状态,不处理 
 371   2          return;
 372   2        } 
 373   1        switch(byKey)
 374   1        {   
 375   2          case DEAL_KEY:
 376   2            if((bBusy|bChannel1Talk|bChannel1Talked))
 377   2            { //本机不是处于空闲状态,不作任何处理
 378   3              break;
 379   3            }       
 380   2            if(bNurseIn)
 381   2            { //护士到位,发送办公区广播命令
 382   3              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
 383   3              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
 384   3              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
 385   3              stLocalControl.stBusDealFreq.byRecSecAddr = 0xff;
 386   3              stLocalControl.stBusDealFreq.byRecRoomAddr = 0xff;
 387   3              stLocalControl.stBusDealFreq.byRecBedAddr = 0xff;
 388   3              stLocalControl.stBusDealFreq.byCmd = CMD_BROADCAST2;          
 389   3              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));       
 390   3            }     
 391   2            break;  
 392   2          default:
 393   2            break;
 394   2        }   
 395   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    794    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
