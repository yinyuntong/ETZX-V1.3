C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 11:57:08 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SINGLEBUS
OBJECT MODULE PLACED IN SingleBus.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE SingleBus.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*
   2          ************************Copyright(c)************************
   3          *                                  湖南一特电子股份有限公司
   4          *                               All Rights Reserved
   5          *                                        
   6          *
   7          *-----------------------文件信息---------------------------
   8          *文件名称               :SingleBus.c
   9          *文件描述               :单总线程序
  10          *创建人                 :尹运同
  11          *创建日期               :2008-9-22
  12          *版本号                 :V1.0
  13          *注释                   :                                       
  14          *----------------------------------------------------------
  15          *修改人                         :
  16          *修改日期                       :
  17          *版本号                 :
  18          *注释                   :
  19          ***********************************************************
  20          */
  21          #define _IN_SINGLE_BUS_
  22          #include "config.h"
  23          
  24          
  25          bit FLED;
  26          
  27          //总线0变量定义
  28          uint8 bdata byBus0State0        = 0;                                                    //单总线0状态字1
  29          sbit  bBus0StartRec                     = byBus0State0^0;                               //单总线0开始接收起始位标志
  30          sbit  bBus0OnRec                        = byBus0State0^1;                               //单总线0开始接收数据位标志
  31          sbit  bBus0Enable                       = byBus0State0^2;                               //单总线0允许发送标志
  32          sbit  bBus0ReqSend                      = byBus0State0^3;                               //单总线0请求发送标志
  33          sbit  bBus0OnSendBit            = byBus0State0^4;                               //单总线0正在发送一个数据位标志
  34          sbit  bBus0OnSendFreq           = byBus0State0^5;                               //单总线0正在发送一个数据帧标志
  35          sbit  bBus0SendError            = byBus0State0^6;                               //单总线0发送错误标志
  36          sbit  bBus0Error                        = byBus0State0^7;                               //单总线0故障标志
  37          uint8 bdata byBus0State1        = 0;                                                    //单总线0状态字2
  38          sbit  bBus0RecFinish            = byBus0State1^0;                               //单总线0接收完成标志
  39          sbit  bBus0RecBit9                      = byBus0State1^1;                               //单总线0接收字节数据的第9位
  40          sbit  bBus0SendFinish           = byBus0State1^2;                               //单总线0发送完成标志
  41          sbit  bBus0Disable                      = byBus0State1^3;                               //单总线0禁止发送标志
  42          sbit  bBus0SendBit                      = byBus0State1^4;                               //单总线0正在发送的数据位
  43          sbit  bBus0RecBit                       = byBus0State1^5;                               //单总线0正在接收的数据位
  44          uint8 data byBus0RecCount = 0;                                                          //高4位是总线0接收定时中断计数，低4位是接收到的位计数
  45          uint8 data byBus0RecBuf;                                                                        //总线0接收缓冲单元
  46          uint8 data byBus0SendBuf;                                                                       //总线0发送缓冲单元     
  47          uint8 data byBus0RecData[BUS0_FREQ_SIZE];                                       //总线0接收缓冲区
  48          uint8 data byBus0SendData[BUS0_FREQ_SIZE];                                      //总线0发送缓冲区
  49          uint8 data byBus0SendCount = 0;                                                         //高4位是总线0发送定时中断计数，低4位是发送的位计数
  50          uint8 data byBus0RecSendCount = 0;                                                      //高4位是总线0接收到的字节计数，低4位是总线0发送完的字节计数
  51          uint8 data byBus0SendStopCount;                                                         //总线0停止时间计数
  52          uint8 data byBus0RecTimeOut = 0;                                                        //总线0接收超时计数
  53          uint8 data byBus0DisableCount = 0;                                                      //总线0禁止计数  
  54          uint8 data byBus0TxQ[BUS0_TX_Q_ZISE];                                           //总线0发送队列                                                 
  55          uint8 data byBus0TxHead = 0;                                                            //单总线0发送队列头指针
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 11:57:08 PAGE 2   

  56          uint8 data byBus0TxTail = 0;                                                            //单总线0发送队列尾指针
  57          #define IncBus0TxPtr(addr)    {addr=(addr+1)%BUS0_TX_Q_ZISE;}
  58          #define Bus0TxBuffLen()       ((byBus0TxTail+BUS0_TX_Q_ZISE-byBus0TxHead)%BUS0_TX_Q_ZISE) 
  59          
  60          
  61          sbit  Bus0RecPin        = P3^3;                                                                 //单总线0接收引脚定义
  62          sbit  Bus0SendPin       = P3^4;                                                                 //单总线0发送引脚定义
  63          
  64          uint16  xdata uitTimer0TimerCount=TIMER0_COUNT; 
  65          
  66          void led0flash(void)
  67          {
  68   1              if(FLED==FLAG_LED_ON)
  69   1              {
  70   2                      LED=LED_OFF;
  71   2                      FLED=FLAG_LED_OFF;
  72   2              }
  73   1              else
  74   1              {
  75   2                      LED=LED_ON;
  76   2                      FLED=FLAG_LED_ON;
  77   2              }
  78   1      }
  79          /**********************************************************
  80          *函数名称                       :SingleBusInit  
  81          *函数描述               :单总线初始化
  82          *输入参数               :
  83          *返回值                         :       
  84          *全局变量                       :
  85          *调用模块                       :
  86          ***********************************************************
  87          *创建人                 :尹运同
  88          *创建日期                       :2008-9-22
  89          ***********************************************************
  90          *修改人                         :
  91          *修改日期               :
  92          *注释                   :
  93          **********************************************************/
  94          void SingleBusInit(void)
  95          {
  96   1              //STC12C54/56系列M0=0,M1=0:准双向，M0=0,M1=1:推挽，M0=1,M1=0:高阻，M0=1,M1=1:开漏
  97   1              //总线0发送脚设置为推挽输出，接收脚设置为高阻输入:
  98   1      
  99   1      
 100   1              //STC12C52/5A系列:M0=0,M1=0:准双向，M0=0,M1=1:高阻，M0=1,M1=0:推挽，M0=1,M1=1:开漏
 101   1              //总线0接收脚设置为高阻输入:发送脚设置为推挽输出，
 102   1      
 103   1              
 104   1              //P3^3,高阻输入
 105   1              P3M0 &= (~Bin(0,0,0,0,1,0,0,0));
 106   1              P3M1 |=   Bin(0,0,0,0,1,0,0,0);
 107   1      
 108   1              //,P3^4,开漏
 109   1              P3M0 |=   Bin(0,0,0,1,0,0,0,0);
 110   1              P3M1 |=   Bin(0,0,0,1,0,0,0,0);
 111   1      
 112   1              //总线电平设置
 113   1              Bus0SendPin = 1;
 114   1              Bus0RecPin = 1;  
 115   1              
 116   1              
 117   1      
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 11:57:08 PAGE 3   

 118   1              TMOD &= 0xf0;   //  ;t1作波特率发生器(不变)，
 119   1              TMOD |= 0X01;   //t0作方式1（16位)定时器
 120   1      
 121   1              TL0 = TIMER0_L;
 122   1              TH0 = TIMER0_H;
 123   1      //      TL0 = (uint8)uitTimer0TimerCount;
 124   1      //      TH0 = (uint8)(uitTimer0TimerCount>>8);
 125   1              
 126   1              TF0 = 0;                                                                                                //清除中断标志
 127   1              AUXR &= (~T0x12);                                                                               //传统12分频速度  
 128   1              ET0 = 1;                                                                                                //允许定时器0中断 
 129   1              TR0 = 1;                                                                                                //启动定时器
 130   1              //其它控制设置
 131   1              byBus0SendStopCount = 240;                                                              //上电总线0禁止发送时间设置             
 132   1              IE1 = 0;                                                                                                //清除中断标志
 133   1              IT1 = 1;                                                                                                //外部中断1为下降沿触发模式                                     
 134   1              if(Bus0RecPin)
 135   1              {       //如果总线正常,开中断   
 136   2                      EX1 = 1;
 137   2              }
 138   1              else
 139   1              {       //如果总线不正常,置总线故障标志                                 
 140   2                      bBus0Error = 1;
 141   2              }       
 142   1      }
 143          /**********************************************************
 144          *函数名称                       :Bus0RecInt     
 145          *函数描述               :外部中断0函数,单总线0接收中断
 146          *输入参数               :
 147          *返回值                         :       
 148          *全局变量                       :
 149          *调用模块                       :
 150          ***********************************************************
 151          *创建人                 :尹运同
 152          *创建日期                       :2008-9-22
 153          ***********************************************************
 154          *修改人                         :
 155          *修改日期               :
 156          *注释                   :
 157          **********************************************************/
 158          #pragma disable
 159          void Bus0RecInt(void) interrupt X1_INTNO
 160          { 
 161   1              DisableBus0RecInt();                                                                    //禁止再次下降沿中断
 162   1              bBus0StartRec = 1;                                                                              //启动起始位沿检测
 163   1              bBus0Enable = 0;                                                                                //禁止总线发送                                                  
 164   1              byBus0RecCount = 0;                                                                             //清接收寄存器          
 165   1      }
 166          /**********************************************************
 167          *函数名称                       :Timer0Int      
 168          *函数描述               :定时器0溢出中断,定时器每93.75us中断一次
 169                                                   程序间隔检查总线0与总线1的接收和发送
 170          *输入参数               :
 171          *返回值                         :       
 172          *全局变量                       :
 173          *调用模块                       :
 174          ***********************************************************
 175          *创建人                 :陈卫国
 176          *创建日期                       :2008-9-22
 177          ***********************************************************
 178          *修改人                         :
 179          *修改日期               :
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 11:57:08 PAGE 4   

 180          *注释                   :
 181          **********************************************************/
 182          #pragma disable
 183          void Timer0Int(void) interrupt T0_INTNO
 184          { 
 185   1              TR0=0;
 186   1              TH0=TIMER0_H;
 187   1              TL0=TIMER0_L;
 188   1              TR0=1;
 189   1              bBus0RecBit = Bus0RecPin;       
 190   1              /*******************************总线0接收处理***********************************/
 191   1              if(bBus0StartRec)                                                                               //判断总线所处的状态，接收到起始位
 192   1              {                       
 193   2                      byBus0RecCount += 0x10;                                                         //增加定时中断计数次数
 194   2                      if(0x50 == (byBus0RecCount & 0xf0))                                     //到总线起始位检测时间
 195   2                      {                       
 196   3                              bBus0StartRec = 0;
 197   3                              byBus0RecCount = 0x00;                                                  //重新开始计数                  
 198   3                              if(bBus0RecBit)                 
 199   3                              {       //无效起始位                                                                                                                                            
 200   4                                      if((!bBus0SendError)&&bBus0OnSendFreq)
 201   4                                      {       //没有发生过总线发送错误,且有一帧数据正在发送,停止帧数据发送,置发送错误标志                                             
 202   5                                              byBus0State0 &= (~BUS0_SEND_CON);
 203   5                                              bBus0SendError = 1;
 204   5                                              Bus0SendPin = 1;                                                //释放总线                                      
 205   5                                      }                               
 206   4                                      byBus0SendStopCount = 240;                                      
 207   4                                      byBus0RecSendCount = 0x00;                                      //接收出错,重置接收发送计数值
 208   4                                      EnableBus0RecInt();                             
 209   4                              }
 210   3                              else                                                            
 211   3                              {       //有效起始位
 212   4                                      bBus0OnRec = 1;                                                         //开始接收数据位                                                                                        
 213   4                              }
 214   3                      }
 215   2              }
 216   1              else if(bBus0OnRec)
 217   1              {               
 218   2                      byBus0RecCount += 0x10;                                                         //增加定时中断计数次数                  
 219   2                      if(0xa0 == (byBus0RecCount & 0xf0))
 220   2                      {
 221   3                              byBus0RecCount &= 0x0f;                                                 //清除定时中断计数次数
 222   3                              byBus0RecCount += 0x01;
 223   3                              if(0x0a == (byBus0RecCount & 0x0f))     
 224   3                              {       //收到第10位,结束位                                     
 225   4                                      bBus0OnRec = 0;                                                         //停止数据接收                                  
 226   4                                      if(bBus0RecBit)
 227   4                                      {       //有效的结束位                                                  
 228   5                                              if(((bit)(byBus0RecSendCount & 0xf0) == bBus0RecBit9)) 
 229   5                                              {       //数据桢错误
 230   6                                                      byBus0RecTimeOut = 0;
 231   6                                                      byBus0RecSendCount &= 0x0f;                                                                                     
 232   6                                              }
 233   5                                              else 
 234   5                                              {       //数据桢正确                                    
 235   6                                                      byBus0RecTimeOut = 230;                         //设置下一个字节数据接收超时时间
 236   6                                                      byBus0RecData[byBus0RecSendCount>>4] = byBus0RecBuf;
 237   6                                                      byBus0RecSendCount += 0x10;                                                                                                                                                                     
 238   6                                                      if((byBus0RecSendCount & 0xf0) >= BUS0_FREQ_SIZE_HI)
 239   6                                                      {                                                                                                                                                                               
 240   7                                                              byBus0RecSendCount &= 0x0f;                                                     
 241   7                                                              if(!((bBus0OnSendFreq == 1)&&(bBus0ReqSend == 0)))
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 11:57:08 PAGE 5   

 242   7                                                              {       //如果接收到的这帧数据是自己发送的不置标志                                                      
 243   8                                                                      bBus0RecFinish = 1;                                                                                                                                                                                                                                                                                                             
 244   8                                                              }                                                                                                                                               
 245   7                                                              byBus0RecTimeOut = 0;
 246   7                                                              byBus0DisableCount = 10;
 247   7                                                              bBus0Disable = 1;                               //禁止总线使用                                                  
 248   7                                                      }       
 249   6                                              }                               
 250   5                                              byBus0SendStopCount = 240;
 251   5                                              EnableBus0RecInt();                                             
 252   5                                      }
 253   4                                      else                                                    
 254   4                                      {       //无效结束位
 255   5                                              bBus0Error = 1;                                                                         
 256   5                                              if((!bBus0SendError) && bBus0OnSendFreq)
 257   5                                              {       //没有发生过总线发送错误,且有一帧数据正在发送,停止帧数据发送,置发送错误标志
 258   6                                                      byBus0State0 &= (~BUS0_SEND_CON);
 259   6                                                      bBus0SendError = 1;                                                     
 260   6                                                      Bus0SendPin = 1;                                        //释放总线
 261   6                                              }
 262   5                                              byBus0RecSendCount = 0x00;                              //接收出错,重置接收发送计数值                                   
 263   5                                      }
 264   4                              }
 265   3                              else if(0x09 == (byBus0RecCount & 0x0f))
 266   3                              {       //第9位数据
 267   4                                      bBus0RecBit9 = bBus0RecBit;                                     
 268   4                              }
 269   3                              else                                                                                    
 270   3                              {       //有效数据位
 271   4                                      byBus0RecBuf >>= 1;
 272   4                                      if(bBus0RecBit)
 273   4                                      {       //为高电平
 274   5                                              byBus0RecBuf |= 0x80;
 275   5                                      }       
 276   4                              }
 277   3                      }
 278   2              }
 279   1              /*******************************总线0发送处理***********************************/
 280   1              if((byBus0State0 & BUS0_CAN_SEND) == BUS0_CAN_SEND)
 281   1              {       //总线0上有数据发送请求,且总线允许发送          
 282   2                      if(bBus0RecBit)
 283   2                      {       //总线正常,可以发送
 284   3                              Bus0SendPin = 0;
 285   3                              bBus0SendBit = 0;                                                               //发送起始位数据                        
 286   3                              byBus0SendCount = 0;
 287   3                              byBus0State0 &= (~BUS0_CAN_SEND);
 288   3                              byBus0SendBuf = byBus0SendData[byBus0RecSendCount & 0x0f];
 289   3                              bBus0OnSendBit = 1;                                                             //取出待发送的数据并置正在发送标志              
 290   3                      }
 291   2                      else
 292   2                      {       //总线不正常,停止发送
 293   3                              byBus0State0 &= (~BUS0_SEND_CON);
 294   3                              bBus0SendError = 1;                     
 295   3                              byBus0RecSendCount &= 0xf0;
 296   3                              Bus0SendPin = 1;
 297   3                              byBus0SendStopCount = 240;
 298   3                      }
 299   2              }
 300   1              else if(bBus0OnSendBit)
 301   1              {       //有数据位正在发送,首先发送的是起始位                   
 302   2                      if(bBus0SendBit == bBus0RecBit)                 
 303   2                      {       //发送的数据和接收的数据相同
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 11:57:08 PAGE 6   

 304   3                              byBus0SendCount += 0x10;
 305   3                              if(0xa0 == (byBus0SendCount & 0xf0))
 306   3                              {       //一位数据发送完毕,首先发送的是起始位
 307   4                                      byBus0SendCount &= 0x0f;
 308   4                                      byBus0SendCount += 0x01;                                
 309   4                                      if(0x09 == (byBus0SendCount & 0x0f))
 310   4                                      {       //发送到第9位了
 311   5                                              bBus0SendBit = !(bit)(byBus0RecSendCount & 0x0f);
 312   5                                              Bus0SendPin = bBus0SendBit;                                             
 313   5                                      }
 314   4                                      else if(0x0a == (byBus0SendCount & 0x0f))
 315   4                                      {       //发送到结束位了
 316   5                                              bBus0SendBit = 1;
 317   5                                              Bus0SendPin = 1;        
 318   5                                      }
 319   4                                      else if(0x0b == (byBus0SendCount & 0x0f))
 320   4                                      {       //已经发送完结束位了
 321   5                                              bBus0OnSendBit = 0;                                             
 322   5                                              byBus0RecSendCount += 0x01;                                                                     
 323   5                                              if((byBus0RecSendCount & 0x0f) >= BUS0_FREQ_SIZE)
 324   5                                              {       //发送完一帧数据                                                                                                
 325   6                                                      byBus0RecSendCount &= 0xf0;                     //重新进入数据帧的发送阶段
 326   6                                                      byBus0State0 &= (~BUS0_SEND_CON);
 327   6                                                      byBus0SendStopCount = 240;
 328   6                                                      byBus0State1 |= BUS0_SEND_FINISH;                                                               
 329   6                                                      byBus0DisableCount = 10;                                                
 330   6                                              }
 331   5                                              else
 332   5                                              {                                               
 333   6                                                      byBus0SendStopCount = 10;
 334   6                                                      bBus0ReqSend = 1;
 335   6                                              }
 336   5                                              EnableBus0RecInt();                                             //再次使能接收中断
 337   5                                      }
 338   4                                      else
 339   4                                      {
 340   5                                              if(byBus0SendBuf & 0x01)
 341   5                                              {       //发送高电平
 342   6                                                      bBus0SendBit = 1;
 343   6                                                      Bus0SendPin = 1;                                        
 344   6                                              }
 345   5                                              else
 346   5                                              {       //发送低电平
 347   6                                                      bBus0SendBit = 0;
 348   6                                                      Bus0SendPin = 0;
 349   6                                              }
 350   5                                              byBus0SendBuf >>= 1;                                    //发送数据位移位操作
 351   5                                      }
 352   4                              }
 353   3                      }
 354   2                      else
 355   2                      {       //不相同,发送失败                                                               
 356   3                              byBus0State0 &= ~BUS0_SEND_CON;
 357   3                              byBus0RecSendCount &= 0xf0;
 358   3                              bBus0SendError = 1;                                     
 359   3                              Bus0SendPin = 1; 
 360   3                              byBus0SendStopCount = 240;
 361   3                      }
 362   2              }       
 363   1              /*******************************总线0控制处理***********************************/
 364   1              if(0 == (byBus0State0 & BUS0_ON_REC))
 365   1              {       
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 11:57:08 PAGE 7   

 366   2                      if(byBus0SendStopCount != 0)
 367   2                      {
 368   3                              if((--byBus0SendStopCount) == 0)
 369   3                              {                               
 370   4                                      bBus0Enable = 1;                                                                
 371   4                              }
 372   3                      }               
 373   2                      if(bBus0Error)
 374   2                      {                                                               
 375   3                              bBus0Enable = 0;                        
 376   3                              if(bBus0RecBit)
 377   3                              {                               
 378   4                                      bBus0Error = 0;
 379   4                                      EnableBus0RecInt();
 380   4                                      byBus0SendStopCount = 240;
 381   4                              }
 382   3                      }
 383   2              }       
 384   1              /*******************************总线0超时处理***********************************/
 385   1              if(byBus0RecTimeOut != 0)
 386   1              {
 387   2                      if(--byBus0RecTimeOut == 0)                                                     
 388   2                      {       //接收超时到
 389   3                              byBus0RecSendCount &= 0x0f;                     
 390   3                      }
 391   2              }
 392   1              if(byBus0DisableCount != 0)
 393   1              {
 394   2                      if(--byBus0DisableCount == 0)                                           
 395   2                      {       //禁止超时到            
 396   3                              bBus0Disable = 0;
 397   3                      }
 398   2              }       
 399   1              /***********总线0自动发送管理**********/         
 400   1              if((byBus0State0 & BUS0_ON_WORK) == 0x00)                               
 401   1              {       //总线0没有工作                         
 402   2                      if(bBus0SendError)                                              
 403   2                      {       //产生了发送错误,自动重发                                                               
 404   3                              bBus0SendError = 0;                             
 405   3                              byBus0State0 |= BUS0_REQ_SEND;          
 406   3                      }
 407   2                      else                                                                    
 408   2                      {       //总线0无发送错误               
 409   3                              if(!(bBus0SendFinish|bBus0Disable))
 410   3                              {       //总线0没有禁止使用,且发送结束处理已经完成
 411   4                                      if(Bus0TxBuffLen() >= BUS0_FREQ_SIZE)
 412   4                                      {       //有一帧完整的数据在发送队列中                                                                                                                                          
 413   5                                              byBus0SendData[0] = byBus0TxQ[byBus0TxHead];
 414   5                                              IncBus0TxPtr(byBus0TxHead);
 415   5                                              byBus0SendData[1] = byBus0TxQ[byBus0TxHead];
 416   5                                              IncBus0TxPtr(byBus0TxHead);
 417   5                                              byBus0SendData[2] = byBus0TxQ[byBus0TxHead];
 418   5                                              IncBus0TxPtr(byBus0TxHead);
 419   5                                              byBus0SendData[3] = byBus0TxQ[byBus0TxHead];
 420   5                                              IncBus0TxPtr(byBus0TxHead);
 421   5                                              byBus0SendData[4] = byBus0TxQ[byBus0TxHead];
 422   5                                              IncBus0TxPtr(byBus0TxHead);
 423   5                                              byBus0SendData[5] = byBus0TxQ[byBus0TxHead];
 424   5                                              IncBus0TxPtr(byBus0TxHead);
 425   5                                              byBus0SendData[6] = byBus0TxQ[byBus0TxHead];
 426   5                                              IncBus0TxPtr(byBus0TxHead);     
 427   5                                              byBus0State0 |= BUS0_REQ_SEND;                                          
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 11:57:08 PAGE 8   

 428   5                                      }
 429   4                                      else
 430   4                                      {       //没有一帧完整的数据在发送队列中了
 431   5                                              byBus0TxHead = byBus0TxTail = 0;
 432   5                                      }                                                               
 433   4                              }
 434   3                      }
 435   2              }       
 436   1      }
 437          
 438          /**********************************************************
 439          *函数名称                       :Bus0OutputData 
 440          *函数描述               :单总线0将待发送数据放入缓冲区
 441          *输入参数               :pbyData:待发送的数据指针
 442          *返回值                         :TRUE:发送成功,FALSE:队列满,发送失败    
 443          *全局变量                       :
 444          *调用模块                       :
 445          ***********************************************************
 446          *创建人                 :尹运同
 447          *创建日期                       :2008-9-22
 448          ***********************************************************
 449          *修改人                         :
 450          *修改日期               :
 451          *注释                   :
 452          **********************************************************/
 453          uint8 Bus0OutputData(uint8* pbyData)
 454          {
 455   1              uint8 byTemp = BUS0_FREQ_SIZE;
 456   1      
 457   1              OS_ENTER_CRITICAL();
 458   1              if(Bus0TxBuffLen() >= (BUS0_TX_Q_ZISE - 1))
 459   1              {       //没有空间存储了,失败   
 460   2                      OS_EXIT_CRITICAL();
 461   2                      return(FALSE);
 462   2              }       
 463   1              while(byTemp--)
 464   1              {       //数据入发送队列
 465   2                      byBus0TxQ[byBus0TxTail] = *pbyData++;
 466   2                      IncBus0TxPtr(byBus0TxTail);
 467   2              }
 468   1              OS_EXIT_CRITICAL();     
 469   1              return(TRUE);   
 470   1      }
 471          /**********************************************************
 472          *函数名称                       :AddrCompare    
 473          *函数描述               :比较地址(含广播地址)
 474          *输入参数               :pstBusFreq:待比较的数据帧指针
 475          *返回值                         :1:发送到本机的数据,0:不是发送到本机的数据      
 476          *全局变量                       :
 477          *调用模块                       :
 478          ***********************************************************
 479          *创建人                 :尹运同
 480          *创建日期                       :2008-9-22
 481          ***********************************************************
 482          *修改人                         :
 483          *修改日期               :
 484          *注释                   :
 485          **********************************************************/
 486          bit AddrCompare(pSTBusFreq pstBusFreq)
 487          {
 488   1              if((pstBusFreq->byRecSecAddr != 0xff) && (pstBusFreq->byRecSecAddr != stLocalControl.stEepromCfgData.bySe
             -lfSecAddr))
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 11:57:08 PAGE 9   

 489   1              {       
 490   2                      return(0);
 491   2              } 
 492   1              if((pstBusFreq->byRecRoomAddr != 0xff) && (pstBusFreq->byRecRoomAddr != stLocalControl.stEepromCfgData.by
             -SelfRoomAddr))
 493   1              {       
 494   2                      return(0);
 495   2              }
 496   1              if((pstBusFreq->byRecBedAddr != 0xff) && (pstBusFreq->byRecBedAddr != stLocalControl.stEepromCfgData.bySe
             -lfBedAddr))
 497   1              {       
 498   2                      return(0);
 499   2              }
 500   1              return(1); 
 501   1      }
 502          /**********************************************************
 503          *函数名称                       :DirAddrCompare 
 504          *函数描述               :绝对比较地址
 505          *输入参数               :pstBusFreq:待比较的数据帧指针
 506          *返回值                         :1:发送到本机的数据,0:不是发送到本机的数据      
 507          *全局变量                       :
 508          *调用模块                       :
 509          ***********************************************************
 510          *创建人                 :尹运同
 511          *创建日期                       :2008-9-22
 512          ***********************************************************
 513          *修改人                         :
 514          *修改日期               :
 515          *注释                   :
 516          **********************************************************/
 517          bit DirAddrCompare(pSTBusFreq pstBusFreq)
 518          {
 519   1              if(pstBusFreq->byRecSecAddr != stLocalControl.stEepromCfgData.bySelfSecAddr)
 520   1              {       
 521   2                      return(0);
 522   2              } 
 523   1              if(pstBusFreq->byRecRoomAddr != stLocalControl.stEepromCfgData.bySelfRoomAddr)
 524   1              {       
 525   2                      return(0);
 526   2              }
 527   1              if(pstBusFreq->byRecBedAddr != stLocalControl.stEepromCfgData.bySelfBedAddr)
 528   1              {       
 529   2                      return(0);
 530   2              }
 531   1              return(1); 
 532   1      }
 533          /**********************************************************
 534          *函数名称                       :MakeCH0TimerOut        
 535          *函数描述               :设置通道0超时参数
 536          *输入参数               :byTimerOut:超时时间,byTimerOutCount:超时次数
 537          *返回值                         :
 538          *全局变量                       :stLocalControl
 539          *调用模块                       :
 540          ***********************************************************
 541          *创建人                 :尹运同
 542          *创建日期                       :2008-9-22
 543          ***********************************************************
 544          *修改人                         :
 545          *修改日期               :
 546          *注释                   :
 547          **********************************************************/  
 548          void MakeCH0TimerOut(uint8 byTimerOut, uint8 byTimerOutCount)
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 11:57:08 PAGE 10  

 549          {
 550   1              stLocalControl.stCH0TimerOut.byTimerOutSet = byTimerOut;
 551   1              stLocalControl.stCH0TimerOut.byTimerOut = byTimerOut;
 552   1              stLocalControl.stCH0TimerOut.byTimerOutCount = byTimerOutCount; 
 553   1      }
 554          
 555          /**********************************************************
 556          *函数名称                       :SysReset       
 557          *函数描述               :系统复位,该函数仅仅将通道0复位,将通道0
 558                                                   恢复到空闲状态
 559          *输入参数               :
 560          *返回值                         :
 561          *全局变量                       :
 562          *调用模块                       :
 563          ***********************************************************
 564          *创建人                 :尹运同
 565          *创建日期                       :2008-9-22
 566          ***********************************************************
 567          *修改人                         :
 568          *修改日期               :
 569          *注释                   :
 570          **********************************************************/
 571          void SysReset(void)
 572          {       
 573   1              
 574   1      }
 575          uint8 ParaCrcCheck(uint16 addr)
 576          {
 577   1              uint8 crcResult=0;
 578   1              uint8 crcData =0;
 579   1              uint8 i;
 580   1              uint8 paraData;
 581   1              EnableIAP(IAP_READ);
 582   1              for(i=0;i<sizeof(STEepromCfgData)-1;i++)
 583   1              {
 584   2                      paraData = IapReadByte(addr);
 585   2                      crcResult +=paraData; /*IapReadByte(addr)*/;
 586   2                      addr++;
 587   2              }
 588   1              crcData = IapReadByte(addr);
 589   1              DisableIAP();
 590   1              
 591   1              if(crcData == crcResult) return 1;
 592   1              else return 0;
 593   1      }
 594          
 595          
 596          
 597          uint8 CalcParaCrc(void)
 598          {
 599   1              uint8 crcResult=0;
 600   1              uint8 i;
 601   1              uint8 *addr= &(stLocalControl.stEepromCfgData.byInitFlag);
 602   1              EnableIAP(IAP_READ);
 603   1              for(i=0;i<sizeof(STEepromCfgData)-1;i++)
 604   1              {
 605   2                      crcResult += *addr;
 606   2                      addr++;
 607   2              }
 608   1              DisableIAP();
 609   1              return crcResult;
 610   1      }
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 11:57:08 PAGE 11  

 611          
 612          /**********************************************************
 613          *函数名称                       :ReadParameter  
 614          *函数描述               :将Flash中的配置数据读入到内存中
 615          *输入参数               :
 616          *返回值                         :
 617          *全局变量                       :stLocalControl
 618          *调用模块                       :EnableIAP,IapReadByte,DisableIAP
 619          ***********************************************************
 620          *创建人                 :尹运同
 621          *创建日期                       :2008-9-22
 622          ***********************************************************
 623          *修改人                         :
 624          *修改日期               :
 625          *注释                   :
 626          **********************************************************/
 627          void ReadParameter(uint16 addr)
 628          {
 629   1      
 630   1              uint8 i=0;
 631   1              uint8 *pbyData = &(stLocalControl.stEepromCfgData.byInitFlag);
 632   1              
 633   1              EnableIAP(IAP_READ); 
 634   1              for(i=0;i<sizeof(STEepromCfgData);i++)
 635   1              {
 636   2                      *pbyData = IapReadByte(addr);
 637   2                      pbyData++;
 638   2                      addr++;
 639   2              }
 640   1              DisableIAP();
 641   1      
 642   1      }
 643          /**********************************************************
 644          *函数名称                       :SaveParameter  
 645          *函数描述               :存储配置参数,存储参数前先擦除整个扇区,
 646                                                   然后将所有参数重新写入扇区
 647          *输入参数               :
 648          *返回值                         :
 649          *全局变量                       :stLocalControl
 650          *调用模块                       :EnableIAP,IapErase,IapWriteByte,DisableIAP
 651          ***********************************************************
 652          *创建人                 :尹运同
 653          *创建日期                       :2008-9-22
 654          ***********************************************************
 655          *修改人                         :
 656          *修改日期               :
 657          *注释                   :
 658          **********************************************************/
 659          
 660          void SaveParameter(uint16 addr)
 661          {
 662   1              uint8 i;
 663   1              uint16 addr_temp=addr;
 664   1              uint8 *pbyData;
 665   1              uint8 readtimes;
 666   1              uint8 writetimes;
 667   1              uint8 crc_temp;
 668   1      
 669   1              stLocalControl.stEepromCfgData.byCrc = CalcParaCrc();
 670   1              WDT_CONTR = 0x3d;       //喂狗
 671   1              writetimes =3;
 672   1              do
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 11:57:08 PAGE 12  

 673   1              {
 674   2                      EnableIAP(IAP_ERASE);
 675   2                      IapErase(addr); 
 676   2      
 677   2                      
 678   2                      EnableIAP(IAP_WRITE); 
 679   2                      addr = addr_temp;
 680   2                      pbyData=&(stLocalControl.stEepromCfgData.byInitFlag);
 681   2                      for(i=0;i<sizeof(STEepromCfgData);i++)
 682   2                      {
 683   3                              IapWriteByte(addr,*pbyData);
 684   3                              pbyData++;
 685   3                              addr++;
 686   3                      }
 687   2      
 688   2                      //地址紧跟前一数据区
 689   2                      pbyData=&(stLocalControl.stEepromCfgData.byInitFlag);
 690   2                      for(i=0;i<sizeof(STEepromCfgData);i++)
 691   2                      {
 692   3                              IapWriteByte(addr,*pbyData);
 693   3                              pbyData++;
 694   3                              addr++;
 695   3                      }
 696   2                      
 697   2      
 698   2                      EnableIAP(IAP_READ);
 699   2                      readtimes=3;
 700   2                      do
 701   2                      {
 702   3                              WDT_CONTR = 0x3d;       //喂狗
 703   3                              pbyData=&(stLocalControl.stEepromCfgData.byInitFlag);
 704   3                              addr = addr_temp;
 705   3      
 706   3      
 707   3                              for(i=0;i<(sizeof(STEepromCfgData))*2;)
 708   3                              {
 709   4                                      if(*pbyData != IapReadByte(addr)) break;
 710   4                                      
 711   4                                      pbyData++;
 712   4                                      addr++;
 713   4                                      i++;
 714   4                                      if(i== sizeof(STEepromCfgData)) pbyData=&(stLocalControl.stEepromCfgData.byInitFlag);
 715   4                              }       
 716   3      
 717   3                              if(i>= (sizeof(STEepromCfgData)*2))
 718   3                              {//写进去的数据与读出来的数据相同
 719   4                                      break;
 720   4                              }
 721   3                      
 722   3                      }while(--readtimes);
 723   2      
 724   2                      if(readtimes)
 725   2                      {
 726   3                              break;  //相同
 727   3                      }
 728   2              }while(--writetimes);
 729   1      
 730   1              
 731   1              DisableIAP();
 732   1      }
*** WARNING C280 IN LINE 667 OF SINGLEBUS.C: 'crc_temp': unreferenced local variable
 733          
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 11:57:08 PAGE 13  

 734          
 735          /**********************************************************
 736          *函数名称                       :InitParameter  
 737          *函数描述               :初始化Flash中的配置数据
 738          *输入参数               :
 739          *返回值                         :
 740          *全局变量                       :stLocalControl
 741          *调用模块                       :EnableIAP,IapReadByte,DisableIAP
 742          ***********************************************************
 743          *创建人                 :尹运同
 744          *创建日期                       :2008-9-22
 745          ***********************************************************
 746          *修改人                         :
 747          *修改日期               :
 748          *注释                   :
 749          **********************************************************/
 750          void InitParameter(void)
 751          {
 752   1              uint8 flagData;
 753   1              uint8 readtimes=3;
 754   1      CheckIapSec0:   
 755   1      
 756   1              do
 757   1              {
 758   2      
 759   2                      if(ParaCrcCheck(IAP0_ADDR) ==1)  break;
 760   2                              
 761   2      
 762   2              }while(--readtimes);
 763   1      
 764   1      
 765   1              if(readtimes)
 766   1              {//第一块校验和正确
 767   2      
 768   2                      EnableIAP(IAP_READ);
 769   2                      flagData = IapReadByte(IAP0_ADDR);
 770   2                      DisableIAP();
 771   2                      
 772   2                      if(flagData == INIT_FLAG)
 773   2                      {//数据已经初始化完毕了,读取数据参数
 774   3                              ReadParameter(IAP0_ADDR);
 775   3                              return;
 776   3                      }
 777   2                      else    goto CheckIapSec1;      
 778   2              }
 779   1      
 780   1              else
 781   1              {
 782   2      CheckIapSec1:   
 783   2                      readtimes=3;    
 784   2                      do
 785   2                      {
 786   3                              if(ParaCrcCheck(IAP0_ADDR+sizeof(STEepromCfgData)) ==1)  break;
 787   3                                      
 788   3                      }while(--readtimes);
 789   2              
 790   2              
 791   2                      if(readtimes)
 792   2                      {//第二块校验和正确
 793   3                              EnableIAP(IAP_READ);
 794   3                              flagData = IapReadByte(IAP0_ADDR+sizeof(STEepromCfgData));
 795   3                              DisableIAP();
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 11:57:08 PAGE 14  

 796   3                              
 797   3                              if(flagData == INIT_FLAG)
 798   3                              {//数据已经初始化完毕了,读取数据参数
 799   4                                      ReadParameter(IAP0_ADDR+sizeof(STEepromCfgData));
 800   4                                      SaveParameter(IAP0_ADDR);
 801   4                                      return;
 802   4                              }
 803   3                              else    goto UseInitValue;      
 804   3                      }
 805   2                      else
 806   2                      {//第一块和第二块存储区3次读取都失败或者未初始化，应用初始值，但不保存到内部EEPROM中去
 807   3      UseInitValue:
 808   3                              stLocalControl.stEepromCfgData.byInitFlag = INIT_FLAG;
 809   3                              stLocalControl.stEepromCfgData.bySelfSecAddr = 0x01;
 810   3                              stLocalControl.stEepromCfgData.bySelfRoomAddr = 0x02;
 811   3                              stLocalControl.stEepromCfgData.bySelfBedAddr = 0x03;
 812   3                              
 813   3                              stLocalControl.stEepromCfgData.bySerialNum1= 0xff;
 814   3                              stLocalControl.stEepromCfgData.bySerialNum2= 0xff;
 815   3                              stLocalControl.stEepromCfgData.bySerialNum3= 0xff;
 816   3                              stLocalControl.stEepromCfgData.uiRs485Brt  = 57600;     //默认波特率57600
 817   3                              stLocalControl.stEepromCfgData.byCrc = CalcParaCrc();
 818   3      
 819   3                      }       
 820   2              }
 821   1              DisableIAP();   
 822   1      }
*** WARNING C280 IN LINE 754 OF SINGLEBUS.C: 'CheckIapSec0': unreferenced label
 823          /**********************************************************
 824          *函数名称                       :Bus0RecDeal    
 825          *函数描述               :单总线0收到一帧数据处理函数,该函数首先
 826                                                   取出收到的数据,针对每条命令执行对应的控
 827                                                   制动作
 828          *输入参数               :
 829          *返回值                         :
 830          *全局变量                       :stLocalControl
 831          *调用模块                       :
 832          ***********************************************************
 833          *创建人                 :尹运同
 834          *创建日期                       :2008-9-22
 835          ***********************************************************
 836          *修改人                         :
 837          *修改日期               :
 838          *注释                   :
 839          **********************************************************/
 840          void Bus0RecDeal(void)
 841          {
 842   1              uint8 x,y,temp1,temp2;
 843   1              //取出收到的数据帧                      
 844   1              OS_ENTER_CRITICAL();
 845   1              memcpy(&(stLocalControl.stBusDealFreq), byBus0RecData, sizeof(STBusFreq));
 846   1              bBus0RecFinish = 0;
 847   1              OS_EXIT_CRITICAL();     
 848   1      
 849   1      
 850   1              if(bLanding && (stLocalControl.stBusDealFreq.byCmd != CMD_ENTER))
 851   1              {       //如果是登记状态,收到的命令不是登记确认命令,不作处理
 852   2                      return;
 853   2              }
 854   1              
 855   1              switch(stLocalControl.stBusDealFreq.byCmd)
 856   1              {
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 11:57:08 PAGE 15  

 857   2                      case CMD_ENTER:                                                                         //确认登记命令                          
 858   2                              if(bLanding)
 859   2                              {       
 860   3                                      bLanding=0;
 861   3                                      MakeCH0TimerOut(0, 0); 
 862   3                                      if( (stLocalControl.stEepromCfgData.bySelfSecAddr != stLocalControl.stBusDealFreq.bySndSecAddr)||
 863   3                                              (stLocalControl.stEepromCfgData.bySelfRoomAddr != stLocalControl.stBusDealFreq.bySndRoomAddr)||
 864   3                                              (stLocalControl.stEepromCfgData.bySelfBedAddr != stLocalControl.stBusDealFreq.bySndBedAddr))
 865   3                                      {//已更换手柄,需清空手柄信息
 866   4                                              Byte_Write(DIET_LENGTH_ADDR,0x00);
 867   4                                              Byte_Write1(DIET_LENGTH_ADDR+1,0x00);
 868   4                                              stLocalControl.uiDietDataLen =0x00;
 869   4                                              
 870   4                                              Byte_Write(PRESCRIPTION_LENGTH_ADDR,0x00);
 871   4                                              Byte_Write1(PRESCRIPTION_LENGTH_ADDR+1,0x00);
 872   4                                              stLocalControl.uiPrescriptionDataLen =0x00;
 873   4                                              
 874   4                                              Byte_Write(PROMPT_LENGTH_ADDR,0x00);
 875   4                                              Byte_Write1(PROMPT_LENGTH_ADDR+1,0x00);
 876   4                                              stLocalControl.uiPromptDataLen = 0x00;
 877   4      
 878   4                                              stLocalControl.stEepromCfgData.bySelfSecAddr= stLocalControl.stBusDealFreq.bySndSecAddr;
 879   4                                              stLocalControl.stEepromCfgData.bySelfRoomAddr= stLocalControl.stBusDealFreq.bySndRoomAddr;
 880   4                                              stLocalControl.stEepromCfgData.bySelfBedAddr= stLocalControl.stBusDealFreq.bySndBedAddr;
 881   4                                              SaveParameter(IAP0_ADDR);                                       
 882   4                                      }
 883   3                                      
 884   3                                      if( (stLocalControl.stBusDealFreq.byRecSecAddr&0x01) == 0x01)
 885   3                                      {//bit0==1:表示病人出院
 886   4                                              stLocalControl.byPatientDischarge =1;
 887   4                                              BL_SW=0;        //关背光 
 888   4                                      }
 889   3                                      else
 890   3                                      {//此床位有病人
 891   4                                              stLocalControl.byPatientDischarge =0;
 892   4                                      }
 893   3                                      
 894   3      
 895   3                                      if( (stLocalControl.stBusDealFreq.byRecSecAddr&0x02) == 0x02)
 896   3                                      {//bit1==1:表示显示屏背关打开
 897   4                                              bBL_SW_State=1;
 898   4                                              if(stLocalControl.byPatientDischarge ==0)
 899   4                                              {
 900   5                                                      BL_SW=1;        //背光打开
 901   5                                              }
 902   4                                              else BL_SW=0;
 903   4                                      }
 904   3                                      else 
 905   3                                      {
 906   4                                              bBL_SW_State=BL_SW=0;   //背光关闭
 907   4                                      }
 908   3                                      ShowLandingFace();
 909   3                              }                       
 910   2                              break;
 911   2                      case CMD_INFUSION_ENTER:                                                                //输液呼叫确认命令
 912   2                      case CMD_SERVICE_ENTER:                                                                 //服务呼叫确认命令
 913   2                      case CMD_HELP_ENTER:                                                                    //求援呼叫确认命令
 914   2                      case CMD_EMERGENCY_ENTER:                                                               //紧急呼叫确认命令
 915   2                               SetLedState(LED_ON);
 916   2                               ShowCallSuccess(); 
 917   2                               stLocalControl.uiLcdDisplayOnTime = 250;       //如果黑时亮5S
 918   2                               BL_SW=1;                        
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 11:57:08 PAGE 16  

 919   2                               break;
 920   2                      case CMD_INFUSION_CLEAR:                                                                 //输液呼叫清除命令
 921   2                      case CMD_SERVICE_CLEAR:                                                          //服务呼叫清除命令
 922   2                      case CMD_HELP_CLEAR:                                                                     //求援呼叫清除命令
 923   2                      case CMD_EMERGENCY_CLEAR:                                                                //紧急呼叫清除命令
 924   2                                SetLedState(LED_OFF);
 925   2                                ShowLandingFace();                     
 926   2                                break;
 927   2                      case CMD_TALK_CLEAR:
 928   2                                MicCtrlState=MIC_CTRL=0;
 929   2                                SetLedState(LED_OFF);
 930   2                                ShowLandingFace();                     
 931   2                                break;
 932   2                      case CMD_CALL_LISTEN:
 933   2                      case CMD_CHANNEL_CHANGE:
 934   2                                SetLedState(LED_ON);
 935   2                                MicCtrlState=MIC_CTRL=1;
 936   2                                ShowTalkFace();                        
 937   2                                break;
 938   2                      case CMD_CHANNEL_CLOSE:
 939   2                      case CMD_STOP_INDICATION:
 940   2                      case CMD_SYSTERM_RESET:
 941   2                                MicCtrlState=MIC_CTRL=0;
 942   2                                SetLedState(LED_OFF);
 943   2                                ShowLandingFace();                     
 944   2                                break;
 945   2                      case CMD_DATE_SEND:
 946   2                                stLocalControl.stTime.bySecond=stLocalControl.stBusDealFreq.bySndSecAddr;
 947   2                                stLocalControl.stTime.byMinute=stLocalControl.stBusDealFreq.bySndRoomAddr;
 948   2                                stLocalControl.stTime.byHour  =stLocalControl.stBusDealFreq.bySndBedAddr;
 949   2                                stLocalControl.stTime.byDay=stLocalControl.stBusDealFreq.byRecSecAddr;
 950   2                                stLocalControl.stTime.byMonth=stLocalControl.stBusDealFreq.byRecRoomAddr;
 951   2                                stLocalControl.stTime.byYear=stLocalControl.stBusDealFreq.byRecBedAddr;
 952   2                                if(stLocalControl.byDisplayFace==LAND_FACE)
 953   2                                {
 954   3                                      x=0;y=32;
 955   3                                      temp1=stLocalControl.stTime.byYear;     //BCD码
 956   3                                      temp2=temp1%16; //个位
 957   3                                      temp1=temp1/16; //十位
 958   3                                      DisplayDigitString(&x,&y,&temp1,1,BLACK,CYAN,3);
 959   3                                      DisplayDigitString(&x,&y,&temp2,1,BLACK,CYAN,3);
 960   3                                      //DisplayASCIIString(&x,&y,"-",1,BLACK,CYAN,3); 
 961   3      
 962   3                                      x+=16;
 963   3                                      temp1=stLocalControl.stTime.byMonth;    //BCD码
 964   3                                      temp2=temp1%16; //个位
 965   3                                      temp1=temp1/16; //十位
 966   3                                      DisplayDigitString(&x,&y,&temp1,1,BLACK,CYAN,3);
 967   3                                      DisplayDigitString(&x,&y,&temp2,1,BLACK,CYAN,3);
 968   3                                      //DisplayASCIIString(&x,&y,"-",1,BLACK,CYAN,3);
 969   3      
 970   3                                      x+=16;
 971   3                                      temp1=stLocalControl.stTime.byDay;      //BCD码
 972   3                                      temp2=temp1%16; //个位
 973   3                                      temp1=temp1/16; //十位
 974   3                                      DisplayDigitString(&x,&y,&temp1,1,BLACK,CYAN,3);
 975   3                                      DisplayDigitString(&x,&y,&temp2,1,BLACK,CYAN,3);
 976   3      
 977   3                                      //DisplayBlock(0,64,23,95,CYAN_CODE);
 978   3                                      x=24;y=64;
 979   3                                      temp1=stLocalControl.stTime.byHour; //BCD码
 980   3                                      temp2=temp1%16; //个位
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 11:57:08 PAGE 17  

 981   3                                      temp1=temp1/16; //十位
 982   3                                      DisplayDigitString(&x,&y,&temp1,1,BLACK,CYAN,3);
 983   3                                      DisplayDigitString(&x,&y,&temp2,1,BLACK,CYAN,3);
 984   3                                      //DisplayASCIIString(&x,&y,":",1,BLACK,CYAN,3); 
 985   3      
 986   3                                      x+=16;
 987   3                                      temp1=stLocalControl.stTime.byMinute; //BCD码
 988   3                                      temp2=temp1%16; //个位
 989   3                                      temp1=temp1/16; //十位
 990   3                                      DisplayDigitString(&x,&y,&temp1,1,BLACK,CYAN,3);
 991   3                                      DisplayDigitString(&x,&y,&temp2,1,BLACK,CYAN,3);
 992   3                                      //DisplayBlock(x,y,127,95,CYAN_CODE);                           
 993   3                                }
 994   2                                break;
 995   2                               
 996   2                      case CMD_OPEN_485BUS_IN:
 997   2      //                      if(stLocalControl.stBusDealFreq.byRecSecAddr==CMD_SB_LCD_DISPLAY_DATA)
 998   2                              if((stLocalControl.stBusDealFreq.byRecSecAddr==DIET_TYPE) ||
 999   2                                      (stLocalControl.stBusDealFreq.byRecSecAddr==PRESCRIPTION_TYPE) ||
1000   2                                      (stLocalControl.stBusDealFreq.byRecSecAddr==PROMPT_INFO_TYPE) )
1001   2                              {//是发送显示数据到手柄 ,关闭MIC
1002   3                                      MIC_CTRL=0;                             
1003   3                              }
1004   2                              //包含显示屏数据
1005   2                              stLocalControl.byPatientDischarge = 0;
1006   2                              BL_SW=1;        //打开显示屏背光
1007   2                              stLocalControl.uiLcdDisplayOnTime= 500; //亮10秒钟
1008   2                              break;
1009   2      
1010   2                      case CMD_BUS_ANSWER:
1011   2                              if(stLocalControl.stBusDealFreq.byRecSecAddr == CMD_DISPLAY_DATA)
1012   2                              {//显示屏的回应答信号
1013   3                                      stLocalControl.byPatientDischarge = 0;
1014   3                                      BL_SW=1;        //打开显示屏背光
1015   3                                      stLocalControl.uiLcdDisplayOnTime= 500; //亮10秒钟                      
1016   3                              }
1017   2                              break;
1018   2                              
1019   2                      case CMD_CLOSE_485BUS:
1020   2                              if(stLocalControl.stBusDealFreq.bySndSecAddr==CMD_SB_LCD_DISPLAY_DATA)
1021   2                              {//恢复MIC原来的状态
1022   3                                      MIC_CTRL=MicCtrlState;
1023   3                              }
1024   2                              break;                  
1025   2                      case CMD_BROADCAST1:
1026   2                      case CMD_BROADCAST2:
1027   2                      case CMD_BROADCAST3:
1028   2                              if((stLocalControl.stBusDealFreq.bySndSecAddr == stLocalControl.stEepromCfgData.bySelfSecAddr) &&
1029   2                                 (stLocalControl.stBusDealFreq.bySndRoomAddr == stLocalControl.stEepromCfgData.bySelfRoomAddr) &&
1030   2                                 (stLocalControl.stBusDealFreq.bySndBedAddr == stLocalControl.stEepromCfgData.bySelfBedAddr))
1031   2                              {//是自己广播
1032   3                                MicCtrlState=MIC_CTRL=1;
1033   3                                ShowBroadFace();                       
1034   3                              }
1035   2                                break;
1036   2                      case CMD_OPEN_LCD:
1037   2                              if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
1038   2                              {
1039   3                                      bBL_SW_State=BL_SW=1;
1040   3                              }
1041   2                              else if(AddrCompare(&(stLocalControl.stBusDealFreq)))
1042   2                              {//广播打开
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 11:57:08 PAGE 18  

1043   3                                      bBL_SW_State =1;
1044   3                                      if(stLocalControl.byPatientDischarge ==0 )
1045   3                                      {//病人还没出院
1046   4                                              BL_SW = 1;
1047   4                                      }
1048   3                              }
1049   2                              break;
1050   2                              
1051   2                      case CMD_CLOSE_LCD:
1052   2                              bBL_SW_State = BL_SW =0;
1053   2                              break;
1054   2                              
1055   2                      case CMD_CLEAR_LCD:
1056   2                              stLocalControl.byPatientDischarge = 1;  //病人出院
1057   2                              BL_SW=0;        //关闭显示屏背光
1058   2                              //清床头分机显示屏时,也将清手柄内消息
1059   2                              Byte_Write(DIET_LENGTH_ADDR,0x00);
1060   2                              Byte_Write1(DIET_LENGTH_ADDR+1,0x00);
1061   2                              
1062   2                              Byte_Write(PRESCRIPTION_LENGTH_ADDR,0x00);
1063   2                              Byte_Write1(PRESCRIPTION_LENGTH_ADDR+1,0x00);
1064   2                              
1065   2                              Byte_Write(PROMPT_LENGTH_ADDR,0x00);
1066   2                              Byte_Write1(PROMPT_LENGTH_ADDR+1,0x00);
1067   2                              
1068   2                              stLocalControl.uiDietDataLen =0x00;
1069   2                              stLocalControl.uiPrescriptionDataLen =0x00;
1070   2                              stLocalControl.uiPromptDataLen =0x00;                   
1071   2                              break;
1072   2      
1073   2                      case CMD_CLEAR_HANDLE_LCD:      //清空手柄各数据
1074   2                              Byte_Write(DIET_LENGTH_ADDR,0x00);
1075   2                              Byte_Write1(DIET_LENGTH_ADDR+1,0x00);
1076   2                              
1077   2                              Byte_Write(PRESCRIPTION_LENGTH_ADDR,0x00);
1078   2                              Byte_Write1(PRESCRIPTION_LENGTH_ADDR+1,0x00);
1079   2                              
1080   2                              Byte_Write(PROMPT_LENGTH_ADDR,0x00);
1081   2                              Byte_Write1(PROMPT_LENGTH_ADDR+1,0x00);
1082   2      
1083   2                              stLocalControl.uiDietDataLen =0x00;
1084   2                              stLocalControl.uiPrescriptionDataLen =0x00;
1085   2                              stLocalControl.uiPromptDataLen =0x00;
1086   2                              break;
1087   2                              
1088   2                      case CMD_NURSE_IN:
1089   2                              if((bBL_SW_State==0)||(stLocalControl.byPatientDischarge == 1)) //黑屏的情况下
1090   2                              {
1091   3                                      BL_SW=1;        //打开显示屏
1092   3                              }
1093   2                              break;
1094   2                      case CMD_NURSE_OUT:
1095   2                              if((bBL_SW_State==0)||(stLocalControl.byPatientDischarge == 1)) //黑屏的情况下
1096   2                              {
1097   3                                      BL_SW=0;        //关闭显示屏
1098   3                              }
1099   2                              break;  
1100   2                      case CMD_NUMBER_SET:
1101   2                              if(stLocalControl.stBusDealFreq.byRecSecAddr==0x02)             //成功  
1102   2                              {
1103   3                                      stLocalControl.stEepromCfgData.bySelfSecAddr= stLocalControl.stBusDealFreq.bySndSecAddr;
1104   3                                      stLocalControl.stEepromCfgData.bySelfRoomAddr= stLocalControl.stBusDealFreq.bySndRoomAddr;
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 11:57:08 PAGE 19  

1105   3                                      stLocalControl.stEepromCfgData.bySelfBedAddr= stLocalControl.stBusDealFreq.bySndBedAddr;
1106   3                                      SaveParameter(IAP0_ADDR);
1107   3                                      ShowLandingFace();
1108   3                              }
1109   2                              break;
1110   2                      case CMD_SYSTEM_SEC_SET:
1111   2                              stLocalControl.stEepromCfgData.bySelfSecAddr = stLocalControl.stBusDealFreq.byRecSecAddr;
1112   2                              SaveParameter(IAP0_ADDR);
1113   2                              break;
1114   2                              
1115   2                      case CMD_BUS1_TEST:
1116   2                              stLocalControl.stBusDealFreq.byCmd = CMD_BUS1_TEST_ANSWER;
1117   2                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1118   2                              break;
1119   2                              
1120   2                      case CMD_POWER_ON:                                                                      //本机重新热启动
1121   2                              if(AddrCompare(&(stLocalControl.stBusDealFreq)))
1122   2                              {       
1123   3                                      OS_ENTER_CRITICAL();                                            
1124   3                                      //关闭所有中断
1125   3                                      CCAPM0 = 0;
1126   3                                      ET0 = 0;
1127   3                                      TR0 = 0;
1128   3                                      EX1 = 0;
1129   3                                      ISP_CONTR = 0x20;                       
1130   3                              }
1131   2                              break;
1132   2                              
1133   2                      case CMD_BUS1_CHECK:
1134   2                              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1135   2                              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1136   2                              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1137   2                              stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER;
1138   2                              stLocalControl.stBusDealFreq.byRecSecAddr = CMD_BUS1_CHECK;
1139   2                              stLocalControl.stBusDealFreq.byRecRoomAddr = 0x00;
1140   2                              stLocalControl.stBusDealFreq.byRecBedAddr = 0x00;
1141   2                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1142   2                              break;
1143   2                      case CMD_RS485_BRT_SET:
1144   2                              switch(stLocalControl.stBusDealFreq.byRecSecAddr)
1145   2                              {
1146   3                                      case 1:
1147   3                                              stLocalControl.stEepromCfgData.uiRs485Brt       =1200;
1148   3                                              break;
1149   3                                      case 2:
1150   3                                              stLocalControl.stEepromCfgData.uiRs485Brt       = 2400;
1151   3                                              break;
1152   3                                      case 3:
1153   3                                              stLocalControl.stEepromCfgData.uiRs485Brt       = 4800;
1154   3                                              break;
1155   3                                      case 4:
1156   3                                              stLocalControl.stEepromCfgData.uiRs485Brt       = 9600;
1157   3                                              break;
1158   3                                      case 5:
1159   3                                              stLocalControl.stEepromCfgData.uiRs485Brt       = 14400;
1160   3                                              break;
1161   3                                      case 6:
1162   3                                              stLocalControl.stEepromCfgData.uiRs485Brt       = 19200;
1163   3                                              break;
1164   3                                      case 7:
1165   3                                              stLocalControl.stEepromCfgData.uiRs485Brt       = 28800;
1166   3                                              break;
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 11:57:08 PAGE 20  

1167   3                                      case 8:
1168   3                                              stLocalControl.stEepromCfgData.uiRs485Brt       = 38400;
1169   3                                              break;
1170   3                                      case 9:
1171   3                                              stLocalControl.stEepromCfgData.uiRs485Brt       = 57600;
1172   3                                              break;
1173   3                                      default:
1174   3                                              return;         //其它无效，退出
1175   3                                              
1176   3                              }
1177   2                              UsartInit();    
1178   2                              SaveParameter(IAP0_ADDR);
1179   2                      default:
1180   2                              break;
1181   2              }       
1182   1      
1183   1      }
1184          /**********************************************************
1185          *函数名称                       :Bus0SendDeal   
1186          *函数描述               :单总线0发送完一帧数据处理函数,该函数首先
1187                                                   取出收到的数据,针对每条命令执行对应的控
1188                                                   制动作
1189          *输入参数               :
1190          *返回值                         :
1191          *全局变量                       :stLocalControl
1192          *调用模块                       :
1193          ***********************************************************
1194          *创建人                 :尹运同
1195          *创建日期                       :2008-9-22
1196          ***********************************************************
1197          *修改人                         :
1198          *修改日期               :
1199          *注释                   :
1200          **********************************************************/
1201          void Bus0SendDeal(void)
1202          { 
1203   1              //取出发送完成的数据帧
1204   1              OS_ENTER_CRITICAL();
1205   1              memcpy(&(stLocalControl.stBusDealFreq), byBus0SendData, sizeof(STBusFreq));             
1206   1              bBus0SendFinish = 0;
1207   1              OS_EXIT_CRITICAL();     
1208   1      
1209   1              //以下仅供测试用
1210   1      //      led0flash();
1211   1      
1212   1              /////////////////////////////////////////////////////////////////////////////////////
1213   1      
1214   1              switch(stLocalControl.stBusDealFreq.byCmd)
1215   1              {
1216   2                      case CMD_LANDING:                                                                       //登记命令
1217   2                              if(bLanding)
1218   2                              {       //本机确实处在登记状态,设置等待确认超时
1219   3                                      MakeCH0TimerOut(150, 0);                                
1220   3                              }                       
1221   2                              break;                  
1222   2                      default:
1223   2                              break;
1224   2      
1225   2              }       
1226   1      }
1227          /**********************************************************
1228          *函数名称                       :Bus0Manage     
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 11:57:08 PAGE 21  

1229          *函数描述               :单总线0管理线程
1230          *输入参数               :
1231          *返回值                         :
1232          *全局变量                       :byMainCmdQ
1233          *调用模块                       :OSQPost
1234          ***********************************************************
1235          *创建人                 :尹运同
1236          *创建日期                       :2008-9-22
1237          ***********************************************************
1238          *修改人                         :
1239          *修改日期               :
1240          *注释                   :
1241          **********************************************************/
1242          void Bus0Manage(void)
1243          {       
1244   1              while(TRUE)
1245   1              {               
1246   2                      WDT_CONTR = 0x3d;       //喂狗
1247   2                      if(bBus0RecFinish)                                                                      //总线0收到数据
1248   2                      {       
1249   3                              OSQPost(byMainCmdQ, BUS0_REC);                          
1250   3                      }
1251   2                      if(bBus0SendFinish)                                                                     //总线0发送完数据帧
1252   2                      {
1253   3                              OSQPost(byMainCmdQ, BUS0_SND);                  
1254   3                      } 
1255   2                      OSWait(K_TMO, 1);                                       
1256   2              }
1257   1      }
1258          /**********************************************************
1259          *函数名称                       :TimerOutDeal   
1260          *函数描述               :超时处理函数
1261          *输入参数               :
1262          *返回值                         :
1263          *全局变量                       :stLocalControl
1264          *调用模块                       :Bus0OutputData,Bus1OutputData,VoiceChannelCtx,
1265                                                   LedControl,SetHandLedState
1266          ***********************************************************
1267          *创建人                 :尹运同
1268          *创建日期                       :2008-9-22
1269          ***********************************************************
1270          *修改人                         :
1271          *修改日期               :
1272          *注释                   :
1273          **********************************************************/
1274          void TimerOutDeal(void)
1275          { 
1276   1      uint8 xdata x,y;
1277   1      
1278   1              if(stLocalControl.stCH0TimerOut.byTimerOut != 0)
1279   1              {       //有超时设置存在
1280   2                      stLocalControl.stCH0TimerOut.byTimerOut--;
1281   2                      if(stLocalControl.stCH0TimerOut.byTimerOut == 0)
1282   2                      {       //超时一次到了 
1283   3                              if(stLocalControl.stCH0TimerOut.byTimerOutCount == 0x00)
1284   3                              {       //所有超时完成
1285   4                                      goto TIMER0OUTDEAL;
1286   4                              }
1287   3                              else
1288   3                              {       //超时次数没有完
1289   4                                      stLocalControl.stCH0TimerOut.byTimerOutCount--;
1290   4                                      if(stLocalControl.stCH0TimerOut.byTimerOutCount == 0x00)
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 11:57:08 PAGE 22  

1291   4                                      {       //所有超时完成
1292   5      TIMER0OUTDEAL:
1293   5                                              if(bLanding)
1294   5                                              {       //上电状态
1295   6                                                      stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1296   6                                                      stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1297   6                                                      stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1298   6                                                      stLocalControl.stBusDealFreq.byCmd = CMD_LANDING;
1299   6                                                      stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.bySerialNum1;
1300   6                                                      stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stEepromCfgData.bySerialNum2;
1301   6                                                      stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stEepromCfgData.bySerialNum3;
1302   6                                                      Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                                           
1303   6                                              }
1304   5      
1305   5                                      }
1306   4                                      else
1307   4                                      {       //超时次数没有完成，重新加载单位超时时间                                
1308   5                                              stLocalControl.stCH0TimerOut.byTimerOut = stLocalControl.stCH0TimerOut.byTimerOutSet;
1309   5                                      }
1310   4                              }                       
1311   3                      }
1312   2              }       
1313   1              //灯状态控制
1314   1              if(--stLocalControl.byLedFlashTime == 0x00)
1315   1              {
1316   2                      stLocalControl.byLedFlashTime = stLocalControl.byLedTimeSet;
1317   2                      if((stLocalControl.byLedState & 0x0f) == LED_FLASH)
1318   2                      {       //灯闪烁状态
1319   3                              FLED = !FLED;
1320   3                              LED = FLED;
1321   3                      }       
1322   2              }
1323   1      
1324   1              if(--stLocalControl.bySecondFlashTime==0)
1325   1              {
1326   2                      stLocalControl.bySecondFlashTime=25;
1327   2                      if(stLocalControl.byDisplayFace==LAND_FACE)
1328   2                      {
1329   3                              x=56;y=64;
1330   3                              bSecondDisState=!bSecondDisState;
1331   3                              if(bSecondDisState)
1332   3                              {
1333   4                                      Display_ASCII(56,64,ColonCode16x32,BLACK,CYAN,3);       //":"                           
1334   4                              }
1335   3                              else
1336   3                              {
1337   4                                      DisplayBlock(56,64,56+15,64+31,CYAN_CODE);
1338   4                              }
1339   3                              
1340   3                      }
1341   2              }
1342   1              if(stLocalControl.uiLcdDisplayOnTime)
1343   1              {
1344   2                      if(--stLocalControl.uiLcdDisplayOnTime==0)      //LCD在显示常关的情况下显示时间已到
1345   2                      {
1346   3                              if((bBL_SW_State==0)||(stLocalControl.byPatientDischarge==1))
1347   3                              {//此床没病人或者在关背光时段
1348   4                                      BL_SW =0;       //关显示屏
1349   4                              }
1350   3                      }
1351   2              }
1352   1      
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 11:57:08 PAGE 23  

1353   1              if(stLocalControl.uiLcdDisplayInfoTime)
1354   1              {
1355   2                      if(--stLocalControl.uiLcdDisplayInfoTime==0)
1356   2                      {
1357   3                              CurrentPage =0;
1358   3                              stLocalControl.uiLcdDisplayInfoTime =0;         
1359   3                              ShowLandingFace();
1360   3                      }
1361   2              }
1362   1      }
1363          /**********************************************************
1364          *函数名称                       :TimerOutManager        
1365          *函数描述               :超时管理线程
1366          *输入参数               :
1367          *返回值                         :
1368          *全局变量                       :stLocalControl,byMainCmdQ
1369          *调用模块                       :OSQPost                                
1370          ***********************************************************
1371          *创建人                 :尹运同
1372          *创建日期                       :2008-9-22
1373          ***********************************************************
1374          *修改人                         :
1375          *修改日期               :
1376          *注释                   :
1377          **********************************************************/     
1378          void TimerOutManager(void)       
1379          {       
1380   1              while(1)
1381   1              {       
1382   2                      WDT_CONTR = 0x3d;       //喂狗
1383   2                      OSWait(K_TMO, 4);                                                                       //设置20ms超时  
1384   2                      if(stLocalControl.stCH0TimerOut.byTimerOut)
1385   2                      {       
1386   3                              OSQPost(byMainCmdQ, TIMER_OUT);                         
1387   3                      }
1388   2                      else
1389   2                      {               
1390   3                              OSQPost(byMainCmdQ, TIMER_OUT); 
1391   3                      }                       
1392   2              }
1393   1      } 
1394                            


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4138    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2      38
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     67    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
