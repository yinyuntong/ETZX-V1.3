C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE LCD
OBJECT MODULE PLACED IN LCD.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE LCD.c LARGE BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*
   2          ************************Copyright(c)************************
   3          *            湖南一特电子股份有限公司
   4          *             All Rights Reserved
   5          *              
   6          *
   7          *-----------------------文件信息---------------------------
   8          *文件名称         :TFT.c
   9          *文件描述       :TFT彩屏驱动程序
  10          *创建人         :尹运同
  11          *创建日期       :2008-9-22
  12          *版本号           :V1.0
  13          *注释                   
  14          *----------------------------------------------------------
  15          *修改人       :
  16          *修改日期       :
  17          *版本号           :
  18          *注释         :
  19          ***********************************************************
  20          */
  21          #define _IN_LCD_
  22          #include "config.h"
  23          
  24          
  25          uint8 xdata fontbuf1,fontbuf2,fontbuf3;
  26          uint8 xdata BedDataBuff[SEGMENT_DATA_LEN];
  27          
  28          
  29          uint16 code ColorArray[8]={BLACK,RED,GREEN,BLUE,YELLOW,PURPLE,CYAN,WHITE};
  30          
  31          uint16 x;
  32          uint16 y;
  33          uint8 size;
  34          uint8 mul_row;
  35          uint8 mul_col;
  36          uint16 fcolor;
  37          uint16 bcolor;
  38          uint8 *pDispData;
  39          uint8 page;
  40          uint16 start_x;
  41          uint16 start_y;
  42          uint16 end_x;
  43          uint16 end_y;
  44          uint8 Length;
  45          uint8 DotWidth;
  46          
  47          bit fTitle_TextAtLine=0;  //正文与标题在同一行标志
  48          
  49          uint8 dot_number=0;
  50          uint8  current_size=0;  //当前字符尺寸
  51          uint8  current_vert_spac=0;//当前行间距
  52          
  53          
  54          void DispManager(void);
  55          
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 2   

  56          void Send_Ssd1963_Command(uint8 ssd1963_command);
  57          void Send_Ssd1963_Data(uint8 ssd1963_data);
  58          void InitSSD1963(void);
  59          void Set_Display_Area(uint16 start_x,uint16 end_x,uint16 start_y,uint16 end_y);
  60          void Display_Dot(void);
  61          void Display_HLine(uint16  width);
  62          void Display_VLine(uint16  height);
  63          void Lcd_Clear(void);
  64          
  65          
  66          
  67          void ShowBroadFace(uint8 byRoomAddr, uint8 byBedAddr, bit bSelf);
  68          void ShowCallFace(uint8 byRoomAddr, uint8 byBedAddr, uint8 byCallType);
  69          void ShowTalkFace(uint8 byRoomAddr, uint8 byBedAddr);
  70          void ShowBedFace(void);
  71          
  72          void ShowStartInfusionCall();
  73          void ShowStartServiceCall();
  74          void ShowStartEmergencyCall();
  75          void ShowStartHelpCall();
  76          void ShowCallSuccess();
  77          
  78          void lcd_fangda_dis_text(uint8 type_x_wide, uint8 type_y_height);
  79          void DisplayDigitString(void);
  80          void DisplayString(void);
  81          void DisplayStringLen(void);
  82          void DisplayOneChar(uint8 byChar);
  83          
  84          
  85          
  86          void ShowPatientBaseInfo(void);
  87          
  88          
  89          void BL_OFF(void);
  90          void BL_ON(void);
  91          void ShowPowerUpFace(void); //写在第0页
  92          void Set_VisualPage(uint8 VisualPage);
  93          void ShowBedFaceForm(void);
  94          
  95          
  96          void ShowItem(uint8 ItemCode);
  97          
  98          
  99          uint8 GetTitleLength(uint8 ItemCode);
 100          uint8* GetTitle(uint8 ItemCode);
 101          
 102          
 103          void get_dot_number();
 104          void get_basesize_mul();
 105          
 106          
 107          
 108          #define WriteData8(sdata) {DataPortL=(sdata); SSD1963_WR=0; SSD1963_WR=1;}  
 109            
 110          #define WriteData16(sdata) {DataPortL=(sdata); DataPortH=(sdata)>>8;SSD1963_WR=0; SSD1963_WR=1;} 
 111          
 112          /*---------------------------------------------------------------------------
 113          函数原型: void Send_Ssd1963_Command(uint8 xdata ssd1963_command)
 114          参数说明: ssd1963_command:需要写的命令
 115          返 回 值: 无
 116          函数功能: 写命令
 117          ----------------------------------------------------------------------------*/
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 3   

 118          void Send_Ssd1963_Command(uint8 ssd1963_command)
 119          {
 120   1        SSD1963_CD=0;
 121   1        SSD1963_CS=0;
 122   1        DataPortL=ssd1963_command;
 123   1        SSD1963_WR=0; 
 124   1        SSD1963_WR=1;
 125   1        SSD1963_CS=1;
 126   1        SSD1963_CD=1;  
 127   1        
 128   1      }
 129          /*---------------------------------------------------------------------------
 130          函数原型: void Send_Ssd1963_Data(uint8 xdata ssd1963_data)
 131          参数说明: ssd1963_data:需要写的数据
 132          返 回 值: 无
 133          函数功能: 写数据
 134          ----------------------------------------------------------------------------*/
 135          void Send_Ssd1963_Data(uint8 ssd1963_data)
 136          {
 137   1        SSD1963_CS=0;
 138   1        DataPortL=ssd1963_data;
 139   1        SSD1963_WR=0;
 140   1        SSD1963_WR=1;
 141   1        SSD1963_CS=1;
 142   1      
 143   1      }
 144          
 145          
 146          void SSD1963Data_16(uint16 sdata)
 147          
 148          {
 149   1        SSD1963_CS=0;
 150   1        DataPortL=sdata;//temp.UByte[1];
 151   1        DataPortH=sdata>>8;//temp.UByte[0];
 152   1        SSD1963_WR=0;
 153   1        SSD1963_WR=1;
 154   1        SSD1963_CS=1;
 155   1      }
 156          
 157          
 158          /*---------------------------------------------------------------------------
 159          函数原型: void Read_Ssd1963_Data()
 160          参数说明: 
 161          返 回 值: 无
 162          函数功能: 读参数
 163          ----------------------------------------------------------------------------*/
 164          uint8 Read_Ssd1963_Data()
 165          {
 166   1        uint8 RdData;
 167   1        SSD1963_CS=0;
 168   1        SSD1963_RD=0;
 169   1        SSD1963_RD=1; 
 170   1        RdData=DataPortL;
 171   1        SSD1963_CS=1;
 172   1        return(RdData);
 173   1      
 174   1      }
 175          
 176          
 177          void SetScrollArea(uint16 top, uint16 scroll, uint16 bottom)
 178          {
 179   1      
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 4   

 180   1        Send_Ssd1963_Command(cmd_set_scroll_area);
 181   1        Send_Ssd1963_Data(top>>8);
 182   1        Send_Ssd1963_Data(top);
 183   1        Send_Ssd1963_Data(scroll>>8);
 184   1        Send_Ssd1963_Data(scroll);
 185   1        Send_Ssd1963_Data(bottom>>8);
 186   1        Send_Ssd1963_Data(bottom);
 187   1      }
 188          
 189          void SetScrollStart(uint16 line)
 190          {
 191   1        Send_Ssd1963_Command(cmd_set_scroll_start);
 192   1        Send_Ssd1963_Data(line>>8);
 193   1        Send_Ssd1963_Data(line); 
 194   1      }
 195          
 196          void Set_VisualPage(uint8 VisualPage)
 197          {
 198   1        SetScrollStart(VisualPage*272);
 199   1      }
 200          
 201          /*---------------------------------------------------------------------------
 202          函数原型: void InitSSD1963(void)
 203          参数说明: 无
 204          返 回 值: 无
 205          函数功能: 初始化LCD控制器
 206          ----------------------------------------------------------------------------*/
 207          void InitSSD1963(void)
 208          {
 209   1        //-------------------------
 210   1        SSD1963_TE=1;
 211   1        SSD1963_RD=1;
 212   1        SSD1963_CS=0;
 213   1        //-------------------------
 214   1        SSD1963_RST=1;         //硬件复位
 215   1        Delayms(50);
 216   1        SSD1963_RST=0;
 217   1        Delayms(200);
 218   1        SSD1963_RST=1;
 219   1        Delayms(50);
 220   1      
 221   1        
 222   1        //设定PLL分频系数
 223   1        //pll: n= 34 m= 3
 224   1        Send_Ssd1963_Command(cmd_set_pll_mn);      
 225   1        Send_Ssd1963_Data(0x3B); //倍频系数为60 晶振为6M 倍频后为360M VCO
 226   1        Send_Ssd1963_Data(0x02); //分频系数为3 工作频率为360M/3=42M
 227   1        Send_Ssd1963_Data(0x54); //固定值 
 228   1      
 229   1        Send_Ssd1963_Command(cmd_set_pll); //允许PLL
 230   1        Send_Ssd1963_Data(0x01);   
 231   1        //延时1Ms
 232   1        Delayms(1);
 233   1        Send_Ssd1963_Command(cmd_set_pll);     //锁定PLL
 234   1        Send_Ssd1963_Data(0x03);
 235   1      
 236   1      
 237   1        //software reset    
 238   1      
 239   1        Send_Ssd1963_Command(cmd_soft_reset);
 240   1        
 241   1        //设定像素时钟  
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 5   

 242   1        //屏幕为4.3时(480x272)，帧频为30FPS 像素时钟为3.9168M FPR=32596    60FPS时 FPR= 65192
 243   1        Send_Ssd1963_Command(cmd_set_lshift_freq);      
 244   1        Send_Ssd1963_Data(0x01); //00
 245   1        Send_Ssd1963_Data(0x33); //63
 246   1        Send_Ssd1963_Data(0x32); //32
 247   1        
 248   1        //面板参数设定       
 249   1        Send_Ssd1963_Command(cmd_set_lcd_mode);
 250   1        Send_Ssd1963_Data(0x18);  //显示18bit总线 允许FRC 下降沿及低电平有效
 251   1        Send_Ssd1963_Data(0x20);  //TFT RGB总线 允许控制信号
 252   1        Send_Ssd1963_Data((DISP_HOR_RESOLUTION-1)>>8);
 253   1        Send_Ssd1963_Data(DISP_HOR_RESOLUTION-1);  //水平像素480
 254   1        Send_Ssd1963_Data((DISP_VER_RESOLUTION-1)>>8); 
 255   1        Send_Ssd1963_Data(DISP_VER_RESOLUTION-1);  //Hor 像素272
 256   1        Send_Ssd1963_Data(0x00);  //像素序列RGB
 257   1      
 258   1      
 259   1          
 260   1        //水平同步信号设定
 261   1        Send_Ssd1963_Command(cmd_set_hori_period);     
 262   1           
 263   1      #define HT (DISP_HOR_RESOLUTION+DISP_HOR_PULSE_WIDTH+DISP_HOR_BACK_PORCH+DISP_HOR_FRONT_PORCH)
 264   1        Send_Ssd1963_Data((HT-1)>>8);
 265   1        Send_Ssd1963_Data(HT-1); //水平周期 503个时钟周期 (包含显示周期与非显示周期)
 266   1      #define HPS (DISP_HOR_PULSE_WIDTH+DISP_HOR_BACK_PORCH)
 267   1        Send_Ssd1963_Data((HPS-1)>>8); 
 268   1        Send_Ssd1963_Data(HPS-1); //水平非显示周期时钟个数为42
 269   1        Send_Ssd1963_Data(DISP_HOR_PULSE_WIDTH-1); //水平同步信号宽度时钟个数为3
 270   1        Send_Ssd1963_Data(0x00); 
 271   1        Send_Ssd1963_Data(0x00); //水平同步信号开始位置
 272   1        Send_Ssd1963_Data(0x00);
 273   1        
 274   1        //vsync setting
 275   1        Send_Ssd1963_Command(cmd_set_vert_period); 
 276   1        
 277   1      #define VT (DISP_VER_PULSE_WIDTH+DISP_VER_BACK_PORCH+DISP_VER_FRONT_PORCH+DISP_VER_RESOLUTION)    
 278   1        Send_Ssd1963_Data((VT-1)>>8);  //
 279   1        Send_Ssd1963_Data(VT-1);  //preiod width=  295
 280   1      #define VSP (DISP_VER_PULSE_WIDTH+DISP_VER_BACK_PORCH)
 281   1        Send_Ssd1963_Data((VSP-1)>>8);
 282   1        Send_Ssd1963_Data(VSP-1);  //no-preiod width=10
 283   1        Send_Ssd1963_Data(DISP_VER_PULSE_WIDTH-1);  //plus width=3
 284   1        Send_Ssd1963_Data(0x00);
 285   1        Send_Ssd1963_Data(0x00);
 286   1      
 287   1          //显示像素格式设定
 288   1        Send_Ssd1963_Command(cmd_set_pixel_format);     
 289   1      #ifndef DATA_BUS8
 290   1        Send_Ssd1963_Data(0x50); //16bit
 291   1      #else
                Send_Ssd1963_Data(RGB_DATA_FORMAT_18); //24bit
              #endif
 294   1      
 295   1        //数据总线接口设定
 296   1        
 297   1        Send_Ssd1963_Command(cmd_set_pixel_data_interface);
 298   1      #ifndef DATA_BUS8      
 299   1        Send_Ssd1963_Data(0x03);   //16BIT RGB565
 300   1      #else
                Send_Ssd1963_Data(0x00);   //8BIT
              #endif
 303   1      
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 6   

 304   1        //设置RGB颜色顺序
 305   1        Send_Ssd1963_Command(0x36);
 306   1        Send_Ssd1963_Data(0x08);   //RGB 
 307   1      
 308   1      #ifdef USE_SSD1963_PWM  
                Send_Ssd1963_Command(0xbe);//设置PWM 
                Send_Ssd1963_Data(0X0E);
                Send_Ssd1963_Data(0XFF);
                Send_Ssd1963_Data(0X09);
                Send_Ssd1963_Data(0XFF);
                Send_Ssd1963_Data(0X00);
                Send_Ssd1963_Data(0X00); 
                //(Define the threshold value)
                Send_Ssd1963_Command(cmd_set_dbc_th); 
                Send_Ssd1963_Data(0X00);
                Send_Ssd1963_Data(0X09);
                Send_Ssd1963_Data(0X90);
                Send_Ssd1963_Data(0X00);
                Send_Ssd1963_Data(0X17);
                Send_Ssd1963_Data(0XE8);
                Send_Ssd1963_Data(0X00); 
                Send_Ssd1963_Data(0X39);
                Send_Ssd1963_Data(0X60); 
                
                Send_Ssd1963_Command(cmd_set_dbc_conf);
                Send_Ssd1963_Data(0x0d);
              #endif
 331   1        Send_Ssd1963_Command(0xB8);       // Set all GPIOs to output, controlled by host
 332   1        Send_Ssd1963_Data(0x01);        // Set GPIO0 as output
 333   1        Send_Ssd1963_Data(0x01);        // GPIO[3:0] used as normal GPIOs
 334   1        Send_Ssd1963_Command(0xBA);       // Set all GPIOs Value
 335   1        Send_Ssd1963_Data(0x01);        // Set GPIO0 to high
 336   1      
 337   1        SetScrollArea(0,272,0);
 338   1      
 339   1      
 340   1      /*  Send_Ssd1963_Command(0xBC);
 341   1        Send_Ssd1963_Data(0x40);//对比度值
 342   1        Send_Ssd1963_Data(0x10);//亮度值  
 343   1        Send_Ssd1963_Data(0x40);//饱和度值 
 344   1        Send_Ssd1963_Data(0x01);//处理机允许
 345   1      */
 346   1      
 347   1      
 348   1      
 349   1      
 350   1      // set pwm enable by host
 351   1        P3M0 |= Bin(0,0,1,0,0,0,0,0); //开漏输出
 352   1        P3M1 |= Bin(0,0,1,0,0,0,0,0);
 353   1        BL_SW=1;
 354   1        Send_Ssd1963_Command(0xBE); //SET_PWM_CONF
 355   1        Send_Ssd1963_Data(0x0e);//set pwm freq
 356   1      //  Send_Ssd1963_Data(0x3f);//set pwm duty cycle  
 357   1        Send_Ssd1963_Data(0xf0);//set pwm duty cycle  
 358   1      
 359   1        Send_Ssd1963_Data(0x01);//enable pwm by host
 360   1        Send_Ssd1963_Data(0xff);//DBC manu brightness 
 361   1        Send_Ssd1963_Data(0x00);//DBC mini brightness
 362   1        Send_Ssd1963_Data(0x00);//brightness prescaler  
 363   1      
 364   1        
 365   1        //开显示
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 7   

 366   1        Send_Ssd1963_Command(cmd_set_display_on);
 367   1      
 368   1      
 369   1      /*
 370   1        //强推挽输出
 371   1        P3M0 |= (Bin(0,0,1,0,0,0,0,0));
 372   1        P3M1 &= (~Bin(0,0,1,0,0,0,0,0));
 373   1        //打开背光
 374   1        BL_SW=1;
 375   1      */
 376   1      }
 377          
 378          
 379          void BL_OFF(void)
 380          {
 381   1          Send_Ssd1963_Command(0xBE); //SET_PWM_CONF
 382   1          Send_Ssd1963_Data(0x0e);//set pwm freq
 383   1        //  Send_Ssd1963_Data(0x3f);//set pwm duty cycle  
 384   1          Send_Ssd1963_Data(0x00);//set pwm duty cycle  
 385   1        
 386   1          Send_Ssd1963_Data(0x01);//enable pwm by host
 387   1          Send_Ssd1963_Data(0xff);//DBC manu brightness 
 388   1          Send_Ssd1963_Data(0x00);//DBC mini brightness
 389   1          Send_Ssd1963_Data(0x00);//brightness prescaler  
 390   1      
 391   1          Send_Ssd1963_Command(cmd_set_display_off);
 392   1      
 393   1      }
 394          
 395          
 396          void BL_ON(void)
 397          {
 398   1          Send_Ssd1963_Command(0xBE); //SET_PWM_CONF
 399   1          Send_Ssd1963_Data(0x0e);//set pwm freq
 400   1        //  Send_Ssd1963_Data(0x3f);//set pwm duty cycle  
 401   1          Send_Ssd1963_Data(0xf0);//set pwm duty cycle  
 402   1        
 403   1          Send_Ssd1963_Data(0x01);//enable pwm by host
 404   1          Send_Ssd1963_Data(0xff);//DBC manu brightness 
 405   1          Send_Ssd1963_Data(0x00);//DBC mini brightness
 406   1          Send_Ssd1963_Data(0x00);//brightness prescaler
 407   1      
 408   1          Send_Ssd1963_Command(cmd_set_display_on);
 409   1      }
 410          
 411          uint16 GetColor(uint8 srgb)
 412          {
 413   1        if(srgb==BLACK_CODE)  return(BLACK);
 414   1        else if(srgb==RED_CODE) return(RED);
 415   1        else if(srgb==GREEN_CODE) return(GREEN);  
 416   1        else if(srgb==POWDER_BLUE_CODE) return(POWDER_BLUE);
 417   1        else if(srgb==BLUE_CODE)  return(BLUE);
 418   1        else if(srgb==YELLOW_CODE)  return(YELLOW);
 419   1        else if(srgb==PURPLE_CODE)  return(PURPLE);
 420   1        else if(srgb==CYAN_CODE)  return(CYAN);   
 421   1        else if(srgb==WHITE_CODE) return(WHITE);
 422   1        else if(srgb==BLUE3_CODE) return(BLUE3_VALUE);
 423   1        else if(srgb==BLUE4_CODE) return(BLUE4_VALUE);  
 424   1        else return(WHITE); 
 425   1      }
 426          
 427          /*--------------------------------------------------------------------------------------------
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 8   

 428          函数原型: void Set_Display_Area(uint16 xdata start_x,uint16 xdata end_x,uint16 xdata start_y,uint16 xdata 
             -end_y) 
 429          参数说明: start_x:点的X起始坐标
 430                    end_x:点的X结束坐标
 431                start_y:点的Y起始坐标
 432                    end_y:点的Y结束坐标
 433          返 回 值: 无
 434          函数功能: 设置屏幕区域
 435          ----------------------------------------------------------------------------------------------*/
 436          
 437          void Set_Display_Area(uint16  start_x,uint16  end_x,uint16 start_y,uint16  end_y)
 438          {
 439   1        uint8 xdata shigh_x1,slow_x1,shigh_x2,slow_x2;
 440   1        uint8 xdata shigh_y1,slow_y1,shigh_y2,slow_y2;
 441   1        shigh_x1=start_x/256;
 442   1        slow_x1=start_x%256;
 443   1        shigh_x2=end_x/256;
 444   1        slow_x2=end_x%256;
 445   1        shigh_y1=start_y/256;
 446   1        slow_y1=start_y%256;
 447   1        shigh_y2=end_y/256;
 448   1        slow_y2=end_y%256;
 449   1        Send_Ssd1963_Command(0x2A);
 450   1        Send_Ssd1963_Data(shigh_x1);
 451   1        Send_Ssd1963_Data(slow_x1);
 452   1        Send_Ssd1963_Data(shigh_x2);
 453   1        Send_Ssd1963_Data(slow_x2);
 454   1        Send_Ssd1963_Command(0x2B);
 455   1        Send_Ssd1963_Data(shigh_y1);
 456   1        Send_Ssd1963_Data(slow_y1);
 457   1        Send_Ssd1963_Data(shigh_y2);
 458   1        Send_Ssd1963_Data(slow_y2);
 459   1      }
 460          
 461          
 462          
 463          
 464          
 465          /*--------------------------------------------------------------------------------------------
 466          函数原型: void Lcd_Clear(uint32 xdata color)
 467          参数说明: color:清屏的颜色
 468          返 回 值: 无
 469          函数功能: 清屏
 470          ----------------------------------------------------------------------------------------------*/
 471          //void Lcd_Clear(uint16  color,uint8 page)
 472          void Lcd_Clear(void)
 473          {
 474   1        uint16 xdata k,j;
 475   1      
 476   1        Set_Display_Area(0,479,page*LCD_PIX_Y,page*LCD_PIX_Y+271);
 477   1        Send_Ssd1963_Command(0x2C);
 478   1        SSD1963_CS=0;
 479   1        for(k=0;k<480;k++)
 480   1          {
 481   2           for(j=0;j<272;j++)
 482   2           {
 483   3          WriteData16(fcolor);
 484   3         }
 485   2          }
 486   1        SSD1963_CS=1;
 487   1      }
 488          
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 9   

 489          /*------------------------------------------------------------------------------
 490          函数原型: void Display_Dot(uint16 xdata x,uint16 xdata y,uint32 xdata color)   
 491          参数说明: x:点的X坐标,y:点的Y坐标,color:点的颜色
 492          返 回 值: 无
 493          函数功能: 在屏幕上显示点
 494          -------------------------------------------------------------------------------*/
 495          //void Display_Dot(uint16  x,uint16  y,uint16  color,uint8 page)
 496          void Display_Dot(void)  
 497          {  
 498   1      
 499   1        Set_Display_Area(x,x,y+page*LCD_PIX_Y,y+page*LCD_PIX_Y);
 500   1        Send_Ssd1963_Command(0x2C);
 501   1        SSD1963_CS=0;
 502   1        WriteData16(fcolor);
 503   1        SSD1963_CS=1;
 504   1      }
 505          
 506          
 507          /*-------------------------------------------------------------------------------------------------
 508          函数原型: void Display_HLine(uint16 xdata x,uint16 xdata y,uint16 xdata width,uint32 xdata color) 
 509          参数说明: x:点的X坐标,y:点的Y坐标,width:水平直线的长度,color:点的颜色
 510          返 回 值: 无
 511          函数功能: 在屏幕上显示水平直线
 512          --------------------------------------------------------------------------------------------------*/
 513          //void Display_HLine(uint16  x,uint16  y,uint16  width,uint16  color,uint8 page)
 514          void Display_HLine(uint16  width)
 515          {
 516   1      
 517   1        Set_Display_Area(x,x+width-1,y+page*LCD_PIX_Y,y+page*LCD_PIX_Y);
 518   1        Send_Ssd1963_Command(0x2C);
 519   1        SSD1963_CS=0;
 520   1        while(width--)
 521   1        {
 522   2          WriteData16(fcolor);
 523   2        }
 524   1         SSD1963_CS=1;
 525   1      }
 526          
 527          /*--------------------------------------------------------------------------------------------------
 528          函数原型: void Display_VLine(uint16 xdata x,uint16 xdata y,uint16 xdata height,uint32 xdata color)
 529          参数说明: x:点的X坐标,y:点的Y坐标,height:垂直直线的长度,color:点的颜色
 530          返 回 值: 无
 531          函数功能: 在屏幕上显示垂直直线
 532          ----------------------------------------------------------------------------------------------------*/
 533          //void Display_VLine(uint16  x,uint16  y,uint16  height,uint16  color,uint8 page)
 534          void Display_VLine(uint16  height)
 535          {
 536   1      
 537   1        Set_Display_Area(x,x,y+page*LCD_PIX_Y,y+height-1+page*LCD_PIX_Y);
 538   1        Send_Ssd1963_Command(0x2C);
 539   1        SSD1963_CS=0;
 540   1        while(height--)
 541   1        {
 542   2        WriteData16(fcolor);
 543   2        }
 544   1        SSD1963_CS=1;
 545   1      } 
 546          
 547          
 548          //显示一个方框
 549          //void DisplayFrame(uint16 start_x,uint16 start_y,uint16 end_x,uint16 end_y, uint16 color,uint8 page)
 550          void DisplayFrame(void)
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 10  

 551          {
 552   1        //Display_HLine(start_x,start_y,end_x-start_x+1,fcolor,page);
 553   1        x=start_x;
 554   1        y=start_y;
 555   1        Display_HLine(end_x-start_x+1);
 556   1      
 557   1        x=start_x;
 558   1        y=end_y;
 559   1        Display_HLine(end_x-start_x+1);
 560   1      
 561   1      
 562   1        x=start_x;
 563   1        y=start_y;  
 564   1        Display_VLine(end_y-start_y+1);
 565   1      
 566   1        x=end_x;
 567   1        y=start_y;  
 568   1        Display_VLine(end_y-start_y+1); 
 569   1      }
 570          
 571          
 572          
 573          
 574          //显示一个颜色块
 575          //void DisplayBlock(uint16 start_x,uint16 start_y,uint16 end_x,uint16 end_y, uint16 color,uint8 page)
 576          void DisplayBlock(void)
 577          {
 578   1        uint16 xdata width,height;
 579   1        uint16 i,j;
 580   1      
 581   1        if(end_x >= LCD_PIX_X || end_y >=LCD_PIX_Y) return;
 582   1        if(start_x>=end_x || start_y>= end_y) return;
 583   1      
 584   1      
 585   1        Set_Display_Area(start_x,end_x,start_y+page*LCD_PIX_Y,end_y+page*LCD_PIX_Y);
 586   1        Send_Ssd1963_Command(0x2C);
 587   1      
 588   1      
 589   1        width=end_x-start_x+1;
 590   1      
 591   1        height=end_y-start_y+1;
 592   1      
 593   1        SSD1963_CS=0;
 594   1        for(j=0;j<height;j++)
 595   1        {
 596   2          for(i=0;i<width;i++)
 597   2          {
 598   3            WriteData16(bcolor);
 599   3          }
 600   2        } 
 601   1        SSD1963_CS=1;
 602   1      }
 603          
 604           
 605          
 606          /*--------------------------------------------------------------------------------------------------------
             -------------------------------
 607           函数原型: void Display_ASCII(uint16 xdata x,uint16 xdata y,uint8 xdata *p,uint32 xdata fcolor,uint32 xdat
             -a bcolor)
 608           参数说明: x:字符的X坐标,y:字符的Y坐标,frcolor:字符的颜色，brcolor:字符的背景颜色
 609           返 回 值: 无
 610           函数功能: 在屏幕上显示字符
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 11  

 611           ---------------------------------------------------------------------------------------------------------
             --------------------------------*/
 612          //void Display_ASCII_Mul(uint16 x,uint16 y,uint8 size,uint8 mul_row,uint8 mul_col,uint16 fcolor,uint16 bco
             -lor,uint8 *p,uint8 page)
 613          void Display_ASCII_Mul(void)
 614          {
 615   1        uint8 xdata i,j,k;
 616   1        uint8 xdata *p;
 617   1        switch(size)
 618   1        {
 619   2          
 620   2           case 1: //8*16
 621   2           default:
 622   2            lcd_fangda_dis_text(8,16);     
 623   2             break;
 624   2           case 2: //12*24
 625   2             lcd_fangda_dis_text(16,24);
 626   2             break;
 627   2           case 3: //16*32
 628   2             lcd_fangda_dis_text(16,32);
 629   2             break;
 630   2           case 4://48*96   在这种字体下，不存在放大  4号字体特殊处理
 631   2            //因GT23_REC_DATA[128]存储空间有限，只能按如下处理
 632   2      
 633   2             if( (*pDispData>=0x30)&&(*pDispData<=0x39)) 
 634   2              {//数字内码
 635   3              Set_Display_Area(x,x+47,y+page*LCD_PIX_Y,y+page*LCD_PIX_Y+95);
 636   3              Send_Ssd1963_Command(0x2C);
 637   3          
 638   3              
 639   3              for(i=0;i<6;i++)
 640   3              {//分8次读取点阵数据到GT23_REC_DATA
 641   4                Read_Cont(GT23_Rec_Data,576*(*pDispData-0x30)+D48BaseAdd+i*96,96);
 642   4                k=96;
 643   4                p=GT23_Rec_Data;
 644   4                SSD1963_CS=0;
 645   4                for(;k>0;k--)
 646   4                {
 647   5                   for(j=0;j<8;j++)
 648   5                   {
 649   6                    if(*p&(0x80>>j))
 650   6                    {
 651   7                      WriteData16(fcolor);
 652   7                    }
 653   6                    else
 654   6                    {
 655   7                      WriteData16(bcolor);
 656   7          
 657   7                    }
 658   6          
 659   6                   }
 660   5                   p++;
 661   5                }
 662   4                SSD1963_CS=1;
 663   4              }       
 664   3              }
 665   2             break;
 666   2        }
 667   1      
 668   1      }
 669          
 670          
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 12  

 671          
 672          /*-----------------------------------------------------------------------------
 673          函数原型: void Display_Chinese(uint x,uint y,uchar *p,ulong fcolor,ulong bcolor)
 674          参数说明: x:汉字的X坐标,y:汉字的Y坐标,fcolor:汉字的颜色，bcolor：汉字的背景颜色
 675          返 回 值: 无
 676          函数功能: 在屏幕上显示汉字
 677          ----------------------------------------------------------------------------*/
 678          //void Display_Chinese_Mul(uint16 x,uint16 y,uint8 size,uint8 mul_row,uint8 mul_col,uint16 fcolor,uint16 b
             -color,uint8 *p,uint8 page)
 679          
 680          void Display_Chinese_Mul(void)
 681          {
 682   1        switch(size)
 683   1        {
 684   2          
 685   2        case 1: //16*16
 686   2        default:
 687   2          lcd_fangda_dis_text(16,16);
 688   2            break; 
 689   2      
 690   2      
 691   2        case 3: //32*32
 692   2          lcd_fangda_dis_text(32,32);
 693   2            break;
 694   2           
 695   2        }
 696   1      
 697   1       }
 698          
 699          
 700          //写前所写区域处理
 701          // uint8 WriteAreaHandlerMul(uint16 *px,uint16 *py,uint8 size,uint8 mul_row,uint8 mul_col,uint8 type,uint1
             -6 s_x,uint16 s_y,uint16 end_x,uint16 end_y)
 702          uint8 WriteAreaHandlerMul(uint8 type)
 703          {
 704   1        uint16 old_x =x;
 705   1        uint16 old_y =y;
 706   1        
 707   1        if(type==0) //半角数据
 708   1        {
 709   2          if(x+dot_number/2-1 > end_x)
 710   2          {//超过右边界,从头开始
 711   3            x=start_x;
 712   3            if(y+2*dot_number+current_vert_spac-1>end_y)    goto fail;  //超出所写区域
 713   3            else
 714   3            {
 715   4              y += (dot_number+current_vert_spac);  //换到下一行
 716   4              if(x+dot_number/2-1 > end_x)  goto fail;    //从新行开始，还是1个字符都放不下
 717   4              else return 1;
 718   4            }
 719   3          }
 720   2          else 
 721   2          {
 722   3            return 1;
 723   3          }
 724   2      
 725   2        }
 726   1        else if(type==1)  //全角数据
 727   1        {
 728   2        
 729   2          if(x+dot_number-1 >end_x)
 730   2          {//超过右边界,从头开始
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 13  

 731   3            x=start_x;
 732   3            if(y+2*dot_number+current_vert_spac-1>end_y)    goto fail;  //超出所写区域
 733   3            else
 734   3            {
 735   4              y += (dot_number+current_vert_spac);  //换到下一行
 736   4              if(x+dot_number-1 > end_x)  goto fail;    //从新行开始，还是1个汉字都放不下
 737   4              else return 1;
 738   4            }
 739   3          }
 740   2          else return 1;
 741   2        }
 742   1      
 743   1        fail:
 744   1          x=old_x;
 745   1          y=old_y;
 746   1          return 0;
 747   1      
 748   1      } 
 749          
 750          
 751          //x,y:起始点的坐标
 752          //type_x_wide:原子体X轴的宽度, type_y_height:原子体Y轴的高度
 753          //mul_row:纵向放大倍数,   mul_col:横向放大一倍
 754          //cbc_filter:过滤参数 1:过滤背景色
 755          //p:要显示的图片数据指针
 756          
 757          //void lcd_fangda_dis_text(uint16 x, uint16 y, uint8 type_x_wide, uint8 type_y_height, 
 758          //             uint8 mul_row,uint8 mul_col,uint16 fcolor,uint16 bcolor,uint8 *p,uint8 page)
 759          void lcd_fangda_dis_text(uint8 type_x_wide, uint8 type_y_height)
 760          {
 761   1      
 762   1        unsigned char  i,j,k,m,n;
 763   1      
 764   1      
 765   1        Set_Display_Area(x,x+type_x_wide*mul_col-1,y+page*LCD_PIX_Y,y+page*LCD_PIX_Y+type_y_height*mul_row-1);
 766   1        Send_Ssd1963_Command(0x2C);
 767   1      
 768   1      
 769   1        SSD1963_CS=0; 
 770   1      
 771   1        for (i=0;i<type_y_height;i++) //原字体有多少行
 772   1        {
 773   2      
 774   2          for(n=0;n<mul_row;n++)  //纵坐标的放大倍数
 775   2          {
 776   3      
 777   3            for(j=0;j<type_x_wide/8;j++)  //一横有几个字节,例16*16 行向2个字节
 778   3            {
 779   4      
 780   4              for(k=0;k<8;k++)  //1个字节8点
 781   4              {
 782   5      
 783   5                for(m=0;m<mul_col;m++)  //横坐标放大倍数
 784   5                {
 785   6                  //if(((x+8*j*mul_col+k*mul_col+m)<LCD_PIX_X)&&((y+i*mul_row+n)<LCD_PIX_Y))  //在区域范围内
 786   6                  //{
 787   6                    if ((GT23_Rec_Data[i*(type_x_wide/8)+j]>>(7-k))&0x1)
 788   6                    {
 789   7                      WriteData16(fcolor);
 790   7                    }
 791   6      
 792   6                    else 
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 14  

 793   6                    {
 794   7                      WriteData16(bcolor);                
 795   7                    }
 796   6                    
 797   6                  //}
 798   6                }
 799   5              }
 800   4            }
 801   3          }
 802   2        }
 803   1        SSD1963_CS=1;
 804   1      }
 805          
 806          
 807          
 808          
 809          
 810          //px,py  写入字符串的起始x,y坐标
 811          //size:  字体大小
 812          //mul_row,mul_col:行列放大倍数
 813          //fcolor,bcolor:前景色，背景色
 814          //pDigit:要写入的字符串
 815          //page: 写入的页面
 816          //s_x,s_y:写入区域的起始点坐标
 817          //end_x,end_y:写入区域的结束点坐标
 818          
 819          
 820          //void DisplayString(uint16 *px,uint16 *py,uint8 size,uint8 mul_row,uint8 mul_col,uint16 fcolor,uint16 bco
             -lor,uint8 *pDispData,uint8 page,uint16 s_x,uint16 s_y,uint16 end_x,uint16 end_y)
 821          void DisplayString(void)
 822          {
 823   1        
 824   1        while(*pDispData)
 825   1        { 
 826   2          if((*pDispData>=0x81)&&(*pDispData<=0xfe))  //高字节符合汉字内码条件
 827   2          {
 828   3            pDispData++;
 829   3            if(*pDispData>=0x40)
 830   3            {
 831   4            
 832   4              pDispData--;
 833   4              Get_GT23_Data(pDispData,size);  
 834   4      
 835   4              //先进行写空间处理
 836   4              if(WriteAreaHandlerMul(1)==0)   break;  //超出区域退出
 837   4      
 838   4              Display_Chinese_Mul();
 839   4      
 840   4              x+=dot_number;
 841   4              pDispData=pDispData+2;  //一个汉字内码占两个字节
 842   4      
 843   4            }
 844   3            else
 845   3            {//低字节不符合汉字条件
 846   4              if(*pDispData==0x00) break;
 847   4            }
 848   3          }
 849   2          else if((*pDispData>=0x20)&&(*pDispData<=0x7e)) //符合ASCII字符条件
 850   2          {
 851   3            Get_GT23_Data(pDispData,size);
 852   3                  
 853   3            //先进行写空间处理
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 15  

 854   3            if(WriteAreaHandlerMul(0)==0)   break;  //超出区域退出
 855   3            
 856   3            Display_ASCII_Mul();
 857   3      
 858   3             x+= dot_number/2;
 859   3            pDispData++;
 860   3          }
 861   2          else //非法字符
 862   2          {
 863   3            pDispData++;
 864   3          }
 865   2      
 866   2        }
 867   1        WDT_CONTR = 0x3e; //喂狗
 868   1      }
 869              
 870          
 871          //px,py  写入字符串的起始x,y坐标
 872          //size:  字体大小
 873          //mul_row,mul_col:行列放大倍数
 874          //fcolor,bcolor:前景色，背景色
 875          //pDigit:要写入的字符串
 876          //page: 写入的页面
 877          //s_x,s_y:写入区域的起始点坐标
 878          //end_x,end_y:写入区域的结束点坐标
 879          //lenth:数字长度
 880          
 881          //void DisplayDigitString(uint16 *px,uint16 *py,uint8 size,uint8 mul_row,uint8 mul_col,uint16 fcolor,uint1
             -6 bcolor,uint8 *pDigit,uint8 page,uint16 s_x,uint16 s_y,uint16 end_x,uint16 end_y,uint8 lenth)
 882          void DisplayDigitString(void)
 883          {
 884   1        uint8 Digit;
 885   1        for(;Length>0;Length--)
 886   1        { 
 887   2          Digit = *pDispData;
 888   2          if(*pDispData<10)
 889   2          {
 890   3            Digit += 0x30;
 891   3            Get_GT23_Data(&Digit,size);
 892   3          }
 893   2          else 
 894   2          {
 895   3            Digit += 55;
 896   3            Get_GT23_Data(&Digit,size); //十六进制中的ABC....
 897   3          }
 898   2          if(WriteAreaHandlerMul(0)==0) return;
 899   2          Display_ASCII_Mul();
 900   2      
 901   2          x+= dot_number/2;
 902   2          pDispData++;
 903   2        } 
 904   1      } 
 905          
 906          
 907          //根据长度写入字符
 908          //px,py  写入字符串的起始x,y坐标
 909          //size:  字体大小
 910          //mul_row,mul_col:行列放大倍数
 911          //fcolor,bcolor:前景色，背景色
 912          //pDigit:要写入的字符串
 913          //page: 写入的页面
 914          //s_x,s_y:写入区域的起始点坐标
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 16  

 915          //end_x,end_y:写入区域的结束点坐标
 916          
 917          
 918          //void DisplayStringLen(uint16 *px,uint16 *py,uint8 size,uint8 mul_row,uint8 mul_col,uint16 fcolor,uint16 
             -bcolor,uint8 *pDispData,uint8 page,uint16 s_x,uint16 s_y,uint16 end_x,uint16 end_y,uint8 Length)
 919          void DisplayStringLen(void)
 920          {
 921   1        for(;Length>0;)
 922   1        { 
 923   2          if((*pDispData>=0x81)&&(*pDispData<=0xfe))  //高字节符合汉字内码条件
 924   2          {
 925   3            pDispData++;
 926   3            if(*pDispData>=0x40)
 927   3            {
 928   4              if(Length>=2)
 929   4              {//防止混乱数据串时数据长度向0  溢出      
 930   5                pDispData--;
 931   5                Get_GT23_Data(pDispData,size);  
 932   5      
 933   5                //先进行写空间处理
 934   5                if(WriteAreaHandlerMul(1)==0)   break;  //超出区域退出
 935   5      
 936   5                Display_Chinese_Mul();
 937   5      
 938   5                x+= dot_number;
 939   5                pDispData=pDispData+2;  //一个汉字内码占两个字节
 940   5                Length -=2;
 941   5              }
 942   4              else
 943   4              {//长度不足2
 944   5                Length--;       
 945   5              }
 946   4            }
 947   3            else
 948   3            {//低字节不符合汉字条件
 949   4              Length--;
 950   4            }
 951   3          }
 952   2          else if((*pDispData>=0x20)&&(*pDispData<=0x7e)) //符合ASCII字符条件
 953   2          {
 954   3            Get_GT23_Data(pDispData,size);
 955   3            //先进行写空间处理
 956   3            if(WriteAreaHandlerMul(0)==0)   break;  //超出区域退出
 957   3            
 958   3            Display_ASCII_Mul();
 959   3      
 960   3            x +=dot_number/2;
 961   3            pDispData++;
 962   3            Length--;
 963   3          }
 964   2          else  //其它不相关数据
 965   2          {
 966   3            pDispData++;
 967   3            Length--;   
 968   3          }   
 969   2      
 970   2        }
 971   1        
 972   1      }
 973                  
 974          
 975          //void DisplayOneChar(uint16 *px,uint16 *py,uint8 size,uint8 mul_row,uint8 mul_col,uint16 fcolor,uint16 bc
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 17  

             -olor,uint8 byChar,uint8 page,uint16 s_x,uint16 s_y,uint16 end_x,uint16 end_y)   
 976          void DisplayOneChar(uint8 byChar)   
 977          {
 978   1        BedDataBuff[0]=byChar/100;
 979   1        BedDataBuff[1]=(byChar%100)/10;
 980   1        BedDataBuff[2]=(byChar%100)%10;
 981   1        BedDataBuff[3]=0;
 982   1      
 983   1        if(BedDataBuff[0])
 984   1        {
 985   2          pDispData=BedDataBuff;
 986   2          Length =3;
 987   2          DisplayDigitString();
 988   2        
 989   2        }
 990   1        else 
 991   1        {
 992   2          if(BedDataBuff[1])
 993   2          {
 994   3            pDispData=&(BedDataBuff[1]);
 995   3            Length =2;
 996   3            DisplayDigitString();
 997   3          }
 998   2          else 
 999   2          {
1000   3            pDispData=&(BedDataBuff[2]);
1001   3            Length =1;        
1002   3            DisplayDigitString();
1003   3          }
1004   2        }
1005   1            
1006   1      }
1007          
1008          
1009          
1010          
1011          //void ShowAddBedCallFace(uint8 byBedAddr,uint8 page)
1012          
1013          void ShowAddBedCallFace(uint8 byBedAddr){
1014   1        start_x = 0;
1015   1        start_y = 120;
1016   1        end_x= 479;
1017   1        end_y= 152;
1018   1        bcolor =BLUE;
1019   1        DisplayBlock(); 
1020   1      
1021   1        x=(480-32*7)/2;     //128     
1022   1        y=(272-32)/2;     //120
1023   1        current_size=2;
1024   1        get_dot_number();
1025   1        get_basesize_mul();
1026   1      
1027   1        fcolor=WHITE;
1028   1        bcolor=BLUE;
1029   1        pDispData= "加";
1030   1        start_x=0;
1031   1        start_y=0;
1032   1        end_x=480;
1033   1        end_y=272;
1034   1        DisplayString();
1035   1      
1036   1        DisplayOneChar(byBedAddr);
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 18  

1037   1      
1038   1        pDispData= "床呼叫";  
1039   1        DisplayString();
1040   1      
1041   1        
1042   1        Set_VisualPage(page);
1043   1        stLocalControl.byDisplayFace=BED_INFO_FACE;
1044   1      }
1045          
1046          
1047          
1048          void DisSendPinBugFace(void)
1049          //void DisSendPinBugFace(uint8 page)
1050          {
1051   1      
1052   1        start_x = 357;
1053   1        start_y = 242;
1054   1        end_x= 479;
1055   1        end_y= 271;
1056   1        bcolor =BLACK;
1057   1        DisplayBlock(); 
1058   1      
1059   1      
1060   1      
1061   1        x=357;
1062   1        y=246;
1063   1        current_size=1;
1064   1        get_dot_number();
1065   1        get_basesize_mul();
1066   1      
1067   1        fcolor=BLUE;
1068   1        bcolor=BLACK;
1069   1        pDispData= "本机故障!";
1070   1        start_x=357;
1071   1        start_y=246;
1072   1        end_x=480;
1073   1        end_y=272;
1074   1      
1075   1        DisplayString();
1076   1          
1077   1        Set_VisualPage(page);
1078   1        stLocalControl.byDisplayFace=INFO_INDICATION_FACE;
1079   1      
1080   1      //  BL_SW=1;  //背关打开
1081   1        BL_ON();
1082   1        
1083   1      }
1084          
1085          
1086          //void ShowCallFace(uint8 byRoomAddr, uint8 byBedAddr, uint8 byCallType,uint8 page)
1087          void ShowCallFace(uint8 byRoomAddr, uint8 byBedAddr, uint8 byCallType)
1088          {
1089   1        start_x = 0;
1090   1        start_y = 120;
1091   1        end_x= 479;
1092   1        end_y= 271;
1093   1        bcolor =BLUE;
1094   1        DisplayBlock(); 
1095   1        
1096   1        byRoomAddr &= 0x7f;
1097   1      
1098   1        current_size=2;
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 19  

1099   1        get_dot_number();
1100   1        get_basesize_mul(); 
1101   1      //  CCAPM0=0X48;  //禁止调度
1102   1      //  MCUMasterSPI(); //单片机为主模式
1103   1        switch(byCallType)
1104   1        {
1105   2          case CMD_INFUSION_CALL:               //护理呼叫
1106   2            x=(480-32*7)/2;     //128
1107   2            y=(272-32)/2;     //120
1108   2      
1109   2            fcolor=WHITE;
1110   2            bcolor=BLUE;
1111   2            start_x=0;
1112   2            start_y=0;
1113   2            end_x=480;
1114   2            end_y=272;
1115   2            DisplayOneChar(byRoomAddr);
1116   2      
1117   2            pDispData= "房";
1118   2            DisplayString();
1119   2      
1120   2            DisplayOneChar(byBedAddr);
1121   2      
1122   2            pDispData= "床呼叫";
1123   2            DisplayString();      
1124   2            break;
1125   2      
1126   2          case CMD_SERVICE_CALL:                //输液完毕呼叫
1127   2            x=(480-32*8)/2;
1128   2            y=(272-32)/2;
1129   2      
1130   2            fcolor=WHITE;
1131   2            bcolor=BLUE;
1132   2            start_x=0;
1133   2            start_y=0;
1134   2            end_x=480;
1135   2            end_y=272;
1136   2      
1137   2            DisplayOneChar(byRoomAddr);
1138   2            pDispData= "房";
1139   2            DisplayString();
1140   2      
1141   2            DisplayOneChar(byBedAddr);
1142   2            pDispData= "床输液完毕";
1143   2            DisplayString();
1144   2            break;      
1145   2          case CMD_EMERGENCY_CALL:                //紧急呼叫
1146   2            
1147   2            x=(480-32*7)/2;
1148   2            y=(272-32)/2;
1149   2            fcolor=WHITE;
1150   2            bcolor=BLUE;
1151   2            start_x=0;
1152   2            start_y=0;
1153   2            end_x=480;
1154   2            end_y=272;
1155   2      
1156   2            DisplayOneChar(byRoomAddr);
1157   2            pDispData= "房卫生间呼叫";
1158   2            DisplayString();            
1159   2            break;
1160   2        } 
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 20  

1161   1      
1162   1      //  EPH1660MasterSPI(); //
1163   1      //  CCAPM0=0X49;  //开启调度
1164   1      
1165   1        Set_VisualPage(page);
1166   1        stLocalControl.byDisplayFace=INFO_INDICATION_FACE;  
1167   1      }
1168          
1169          
1170          /**********************************************************
1171          *函数名称     :ShowTalkFace 
1172          *函数描述         :显示通话界面
1173          *输入参数       :byRoomAddr:房地址,byBedAddr:床地址
1174          *返回值       :     
1175          *全局变量     :
1176          *调用模块       :
1177          ***********************************************************
1178          *创建人           :
1179          *创建日期     :2009-3-16
1180          ***********************************************************
1181          *修改人         :
1182          *修改日期       :
1183          *注释           :
1184          **********************************************************/
1185          //void ShowTalkFace(uint8 byRoomAddr, uint8 byBedAddr,uint8 page)
1186          void ShowTalkFace(uint8 byRoomAddr, uint8 byBedAddr)
1187          { 
1188   1        byRoomAddr=byRoomAddr;
1189   1        byBedAddr=byBedAddr;
1190   1        start_x = 357;
1191   1        start_y = 242;
1192   1        end_x= 479;
1193   1        end_y= 271;
1194   1        bcolor =BLUE; 
1195   1      
1196   1        DisplayBlock();
1197   1      
1198   1      
1199   1        x=(480-32*7)/2;     //128
1200   1        y=(272-32)/2;     //120
1201   1        current_size=2;
1202   1        get_dot_number();
1203   1        get_basesize_mul();
1204   1      
1205   1        fcolor=WHITE;
1206   1        bcolor=BLUE;
1207   1        start_x=0;
1208   1        start_y=0;
1209   1        end_x=480;
1210   1        end_y=272;
1211   1        pDispData= "本机正在通话中";
1212   1        DisplayString();  
1213   1      
1214   1      
1215   1        Set_VisualPage(page);
1216   1        stLocalControl.byDisplayFace=TALK_FACE;
1217   1      }
1218          
1219          
1220          
1221          
1222          /*********************************************************
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 21  

1223          函数名称      :ShowBroadFace  
1224          *函数描述         :显示通话界面
1225          *输入参数       :byRoomAddr:房地址,byBedAddr:床地址,bSelf:是否自身广播中
1226          *返回值       :     
1227          *全局变量     :
1228          *调用模块       :
1229          ***********************************************************
1230          *创建人           :陈卫国
1231          *创建日期     :2009-4-14
1232          ***********************************************************
1233          *修改人         :
1234          *修改日期       :
1235          *注释           :
1236          **********************************************************/
1237          //void ShowBroadFace(uint8 byRoomAddr, uint8 byBedAddr, bit bSelf,uint8 page)
1238          void ShowBroadFace(uint8 byRoomAddr, uint8 byBedAddr, bit bSelf)
1239          { 
1240   1      
1241   1        start_x = 0;
1242   1        start_y = 120;
1243   1        end_x= 479;
1244   1        end_y= 152;
1245   1        bcolor =BLUE; 
1246   1        DisplayBlock();
1247   1      
1248   1      //  CCAPM0=0X48;  //禁止调度
1249   1      //  MCUMasterSPI(); //单片机为主模式  
1250   1      
1251   1        current_size=2;
1252   1        get_dot_number();
1253   1        get_basesize_mul();
1254   1      
1255   1        fcolor=WHITE;
1256   1        bcolor=BLUE;
1257   1        start_x=0;
1258   1        start_y=0;
1259   1        end_x=480;
1260   1        end_y=272;
1261   1      
1262   1        if(bSelf)
1263   1        {
1264   2      
1265   2          x=(480-32*7)/2;
1266   2          y=(272-32)/2;
1267   2          pDispData= "本机正在广播中";
1268   2          DisplayString();
1269   2        }
1270   1        else
1271   1        {
1272   2          if(byRoomAddr==YHFJ_ROOM_ADDR)
1273   2          {
1274   3      
1275   3            x=(480-32*10)/2;
1276   3            y=(272-32)/2;
1277   3      
1278   3            DisplayOneChar(byBedAddr);
1279   3            
1280   3            pDispData= "号医护分机正在广播";
1281   3            DisplayString();
1282   3                
1283   3          }
1284   2          else
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 22  

1285   2          {     
1286   3            x=(480-32*8)/2;
1287   3            y=(272-32)/2;
1288   3      
1289   3            DisplayOneChar(byRoomAddr);
1290   3            
1291   3            pDispData= "房";
1292   3            DisplayString();
1293   3      
1294   3            DisplayOneChar(byBedAddr);
1295   3            
1296   3            pDispData= "床正在广播";
1297   3            DisplayString();      
1298   3      
1299   3          
1300   3          }
1301   2        }
1302   1      
1303   1      //  EPH1660MasterSPI(); //
1304   1      //  CCAPM0=0X49;  //开启调度  
1305   1      
1306   1        Set_VisualPage(page);
1307   1        stLocalControl.byDisplayFace=BROAD_FACE;  
1308   1       }
1309          
1310          
1311          
1312          
1313          //void ShowStartInfusionCall(uint8 page)
1314          void ShowStartInfusionCall(void)
1315          {
1316   1        start_x = 0;
1317   1        start_y = 120;
1318   1        end_x= 479;
1319   1        end_y= 152;
1320   1        fcolor =BLUE; 
1321   1        DisplayBlock();
1322   1      
1323   1        x=144;
1324   1        y=120;
1325   1        current_size=2;
1326   1        get_dot_number();
1327   1        get_basesize_mul();
1328   1      
1329   1        fcolor=WHITE;
1330   1        bcolor=BLUE;
1331   1        start_x=0;
1332   1        start_y=0;
1333   1        end_x=480;
1334   1        end_y=272;
1335   1        pDispData= "开始护理呼叫";
1336   1        DisplayString();  
1337   1      
1338   1      
1339   1        Set_VisualPage(page);
1340   1        stLocalControl.byDisplayFace=INFUSION_CALL_FACE;
1341   1      }
1342          
1343          
1344          //void ShowStartServiceCall(uint8 page)
1345          void ShowStartServiceCall(void)
1346          {
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 23  

1347   1        start_x = 0;
1348   1        start_y = 120;
1349   1        end_x= 479;
1350   1        end_y= 152;
1351   1        bcolor =BLUE;
1352   1        DisplayBlock();
1353   1      
1354   1        
1355   1        x=144;
1356   1        y=120;
1357   1        current_size=2;
1358   1        get_dot_number();
1359   1        get_basesize_mul();
1360   1      
1361   1        fcolor=WHITE;
1362   1        bcolor=BLUE;
1363   1        start_x=0;
1364   1        start_y=0;
1365   1        end_x=480;
1366   1        end_y=272;
1367   1        pDispData= "开始服务呼叫";  
1368   1        DisplayString();
1369   1      
1370   1        Set_VisualPage(page);
1371   1        stLocalControl.byDisplayFace=SERVICE_CALL_FACE;
1372   1      
1373   1      }
1374          
1375          
1376          //void ShowStartEmergencyCall(uint8 page)
1377          void ShowStartEmergencyCall(void)
1378          {
1379   1      
1380   1        start_x = 0;
1381   1        start_y = 120;
1382   1        end_x= 479;
1383   1        end_y= 152;
1384   1        bcolor =BLUE;
1385   1        DisplayBlock();
1386   1        
1387   1        x=144;
1388   1        y=120;
1389   1        current_size=2;
1390   1        get_dot_number();
1391   1        get_basesize_mul();
1392   1      
1393   1        fcolor=WHITE;
1394   1        bcolor=BLUE;
1395   1        start_x=0;
1396   1        start_y=0;
1397   1        end_x=480;
1398   1        end_y=272;  
1399   1        pDispData= "开始紧急呼叫";  
1400   1        DisplayString();
1401   1        
1402   1        Set_VisualPage(page);
1403   1        stLocalControl.byDisplayFace=EMERGENCY_CALL_FACE;
1404   1      
1405   1      }
1406          
1407          //void ShowStartHelpCall(uint8 page)
1408          void ShowStartHelpCall(void)
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 24  

1409          {
1410   1        start_x = 0;
1411   1        start_y = 120;
1412   1        end_x= 479;
1413   1        end_y= 152;
1414   1        bcolor =BLUE;
1415   1        DisplayBlock();
1416   1      
1417   1        
1418   1        x=144;
1419   1        y=120;
1420   1        current_size=2;
1421   1        get_dot_number();
1422   1        get_basesize_mul();
1423   1      
1424   1        fcolor=WHITE;
1425   1        bcolor=BLUE;
1426   1        start_x=0;
1427   1        start_y=0;
1428   1        end_x=480;
1429   1        end_y=272;  
1430   1        pDispData= "开始求援呼叫";
1431   1        DisplayString();
1432   1      
1433   1        Set_VisualPage(page);
1434   1        stLocalControl.byDisplayFace=HELP_CALL_FACE;
1435   1      
1436   1      }
1437          
1438          
1439          void get_basesize_mul()
1440          {
1441   1        switch(current_size)
1442   1        {
1443   2          default:
1444   2          case 1:  //16x16
1445   2            size =1;
1446   2            mul_col=1;
1447   2            mul_row=1;
1448   2            break;
1449   2          case 2: //32x32
1450   2            size =3;
1451   2            mul_col=1;
1452   2            mul_row=1;
1453   2            break;
1454   2          case 3: //48x48
1455   2            size=1;
1456   2            mul_col=3;
1457   2            mul_row=3;
1458   2            break;
1459   2          case 4: //64x64
1460   2            size=3;
1461   2            mul_col=2;
1462   2            mul_row=2;
1463   2            break;
1464   2          case 5: //80x80
1465   2            size=1;
1466   2            mul_col=5;
1467   2            mul_row=5;
1468   2            break;
1469   2          case 6: //96x96
1470   2            size=3;
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 25  

1471   2            mul_col=3;
1472   2            mul_row=3;
1473   2            break;
1474   2          case 7: //128x128
1475   2            size=3;
1476   2            mul_col=4;
1477   2            mul_row=4;
1478   2            break;
1479   2      
1480   2          case 8: //160x160
1481   2            size=3;
1482   2            mul_col=5;
1483   2            mul_row=5;
1484   2            break;      
1485   2            
1486   2        }
1487   1      }
1488          
1489          
1490          void get_dot_number()
1491          {
1492   1        switch(current_size)
1493   1        {
1494   2          case 1: 
1495   2              dot_number=16;
1496   2                current_vert_spac = VERT_SPAC_16;
1497   2              break;
1498   2          case 2:
1499   2              dot_number=32;
1500   2              current_vert_spac = VERT_SPAC_32;
1501   2              break;
1502   2          case 3:
1503   2              dot_number=48;
1504   2              current_vert_spac = VERT_SPAC_48;
1505   2              break;
1506   2          case 4: 
1507   2              dot_number=64;
1508   2              current_vert_spac = VERT_SPAC_64;
1509   2              break;
1510   2          case 5:
1511   2              dot_number=80;
1512   2              current_vert_spac = VERT_SPAC_80;
1513   2              break;
1514   2          case 6:
1515   2              dot_number=96;
1516   2              current_vert_spac = VERT_SPAC_96;
1517   2              break;
1518   2              
1519   2          case 7:
1520   2              dot_number=128;
1521   2              current_vert_spac = VERT_SPAC_128;
1522   2              break;
1523   2          case 8:
1524   2              dot_number=160;
1525   2              current_vert_spac = VERT_SPAC_160;
1526   2              break;
1527   2              
1528   2          default:
1529   2              dot_number=16;
1530   2                current_vert_spac = VERT_SPAC_16;     
1531   2              break;
1532   2            
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 26  

1533   2        }
1534   1      
1535   1      }
1536          
1537          void ShowInfoBlockLen(void)
1538          {
1539   1        uint8 RowCharNum;
1540   1        uint8 ColumnCharNum;
1541   1        
1542   1      
1543   1        uint16 area_width=0;
1544   1        uint16 area_height=0;
1545   1      
1546   1        uint8 title_length=0; //标题长度
1547   1        uint8 LengthBack=Length;  //备份要显示的原始数据长茺
1548   1        uint8 *pdispdata2 = pDispData;  //备份原始要显示的数据
1549   1      
1550   1      
1551   1        area_width = end_x-start_x+1;
1552   1        area_height = end_y-start_y+1;
1553   1      
1554   1        if(area_height-VERT_SPAC_160 >=160)     {current_size = DOT160X160;current_vert_spac = VERT_SPAC_160;}
1555   1        else if(area_height-VERT_SPAC_128 >=128)    {current_size = DOT128X128;current_vert_spac = VERT_SPAC_128;}
             -  
1556   1        else if(area_height-VERT_SPAC_96 >=96)    {current_size = DOT96X96;current_vert_spac = VERT_SPAC_96;}
1557   1        else if(area_height-VERT_SPAC_80 >=80)    {current_size = DOT80X80;current_vert_spac = VERT_SPAC_80;}
1558   1        else if(area_height-VERT_SPAC_64 >=64)    {current_size = DOT64X64;current_vert_spac = VERT_SPAC_64;}
1559   1        else if(area_height-VERT_SPAC_48 >=48)    {current_size = DOT48X48;current_vert_spac = VERT_SPAC_48;}
1560   1        else if(area_height-VERT_SPAC_32 >=32)    {current_size = DOT32X32;current_vert_spac = VERT_SPAC_32;}
1561   1        else if(area_height-VERT_SPAC_16 >=16)    {current_size = DOT16X16;current_vert_spac = VERT_SPAC_16;}
1562   1        else
1563   1        {//高度太小，连最小尺寸的字符都显示不下，直接跳过
1564   2          fTitle_TextAtLine =0;
1565   2          return;
1566   2        }
1567   1      
1568   1        if(fTitle_TextAtLine)
1569   1        {
1570   2          title_length = GetTitleLength(stLocalControl.stItemForm.ItemCode);  //获取标题长度进入到总长度中
1571   2          if(stLocalControl.stItemForm.DispMode &0x08)  title_length ++;    //bit3:标题是带“：”
1572   2          Length += title_length;
1573   2                      
1574   2        }
1575   1      
1576   1        do
1577   1        {
1578   2          get_dot_number();
1579   2      
1580   2          RowCharNum= area_height/(dot_number+current_vert_spac);
1581   2      
1582   2          ColumnCharNum= area_width/(dot_number/2);
1583   2          
1584   2          if(Length<=RowCharNum*ColumnCharNum)
1585   2          {//个数符合要求
1586   3            get_basesize_mul();
1587   3      
1588   3            x=start_x;  // 横向顶格显示
1589   3            if(area_width >= Length * (dot_number/2)) y=start_y + (area_height - dot_number)/2;   // 1行就能显示
1590   3            else y= start_y +(area_height-(dot_number+current_vert_spac)*(RowCharNum-1)-dot_number)/2;   //竖向居中
             -显示
1591   3            
1592   3            if(fTitle_TextAtLine)
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 27  

1593   3            {//标题与正文同行
1594   4      
1595   4              //if(area_width >= Length * (dot_number/2)) y=start_y + (area_height - dot_number)/2;   // 1行就能显示
             -
1596   4              pDispData = GetTitle(stLocalControl.stItemForm.ItemCode);
1597   4              if(pDispData!=NULL)
1598   4              {
1599   5                DisplayString();
1600   5                if(stLocalControl.stItemForm.DispMode &0x08)
1601   5                {
1602   6                  
1603   6                  pDispData=":";
1604   6                  DisplayString();
1605   6      
1606   6                }
1607   5                
1608   5              }
1609   4              pDispData = pdispdata2;
1610   4              Length    = LengthBack;
1611   4            }
1612   3            get_basesize_mul();
1613   3            DisplayStringLen();
1614   3            break;
1615   3            
1616   3          }
1617   2          else 
1618   2          { if(RowCharNum ==1)
1619   3            {//只能显示一行
1620   4              if(fTitle_TextAtLine)
1621   4              {//标题与正文同行
1622   5                if(area_width>= title_length*8+LengthBack*(dot_number/2)) //标题用16字体
1623   5                {
1624   6                  x=start_x;
1625   6                  y=start_y+(area_height-16)/2;
1626   6                  pDispData = GetTitle(stLocalControl.stItemForm.ItemCode);
1627   6                  if(pDispData!=NULL)
1628   6                  {
1629   7                    dot_number=16;
1630   7                    size=1;
1631   7                    mul_row =1;
1632   7                    mul_col=1;
1633   7                    DisplayString();
1634   7                    if(stLocalControl.stItemForm.DispMode &0x08)
1635   7                    {
1636   8                      
1637   8                      pDispData=":";
1638   8                      DisplayString();
1639   8      
1640   8                    }
1641   7                    
1642   7                  }
1643   6                  get_dot_number();
1644   6                  y=start_y+(area_height-dot_number)/2;
1645   6                  pDispData = pdispdata2;
1646   6                  Length    = LengthBack; 
1647   6      
1648   6                  get_basesize_mul();
1649   6                  DisplayStringLen();
1650   6                  break;              
1651   6                }
1652   5                //else current_size--;
1653   5              }
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 28  

1654   4              //else current_size--;
1655   4            }
1656   3      
1657   3            //else current_size--;
1658   3            current_size--;
1659   3          }
1660   2        }while(current_size);
1661   1        
1662   1        WDT_CONTR = 0x3e; //喂狗
1663   1        fTitle_TextAtLine =0;
1664   1      
1665   1      }
1666          
1667          
1668          
1669          
1670          //void ShowCallSuccess(uint8 page)
1671          void ShowCallSuccess(void)
1672          {
1673   1        start_x = 0;
1674   1        start_y = 120;
1675   1        end_x= 479;
1676   1        end_y= 152;
1677   1        bcolor =BLUE;
1678   1        DisplayBlock();
1679   1      
1680   1        
1681   1        x=120;
1682   1        y=120;
1683   1        current_size=2;
1684   1        get_dot_number();
1685   1        get_basesize_mul();
1686   1      
1687   1        fcolor=WHITE;
1688   1        bcolor=BLUE;
1689   1        start_x=0;
1690   1        start_y=0;
1691   1        end_x=480;
1692   1        end_y=272;  
1693   1        pDispData= "呼叫成功,请等待";
1694   1        DisplayString();
1695   1      
1696   1        Set_VisualPage(page); 
1697   1        stLocalControl.byDisplayFace=CALL_SUCCESS_FACE;
1698   1      }
1699          
1700          
1701          void ShowItem(uint8 ItemCode)
1702          {
1703   1      
1704   1        uint8 xdata position=0;
1705   1        uint8 num=0;
1706   1        uint8 i=0;
1707   1      //  uint8 j,k;
1708   1        
1709   1        page=1;
1710   1        mul_row=1;
1711   1        mul_col=1;
1712   1      
1713   1        //读取界面格式总长度
1714   1        Read_Cont((uint8*)&(stLocalControl.uiBedFaceFormLen),BED_FACE_FORM_LENGTH_ADDR,2);  
1715   1      
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 29  

1716   1      
1717   1        //从格式段中去找开始与结束点
1718   1        num= stLocalControl.uiBedFaceFormLen/sizeof(STItemForm);
1719   1        if(num>=MAX_ITEM_CODE)
1720   1        {//超限
1721   2          stLocalControl.uiBedFaceFormLen=0;
1722   2          Write_Cont(BED_FACE_FORM_LENGTH_ADDR,&(stLocalControl.uiBedFaceFormLen),2);
*** WARNING C182 IN LINE 1722 OF LCD.C: pointer to different objects
1723   2          Write_Cont(BED_FACE_FORM_BAK,&(stLocalControl.uiBedFaceFormLen),2);
*** WARNING C182 IN LINE 1723 OF LCD.C: pointer to different objects
1724   2          return;
1725   2        }
1726   1      
1727   1        i=0;
1728   1        for(;num>0;num--)
1729   1        {
1730   2          if(Read(BED_FACE_FORM_START_ADDR+i*sizeof(STItemForm))== ItemCode) break; //找到项目代码
1731   2          else i++;
1732   2          
1733   2        }
1734   1        if(num!=0)
1735   1        {//找到对应的格式项
1736   2          Read_Cont(&(stLocalControl.stItemForm.ItemCode),BED_FACE_FORM_START_ADDR+i*sizeof(STItemForm),sizeof(STI
             -temForm));//读取整项格式数据
1737   2          start_x=stLocalControl.stItemForm.StartPoint.x;
1738   2          start_y=stLocalControl.stItemForm.StartPoint.y;
1739   2      
1740   2          end_x= stLocalControl.stItemForm.EndPoint.x;
1741   2          end_y= stLocalControl.stItemForm.EndPoint.y;
1742   2      
1743   2      
1744   2          if(end_x >= LCD_PIX_X || end_y >=LCD_PIX_Y) return;
1745   2          if(start_x>=end_x || start_y>= end_y) return;
1746   2      
1747   2          if((ItemCode == ILLNESS_LEVEL) ||(ItemCode == MEDICAL_LEVEL)||(ItemCode == NURSING_LEVEL)||(ItemCode == 
             -DIETARY_LEVEL))
1748   2          {//特例,背景字体颜色从数据项中取
1749   3            fcolor= GetColor(*(stLocalControl.stItemData.pData)); //字体
1750   3            bcolor= GetColor(*(stLocalControl.stItemData.pData+1));           
1751   3          }
1752   2          else
1753   2          {
1754   3            fcolor= GetColor(stLocalControl.stItemForm.fcolor);
1755   3            bcolor= GetColor(stLocalControl.stItemForm.bcolor);
1756   3          }
1757   2          if(ItemCode!=BED_NUMBER)
1758   2          {//床号没有标题，不受标题格式影响
1759   3            if(stLocalControl.stItemForm.DispMode & 0x20) //bit5:是否显示标题
1760   3            {//显示标题
1761   4              if(stLocalControl.stItemForm.DispMode &0x10)//bit4:标题显示方向
1762   4              {//竖向显示
1763   5                fTitle_TextAtLine =0;
1764   5                if(stLocalControl.stItemForm.DispMode &0x08)//bit3:标题是否带“：”
1765   5                {//标题带“：”
1766   6                  start_x +=24;
1767   6                  
1768   6                }
1769   5                else
1770   5                {//标题不带":"
1771   6                  start_x +=16;
1772   6                }
1773   5                
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 30  

1774   5              }
1775   4              else
1776   4              {//横向显示
1777   5                //if((ItemCode == OX_START) ||(ItemCode == OX_END)||(ItemCode == OX_SUBTOTAL)||(ItemCode ==OX_TOTAL))
1778   5                if(stLocalControl.stItemForm.DispMode &0x01)//bit0:判断正文与标题是否另起一行
1779   5                {//另起一起
1780   6                  start_y +=16;
1781   6                  fTitle_TextAtLine =0;
1782   6                }
1783   5      
1784   5                else 
1785   5                {//在一行显示
1786   6                  fTitle_TextAtLine =1;
1787   6                        
1788   6                }
1789   5      
1790   5              }
1791   4            
1792   4            }
1793   3          }
1794   2          DisplayBlock();//把原有的消息清空 
1795   2        switch(ItemCode)
1796   2          {
1797   3            case OX_START:
1798   3              BedDataBuff[0]=(stLocalControl.stSupplyOxStartTime.byHour/10)+0x30; //转换成ASCII数字
1799   3              BedDataBuff[1]=(stLocalControl.stSupplyOxStartTime.byHour%10)+0x30;
1800   3              BedDataBuff[2]= 58;   //":"号
1801   3              BedDataBuff[3]=(stLocalControl.stSupplyOxStartTime.byMin/10)+0x30;
1802   3              BedDataBuff[4]=(stLocalControl.stSupplyOxStartTime.byMin%10)+0x30;
1803   3              BedDataBuff[5]=0x00;
1804   3      
1805   3              pDispData = BedDataBuff;
1806   3              Length = 5;       
1807   3              ShowInfoBlockLen();       
1808   3              break;
1809   3            case OX_END:
1810   3              BedDataBuff[0]=(stLocalControl.stSupplyOxEndTime.byHour/10)+0x30; //转换成ASCII数字
1811   3              BedDataBuff[1]=(stLocalControl.stSupplyOxEndTime.byHour%10)+0x30;
1812   3              BedDataBuff[2]= 58;   //":"号
1813   3              BedDataBuff[3]=(stLocalControl.stSupplyOxEndTime.byMin/10)+0x30;
1814   3              BedDataBuff[4]=(stLocalControl.stSupplyOxEndTime.byMin%10)+0x30;
1815   3              BedDataBuff[5]=0x00;
1816   3      
1817   3              pDispData = BedDataBuff;
1818   3              Length = 5;       
1819   3              ShowInfoBlockLen(); 
1820   3              break;
1821   3            case OX_SUBTOTAL:
1822   3              x=stLocalControl.stSupplyOxSubtotalTime.uiHour%10000; //得千位余数
1823   3              //BedDataBuff[0]=(x/1000)+0x30;   //得千位数  转换成ASCII数字
1824   3              y=x%1000;           //得百位余数
1825   3              //BedDataBuff[1]=(y/100)+0x30;    //得百位数
1826   3              BedDataBuff[0]=((y%100)/10)+0x30;
1827   3              BedDataBuff[1]=((y%100)%10)+0x30;   
1828   3              BedDataBuff[2]= 58;   //":"号
1829   3              BedDataBuff[3]=(stLocalControl.stSupplyOxSubtotalTime.byMin/10)+0x30;
1830   3              BedDataBuff[4]=(stLocalControl.stSupplyOxSubtotalTime.byMin%10)+0x30;   
1831   3              BedDataBuff[5]=0x00;
1832   3              
1833   3      
1834   3              pDispData = BedDataBuff;
1835   3              Length = 5;       
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 31  

1836   3              ShowInfoBlockLen(); 
1837   3              break;
1838   3              
1839   3            case OX_TOTAL:
1840   3              DisplayBlock();//把原有的消息清空 
1841   3              x=stLocalControl.stSupplyOxTotalTime.uiHour%10000;  //千位余数
1842   3              BedDataBuff[0]=(x/1000)+0x30;       //转换成ASCII数字
1843   3              y=x%1000;
1844   3              BedDataBuff[1]=(y/100)+0x30;
1845   3              BedDataBuff[2]=((y%100)/10)+0x30;
1846   3              BedDataBuff[3]=((y%100)%10)+0x30;   
1847   3              BedDataBuff[4]= 58;   //":"号
1848   3              BedDataBuff[5]=(stLocalControl.stSupplyOxTotalTime.byMin/10)+0x30;
1849   3              BedDataBuff[6]=(stLocalControl.stSupplyOxTotalTime.byMin%10)+0x30;    
1850   3              BedDataBuff[7]=0x00;
1851   3              
1852   3      
1853   3              pDispData = BedDataBuff;
1854   3              Length = 7;       
1855   3              ShowInfoBlockLen(); 
1856   3              break;
1857   3              
1858   3            case BED_NUMBER:
1859   3                size=4; 
1860   3              current_vert_spac=0;
1861   3              mul_row = 1;
1862   3              mul_col = 1;  
1863   3              x=start_x;y=start_y;
1864   3              BedDataBuff[0]=stLocalControl.stEepromCfgData.bySelfBedAddr/100+0x30;
1865   3              BedDataBuff[1]=(stLocalControl.stEepromCfgData.bySelfBedAddr%100)/10+0x30;
1866   3              BedDataBuff[2]=(stLocalControl.stEepromCfgData.bySelfBedAddr%100)%10+0x30;
1867   3              BedDataBuff[3]=0;   
1868   3      
1869   3              if(BedDataBuff[0] ==0x30)
1870   3              {
1871   4                pDispData =  &(BedDataBuff[1]);
1872   4                Length=2; //只显示两个数字
1873   4              }
1874   3              else
1875   3              {
1876   4                pDispData =  BedDataBuff;
1877   4                Length=3; //显示3个数字       
1878   4              }
1879   3              if((end_y - start_y+1 >=96)&&(end_y - start_y+1 <152))
1880   3              {//y空间满足特殊字体要求
1881   4                if(end_x - start_x +1 >= (48*Length))
1882   4                {//x空间也满足写下床号的要求
1883   5                  x=start_x+ (end_x-start_x-(48*Length))/2;
1884   5                  y= start_y +(end_y-start_y-96)/2;
1885   5                  size =4;
1886   5                  mul_col=1;
1887   5                  mul_row=1;
1888   5                  dot_number =96; 
1889   5                  DisplayString();
1890   5                  return;
1891   5                }
1892   4              }
1893   3      
1894   3              ShowInfoBlockLen();       
1895   3              break;  
1896   3      
1897   3              
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 32  

1898   3            case OX_SUPPLY:
1899   3              break;
1900   3            case ILLNESS_LEVEL:
1901   3            case MEDICAL_LEVEL:
1902   3            case NURSING_LEVEL:
1903   3            case DIETARY_LEVEL:
1904   3              pDispData = stLocalControl.stItemData.pData+2;
1905   3              Length = stLocalControl.stItemData.DataLength-2;
1906   3              ShowInfoBlockLen();   
1907   3              break;        
1908   3            default:        
1909   3              pDispData = stLocalControl.stItemData.pData;
1910   3              Length = stLocalControl.stItemData.DataLength;
1911   3              ShowInfoBlockLen();   
1912   3              break;
1913   3              
1914   3          }
1915   2        }
1916   1      
1917   1      }
1918          
1919          
1920          void ShowPatientBaseInfo(void)
1921          { 
1922   1        uint8 xdata position=0;
1923   1        uint8 num=0;
1924   1        uint8 i=0;
1925   1        uint16 uiDataLen;
1926   1        
1927   1        page=1;
1928   1        mul_row=1;
1929   1        mul_col=1;
1930   1      
1931   1        //读取界面格式总长度
1932   1        Read_Cont((uint8*)&(stLocalControl.uiBedFaceFormLen),BED_FACE_FORM_LENGTH_ADDR,2);  
1933   1        //读取界面数据总长度
1934   1        Read_Cont((uint8*)&(stLocalControl.uiBedFaceDataLen),BED_FACE_DATA_LENGTH_ADDR,2);
1935   1      
1936   1      
1937   1        uiDataLen = stLocalControl.uiBedFaceDataLen;
1938   1        //从格式段中去找开始与结束点
1939   1        num= stLocalControl.uiBedFaceFormLen/sizeof(STItemForm);
1940   1        if(num>=MAX_ITEM_CODE)
1941   1        {//超限
1942   2          stLocalControl.uiBedFaceFormLen=0;
1943   2          Write_Cont(BED_FACE_FORM_LENGTH_ADDR,&(stLocalControl.uiBedFaceFormLen),2);
*** WARNING C182 IN LINE 1943 OF LCD.C: pointer to different objects
1944   2          Write_Cont(BED_FACE_FORM_BAK,&(stLocalControl.uiBedFaceFormLen),2);
*** WARNING C182 IN LINE 1944 OF LCD.C: pointer to different objects
1945   2          return;
1946   2        }
1947   1      
1948   1        for(;uiDataLen>0;)
1949   1        {
1950   2      
1951   2          Read_Cont(&(stLocalControl.stItemData.ItemCode),BED_FACE_DATA_START_ADDR+position,2);
1952   2          position +=2;
1953   2          uiDataLen -=2;
1954   2      
1955   2          if(stLocalControl.stItemData.DataLength)
1956   2          {//有数据
1957   3            if((stLocalControl.stItemData.DataLength<=SEGMENT_DATA_LEN)&&(stLocalControl.stItemData.ItemCode < MAX_
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 33  

             -ITEM_CODE))
1958   3            {//数据段数据不超长或者功能码相符
1959   4              i=0;
1960   4              num= stLocalControl.uiBedFaceFormLen/sizeof(STItemForm);
1961   4              for(;num>0;num--)
1962   4              {
1963   5                if(Read(BED_FACE_FORM_START_ADDR+i*sizeof(STItemForm))== stLocalControl.stItemData.ItemCode) break; /
             -/找到项目代码
1964   5                else i++;
1965   5                
1966   5              }
1967   4              if(num!=0)
1968   4              {//找到对应的格式项
1969   5                Read_Cont(&(stLocalControl.stItemForm.ItemCode),BED_FACE_FORM_START_ADDR+i*sizeof(STItemForm),sizeof(
             -STItemForm));//读取整项格式数据
1970   5                if((stLocalControl.stItemForm.EndPoint.x > stLocalControl.stItemForm.StartPoint.x)&&
1971   5                   (stLocalControl.stItemForm.EndPoint.y > stLocalControl.stItemForm.StartPoint.y))
1972   5      
1973   5                {//起始点X，Y坐标符合要求
1974   6                  start_x=stLocalControl.stItemForm.StartPoint.x;
1975   6                  start_y=stLocalControl.stItemForm.StartPoint.y;
1976   6      
1977   6                  end_x= stLocalControl.stItemForm.EndPoint.x;
1978   6                  end_y= stLocalControl.stItemForm.EndPoint.y;
1979   6      
1980   6      
1981   6                  stLocalControl.stItemData.pData = BedDataBuff;
1982   6                  Read_Cont(stLocalControl.stItemData.pData ,BED_FACE_DATA_START_ADDR+position,stLocalControl.stItemDa
             -ta.DataLength);
1983   6      
1984   6      
1985   6                  if((stLocalControl.stItemData.ItemCode == ILLNESS_LEVEL) ||(stLocalControl.stItemData.ItemCode == ME
             -DICAL_LEVEL)||(stLocalControl.stItemData.ItemCode == NURSING_LEVEL)||(stLocalControl.stItemData.ItemCode == DIETARY_LEVE
             -L))
1986   6                  {//特例,背景字体颜色从数据项中取
1987   7                    fcolor= GetColor(*(stLocalControl.stItemData.pData)); //字体
1988   7                    bcolor= GetColor(*(stLocalControl.stItemData.pData+1));           
1989   7                  }
1990   6                  else
1991   6                  {
1992   7                    fcolor= GetColor(stLocalControl.stItemForm.fcolor);
1993   7                    bcolor= GetColor(stLocalControl.stItemForm.bcolor);
1994   7                  }
1995   6      
1996   6                  if(stLocalControl.stItemForm.DispMode & 0x20) //bit5:是否显示标题
1997   6                  {//显示标题
1998   7                    if(stLocalControl.stItemForm.DispMode &0x10)//bit4:标题显示方向
1999   7                    {//竖向显示
2000   8                      fTitle_TextAtLine=0;
2001   8                      if(stLocalControl.stItemForm.DispMode &0x08)//bit3:标题是否带“：”
2002   8                      {//标题带“：”
2003   9                        start_x +=24;
2004   9                        
2005   9                      }
2006   8                      else
2007   8                      {//标题不带":"
2008   9                        start_x +=16;
2009   9                      }
2010   8                      
2011   8                    }
2012   7                    else
2013   7                    {//横向显示
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 34  

2014   8                      if(stLocalControl.stItemForm.DispMode &0x01)//bit0:判断正文与标题是否另起一行
2015   8                      {//另起一行
2016   9                        start_y +=16;
2017   9                        fTitle_TextAtLine=0;
2018   9                      }
2019   8                      else
2020   8                      {//在同一行
2021   9                        fTitle_TextAtLine =1;
2022   9                                    
2023   9                      }
2024   8                    }
2025   7                    
2026   7                  }
2027   6                  
2028   6                  DisplayBlock();//把原有的消息清空 
2029   6                  if((stLocalControl.stItemData.ItemCode == ILLNESS_LEVEL) ||(stLocalControl.stItemData.ItemCode == ME
             -DICAL_LEVEL)||(stLocalControl.stItemData.ItemCode == NURSING_LEVEL)||(stLocalControl.stItemData.ItemCode == DIETARY_LEVE
             -L))
2030   6                  {//特例,真正的数据从第三个字节开始
2031   7                    pDispData = stLocalControl.stItemData.pData+2;
2032   7                    Length = stLocalControl.stItemData.DataLength-2;            
2033   7                  }
2034   6                  else
2035   6                  {
2036   7                    pDispData = stLocalControl.stItemData.pData;
2037   7                    Length = stLocalControl.stItemData.DataLength;
2038   7                  }
2039   6                  ShowInfoBlockLen();
2040   6                }
2041   5              }
2042   4            }
2043   3            position +=stLocalControl.stItemData.DataLength;
2044   3            uiDataLen -= stLocalControl.stItemData.DataLength;      
2045   3          }  //有数据的末尾
2046   2      
2047   2        }
2048   1      
2049   1      }
2050          
2051          
2052          
2053          void ShowBedFace(void)
2054          { 
2055   1        uint8 i;
2056   1        Read_Cont((uint8*)&(stLocalControl.uiBedFaceFormLen),BED_FACE_FORM_LENGTH_ADDR,2);  //读格式数据总个数
2057   1      
2058   1        if(StoreDataCheck(BED_FACE_FORM_LENGTH_ADDR,stLocalControl.uiBedFaceFormLen+2)) //将数据长度也包含进去
2059   1        {
2060   2          ShowBedFaceForm();  
2061   2          if(StoreDataCheck(BED_FACE_FORM_BAK,stLocalControl.uiBedFaceFormLen+2)!=1)
2062   2          {//如果备份区不正确
2063   3            for(i=0;i<5;i++)
2064   3            {
2065   4              SectorDataCopy(BED_FACE_FORM_BAK,BED_FACE_FORM_LENGTH_ADDR,stLocalControl.uiBedFaceFormLen+3);  //拷贝
             -亮硪槐阜萸        
2066   4              if(StoreDataCheck(BED_FACE_FORM_BAK,stLocalControl.uiBedFaceFormLen+2)==1)  break;  
2067   4            }   
2068   3          }
2069   2        }
2070   1        else
2071   1        {//主格式不正确
2072   2          Read_Cont((uint8*)&(stLocalControl.uiBedFaceFormLen),BED_FACE_FORM_BAK,2);  //读备份区格式数据总个数  
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 35  

2073   2        
2074   2          if(StoreDataCheck(BED_FACE_FORM_BAK,stLocalControl.uiBedFaceFormLen+2))
2075   2          {//备份区正确
2076   3            while(1)
2077   3            {
2078   4              SectorDataCopy(BED_FACE_FORM_LENGTH_ADDR,BED_FACE_FORM_BAK,stLocalControl.uiBedFaceFormLen+3);  //拷贝
             -林鞲袷角        
2079   4              if(StoreDataCheck(BED_FACE_FORM_LENGTH_ADDR,stLocalControl.uiBedFaceFormLen+2)==1)  break;          
2080   4            }
2081   3            ShowBedFaceForm();
2082   3          }
2083   2          else return;    //主格式区不正确，备份格式区也不正确。
2084   2        }
2085   1      
2086   1      
2087   1      //  ShowBedFaceForm();
2088   1        WDT_CONTR = 0x3e; 
2089   1        ShowItem(BED_NUMBER);
2090   1        Read_Cont((uint8*)&(stLocalControl.uiBedFaceDataLen),BED_FACE_DATA_LENGTH_ADDR,2);  //读床头卡数据总个数
2091   1      
2092   1        if(StoreDataCheck(BED_FACE_DATA_LENGTH_ADDR,stLocalControl.uiBedFaceDataLen+2)) //将数据长度也包含进去
2093   1        {
2094   2          
2095   2          
2096   2          ShowPatientBaseInfo();      
2097   2          if(StoreDataCheck(BED_FACE_DATA_BAK,stLocalControl.uiBedFaceDataLen+2)!=1)
2098   2          {//如果备份区不正确
2099   3            for(i=0;i<5;i++)
2100   3            {
2101   4              SectorDataCopy(BED_FACE_DATA_BAK,BED_FACE_DATA_LENGTH_ADDR,stLocalControl.uiBedFaceDataLen+3);  //拷贝
             -亮硪槐阜萸        
2102   4              if(StoreDataCheck(BED_FACE_DATA_BAK,stLocalControl.uiBedFaceDataLen+2)==1)  break;  
2103   4            }   
2104   3          }
2105   2        }
2106   1        else
2107   1        {//主格式不正确
2108   2          Read_Cont((uint8*)&(stLocalControl.uiBedFaceDataLen),BED_FACE_DATA_BAK,2);  //读备份区床头卡数据总个数
2109   2          
2110   2          if(StoreDataCheck(BED_FACE_DATA_BAK,stLocalControl.uiBedFaceDataLen+2))
2111   2          {//备份区正确
2112   3            while(1)
2113   3            {
2114   4              SectorDataCopy(BED_FACE_DATA_LENGTH_ADDR,BED_FACE_DATA_BAK,stLocalControl.uiBedFaceDataLen+3);  //拷贝
             -林魇据区        
2115   4              if(StoreDataCheck(BED_FACE_DATA_LENGTH_ADDR,stLocalControl.uiBedFaceDataLen+2)==1)  break;          
2116   4            }
2117   3            ShowPatientBaseInfo();
2118   3          }
2119   2          else return;    //主数据区不正确，备份数据区也不正确。
2120   2        }
2121   1      //    ShowPatientBaseInfo();
2122   1        ShowItem(OX_START);
2123   1        ShowItem(OX_END);
2124   1        ShowItem(OX_SUBTOTAL);  
2125   1        ShowItem(OX_TOTAL);
2126   1      
2127   1      }
2128          
2129          
2130          
2131          void ShowPowerUpFace(void)  //写在第0页
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 36  

2132          {
2133   1        fcolor=BLUE;
2134   1        Lcd_Clear();
2135   1      
2136   1        current_size = 2; //32*32
2137   1        get_dot_number();
2138   1        get_basesize_mul();
2139   1      
2140   1        x=(LCD_PIX_X-dot_number*6)/2;   
2141   1        y=(LCD_PIX_Y-(dot_number+current_vert_spac)*4)/2;   
2142   1        
2143   1        fcolor=WHITE;
2144   1        bcolor=BLUE;
2145   1        pDispData="系统初始化...";
2146   1        start_x =0;
2147   1        start_y =0;
2148   1        end_x = 480;
2149   1        end_y =272;   
2150   1        DisplayString();
2151   1        
2152   1      
2153   1        y += (dot_number+current_vert_spac);      //106
2154   1        x=(LCD_PIX_X-dot_number*4)/2;   //176
2155   1        pDispData="版本V";
2156   1        DisplayString();
2157   1      
2158   1        stLocalControl.stEepromCfgData.byVersionHi=3;
2159   1        DisplayOneChar(stLocalControl.stEepromCfgData.byVersionHi);
2160   1        pDispData=".";
2161   1          DisplayString();
2162   1        stLocalControl.stEepromCfgData.byVersionLo=7;
2163   1        DisplayOneChar(stLocalControl.stEepromCfgData.byVersionLo);
2164   1        
2165   1        
2166   1      
2167   1        y += (dot_number+current_vert_spac);
2168   1        x =(LCD_PIX_X-dot_number*10)/2;
2169   1        pDispData="病房护理系统床头分机";
2170   1        DisplayString();  
2171   1      
2172   1      
2173   1      /*  y += (dot_number+current_vert_spac);
2174   1        x =(LCD_PIX_X-dot_number*4)/2;
2175   1        pDispData="床头分机";
2176   1        DisplayString();  */
2177   1      
2178   1        
2179   1        Set_VisualPage(page);
2180   1        stLocalControl.byDisplayFace=POWER_UP_FACE;
2181   1      }
2182          
2183          
2184          void ShowStartNumSet(void)
2185          {
2186   1      
2187   1        start_x=0;
2188   1        start_y=120;
2189   1        end_x = 479;
2190   1        end_y =152; 
2191   1        bcolor =BLUE;
2192   1        DisplayBlock();
2193   1      
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 37  

2194   1        x=(480-32*10)/2;    //60
2195   1        y=120;
2196   1        current_size = 2; //32*32
2197   1        get_dot_number();
2198   1        get_basesize_mul();
2199   1      
2200   1        fcolor=WHITE;
2201   1        bcolor=BLUE;
2202   1        
2203   1        start_x =0;
2204   1        start_y =0;
2205   1        end_x = 480;
2206   1        end_y =272; 
2207   1          DisplayOneChar(stLocalControl.stBusDealFreq.bySndSecAddr);
2208   1        pDispData="区";
2209   1        DisplayString();
2210   1      
2211   1      
2212   1          DisplayOneChar(stLocalControl.stBusDealFreq.bySndRoomAddr);
2213   1        pDispData ="房";
2214   1        DisplayString();
2215   1      
2216   1        
2217   1          DisplayOneChar(stLocalControl.stBusDealFreq.bySndBedAddr);
2218   1        pDispData ="床开始编号";
2219   1        DisplayString();
2220   1      
2221   1      
2222   1        Set_VisualPage(page);
2223   1        stLocalControl.byDisplayFace=START_NUM_SET_FACE;  
2224   1      }
2225          
2226          
2227          void ShowNumSetOk(void)
2228          {
2229   1        start_x=0;
2230   1        start_y=120;
2231   1        end_x = 479;
2232   1        end_y =152; 
2233   1        bcolor =BLUE;
2234   1        DisplayBlock();
2235   1      
2236   1        
2237   1        x=(480-32*4)/2;
2238   1        y=(272-32)/2;
2239   1        current_size = 2; //32*32
2240   1        get_dot_number();
2241   1        get_basesize_mul();
2242   1      
2243   1        fcolor=WHITE;
2244   1        bcolor=BLUE;
2245   1        
2246   1        start_x =0;
2247   1        start_y =0;
2248   1        end_x = 480;
2249   1        end_y =272; 
2250   1        pDispData="编号成功";
2251   1        DisplayString();
2252   1        
2253   1        Set_VisualPage(page);
2254   1        stLocalControl.byDisplayFace=NUM_SET_OK_FACE;
2255   1      
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 38  

2256   1        page=1;
2257   1        ShowItem(BED_NUMBER);   //写在第1页
2258   1      }
2259          
2260          
2261          void ShowStartRfNumSet(void)      
2262          {
2263   1        start_x=0;
2264   1        start_y=120;
2265   1        end_x = 479;
2266   1        end_y =152; 
2267   1        bcolor =BLUE;
2268   1        DisplayBlock();
2269   1      
2270   1        
2271   1        x=(480-32*9)/2;
2272   1        y=(272-32)/2;
2273   1        current_size = 2; //32*32
2274   1        get_dot_number();
2275   1        get_basesize_mul();
2276   1      
2277   1        fcolor=WHITE;
2278   1        bcolor=BLUE;
2279   1        
2280   1        start_x =0;
2281   1        start_y =0;
2282   1        end_x = 480;
2283   1        end_y =272; 
2284   1        pDispData="输液报警器开始对码"; 
2285   1        DisplayString();
2286   1      
2287   1      
2288   1        Set_VisualPage(page);
2289   1        stLocalControl.byDisplayFace=START_RF_NUM_SET_FACE;   
2290   1      }
2291          
2292          void ShowRfNumSetOk(void)     
2293          {
2294   1        start_x=0;
2295   1        start_y=120;
2296   1        end_x = 479;
2297   1        end_y =152; 
2298   1        bcolor =BLUE;
2299   1        DisplayBlock();
2300   1      
2301   1        
2302   1        x=(480-32*9)/2;
2303   1        y=(272-32)/2;
2304   1        
2305   1        current_size = 2; //32*32
2306   1        get_dot_number();
2307   1        get_basesize_mul();
2308   1      
2309   1        fcolor=WHITE;
2310   1        bcolor=BLUE;
2311   1        
2312   1        start_x =0;
2313   1        start_y =0;
2314   1        end_x = 480;
2315   1        end_y =272; 
2316   1        pDispData="输液报警器对码成功";   
2317   1        DisplayString();
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 39  

2318   1      
2319   1        Set_VisualPage(page);
2320   1        stLocalControl.byDisplayFace=RF_NUM_SET_OK_FACE;    
2321   1      }
2322          
2323          
2324          
2325          
2326          uint8* GetTitle(uint8 ItemCode)
2327          {
2328   1        switch(ItemCode)
2329   1        {
2330   2          case BED_NUMBER:
2331   2            return("床号");
2332   2            break;
2333   2      
2334   2          case ILLNESS_LEVEL:
2335   2            return("病情");
2336   2            break;
2337   2      
2338   2          case MEDICAL_LEVEL:
2339   2            return("医保");
2340   2            break;
2341   2      
2342   2          case NURSING_LEVEL:
2343   2            return("护理");
2344   2            break;
2345   2      
2346   2          case DIETARY_LEVEL:
2347   2            return("饮食");
2348   2            break;
2349   2      
2350   2          case HOSPITALIZED_NO:
2351   2            return("入院号");
2352   2            break;
2353   2      
2354   2          case NAME:
2355   2            return("姓名");
2356   2            break;
2357   2      
2358   2          case SEX:
2359   2            return("性别");
2360   2            break;
2361   2      
2362   2          case AGE:
2363   2            return("年龄");
2364   2            break;
2365   2          
2366   2          case ADMISSION_DATE:
2367   2            return("入院");
2368   2            break;
2369   2      
2370   2          case DIAGNOSIS:
2371   2            return("诊断");
2372   2            break;
2373   2      
2374   2          case BLOOD:
2375   2            return("血型");
2376   2            break;
2377   2      
2378   2              case CAUTION:
2379   2            return("安全警示");
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 40  

2380   2            break;
2381   2      
2382   2          case ALERGY_DRUGS:
2383   2            return("过敏史");
2384   2            break;
2385   2      
2386   2            
2387   2          case DOCTOR:
2388   2            return("医生");
2389   2            break;
2390   2      
2391   2          case NURSE:
2392   2            return("护士");
2393   2            break;
2394   2      
2395   2          case ILLNESS_CHANGE:
2396   2            return("病情变化");
2397   2            break;
2398   2      
2399   2          case PHARMACY:
2400   2            return("用药");
2401   2            break;
2402   2      
2403   2          case MESSAGE_BOARD:
2404   2            return("留言板");
2405   2            break;
2406   2      
2407   2          case DIET_INFO:
2408   2            return("饮食信息");
2409   2            break;
2410   2      
2411   2          case DOCTOR_ADVICE:
2412   2            return("医嘱");
2413   2            break;
2414   2      
2415   2          case HINT:
2416   2            return("提示");
2417   2            break;
2418   2            
2419   2            
2420   2          case OX_SUPPLY:
2421   2            return("供氧");
2422   2            break;
2423   2      
2424   2          case OX_START:
2425   2            return("开始");
2426   2            break;
2427   2      
2428   2          case OX_END:
2429   2            return("结束");
2430   2            break;
2431   2      
2432   2          case OX_SUBTOTAL:
2433   2            return("小计");
2434   2            break;
2435   2          case OX_TOTAL:
2436   2            return("累计");
2437   2            break;
2438   2      
2439   2          case MESSAGE2:
2440   2            return("消息栏2");
2441   2            break;
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 41  

2442   2      
2443   2          case MESSAGE3:
2444   2            return("消息栏3");
2445   2            break;  
2446   2      
2447   2          case MESSAGE4:
2448   2            return("消息栏4");
2449   2            break;  
2450   2      
2451   2          case MESSAGE5:
2452   2            return("消息栏5");
2453   2            break;  
2454   2      
2455   2          case MESSAGE6:
2456   2            return("消息栏6");
2457   2            break;  
2458   2            
2459   2      
2460   2          default:
2461   2            return(NULL);
2462   2            break;    
2463   2        }
2464   1      }
2465          
2466          
2467          uint8 GetTitleLength(uint8 ItemCode)
2468          {
2469   1        uint8 title_length=0;
2470   1        switch(ItemCode)
2471   1        {
2472   2          case BED_NUMBER:
2473   2          case ILLNESS_LEVEL:
2474   2          case MEDICAL_LEVEL:
2475   2          case DIETARY_LEVEL:
2476   2          case NAME:
2477   2          case SEX:
2478   2          case AGE:
2479   2          case ADMISSION_DATE:
2480   2          case DIAGNOSIS:
2481   2          case BLOOD:
2482   2          case DOCTOR:
2483   2          case NURSE:
2484   2          case PHARMACY:
2485   2          case DOCTOR_ADVICE:
2486   2          case HINT:
2487   2          case OX_SUPPLY: 
2488   2          case OX_START:
2489   2          case OX_END:
2490   2          case OX_SUBTOTAL:
2491   2          case OX_TOTAL:
2492   2             title_length= 4;     //都是2个汉字的
2493   2             break;
2494   2      
2495   2      
2496   2      
2497   2          case HOSPITALIZED_NO:
2498   2          case ALERGY_DRUGS:
2499   2          case MESSAGE_BOARD:
2500   2             title_length= 6;     //都是3个汉字的
2501   2             break;     
2502   2      
2503   2      
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 42  

2504   2          case MESSAGE2:
2505   2          case MESSAGE3:
2506   2          case MESSAGE4:
2507   2          case MESSAGE5:
2508   2          case MESSAGE6:
2509   2             title_length= 7;     //都是3.5个汉字的
2510   2             break;       
2511   2            
2512   2      
2513   2              case CAUTION:
2514   2          case ILLNESS_CHANGE:
2515   2          case DIET_INFO:
2516   2             title_length= 8;     //都是4个汉字的
2517   2             break;   
2518   2      
2519   2          default:
2520   2            title_length= 0;
2521   2            break;    
2522   2        }
2523   1        return title_length;
2524   1      }
2525          
2526          
2527          //显示床头分机界面格式
2528          void ShowBedFaceForm(void)
2529          {
2530   1        uint16 position=0;
2531   1        uint16 uiFormLen;
2532   1        page=1;
2533   1        fcolor=WHITE;
2534   1        Lcd_Clear();
2535   1      
2536   1      //  Read_Cont((uint8*)&(stLocalControl.uiBedFaceFormLen),BED_FACE_FORM_LENGTH_START_ADDR,2);  //读格式数据总
             -个数
2537   1        uiFormLen= stLocalControl.uiBedFaceFormLen;
2538   1      
2539   1        if(((stLocalControl.uiBedFaceFormLen/sizeof(STItemForm))>=MAX_ITEM_CODE) ||(stLocalControl.uiBedFaceFormL
             -en ==0xffff))
2540   1        {//项目超限
2541   2          stLocalControl.uiBedFaceFormLen=0;
2542   2          Write_Cont(BED_FACE_FORM_LENGTH_ADDR,&(stLocalControl.uiBedFaceFormLen),2);
*** WARNING C182 IN LINE 2542 OF LCD.C: pointer to different objects
2543   2          Write_Cont(BED_FACE_FORM_BAK,&(stLocalControl.uiBedFaceFormLen),2);
*** WARNING C182 IN LINE 2543 OF LCD.C: pointer to different objects
2544   2          return;
2545   2        }
2546   1      
2547   1        for(;uiFormLen>=sizeof(STItemForm);)
2548   1        {
2549   2          Read_Cont(&(stLocalControl.stItemForm.ItemCode),BED_FACE_FORM_START_ADDR+position,sizeof(STItemForm));
2550   2          start_x = stLocalControl.stItemForm.StartPoint.x;
2551   2          start_y = stLocalControl.stItemForm.StartPoint.y;
2552   2          end_x = stLocalControl.stItemForm.EndPoint.x;
2553   2          end_y = stLocalControl.stItemForm.EndPoint.y;
2554   2      
2555   2          fcolor=GetColor(stLocalControl.stItemForm.fcolor);
2556   2          bcolor=GetColor(stLocalControl.stItemForm.bcolor);
2557   2      
2558   2          mul_col=1;
2559   2          mul_row=1;  
2560   2          DisplayBlock();
2561   2      
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 43  

2562   2          if(stLocalControl.stItemForm.DispMode & 0x20) //bit5
2563   2          {//显示标题   
2564   3            if(stLocalControl.stItemForm.DispMode & 0x10) //bit4
2565   3            {//竖向显示
2566   4            
2567   4              pDispData=GetTitle(stLocalControl.stItemForm.ItemCode);
2568   4              Length = GetTitleLength(stLocalControl.stItemForm.ItemCode)/2;
2569   4      
2570   4              end_x = start_x +16;
2571   4              
2572   4              
2573   4              if(pDispData!=NULL)
2574   4              {//竖向标题用16点阵，都居中显示
2575   5                x=start_x;
2576   5                if( (end_y-start_y)/16>= Length)
2577   5                {//空间足够
2578   6                  y= start_y + (end_y-start_y- 16*Length)/2;
2579   6                  
2580   6                }
2581   5                else 
2582   5                {
2583   6                  Length = (end_y-start_y)/16;
2584   6                  y= start_y + (end_y-start_y- 16*Length)/2;
2585   6                  
2586   6                }
2587   5                size=1;
2588   5                dot_number =16;
2589   5                current_vert_spac=0;
2590   5                mul_row=1;
2591   5                mul_col=1;
2592   5                DisplayString();//显示标题
2593   5                
2594   5      
2595   5                if(stLocalControl.stItemForm.DispMode & 0x08) //bit3
2596   5                {//显示“：”号
2597   6                  x=end_x +1;
2598   6                  size=1;
2599   6                  mul_row=1;
2600   6                  mul_col=1;
2601   6                  Get_GT23_Data(":",1);
2602   6                  Display_ASCII_Mul();          
2603   6                }
2604   5      
2605   5              }
2606   4            }
2607   3            else
2608   3            {//横向显示
2609   4              pDispData=GetTitle(stLocalControl.stItemForm.ItemCode);
2610   4              if(pDispData!=NULL)
2611   4              {
2612   5                x=start_x;
2613   5                y=start_y;
2614   5                if(stLocalControl.stItemForm.DispMode &0x01)//bit0:判断正文与标题是否另起一行
2615   5                {//另起一起 16点阵
2616   6      
2617   6                  y=start_y;
2618   6                    
2619   6                }
2620   5      
2621   5                else 
2622   5                {
2623   6                  if(end_y-start_y>16)
C51 COMPILER V9.00   LCD                                                                   03/11/2019 16:52:16 PAGE 44  

2624   6                  {
2625   7                    y=start_y +(end_y-start_y-16)/2;
2626   7                  }
2627   6                }
2628   5                current_size=1;  //3
2629   5                get_dot_number();
2630   5                get_basesize_mul();
2631   5                DisplayString();//显示标题
2632   5      
2633   5                if(stLocalControl.stItemForm.DispMode & 0x08) //bit3
2634   5                {//显示“：”号
2635   6                  size=1;
2636   6                  mul_col=1;
2637   6                  mul_row=1;
2638   6                  Get_GT23_Data(":",1);
2639   6                  Display_ASCII_Mul();              
2640   6              
2641   6                } 
2642   5              }
2643   4            }
2644   3          }
2645   2          
2646   2          uiFormLen -=sizeof(STItemForm);
2647   2          position  +=sizeof(STItemForm);
2648   2          
2649   2        }
2650   1        Set_VisualPage(page);
2651   1        stLocalControl.byDisplayFace = BED_INFO_FACE; 
2652   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  11199    ----
   CONSTANT SIZE    =    490    ----
   XDATA SIZE       =     91      64
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  6 WARNING(S),  0 ERROR(S)
