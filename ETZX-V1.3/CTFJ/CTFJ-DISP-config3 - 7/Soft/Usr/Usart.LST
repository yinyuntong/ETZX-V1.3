C51 COMPILER V8.08   USART                                                                 01/04/2011 17:09:45 PAGE 1   


C51 COMPILER V8.08, COMPILATION OF MODULE USART
OBJECT MODULE PLACED IN Usart.OBJ
COMPILER INVOKED BY: D:\Program Files\Keil\C51\BIN\C51.EXE Usart.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*
   2          ************************Copyright(c)************************
   3          *                                  湖南一特电子股份有限公司
   4          *                               All Rights Reserved
   5          *                                        
   6          *
   7          *-----------------------文件信息---------------------------
   8          *文件名称               :Uart.c
   9          *文件描述               :串口驱动程序
  10          *创建人                 :尹运同
  11          *创建日期               :2009-4-6
  12          *版本号                 :V1.0
  13          *注释                   :                                       
  14          *----------------------------------------------------------
  15          *修改人                         :
  16          *修改日期                       :
  17          *版本号                 :
  18          *注释                   :
  19          ***********************************************************
  20          */
  21          #define _IN_USART_
  22          #include "config.h"
  23          
  24          //串口变量定义
  25          #if MAX_COM > 0
  26          STUsartCfg  xdata stUsartCfg[MAX_COM];
  27          #define IncRxPtr(byPort,addr)           (addr=(addr+1)%stUsartCfg[byPort].uiRecBufSize)
  28          #define IncTxPtr(byPort,addr)           (addr=(addr+1)%stUsartCfg[byPort].uiSndBufSize)
  29          #endif
  30          //串口0配置
  31          #if MAX_COM >= 1
  32          uint8   xdata byUsart0RecBuf[UART0_RX_BUF_SIZE];
  33          uint8   xdata byUsart0SndBuf[UART0_TX_BUF_SIZE];
  34          
  35          
  36          #endif
  37          //串口1配置
  38          #if MAX_COM >= 2
              uint8   xdata byUsart1RecBuf[UART1_RX_BUF_SIZE];
              uint8   xdata byUsart1SndBuf[UART1_TX_BUF_SIZE];
              
              #endif
  43          
  44          uint8 bdata byUsartState;
  45          sbit bUsart0RecFinish   = byUsartState^0;
  46          sbit bUsart1RecFinish   = byUsartState^1;
  47          
  48          extern STLocalControl xdata stLocalControl;
  49          extern uint8    OS_Q_MEM_SEL    byMainCmdQ[];
  50          /**********************************************************
  51          *函数名称                       :UsartInit      
  52          *函数描述               :串口初始化函数
  53          *输入参数               :
  54          *返回值                         :
  55          *全局变量                       :
C51 COMPILER V8.08   USART                                                                 01/04/2011 17:09:45 PAGE 2   

  56          *调用模块                       :
  57          ***********************************************************
  58          *创建人                 :尹运同
  59          *创建日期                       :2009-4-6
  60          ***********************************************************
  61          *修改人                         :
  62          *修改日期               :
  63          *注释                   :
  64          **********************************************************/
  65          void UsartInit(void)
  66          {
  67   1      #if MAX_COM >= 1
  68   1              //串口0初始化
  69   1              stUsartCfg[0].pbyRecBuf = byUsart0RecBuf;
  70   1              stUsartCfg[0].pbySndBuf = byUsart0SndBuf;
  71   1              stUsartCfg[0].byRecState=0;
  72   1              stUsartCfg[0].uiRecPosition=0;
  73   1              stUsartCfg[0].uiRecLen=0;
  74   1              stUsartCfg[0].byRecCount=0;     
  75   1              stUsartCfg[0].uiSndLen  = stUsartCfg[0].uiSndPos  = 0;
  76   1              
  77   1              SCON=0X50;              //工作方式1
  78   1              TMOD&=0X0F;             //TO方式不变
  79   1              TMOD|=0X20;             //T1 方式2 :8位自动重载
  80   1      
  81   1      
  82   1              TL1     =       0XF6;           //波特率4800  在18.432M晶振的情况下
  83   1              TH1     =       TL1;
  84   1          PCON&=      ~SMOD;   //  ;波特率倍增选择            smod=0
  85   1              AUXR |= T1x12;          //1T模式,最后波特率为:4800*12=57.6K
  86   1          TF1=0;
  87   1          TR1=1;
  88   1              
  89   1              RI=0;
  90   1              TI=0;
  91   1              REN=1;
  92   1              ES=1;   
  93   1      #endif
  94   1      #if MAX_COM >= 2
                      //串口1初始化
                      AUXR1 |= S2_P4;         //串口2切换到P4口
                      stUsartCfg[1].pbyRecBuf = byUsart1RecBuf;
                      stUsartCfg[1].pbySndBuf = byUsart1SndBuf;
                      stUsartCfg[1].byRecState=0;
                      stUsartCfg[1].uiRecPosition=0;
                      stUsartCfg[1].uiRecLen=0;
                      stUsartCfg[1].byRecCount=3;     
                      stUsartCfg[1].uiSndLen  = stUsartCfg[1].uiSndPos  = 0;
              
                      S2CON   =       0X50;           //0101 0000 8位可变波特率,无奇偶校验位
                      AUXR    &=      ~S2SMOD;        //S2MOD=0;
                  AUXR        |=  BRTx12;             //BRTX12=1; 1T模式,最后波特率为:4800*12=57.6K
                  BRT         =       0XF6;           //波特率4800  在18.432M晶振的情况下
                      AUXR    |=      BRTR;           //启动独立波特率发生器
                      IE2     |= ES2;
              #endif
 112   1      }
 113          #if MAX_COM >= 1
 114          /**********************************************************
 115          *函数名称                       :UART0(void)    
 116          *函数描述               :串口0中断函数
 117          *输入参数               :
C51 COMPILER V8.08   USART                                                                 01/04/2011 17:09:45 PAGE 3   

 118          *返回值                         :
 119          *全局变量                       :stUsartCfg
 120          *调用模块                       :
 121          ***********************************************************
 122          *创建人                 :尹运同
 123          *创建日期                       :2009-4-6
 124          ***********************************************************
 125          *修改人                         :
 126          *修改日期               :
 127          *注释                   :
 128          **********************************************************/
 129          #pragma disable
 130          void UART0(void) interrupt UART_INTNO
 131          {
 132   1              uint8 byTemp;
 133   1              if(RI==1)
 134   1              {  
 135   2                      RI=0;
 136   2                      byTemp=SBUF;
 137   2                      if(stUsartCfg[0].uiRecPosition!=0)      //不是起始字节
 138   2                      {
 139   3                              if(stUsartCfg[0].byRecTimeout==0)
 140   3                              {//超时到了
 141   4                                      stUsartCfg[0].byRecState=0;
 142   4                                      stUsartCfg[0].uiRecPosition=0;
 143   4                                      return;
 144   4                              }
 145   3                      }
 146   2                      stUsartCfg[0].byRecTimeout=5;   //又开始定时
 147   2                      byUsart0RecBuf[stUsartCfg[0].uiRecPosition++] = byTemp;         
 148   2                      switch(stUsartCfg[0].byRecState)
 149   2                      {
 150   3                              case 0:                                                         
 151   3                                      if(byTemp == START_BYTE1)
 152   3                                      {
 153   4                                              stUsartCfg[0].byRecState = 1;
 154   4      //                                      byCount = 7;
 155   4                                              stUsartCfg[0].byRecCount = 6;
 156   4                                      }
 157   3                                      else
 158   3                                      {
 159   4                                              stUsartCfg[0].uiRecPosition = 0;
 160   4                                      }
 161   3                                      break;
 162   3                              case 1:                                                         
 163   3                                      if(--stUsartCfg[0].byRecCount == 0)
 164   3                                      {       //收完地址数据                                                                                                                                          
 165   4                                              stUsartCfg[0].byRecState = 2;
 166   4                                              stUsartCfg[0].byRecCount = 3;                                           
 167   4                                      }
 168   3                                      break;                          
 169   3                              case 2:                         
 170   3                                      stUsartCfg[0].byRecCount--;
 171   3                                      if(stUsartCfg[0].byRecCount == 1)
 172   3                                      {       
 173   4                                              stUsartCfg[0].uiRecLen = byTemp<<8; 
 174   4                                      }
 175   3                                      else if(stUsartCfg[0].byRecCount == 0)
 176   3                                      {       //接收完数据长度
 177   4                                              //stUsartCfg[0].uiRecLen += (byTemp << 8);                      //获取数据域长度值
 178   4                                              stUsartCfg[0].uiRecLen += byTemp;
 179   4                                              if(stUsartCfg[0].uiRecLen <= MAX_UART0_DATA_LEN)                                        
C51 COMPILER V8.08   USART                                                                 01/04/2011 17:09:45 PAGE 4   

 180   4                                              {       //数据长度符合要求
 181   5                                                      stUsartCfg[0].byRecState = 3;
 182   5                                                      stUsartCfg[0].uiRecLen += 2;                                                                                                            
 183   5                                              }
 184   4                                              else
 185   4                                              {
 186   5                                                      stUsartCfg[0].byRecState = 0;
 187   5                                                      stUsartCfg[0].uiRecPosition = 0;
 188   5                                              }                                                                               
 189   4                                      }
 190   3                                      break;                  
 191   3                              case 3:                         
 192   3                                      if(--stUsartCfg[0].uiRecLen == 0)
 193   3                                      {       //接收完所有数据
 194   4                                              if(END_BYTE == byTemp)
 195   4                                              {       //结束位正确
 196   5                                                      bUsart0RecFinish=1;
 197   5                                              }
 198   4                                              stUsartCfg[0].byRecState = 0;
 199   4                                              stUsartCfg[0].uiRecPosition = 0;                        
 200   4                                      }
 201   3                                      break;                  
 202   3                              default:
 203   3                                      stUsartCfg[0].byRecState = 0;
 204   3                                      stUsartCfg[0].uiRecPosition = 0;
 205   3                                      break;          
 206   3                      }
 207   2              }
 208   1              else if(TI==1)
 209   1              {
 210   2                      TI=0;
 211   2                      stUsartCfg[0].uiSndLen--;
 212   2                      stUsartCfg[0].uiSndPos++;
 213   2                      if(stUsartCfg[0].uiSndLen!=0)
 214   2                      {
 215   3                              SBUF = stUsartCfg[0].pbySndBuf[stUsartCfg[0].uiSndPos]; 
 216   3                              
 217   3                      }
 218   2              }
 219   1      } 
 220          
 221          #endif
 222          #if MAX_COM >= 2
              /**********************************************************
              *函数名称                       :UART1(void)    
              *函数描述               :串口2中断函数
              *输入参数               :
              *返回值                         :
              *全局变量                       :stUsartCfg
              *调用模块                       :
              ***********************************************************
              *创建人                 :尹运同
              *创建日期                       :2009-4-6
              ***********************************************************
              *修改人                         :
              *修改日期               :
              *注释                   :
              **********************************************************/
              #pragma disable
              void UART1(void) interrupt UART2_INTNO
              {
                      if(S2CON&S2RI)
C51 COMPILER V8.08   USART                                                                 01/04/2011 17:09:45 PAGE 5   

                      {
                              S2CON &= ~S2RI;
                      }
                      else if(S2CON&S2TI)
                      {
                              S2CON &= ~S2TI;
                      }
              }
              
              #endif
 252          /**********************************************************
 253          *函数名称                       :GetPskCrc      
 254          *函数描述               :计算数据桢累加校验和
 255          *输入参数               :pstDataFreq:待计算的数据桢指针
 256          *返回值                         :累加校验和
 257          *全局变量                       :stUsartCfg
 258          *调用模块                       :
 259          ***********************************************************
 260          *创建人                 :尹运同
 261          *创建日期                       :2009-4-6
 262          ***********************************************************
 263          *修改人                         :
 264          *修改日期               :
 265          *注释                   :
 266          **********************************************************/
 267          uint8 GetPskCrc(pSTUartFreq pstDataFreq)
 268          {
 269   1              uint8  *pbyData;
 270   1              uint16 uiLen;
 271   1              uint8  byCrc = 0;
 272   1              
 273   1      //      pbyData = &(pstDataFreq->byRecSecAddr);
 274   1              pbyData = &(pstDataFreq->bySndSecAddr);
 275   1              uiLen = pstDataFreq->uiLen + HEAD_SIZE;
 276   1              while(uiLen--)
 277   1              {
 278   2                      byCrc += *pbyData++;
 279   2              }       
 280   1              return(byCrc);
 281   1      }
 282          /**********************************************************
 283          *函数名称                       :CheckPsk       
 284          *函数描述               :检验数据包的正确型
 285          *输入参数               :pstDataFreq:待校验的数据桢指针
 286          *返回值                         :true:数据包正确,false:数据包有误
 287          *全局变量                       :
 288          *调用模块                       :
 289          ***********************************************************
 290          *创建人                 :尹运同
 291          *创建日期                       :2009-4-6
 292          ***********************************************************
 293          *修改人                         :
 294          *修改日期               :
 295          *注释                   :
 296          **********************************************************/
 297          uint8 CheckPsk(pSTUartFreq pstDataFreq)
 298          {
 299   1              uint8* pbyData;
 300   1              uint16 uiLen;
 301   1              uint8  byCrc = 0;
 302   1              
 303   1      //      pbyData = &(pstDataFreq->byRecSecAddr);
C51 COMPILER V8.08   USART                                                                 01/04/2011 17:09:45 PAGE 6   

 304   1              pbyData = &(pstDataFreq->bySndSecAddr);
 305   1              uiLen = pstDataFreq->uiLen + HEAD_SIZE;
 306   1              while(uiLen--)
 307   1              {
 308   2                      byCrc += *pbyData++;
 309   2              }
 310   1              if(byCrc != *pbyData)
 311   1              {
 312   2                      return(false);
 313   2              }
 314   1              return(true);   
 315   1      }
 316          /**********************************************************
 317          *函数名称                       :UsartSndEnter  
 318          *函数描述               :串口发送确认命令
 319          *输入参数               :byPort :串口号
 320                                              byOriginalCmd:原命令
 321                                              byData:数据
 322          *返回值                         :
 323          *全局变量                       :
 324          *调用模块                       :
 325          ***********************************************************
 326          *创建人                 :尹运同
 327          *创建日期                       :2009-4-6
 328          ***********************************************************
 329          *修改人                         :
 330          *修改日期               :
 331          *注释                   :
 332          **********************************************************/
 333          void UsartSndEnter(uint8 byPort,uint8 byOriginalCmd,uint8 byData)
 334          {
 335   1              pSTUartFreq pstDataFreq;
 336   1              while(stUsartCfg[byPort].uiSndLen!=0)   
 337   1              {//有数据正在发送中
 338   2                      OSTimeDly(20);          //延时100us
 339   2              }
 340   1      #if MAX_COM>=1
 341   1              if(byPort==0)           pstDataFreq = (pSTUartFreq)byUsart0SndBuf;
 342   1      #endif
 343   1      
 344   1      #if MAX_COM>=2
                      else if(byPort==1)              pstDataFreq = (pSTUartFreq)byUsart1SndBuf;
              #endif
 347   1              pstDataFreq->byStartByte1   =START_BYTE1;       
 348   1              pstDataFreq->byCmd                      =CMD_ENTER_PC;          //确认命令
 349   1              pstDataFreq->uiLen                      =0X02;
 350   1              pstDataFreq->byData[0]          =byOriginalCmd; //原命令        
 351   1              pstDataFreq->byData[1]          =byData;                //成功或失败
 352   1              pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
 353   1              pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE;
 354   1              
 355   1              stUsartCfg[byPort].uiSndLen     = pstDataFreq->uiLen+EXT_SIZE;
 356   1              stUsartCfg[byPort].uiSndPos = 0;        //从数据帧头部开始发送数据
 357   1      #if MAX_COM>=1
 358   1              if(byPort==0)
 359   1              {
 360   2                      TI=0;
 361   2                      SBUF=pstDataFreq->byStartByte1;
 362   2              }
 363   1      #endif
 364   1      
 365   1      #if MAX_COM>=2
C51 COMPILER V8.08   USART                                                                 01/04/2011 17:09:45 PAGE 7   

                      else if(byPort==1)
                      {
                              S2CON &= ~S2TI;
                              S2BUF=pstDataFreq->byStartByte1;                
                      }
              #endif
 372   1      
 373   1      }
 374          
 375          
 376          
 377          /**********************************************************
 378          *函数名称                       :UsartSndResult 
 379          *函数描述               :串口发送结果命令
 380          *输入参数               :byPort :串口号
 381                                              byOriginalCmd:原命令
 382                                              byData:数据
 383          *返回值                         :
 384          *全局变量                       :
 385          *调用模块                       :
 386          ***********************************************************
 387          *创建人                 :尹运同
 388          *创建日期                       :2009-4-6
 389          ***********************************************************
 390          *修改人                         :
 391          *修改日期               :
 392          *注释                   :
 393          **********************************************************/
 394          void UsartSndResult(uint8 byPort,uint8 byOriginalCmd,uint8 byData)
 395          {
 396   1              pSTUartFreq pstDataFreq;
 397   1              while(stUsartCfg[byPort].uiSndLen!=0)   
 398   1              {//有数据正在发送中
 399   2                      OSTimeDly(20);          //延时100us
 400   2              }
 401   1      #if MAX_COM>=1
 402   1              if(byPort==0)           pstDataFreq = (pSTUartFreq)byUsart0SndBuf;
 403   1      #endif
 404   1      
 405   1      #if MAX_COM>=2
                      else if(byPort==1)              pstDataFreq = (pSTUartFreq)byUsart1SndBuf;
              #endif
 408   1              pstDataFreq->byStartByte1   =START_BYTE1;       
 409   1              pstDataFreq->byCmd                      =CMD_RESULT_PC;         //确认命令
 410   1              pstDataFreq->uiLen                      =0X02;
 411   1              pstDataFreq->byData[0]          =byOriginalCmd; //原命令        
 412   1              pstDataFreq->byData[1]          =byData;                //成功或失败
 413   1              pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
 414   1              pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE;
 415   1              
 416   1              stUsartCfg[byPort].uiSndLen     = pstDataFreq->uiLen+EXT_SIZE;
 417   1              stUsartCfg[byPort].uiSndPos = 0;        //从数据帧头部开始发送数据
 418   1      
 419   1      #if MAX_COM>=1
 420   1              if(byPort==0)
 421   1              {
 422   2                      TI=0;
 423   2                      SBUF=pstDataFreq->byStartByte1;
 424   2              }
 425   1      #endif
 426   1      
 427   1      #if MAX_COM>=2
C51 COMPILER V8.08   USART                                                                 01/04/2011 17:09:45 PAGE 8   

                      else if(byPort==1)
                      {
                              S2CON &= ~S2TI;
                              S2BUF=pstDataFreq->byStartByte1;                
                      }
              #endif
 434   1      
 435   1      }
 436          /**********************************************************
 437          *函数名称                       :Usart0Manager  
 438          *函数描述               :串口0管理函数
 439          *输入参数               :
 440          *返回值                         :
 441          *全局变量                       :stUsartCfg,stLocalControl
 442          *调用模块                       :
 443          ***********************************************************
 444          *创建人                 :尹运同
 445          *创建日期                       :2009-4-6
 446          ***********************************************************
 447          *修改人                         :
 448          *修改日期               :
 449          *注释                   :
 450          **********************************************************/
 451          void Usart0RecDeal(void)
 452          {               
 453   1              pSTUartFreq pstDataFreq;
 454   1              bUsart0RecFinish=0;
 455   1              UsartSndEnter(0,0x80,true);
 456   1              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
 457   1              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
 458   1              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
 459   1              pstDataFreq = (pSTUartFreq)byUsart0RecBuf;
 460   1              if((pstDataFreq->byRecSecAddr == stLocalControl.stEepromCfgData.bySelfSecAddr)&&
 461   1                      (pstDataFreq->byRecRoomAddr == stLocalControl.stEepromCfgData.bySelfRoomAddr)&&
 462   1                      (pstDataFreq->byRecBedAddr == stLocalControl.stEepromCfgData.bySelfBedAddr))
 463   1              {//是本机地址
 464   2                      if(!CheckPsk(pstDataFreq))      
 465   2                      {//数据帧出错
 466   3                              stLocalControl.stBusDealFreq.byCmd = CMD_DATA_ERROR;                    
 467   3                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));   
 468   3                      }
 469   2                      else
 470   2                      {
 471   3                              stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER; 
 472   3                              stLocalControl.stBusDealFreq.byRecSecAddr = pstDataFreq->byCmd;
 473   3                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                   
 474   3                              switch(pstDataFreq->byCmd)
 475   3                              {
 476   4                                      case CMD_DISPLAY_DATA:
 477   4      
 478   4                                              break;
 479   4                                      default:
 480   4                                              break;
 481   4                              }
 482   3                      }
 483   2              }
 484   1              
 485   1      }
 486          
 487          
 488          /**********************************************************
 489          *函数名称                       :Usart1RecDeal  
C51 COMPILER V8.08   USART                                                                 01/04/2011 17:09:45 PAGE 9   

 490          *函数描述               :串口1协议处理
 491          *输入参数               :
 492          *返回值                         :
 493          *全局变量                       :
 494          *调用模块                       :
 495          ***********************************************************
 496          *创建人                 :尹运同
 497          *创建日期                       :2009-4-6
 498          ***********************************************************
 499          *修改人                         :
 500          *修改日期               :
 501          *注释                   :
 502          **********************************************************/
 503          void Usart1RecDeal(void)
 504          {
 505   1              bUsart1RecFinish=0;
 506   1      }
 507          
 508          
 509          /**********************************************************
 510          *函数名称                       :UsartManager
 511          *函数描述               :单总线0管理线程
 512          *输入参数               :
 513          *返回值                         :
 514          *全局变量                       :stLocalControl
 515          *调用模块                       :
 516          ***********************************************************
 517          *创建人                 :尹运同
 518          *创建日期                       :2009-4-7
 519          ***********************************************************
 520          *修改人                         :
 521          *修改日期               :
 522          *注释                   :
 523          **********************************************************/
 524          void UsartManager(void)  
 525          {       
 526   1              while(true)
 527   1              {
 528   2                      if(bUsart0RecFinish)                                                                    //串口0收到一帧数据
 529   2                      {       
 530   3                              OSQPost(byMainCmdQ,UART0_CMD);  
 531   3                      }
 532   2                      if(bUsart1RecFinish)                                                                    //串口1收到一帧数据
 533   2                      {
 534   3                              OSQPost(byMainCmdQ, UART1_CMD);                 
 535   3                      } 
 536   2                      OSWait(K_TMO, 1);
 537   2                                              
 538   2              }
 539   1      
 540   1      }
 541          
 542          
 543          /**********************************************************
 544          *函数名称                       :Usart0SndData
 545          *函数描述               :串口发送数据
 546          *输入参数                
 547          *返回值                         :
 548          *全局变量                       :
 549          *调用模块                       :
 550          ***********************************************************
 551          *创建人                 :尹运同
C51 COMPILER V8.08   USART                                                                 01/04/2011 17:09:45 PAGE 10  

 552          *创建日期                       :2009-4-6
 553          ***********************************************************
 554          *修改人                         :
 555          *修改日期               :
 556          *注释                   :
 557          **********************************************************/
 558          void Usart0SndData(pSTBusFreq pstBusFreq)
 559          {
 560   1              pSTUartFreq pstDataFreq;
 561   1              while(stUsartCfg[0].uiSndLen!=0)        
 562   1              {//有数据正在发送中
 563   2                      OSTimeDly(20);          //延时100us
 564   2              }
 565   1              pstDataFreq = (pSTUartFreq)byUsart0SndBuf;
 566   1      
 567   1              pstDataFreq->byStartByte1   =START_BYTE1;
 568   1          memcpy(&(pstDataFreq->bySndSecAddr),&(pstBusFreq->bySndSecAddr),3);
 569   1              memcpy(&(pstDataFreq->byRecSecAddr),&(pstBusFreq->byRecSecAddr),3);
 570   1              pstDataFreq->byCmd                      =pstBusFreq->byCmd;             
 571   1              pstDataFreq->uiLen                      =0X00;
 572   1              pstDataFreq->byData[pstDataFreq->uiLen] = GetPskCrc(pstDataFreq);
 573   1              pstDataFreq->byData[pstDataFreq->uiLen+1] = END_BYTE;
 574   1              
 575   1              stUsartCfg[0].uiSndLen  = pstDataFreq->uiLen+EXT_SIZE;
 576   1              stUsartCfg[0].uiSndPos = 0;     //从数据帧头部开始发送数据
 577   1              TI=0;
 578   1              SBUF=pstDataFreq->byStartByte1;
 579   1      }
 580          
 581          
 582          
 583          void Send_Data(uint8 *Databuf,uint8 l)
 584          { 
 585   1              pSTUartFreq pstDataFreq;
 586   1              while(stUsartCfg[0].uiSndLen!=0)        
 587   1              {//有数据正在发送中
 588   2                      OSTimeDly(20);          //延时100us
 589   2              }
 590   1              pstDataFreq = (pSTUartFreq)byUsart0SndBuf;
 591   1      
 592   1              memcpy(pstDataFreq,Databuf,l);
 593   1              stUsartCfg[0].uiSndLen  = l;
 594   1              stUsartCfg[0].uiSndPos = 0;     //从数据帧头部开始发送数据
 595   1              TI=0;
 596   1              SBUF=*Databuf;  
 597   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1567    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    205    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1      44
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
