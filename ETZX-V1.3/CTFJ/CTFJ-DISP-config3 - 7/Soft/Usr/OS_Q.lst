C51 COMPILER V9.00   OS_Q                                                                  03/11/2019 16:49:25 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE OS_Q
OBJECT MODULE PLACED IN .\OS_Q.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\OS\OS_Q.C LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\OS_Q.lst) TABS(2) OBJE
                    -CT(.\OS_Q.obj)

line level    source

   1          /*********************************************************************************************************
   2          **                                       Small RTOS(51)
   3          **                                   The Real-Time Kernel(For Keil c51)
   4          **
   5          **                                  (c) Copyright 2002-2003, chenmingji
   6          **                                           All Rights Reserved
   7          **
   8          **                                                  V1.20.0
   9          **
  10          **
  11          **--------------文件信息--------------------------------------------------------------------------------
  12          **文   件   名: OS_Q.C
  13          **创   建   人: 陈明计
  14          **最后修改日期:  2003年3月8日
  15          **描        述: Small RTOS(51)消息队列代码
  16          **
  17          **--------------历史版本信息----------------------------------------------------------------------------
  18          ** 创建人: 陈明计
  19          ** 版  本: V1.10~V1.12.0
  20          ** 日　期: 2002年6月20日~2002年12月30日
  21          ** 描　述: 完善消息队列代码
  22          **
  23          **------------------------------------------------------------------------------------------------------
  24          ** 修改人: 陈明计
  25          ** 版  本: V1.20.0
  26          ** 日　期: 2003年8月3日
  27          ** 描　述: 删除OSInt*函数，根据新版本要求改变一些代码
  28          **
  29          **--------------当前版本修订-----------------------------------------------------------------------------
  30          ** 修改人:
  31          ** 日　期:
  32          ** 描　述:
  33          **
  34          **------------------------------------------------------------------------------------------------------
  35          ********************************************************************************************************/
  36          
  37          #define  IN_OS_Q
  38          #include "config.h"
  39          
  40          #if EN_OS_Q > 0
  41          /*********************************************************************************************************
  42          ** 函数名称: OSQCreate
  43          ** 功能描述: 初始化消息队列
  44          ** 输　入: Buf:为队列分配的存储空间地址
  45          **         SizeOfBuf:为队列分配的存储空间大小
  46          ** 输　出: NOT_OK:参数错误
  47          **         OS_Q_OK:成功
  48          ** 全局变量: 无
  49          ** 调用模块: 无
  50          **
  51          ** 作　者: 陈明计
  52          ** 日　期: 2002年9月1日
  53          **-------------------------------------------------------------------------------------------------------
  54          ** 修改人: 陈明计
C51 COMPILER V9.00   OS_Q                                                                  03/11/2019 16:49:25 PAGE 2   

  55          ** 日　期: 2002年10月27日
  56          **-------------------------------------------------------------------------------------------------------
  57          ** 修改人:
  58          ** 日　期:
  59          **-------------------------------------------------------------------------------------------------------
  60          ********************************************************************************************************/
  61          
  62                  uint8 OSQCreate(uint8 OS_Q_MEM_SEL *Buf, uint8 SizeOfBuf)
  63          //Buf[0]:队列中字节数,Buf[1]:Buf总长度,Buf[2]:出对端,Buf[3](,Buf[4]):等待队列任务列表
  64          {
  65   1          OS_ENTER_CRITICAL();
  66   1      
  67   1          if ((SizeOfBuf >= 5) && (Buf != NULL))
  68   1          {
  69   2              Buf[0] = 0;                         /* 队列中消息数目           */
  70   2              Buf[1] = SizeOfBuf;                 /* 消息队列占用内存字节数    */
  71   2      #if OS_MAX_TASKS < 9
  72   2              Buf[2] = 4;                         /* 将要出队的消息所在位置    */
  73   2      #else
                      Buf[2] = 5;                         /* 将要出队的消息所在位置    */
              #endif
  76   2              Buf[3] = 0;                         /* 消息队列的等待任务列表    */
  77   2              Buf[4] = 0;                         /* 任务数大于等于8时为等待任务列表的一部分， */
  78   2                                                  /* 否则为消息缓冲区         */
  79   2      
  80   2              OS_EXIT_CRITICAL();
  81   2              return OS_Q_OK;
  82   2          }
  83   1          else
  84   1          {
  85   2              OS_EXIT_CRITICAL();
  86   2              return NOT_OK;
  87   2          }
  88   1      
  89   1      }
  90          
  91          /*********************************************************************************************************
  92          ** 函数名称: OSQPend
  93          ** 功能描述: 等待消息队列中的消息
  94          ** 输　入: Ret:返回的消息
  95          **         Buf:指向队列的指针
  96          **         Tick:等待时间
  97          ** 输　出: NOT_OK:参数错误
  98          **         OS_Q_OK:收到消息
  99          **         OS_Q_TMO:超时到
 100          **         OS_Q_NOT_OK:无消息
 101          ** 全局变量: 无
 102          ** 调用模块: OSRunningTaskID,OS_TaskSuspend,OSSched,OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
 103          **
 104          ** 作　者: 陈明计
 105          ** 日　期: 2002年9月1日
 106          **-------------------------------------------------------------------------------------------------------
 107          ** 修改人: 陈明计
 108          ** 日　期: 2002年10月9日
 109          **------------------------------------------------------------------------------------------------------
 110          ** 修改人: 陈明计
 111          ** 日　期: 2002年12月2日
 112          **-------------------------------------------------------------------------------------------------------
 113          ** 修改人:
 114          ** 日　期:
 115          **-------------------------------------------------------------------------------------------------------
 116          ********************************************************************************************************/
C51 COMPILER V9.00   OS_Q                                                                  03/11/2019 16:49:25 PAGE 3   

 117          #if EN_OS_Q_PENT > 0
 118          
 119                  uint8 OSQPend(uint8 data *Ret, uint8 OS_Q_MEM_SEL *Buf, uint8 Tick)
 120          {
 121   1      #ifdef __C51__
 122   1          uint8 data *cp;
 123   1      #endif
 124   1      
 125   1      #if EN_OS_Q_CHK > 0
                  if (Buf == NULL)
                  {
                      return NOT_OK;
                  }
              #endif
 131   1      
 132   1          OS_ENTER_CRITICAL();
 133   1      
 134   1          OSWaitTick[OSRunningTaskID()] = Tick;       /* 设置超时时间         */
 135   1                                                      /* 可以优化寄存器的使用  */
 136   1      
 137   1                      /* 使用堆栈是为了使函数具有重入性 */
 138   1      #ifdef __C51__
 139   1          SP++;
 140   1          *((uint8 data * data *)SP) = Ret;
 141   1      #endif
 142   1      
 143   1                      /* 把任务加入等待任务队列 */
 144   1      #if OS_MAX_TASKS < 9
 145   1          Buf[3] |= OSMapTbl[OSRunningTaskID()];
 146   1      #else
                  if (OSRunningTaskID() < 8)
                  {
                      Buf[3] |= OSMapTbl[OSRunningTaskID()];
                  }
                  else
                  {
                      Buf[4] |= OSMapTbl[OSRunningTaskID() & 0x07];
                  }
              #endif
 156   1      
 157   1          while (Buf[0] == 0)             /* 消息队列中是否有消息 */
 158   1          {
 159   2                      /* 无消息 */
 160   2      #ifdef __C51__
 161   2              SP = SP + sizeof(Buf);
 162   2              *((uint8 OS_Q_MEM_SEL * data *)(SP + 1 - sizeof(Buf))) = Buf;
 163   2      #endif
 164   2      
 165   2              OS_TaskSuspend(OSRunningTaskID());   /* 任务进入等待状态 */
 166   2              OSSched();                          /* 运行下一个任务 */
 167   2      
 168   2      #ifdef __C51__
 169   2              Buf = *((uint8 OS_Q_MEM_SEL * data *)(SP + 1 - sizeof(Buf)));
 170   2              SP = SP - sizeof(Buf);
 171   2      #endif
 172   2                      /* 任务再次运行，如果超时到，退出循环 */
 173   2              if (OSWaitTick[OSRunningTaskID()] == 0)
 174   2              {
 175   3                  break;
 176   3              }
 177   2          }
 178   1      
C51 COMPILER V9.00   OS_Q                                                                  03/11/2019 16:49:25 PAGE 4   

 179   1                      /* 将任务从等待队列中清除（可以删除） */
 180   1      #if OS_MAX_TASKS < 9
 181   1          Buf[3] &= ~OSMapTbl[OSRunningTaskID()];
 182   1      #else
                  if (OSRunningTaskID() < 8)
                  {
                      Buf[3] &= ~OSMapTbl[OSRunningTaskID()];
                  }
                  else
                  {
                      Buf[4] &= ~OSMapTbl[OSRunningTaskID() & 0x07];
                  }
              #endif
 192   1                      /* 判断消息队列中是否有消息 */
 193   1          if (Buf[0] > 0)
 194   1          {
 195   2                      /* 有，消息出队 */
 196   2              Buf[0]--;           /* 队列的消息数目减一 */
 197   2                      /* 指向下一个出队位置 */
 198   2              Buf[2]++;
 199   2              if (Buf[2] >= Buf[1] )
 200   2              {
 201   3      #if OS_MAX_TASKS < 9
 202   3                  Buf[2] = 4;
 203   3      #else
                          Buf[2] = 5;
              #endif
 206   3              }
 207   2      #ifdef __C51__
 208   2              cp = (uint8 data *)(*((uint8 data *)SP));
 209   2              SP--;
 210   2              *cp = Buf[Buf[2]];
 211   2      #else
                      *Ret = Buf[Buf[2]];
              #endif
 214   2              OS_EXIT_CRITICAL();
 215   2              return OS_Q_OK;
 216   2          }
 217   1          else
 218   1          {
 219   2                      /* 无，返回错误码 */
 220   2      #ifdef __C51__
 221   2              SP--;
 222   2      #endif
 223   2      
 224   2              OS_EXIT_CRITICAL();
 225   2              return OS_Q_TMO;
 226   2          }
 227   1      }
 228          #endif
 229          
 230          /*********************************************************************************************************
 231          ** 函数名称: OSQAccept
 232          ** 功能描述: 无等待从消息队列中取得消息
 233          ** 输　入: Ret:返回的消息
 234          **         Buf:指向队列的指针
 235          ** 输　出: NOT_OK:参数错误
 236          **         OS_Q_OK:收到消息
 237          **         OS_Q_TMO:超时到
 238          **         OS_Q_NOT_OK:无消息
 239          ** 全局变量: 无
 240          ** 调用模块: OS_TaskSuspend,OSSched,OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
C51 COMPILER V9.00   OS_Q                                                                  03/11/2019 16:49:25 PAGE 5   

 241          **
 242          ** 作　者: 陈明计
 243          ** 日　期: 2002年9月1日
 244          **-------------------------------------------------------------------------------------------------------
 245          ** 修改人:
 246          ** 日　期:
 247          **-------------------------------------------------------------------------------------------------------
 248          ********************************************************************************************************/
 249          #if EN_OS_Q_ACCEPT > 0
                      uint8 OSQAccept(uint8 data *Ret, uint8 OS_Q_MEM_SEL *Buf)
              {
              #if EN_OS_Q_CHK > 0
                  if (Buf == NULL)
                  {
                      return NOT_OK;
                  }
              #endif
              
                  OS_ENTER_CRITICAL();
              
                              /* 判断消息队列中是否有消息 */
                  if (*Buf != 0)
                  {
                              /* 有，消息出队 */
                      Buf[0]--;
                      Buf[2]++;
                      if (Buf[2] >= Buf[1])
                      {
              #if OS_MAX_TASKS < 9
                          Buf[2] = 4;
              #else
                          Buf[2] = 5;
              #endif
                      }
                      *Ret = Buf[Buf[2]];
                      OS_EXIT_CRITICAL();
                      return OS_Q_OK;
                  }
                  else
                  {
                              /* 无，返回错误码 */
                      OS_EXIT_CRITICAL();
                      return OS_Q_NOT_OK;
                  }
              }
              #endif
 287          
 288          
 289          /*********************************************************************************************************
 290          ** 函数名称: OSQPost
 291          ** 功能描述: 中断中FIFO方式发送消息
 292          ** 输　入: Buf:指向队列的指针
 293          **         Data:消息数据
 294          ** 输　出: OS_Q_FULL:队列满
 295          **         OS_Q_OK:发送成功
 296          ** 全局变量: 无
 297          ** 调用模块: OSTaskResume,OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
 298          **
 299          ** 作　者: 陈明计
 300          ** 日　期: 2003年8月3日
 301          **-------------------------------------------------------------------------------------------------------
 302          ** 修改人:
C51 COMPILER V9.00   OS_Q                                                                  03/11/2019 16:49:25 PAGE 6   

 303          ** 日　期:
 304          **-------------------------------------------------------------------------------------------------------
 305          ********************************************************************************************************/
 306          #if EN_OS_Q_POST > 0
 307                  uint8 OSQPost(uint8 OS_Q_MEM_SEL *Buf, uint8 Data)
 308          {
 309   1          uint8 temp,i;
 310   1      
 311   1      #if EN_OS_Q_CHK > 0
                  if (Buf == NULL)
                  {
                      return NOT_OK;
                  }
              #endif
 317   1      
 318   1          OS_ENTER_CRITICAL();
 319   1      
 320   1                      /* 队列是否已满 */
 321   1      #if OS_MAX_TASKS < 9
 322   1          if (Buf[0] < (Buf[1]-4))
 323   1      #else
                  if (Buf[0] < (Buf[1]-5))
              #endif
 326   1          {
 327   2                      /* 使用堆栈是为了使函数具有重入性 */
 328   2      #ifdef __C51__
 329   2              SP++;
 330   2              *((uint8 data *)SP) = Data;
 331   2      #endif
 332   2                      /* 计算新入队消息存储位置 */
 333   2              temp = Buf[2] + Buf[0] + 1;
 334   2              if (temp >= Buf[1])
 335   2              {
 336   3      #if OS_MAX_TASKS < 9
 337   3                  temp = temp - Buf[1]+4;
 338   3      #else
                          temp = temp - Buf[1]+5;
              #endif
 341   3              }
 342   2                      /* 存储消息 */
 343   2      #ifdef __C51__
 344   2              Buf[temp] = *((uint8 data *)SP);
 345   2              SP--;
 346   2      #else
                      Buf[temp] = Data;
              #endif
 349   2      
 350   2              Buf[0]++;               /* 消息数目加一 */
 351   2                      /* 判断消息入队前消息队列是否为空 */
 352   2              if (Buf[0] == 1)
 353   2              {
 354   3                      /* 为空，可能有任务等待消息，查找之 */
 355   3                  temp = Buf[3];
 356   3      #if OS_MAX_TASKS < 9
 357   3                  for (i = 0; i < OS_MAX_TASKS; i++)
 358   3                  {
 359   4                      if ((temp & 0x01) != 0)
 360   4                      {
 361   5                          break;
 362   5                      }
 363   4                      temp = temp >> 1;
 364   4                  }
C51 COMPILER V9.00   OS_Q                                                                  03/11/2019 16:49:25 PAGE 7   

 365   3                  if (i < OS_MAX_TASKS )
 366   3                  {
 367   4                      /* 查到，使其中优先级最高的任务进入就绪状态，并将其从等待队列中清除 */
 368   4                      Buf[3] &= ~OSMapTbl[i];
 369   4                      OSTaskResume(i);
 370   4                  }
 371   3      #else
                          for (i = 0; i < 8; i++)
                          {
                              if ((temp & 0x01) != 0)
                              {
                                  break;
                              }
                              temp = temp >> 1;
                          }
                          if (i >= 8 )
                          {
                              temp = Buf[4];
                              for (; i < OS_MAX_TASKS; i++)
                              {
                                  if ((temp & 0x01) != 0)
                                  {
                                      break;
                                  }
                                  temp = temp >> 1;
                              }
                          }
                          if (i < OS_MAX_TASKS )
                          {
                              /* 查到，使其中优先级最高的任务进入就绪状态，并将其从等待队列中清除 */
                              if (i < 8)
                              {
                                  Buf[3] &= ~OSMapTbl[i];
                              }
                              else
                              {
                                  Buf[4] &= ~OSMapTbl[i & 0x07];
                              }
                              OSTaskResume(i);
                          }
              #endif
 406   3              }
 407   2              OS_EXIT_CRITICAL();
 408   2              return OS_Q_OK;
 409   2          }
 410   1          else
 411   1          {
 412   2              OS_EXIT_CRITICAL();
 413   2              return OS_Q_FULL;
 414   2          }
 415   1      }
 416          #endif
 417          
 418          /*********************************************************************************************************
 419          ** 函数名称: OSQPostFront
 420          ** 功能描述: 中断中LIFO方式发送消息
 421          ** 输　入: Buf:指向队列的指针
 422          **         Data:消息数据
 423          ** 输　出: OS_Q_FULL:队列满
 424          **         OS_Q_OK:发送成功
 425          ** 全局变量: 无
 426          ** 调用模块: OSTaskResume,OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
C51 COMPILER V9.00   OS_Q                                                                  03/11/2019 16:49:25 PAGE 8   

 427          **
 428          ** 作　者: 陈明计
 429          ** 日　期: 2003年8月3日
 430          **-------------------------------------------------------------------------------------------------------
 431          ** 修改人:
 432          ** 日　期:
 433          **-------------------------------------------------------------------------------------------------------
 434          ********************************************************************************************************/
 435          #if EN_OS_Q_POST_FRONT > 0
                      uint8 OSQPostFront(uint8 OS_Q_MEM_SEL *Buf, uint8 Data)
              {
                  uint8 temp,i;
              
              #if EN_OS_Q_CHK > 0
                  if (Buf == NULL)
                  {
                      return NOT_OK;
                  }
              #endif
              
                  OS_ENTER_CRITICAL();
              
                              /* 队列是否已满 */
              #if OS_MAX_TASKS < 9
                  if (Buf[0] < (Buf[1]-4))
              #else
                  if (Buf[0] < (Buf[1]-5))
              #endif
                  {
                              /* 存储消息 */
                      Buf[Buf[2]] = Data;
                      Buf[0]++;           /* 消息数目增加一 */
                              /* 指向新的将要出队的消息 */
                      Buf[2]--;
              #if OS_MAX_TASKS < 9
                      if (Buf[2] < 4)
              #else
                      if (Buf[2] < 5)
              #endif
                      {
                          Buf[2] = Buf[1]-1;
                      }
                      
                              /* 判断消息入队前消息队列是否为空 */
                      if (Buf[0] == 1)
                      {
                              /* 为空，可能有任务等待消息，查找之 */
                          temp = Buf[3];
              #if OS_MAX_TASKS < 9
                          for (i = 0; i < OS_MAX_TASKS; i++)
                          {
                              if ((temp & 0x01) != 0)
                              {
                                  break;
                              }
                              temp = temp >> 1;
                          }
                          if (i < OS_MAX_TASKS )
                          {
                              /* 查到，使其中优先级最高的任务进入就绪状态，并将其从等待队列中清除 */
                              Buf[3] &= ~OSMapTbl[i];
                              OSTaskResume(i);
C51 COMPILER V9.00   OS_Q                                                                  03/11/2019 16:49:25 PAGE 9   

                          }
              #else
                          for (i = 0; i < 8; i++)
                          {
                              if ((temp & 0x01) != 0)
                              {
                                  break;
                              }
                              temp = temp >> 1;
                          }
                          if (i >= 8 )
                          {
                              temp = Buf[4];
                              for (; i < OS_MAX_TASKS; i++)
                              {
                                  if ((temp & 0x01) != 0)
                                  {
                                      break;
                                  }
                                  temp = temp >> 1;
                              }
                          }
                          if (i < OS_MAX_TASKS )
                          {
                              /* 查到，使其中优先级最高的任务进入就绪状态，并将其从等待队列中清除 */
                              if (i < 8)
                              {
                                  Buf[3] &= ~OSMapTbl[i];
                              }
                              else
                              {
                                  Buf[4] &= ~OSMapTbl[i & 0x07];
                              }
                              OSTaskResume(i);
                          }
              #endif
                      }
                      OS_EXIT_CRITICAL();
                      return OS_Q_OK;
                  }
                  else
                  {
                      OS_EXIT_CRITICAL();
                      return OS_Q_FULL;
                  }
              }
              #endif
 536          
 537          /*********************************************************************************************************
 538          ** 函数名称: OSQNMsgs
 539          ** 功能描述: 取得消息队列中消息数
 540          ** 输　入: Buf:指向队列的指针
 541          ** 输　出: 消息数
 542          ** 全局变量: 无
 543          ** 调用模块: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
 544          **
 545          ** 作　者: 陈明计
 546          ** 日　期: 2002年9月1日
 547          **-------------------------------------------------------------------------------------------------------
 548          ** 修改人:
 549          ** 日　期:
 550          **-------------------------------------------------------------------------------------------------------
C51 COMPILER V9.00   OS_Q                                                                  03/11/2019 16:49:25 PAGE 10  

 551          ********************************************************************************************************/
 552          #if EN_OS_Q_NMsgs > 0
                      uint8 OSQNMsgs(uint8 OS_Q_MEM_SEL *Buf)
              {
                  uint8 temp;
              
              #if EN_OS_Q_CHK > 0
                  if (Buf == NULL)
                  {
                      return 0;
                  }
              #endif
              
                  OS_ENTER_CRITICAL();
                  temp = Buf[0];
                  OS_EXIT_CRITICAL();
                  return temp;
              }
              #endif
 570          
 571          /*********************************************************************************************************
 572          ** 函数名称: OSQSize
 573          ** 功能描述: 取得消息队列总容量
 574          ** 输　入: Buf:指向队列的指针
 575          ** 输　出: 消息队列总容量
 576          ** 全局变量: 无
 577          ** 调用模块: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
 578          **
 579          ** 作　者: 陈明计
 580          ** 日　期: 2002年9月1日
 581          **-------------------------------------------------------------------------------------------------------
 582          ** 修改人:
 583          ** 日　期:
 584          **-------------------------------------------------------------------------------------------------------
 585          ********************************************************************************************************/
 586          #if EN_OS_Q_SIZE > 0
                      uint8 OSQSize(uint8 OS_Q_MEM_SEL *Buf)
              {
                  uint8 temp;
              
              #if EN_OS_Q_CHK > 0
                  if (Buf == NULL)
                  {
                      return 0;
                  }
              #endif
              
                  OS_ENTER_CRITICAL();
              #if OS_MAX_TASKS < 9
                  temp = Buf[1] - 4;
              #else
                  temp = Buf[1] - 5;
              #endif
                  OS_EXIT_CRITICAL();
                  return temp;
              }
              #endif
 608          
 609          /*********************************************************************************************************
 610          ** 函数名称: OSQFlush
 611          ** 功能描述: 清空队列
 612          ** 输　入: Buf:指向队列的指针
C51 COMPILER V9.00   OS_Q                                                                  03/11/2019 16:49:25 PAGE 11  

 613          ** 输　出: 无
 614          ** 全局变量: 无
 615          ** 调用模块: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
 616          **
 617          ** 作　者: 陈明计
 618          ** 日　期: 2002年9月1日
 619          **-------------------------------------------------------------------------------------------------------
 620          ** 修改人: 陈明计
 621          ** 日　期: 2002年10月26日
 622          **-------------------------------------------------------------------------------------------------------
 623          ** 修改人:
 624          ** 日　期:
 625          **-------------------------------------------------------------------------------------------------------
 626          ********************************************************************************************************/
 627          #if EN_OS_Q_FLUSH > 0
                      void OSQFlush (uint8 OS_Q_MEM_SEL *Buf)
              {
              #if EN_OS_Q_CHK > 0
                  if (Buf == NULL)
                  {
                      return;
                  }
              #endif
              
                  Buf[0] = 0;
              #if OS_MAX_TASKS < 9
                  Buf[2] = 4;
              #else
                  Buf[2] = 5;
              #endif
              }
              #endif
 645          
 646          #endif
 647          /*********************************************************************************************************
 648          **                            End Of File
 649          ********************************************************************************************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    341    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
