C51 COMPILER V9.00   CC1101                                                                02/20/2017 11:10:08 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE CC1101
OBJECT MODULE PLACED IN CC1101.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE CC1101.c COMPACT BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "cc1101.h"
   2          #define LENGTH 32
   3          // RF_SETTINGS is a data structure which contains all relevant CCxxx0 registers
   4          INT8U PaTabel[8] = {0xc0 ,0xc0 ,0xc0 ,0xc0 ,0xc0 ,0xc0 ,0xc0 ,0xc0};  //0dBm
   5          typedef struct S_RF_SETTINGS
   6          {
   7                  INT8U FSCTRL2;          //自已加的
   8              INT8U FSCTRL1;   // Frequency synthesizer control.
   9              INT8U FSCTRL0;   // Frequency synthesizer control.
  10              INT8U FREQ2;     // Frequency control word, high INT8U.
  11              INT8U FREQ1;     // Frequency control word, middle INT8U.
  12              INT8U FREQ0;     // Frequency control word, low INT8U.
  13              INT8U MDMCFG4;   // Modem configuration.
  14              INT8U MDMCFG3;   // Modem configuration.
  15              INT8U MDMCFG2;   // Modem configuration.
  16              INT8U MDMCFG1;   // Modem configuration.
  17              INT8U MDMCFG0;   // Modem configuration.
  18              INT8U CHANNR;    // Channel number.
  19              INT8U DEVIATN;   // Modem deviation setting (when FSK modulation is enabled).
  20              INT8U FREND1;    // Front end RX configuration.
  21              INT8U FREND0;    // Front end RX configuration.
  22              INT8U MCSM0;     // Main Radio Control State Machine configuration.
  23              INT8U FOCCFG;    // Frequency Offset Compensation Configuration.
  24              INT8U BSCFG;     // Bit synchronization Configuration.
  25              INT8U AGCCTRL2;  // AGC control.
  26                  INT8U AGCCTRL1;  // AGC control.
  27              INT8U AGCCTRL0;  // AGC control.
  28              INT8U FSCAL3;    // Frequency synthesizer calibration.
  29              INT8U FSCAL2;    // Frequency synthesizer calibration.
  30                  INT8U FSCAL1;    // Frequency synthesizer calibration.
  31              INT8U FSCAL0;    // Frequency synthesizer calibration.
  32              INT8U FSTEST;    // Frequency synthesizer calibration control
  33              INT8U TEST2;     // Various test settings.
  34              INT8U TEST1;     // Various test settings.
  35              INT8U TEST0;     // Various test settings.
  36              INT8U IOCFG2;    // GDO2 output pin configuration
  37              INT8U IOCFG0;    // GDO0 output pin configuration
  38              INT8U PKTCTRL1;  // Packet automation control.
  39              INT8U PKTCTRL0;  // Packet automation control.
  40              INT8U ADDR;      // Device address.
  41              INT8U PKTLEN;    // Packet length.
  42          /*
  43                  INT8U MCSM2;       // 主通信控制状态机配置*********** 
  44              INT8U WOREVT1;   // 高字节时间0暂停***************** // High uchar Event 0 timeout
  45              INT8U WOREVT0;   // 低字节时间0暂停***************** // Low uchar Event 0 timeout
  46              INT8U WORCTRL;   // 电磁波激活控制****************** // Wake On Radio control
  47          */
  48          } RF_SETTINGS;
  49          
  50          /////////////////////////////////////////////////////////////////
  51          const RF_SETTINGS rfSettings = 
  52          {
  53                  0x00,
  54              0x08,   // FSCTRL1   Frequency synthesizer control.
  55              0x00,   // FSCTRL0   Frequency synthesizer control.
C51 COMPILER V9.00   CC1101                                                                02/20/2017 11:10:08 PAGE 2   

  56              0x10,   // FREQ2     Frequency control word, high byte.
  57              0xA7,   // FREQ1     Frequency control word, middle byte.
  58              0x62,   // FREQ0     Frequency control word, low byte.
  59          
  60              0x58,   // MDMCFG4   Modem configuration.
  61              0x43,   // MDMCFG3   Modem configuration.
  62              0x03,   // MDMCFG2   Modem configuration.
  63              0x22,   // MDMCFG1   Modem configuration.
  64              0xF8,   // MDMCFG0   Modem configuration.
  65          
  66          /*      //
  67              0xc8,   // MDMCFG4   Modem configuration.wor,,
  68              0x93,   // MDMCFG3   Modem configuration.wor,,
  69              0x03,   // MDMCFG2   Modem configuration.wor,,
  70              0xf2,   // MDMCFG1   Modem configuration.wor,,
  71              0xF8,   // MDMCFG0   Modem configuration.wor,,
  72          */
  73              0x00,   // CHANNR    Channel number.
  74              0x47,   // DEVIATN   Modem deviation setting (when FSK modulation is enabled).
  75              0x56,   // FREND1    Front end RX configuration.
  76              0x10,   // FREND0    Front end RX configuration.
  77              0x18,   // MCSM0     Main Radio Control State Machine configuration.
  78              0x1D,   // FOCCFG    Frequency Offset Compensation Configuration.
  79              0x1C,   // BSCFG     Bit synchronization Configuration.
  80              0x43,   // AGCCTRL2  AGC control.
  81              0x40,   // AGCCTRL1  AGC control.
  82              0x91,   // AGCCTRL0  AGC control.
  83          
  84              0xEA,   // FSCAL3    Frequency synthesizer calibration.
  85              0x2A,   // FSCAL2    Frequency synthesizer calibration.
  86              0x00,   // FSCAL1    Frequency synthesizer calibration.
  87              0x11,   // FSCAL0    Frequency synthesizer calibration.
  88              0x59,   // FSTEST    Frequency synthesizer calibration.
  89              0x81,   // TEST2     Various test settings.
  90              0x35,   // TEST1     Various test settings.
  91              0x09,   // TEST0     Various test settings.
  92              0x0E,   // IOCFG2    GDO2 output pin configuration.
  93              0x06,   // IOCFG0D   GDO0 output pin configuration. Refer to SmartRF?Studio User Manual for detailed p
             -seudo register explanation.
  94          
  95             0x04,   // PKTCTRL1  Packet automation control.
  96            //  0x4b,   // PKTCTRL1  Packet automation control  ,,,,wor
  97              0x05,   // PKTCTRL0  Packet automation control.
  98              0x00,   // ADDR      Device address.
  99              LENGTH,   // PKTLEN    Packet length.
 100          ///////////////////////////////////////////////////////////////////////////////////////////
 101          //      0x18,  //MCSM2     // 主通信控制状态机配置************/ 
 102           //   0x01, // WOREVT1   // 高字节时间0暂停*****************/ High uchar Event 0 timeout
 103           //   0xF1, // WOREVT0   // 低字节时间0暂停*****************/ Low uchar Event 0 timeout
 104           //   0x38, // WORCTRL   // 电磁波激活控制******************/ Wake On Radio control
 105          /*
 106              0x09,  //MCSM2     // 主通信控制状态机配置************ / 
 107              0x02, // WOREVT1   // 高字节时间0暂停***************** / High uchar Event 0 timeout
 108              0x08, // WOREVT0   // 低字节时间0暂停***************** / Low uchar Event 0 timeout
 109              0x38, // WORCTRL     // 电磁波激活控制****************** / Wake On Radio control
 110                  */
 111          };
 112          
 113          //*****************************************************************************************
 114          //函数名：delay(unsigned int s)
 115          //输入：时间
 116          //输出：无
C51 COMPILER V9.00   CC1101                                                                02/20/2017 11:10:08 PAGE 3   

 117          //功能描述：普通廷时,内部用
 118          //*****************************************************************************************             
 119          void delay(unsigned int s)
 120          {
 121   1              unsigned int i;
 122   1              for(i=0; i<s; i++);
 123   1              for(i=0; i<s; i++);
 124   1      }
 125          
 126          
 127          void halWait(INT16U timeout) {
 128   1          do {
 129   2              _nop_();
 130   2                      _nop_();
 131   2                      _nop_();
 132   2                      _nop_();
 133   2                      _nop_();
 134   2                      _nop_();
 135   2                      _nop_();
 136   2                      _nop_();
 137   2                      _nop_();
 138   2                      _nop_();
 139   2                      _nop_();
 140   2                      _nop_();
 141   2                      _nop_();
 142   2                      _nop_();
 143   2                      _nop_(); 
 144   2          } while (--timeout);
 145   1      }
 146          
 147          
 148          void SpiInit(void)
 149          {
 150   1              CSN=0;
 151   1              SCK=0;
 152   1              CSN=1;
 153   1      }
 154          
 155          /*****************************************************************************************
 156          //函数名：CpuInit()
 157          //输入：无
 158          //输出：无
 159          //功能描述：SPI初始化程序
 160          /*****************************************************************************************/
 161          void CpuInit(void)
 162          {
 163   1              SpiInit();
 164   1              delay(5000);
 165   1              POWER_UP_RESET_CC1100();
 166   1              halRfWriteRfSettings();
 167   1              halSpiWriteBurstReg(CCxxx0_PATABLE, PaTabel, 8);
 168   1      }
 169                  
 170          
 171          //*****************************************************************************************
 172          //函数名：SpisendByte(INT8U dat)
 173          //输入：发送的数据
 174          //输出：无
 175          //功能描述：SPI发送一个字节
 176          //*****************************************************************************************
 177          INT8U SpiTxRxByte(INT8U dat)
 178          {
C51 COMPILER V9.00   CC1101                                                                02/20/2017 11:10:08 PAGE 4   

 179   1              INT8U i,temp;
 180   1              temp = 0;
 181   1              
 182   1              SCK = 0;
 183   1              for(i=0; i<8; i++)
 184   1              {
 185   2                      if(dat & 0x80)
 186   2                      {
 187   3                              MOSI = 1;
 188   3                      }
 189   2                      else MOSI = 0;
 190   2                      dat <<= 1;
 191   2      
 192   2                      SCK = 1; 
 193   2                      _nop_();
 194   2                      _nop_();
 195   2      
 196   2                      temp <<= 1;
 197   2                      if(MISO)temp++; 
 198   2                      SCK = 0;
 199   2                      _nop_();
 200   2                      _nop_();        
 201   2              }
 202   1              return temp;
 203   1      }
 204          
 205          //*****************************************************************************************
 206          //函数名：void RESET_CC1100(void)
 207          //输入：无
 208          //输出：无
 209          //功能描述：复位CC1100
 210          //*****************************************************************************************
 211          void RESET_CC1100(void) 
 212          {
 213   1              CSN = 0; 
 214   1              while (MISO);
 215   1          SpiTxRxByte(CCxxx0_SRES);           //写入复位命令
 216   1              while (MISO); 
 217   1          CSN = 1; 
 218   1      }
 219          
 220          //*****************************************************************************************
 221          //函数名：void POWER_UP_RESET_CC1100(void) 
 222          //输入：无
 223          //输出：无
 224          //功能描述：上电复位CC1100
 225          //*****************************************************************************************
 226          void POWER_UP_RESET_CC1100(void) 
 227          {
 228   1              CSN = 1; 
 229   1              halWait(1); 
 230   1              CSN = 0; 
 231   1              halWait(1); 
 232   1              CSN = 1; 
 233   1              halWait(41); 
 234   1              RESET_CC1100();                 //复位CC1100
 235   1      }
 236          
 237          //*****************************************************************************************
 238          //函数名：void halSpiWriteReg(INT8U addr, INT8U value)
 239          //输入：地址和配置字
 240          //输出：无
C51 COMPILER V9.00   CC1101                                                                02/20/2017 11:10:08 PAGE 5   

 241          //功能描述：SPI写寄存器
 242          //*****************************************************************************************
 243          void halSpiWriteReg(INT8U addr, INT8U value) 
 244          {
 245   1          CSN = 0;
 246   1          while (MISO);
 247   1          SpiTxRxByte(addr);          //写地址
 248   1          SpiTxRxByte(value);         //写入配置
 249   1          CSN = 1;
 250   1      }
 251          
 252          //*****************************************************************************************
 253          //函数名：void halSpiWriteBurstReg(INT8U addr, INT8U *buffer, INT8U count)
 254          //输入：地址，写入缓冲区，写入个数
 255          //输出：无
 256          //功能描述：SPI连续写配置寄存器
 257          //*****************************************************************************************
 258          void halSpiWriteBurstReg(INT8U addr, INT8U *buffer, INT8U count) 
 259          {
 260   1          INT8U i, temp;
 261   1              temp = addr | WRITE_BURST;
 262   1          CSN = 0;
 263   1          while (MISO);
 264   1          SpiTxRxByte(temp);
 265   1          for (i = 0; i < count; i++)
 266   1              {
 267   2              SpiTxRxByte(buffer[i]);
 268   2          }
 269   1          CSN = 1;
 270   1      }
 271          
 272          //*****************************************************************************************
 273          //函数名：void halSpiStrobe(INT8U strobe)
 274          //输入：命令
 275          //输出：无
 276          //功能描述：SPI写命令
 277          //*****************************************************************************************
 278          void halSpiStrobe(INT8U strobe) 
 279          {
 280   1          CSN = 0;
 281   1          while (MISO);
 282   1          SpiTxRxByte(strobe);                //写入命令
 283   1          CSN = 1;
 284   1      }
 285          
 286          
 287          
 288          
 289          
 290          //*****************************************************************************************
 291          //函数名：INT8U halSpiReadReg(INT8U addr)
 292          //输入：地址
 293          //输出：该寄存器的配置字
 294          //功能描述：SPI读寄存器
 295          //*****************************************************************************************
 296          INT8U halSpiReadReg(INT8U addr) 
 297          {
 298   1              INT8U temp, value;
 299   1          temp = addr|READ_SINGLE;//读寄存器命令
 300   1              CSN = 0;
 301   1              while (MISO);
 302   1              SpiTxRxByte(temp);
C51 COMPILER V9.00   CC1101                                                                02/20/2017 11:10:08 PAGE 6   

 303   1              value = SpiTxRxByte(0);
 304   1              CSN = 1;
 305   1              return value;
 306   1      }
 307          
 308          
 309          //*****************************************************************************************
 310          //函数名：void halSpiReadBurstReg(INT8U addr, INT8U *buffer, INT8U count)
 311          //输入：地址，读出数据后暂存的缓冲区，读出配置个数
 312          //输出：无
 313          //功能描述：SPI连续写配置寄存器
 314          //*****************************************************************************************
 315          void halSpiReadBurstReg(INT8U addr, INT8U *buffer, INT8U count) 
 316          {
 317   1          INT8U i,temp;
 318   1              temp = addr | READ_BURST;               //写入要读的配置寄存器地址和读命令
 319   1          CSN = 0;
 320   1          while (MISO);
 321   1              SpiTxRxByte(temp);   
 322   1          for (i = 0; i < count; i++) 
 323   1              {
 324   2              buffer[i] = SpiTxRxByte(0);
 325   2          }
 326   1          CSN = 1;
 327   1      }
 328          
 329          
 330          //*****************************************************************************************
 331          //函数名：INT8U halSpiReadReg(INT8U addr)
 332          //输入：地址
 333          //输出：该状态寄存器当前值
 334          //功能描述：SPI读状态寄存器
 335          //*****************************************************************************************
 336          INT8U halSpiReadStatus(INT8U addr) 
 337          {
 338   1          INT8U value,temp;
 339   1              temp = addr | READ_BURST;               //写入要读的状态寄存器的地址同时写入读命令
 340   1          CSN = 0;
 341   1          while (MISO);
 342   1          SpiTxRxByte(temp);
 343   1              value = SpiTxRxByte(0);
 344   1              CSN = 1;
 345   1              return value;
 346   1      }
 347          //*****************************************************************************************
 348          //函数名：void halRfWriteRfSettings(RF_SETTINGS *pRfSettings)
 349          //输入：无
 350          //输出：无
 351          //功能描述：配置CC1100的寄存器
 352          //*****************************************************************************************
 353          void halRfWriteRfSettings(void) 
 354          {
 355   1      
 356   1              halSpiWriteReg(CCxxx0_FSCTRL0,  rfSettings.FSCTRL2);//自已加的
 357   1          // Write register settings
 358   1          halSpiWriteReg(CCxxx0_FSCTRL1,  rfSettings.FSCTRL1);
 359   1          halSpiWriteReg(CCxxx0_FSCTRL0,  rfSettings.FSCTRL0);
 360   1          halSpiWriteReg(CCxxx0_FREQ2,    rfSettings.FREQ2);
 361   1          halSpiWriteReg(CCxxx0_FREQ1,    rfSettings.FREQ1);
 362   1          halSpiWriteReg(CCxxx0_FREQ0,    rfSettings.FREQ0);
 363   1          halSpiWriteReg(CCxxx0_MDMCFG4,  rfSettings.MDMCFG4);
 364   1          halSpiWriteReg(CCxxx0_MDMCFG3,  rfSettings.MDMCFG3);
C51 COMPILER V9.00   CC1101                                                                02/20/2017 11:10:08 PAGE 7   

 365   1          halSpiWriteReg(CCxxx0_MDMCFG2,  rfSettings.MDMCFG2);
 366   1          halSpiWriteReg(CCxxx0_MDMCFG1,  rfSettings.MDMCFG1);
 367   1          halSpiWriteReg(CCxxx0_MDMCFG0,  rfSettings.MDMCFG0);
 368   1          halSpiWriteReg(CCxxx0_CHANNR,   rfSettings.CHANNR);
 369   1          halSpiWriteReg(CCxxx0_DEVIATN,  rfSettings.DEVIATN);
 370   1          halSpiWriteReg(CCxxx0_FREND1,   rfSettings.FREND1);
 371   1          halSpiWriteReg(CCxxx0_FREND0,   rfSettings.FREND0);
 372   1          halSpiWriteReg(CCxxx0_MCSM0 ,   rfSettings.MCSM0 );
 373   1          halSpiWriteReg(CCxxx0_FOCCFG,   rfSettings.FOCCFG);
 374   1          halSpiWriteReg(CCxxx0_BSCFG,    rfSettings.BSCFG);
 375   1          halSpiWriteReg(CCxxx0_AGCCTRL2, rfSettings.AGCCTRL2);
 376   1              halSpiWriteReg(CCxxx0_AGCCTRL1, rfSettings.AGCCTRL1);
 377   1          halSpiWriteReg(CCxxx0_AGCCTRL0, rfSettings.AGCCTRL0);
 378   1          halSpiWriteReg(CCxxx0_FSCAL3,   rfSettings.FSCAL3);
 379   1              halSpiWriteReg(CCxxx0_FSCAL2,   rfSettings.FSCAL2);
 380   1              halSpiWriteReg(CCxxx0_FSCAL1,   rfSettings.FSCAL1);
 381   1          halSpiWriteReg(CCxxx0_FSCAL0,   rfSettings.FSCAL0);
 382   1          halSpiWriteReg(CCxxx0_FSTEST,   rfSettings.FSTEST);
 383   1          halSpiWriteReg(CCxxx0_TEST2,    rfSettings.TEST2);
 384   1          halSpiWriteReg(CCxxx0_TEST1,    rfSettings.TEST1);
 385   1          halSpiWriteReg(CCxxx0_TEST0,    rfSettings.TEST0);
 386   1          halSpiWriteReg(CCxxx0_IOCFG2,   rfSettings.IOCFG2);
 387   1          halSpiWriteReg(CCxxx0_IOCFG0,   rfSettings.IOCFG0);    
 388   1          halSpiWriteReg(CCxxx0_PKTCTRL1, rfSettings.PKTCTRL1);
 389   1          halSpiWriteReg(CCxxx0_PKTCTRL0, rfSettings.PKTCTRL0);
 390   1          halSpiWriteReg(CCxxx0_ADDR,     rfSettings.ADDR);
 391   1          halSpiWriteReg(CCxxx0_PKTLEN,   rfSettings.PKTLEN);
 392   1      
 393   1      /*
 394   1              halSpiWriteReg(CCxxx0_MCSM2 ,   rfSettings.MCSM2 );
 395   1          halSpiWriteReg(CCxxx0_WOREVT1,  rfSettings.WOREVT1);
 396   1          halSpiWriteReg(CCxxx0_WOREVT0,  rfSettings.WOREVT0);
 397   1          halSpiWriteReg(CCxxx0_WORCTRL,  rfSettings.WORCTRL);
 398   1      */
 399   1      }
 400          
 401          //*****************************************************************************************
 402          //函数名：void halRfSendPacket(INT8U *txBuffer, INT8U size)
 403          //输入：发送的缓冲区，发送数据个数
 404          //输出：无
 405          //功能描述：CC1100发送一组数据
 406          //*****************************************************************************************
 407          
 408          void halRfSendPacket(INT8U *txBuffer, INT8U size) 
 409          {
 410   1              
 411   1              halSpiWriteReg(CCxxx0_TXFIFO, size);
 412   1          halSpiWriteBurstReg(CCxxx0_TXFIFO, txBuffer, size); //写入要发送的数据
 413   1              while(GDO2);
 414   1          halSpiStrobe(CCxxx0_STX);           //进入发送模式发送数据
 415   1      
 416   1          // Wait for GDO0 to be set -> sync transmitted
 417   1          while (!GDO0);
 418   1          // Wait for GDO0 to be cleared -> end of packet
 419   1          while (GDO0);
 420   1              halSpiStrobe(CCxxx0_SFTX);
 421   1      }
 422          
 423          /*
 424          void setRxMode(void)
 425          {
 426              halSpiStrobe(CCxxx0_SRX);           //进入接收状态
C51 COMPILER V9.00   CC1101                                                                02/20/2017 11:10:08 PAGE 8   

 427          }
 428          */
 429          /*
 430          // Bit masks corresponding to STATE[2:0] in the status byte returned on MISO
 431          #define CCxx00_STATE_BM                 0x70
 432          #define CCxx00_FIFO_BYTES_AVAILABLE_BM  0x0F
 433          #define CCxx00_STATE_TX_BM              0x20
 434          #define CCxx00_STATE_TX_UNDERFLOW_BM    0x70
 435          #define CCxx00_STATE_RX_BM              0x10
 436          #define CCxx00_STATE_RX_OVERFLOW_BM     0x60
 437          #define CCxx00_STATE_IDLE_BM            0x00
 438          
 439          static INT8U RfGetRxStatus(void)
 440          {
 441                  INT8U temp, spiRxStatus1,spiRxStatus2;
 442                  INT8U i=4;// 循环测试次数
 443              temp = CCxxx0_SNOP|READ_SINGLE;//读寄存器命令
 444                  CSN = 0;
 445                  while (MISO);
 446                  SpiTxRxByte(temp);
 447                  spiRxStatus1 = SpiTxRxByte(0);
 448                  do
 449                  {
 450                          SpiTxRxByte(temp);
 451                          spiRxStatus2 = SpiTxRxByte(0);
 452                          if(spiRxStatus1 == spiRxStatus2)
 453                          {
 454                                  if( (spiRxStatus1 & CCxx00_STATE_BM) == CCxx00_STATE_RX_OVERFLOW_BM)
 455                                  {
 456                         halSpiStrobe(CCxxx0_SFRX);
 457                                     return 0;
 458                                  }
 459                              return 1;
 460                          }
 461                           spiRxStatus1=spiRxStatus2;
 462                  }
 463                  while(i--);
 464                  CSN = 1;
 465              return 0;   
 466          }
 467           */
 468          INT8U halRfReceivePacket(INT8U *rxBuffer, INT8U *length) 
 469          {
 470   1          INT8U status[2];
 471   1          INT8U packetLength;
 472   1              INT8U i=(*length)*4;  // 具体多少要根据datarate和length来决定
 473   1      
 474   1         // halSpiStrobe(CCxxx0_SRX);         //进入接收状态
 475   1              //delay(5);
 476   1          //while (!GDO1);
 477   1          //while (GDO1);
 478   1              //delay(2);
 479   1      //      while (GDO0)
 480   1      //      {
 481   1              //      delay(2);
 482   1              //      --i;
 483   1              //      if(i<1)
 484   1              //         return 0;        
 485   1      //      }        
 486   1          if ((halSpiReadStatus(CCxxx0_RXBYTES) & BYTES_IN_RXFIFO)) //如果接的字节数不为0
 487   1              {
 488   2              packetLength = halSpiReadReg(CCxxx0_RXFIFO);//读出第一个字节，此字节为该帧数据长度
C51 COMPILER V9.00   CC1101                                                                02/20/2017 11:10:08 PAGE 9   

 489   2              if (packetLength <= *length)            //如果所要的有效数据长度小于等于接收到的数据包的长度
 490   2                      {
 491   3                  halSpiReadBurstReg(CCxxx0_RXFIFO, rxBuffer, packetLength); //读出所有接收到的数据
 492   3                  *length = packetLength;                             //把接收数据长度的修改为当前数据的长度
 493   3              
 494   3                  // Read the 2 appended status bytes (status[0] = RSSI, status[1] = LQI)
 495   3                  halSpiReadBurstReg(CCxxx0_RXFIFO, status, 2);       //读出CRC校验位
 496   3                              halSpiStrobe(CCxxx0_SFRX);              //清洗接收缓冲区
 497   3                  return (status[1] & CRC_OK);                        //如果校验成功返回接收成功
 498   3              }
 499   2                       else 
 500   2                      {
 501   3                  *length = packetLength;
 502   3                  halSpiStrobe(CCxxx0_SFRX);          //清洗接收缓冲区
 503   3                  return 0;
 504   3              }
 505   2          } 
 506   1              else
 507   1              return 0;
 508   1      }
 509          /*
 510          void Delay(unsigned int s)
 511          {
 512                  unsigned int i;
 513                  for(i=0; i<s; i++);
 514                  for(i=0; i<s; i++);
 515          }*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    857    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     43      21
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
