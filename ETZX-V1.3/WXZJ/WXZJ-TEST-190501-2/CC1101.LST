C51 COMPILER V9.00   CC1101                                                                06/26/2019 10:43:34 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE CC1101
OBJECT MODULE PLACED IN CC1101.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE CC1101.c COMPACT BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "cc1101.h"
   2          #define LENGTH 32
   3          // RF_SETTINGS is a data structure which contains all relevant CCxxx0 registers
   4          INT8U PaTabel[8] = {0xc0 ,0xc0 ,0xc0 ,0xc0 ,0xc0 ,0xc0 ,0xc0 ,0xc0};  //0dBm
   5          
   6          
   7          #if 0
              typedef struct S_RF_SETTINGS
              {
                      INT8U FSCTRL2;          //自已加的
                  INT8U FSCTRL1;   // Frequency synthesizer control.
                  INT8U FSCTRL0;   // Frequency synthesizer control.
                  INT8U FREQ2;     // Frequency control word, high INT8U.
                  INT8U FREQ1;     // Frequency control word, middle INT8U.
                  INT8U FREQ0;     // Frequency control word, low INT8U.
                  INT8U MDMCFG4;   // Modem configuration.
                  INT8U MDMCFG3;   // Modem configuration.
                  INT8U MDMCFG2;   // Modem configuration.
                  INT8U MDMCFG1;   // Modem configuration.
                  INT8U MDMCFG0;   // Modem configuration.
                  INT8U CHANNR;    // Channel number.
                  INT8U DEVIATN;   // Modem deviation setting (when FSK modulation is enabled).
                  INT8U FREND1;    // Front end RX configuration.
                  INT8U FREND0;    // Front end RX configuration.
                  INT8U MCSM0;     // Main Radio Control State Machine configuration.
                  INT8U FOCCFG;    // Frequency Offset Compensation Configuration.
                  INT8U BSCFG;     // Bit synchronization Configuration.
                  INT8U AGCCTRL2;  // AGC control.
                      INT8U AGCCTRL1;  // AGC control.
                  INT8U AGCCTRL0;  // AGC control.
                  INT8U FSCAL3;    // Frequency synthesizer calibration.
                  INT8U FSCAL2;    // Frequency synthesizer calibration.
                      INT8U FSCAL1;    // Frequency synthesizer calibration.
                  INT8U FSCAL0;    // Frequency synthesizer calibration.
                  INT8U FSTEST;    // Frequency synthesizer calibration control
                  INT8U TEST2;     // Various test settings.
                  INT8U TEST1;     // Various test settings.
                  INT8U TEST0;     // Various test settings.
                  INT8U IOCFG2;    // GDO2 output pin configuration
                  INT8U IOCFG0;    // GDO0 output pin configuration
                  INT8U PKTCTRL1;  // Packet automation control.
                  INT8U PKTCTRL0;  // Packet automation control.
                  INT8U ADDR;      // Device address.
                  INT8U PKTLEN;    // Packet length.
              /*
                      INT8U MCSM2;       // 主通信控制状态机配置*********** 
                  INT8U WOREVT1;   // 高字节时间0暂停***************** // High uchar Event 0 timeout
                  INT8U WOREVT0;   // 低字节时间0暂停***************** // Low uchar Event 0 timeout
                  INT8U WORCTRL;   // 电磁波激活控制****************** // Wake On Radio control
              */
              } RF_SETTINGS;
              
              /////////////////////////////////////////////////////////////////
              const RF_SETTINGS rfSettings = 
              {
C51 COMPILER V9.00   CC1101                                                                06/26/2019 10:43:34 PAGE 2   

                      0x00,
                  0x08,   // FSCTRL1   Frequency synthesizer control.
                  0x00,   // FSCTRL0   Frequency synthesizer control.
                  0x10,   // FREQ2     Frequency control word, high byte.
                  0xA7,   // FREQ1     Frequency control word, middle byte.
                  0x62,   // FREQ0     Frequency control word, low byte.
              
                  0x58,   // MDMCFG4   Modem configuration.
                  0x43,   // MDMCFG3   Modem configuration.
              //    0x03,   // MDMCFG2   Modem configuration.
              //    0x00,   // MDMCFG2   Modem configuration.  没有同步/引导  1个数据也收不到
                      0x01,   // MDMCFG2       Modem configuration.　　15位的前导字，16位的同步字
              
                  0x22,   // MDMCFG1   Modem configuration.
                  0xF8,   // MDMCFG0   Modem configuration.
              
              /*      //
                  0xc8,   // MDMCFG4   Modem configuration.wor,,
                  0x93,   // MDMCFG3   Modem configuration.wor,,
                  0x03,   // MDMCFG2   Modem configuration.wor,,
                  0xf2,   // MDMCFG1   Modem configuration.wor,,
                  0xF8,   // MDMCFG0   Modem configuration.wor,,
              */
                  0x00,   // CHANNR    Channel number.
                  0x47,   // DEVIATN   Modem deviation setting (when FSK modulation is enabled).
                  0x56,   // FREND1    Front end RX configuration.
                  0x10,   // FREND0    Front end RX configuration.
                  0x18,   // MCSM0     Main Radio Control State Machine configuration.
                  0x1D,   // FOCCFG    Frequency Offset Compensation Configuration.
                  0x1C,   // BSCFG     Bit synchronization Configuration.
                  0x43,   // AGCCTRL2  AGC control.
                  0x40,   // AGCCTRL1  AGC control.
                  0x91,   // AGCCTRL0  AGC control.
              
                  0xEA,   // FSCAL3    Frequency synthesizer calibration.
                  0x2A,   // FSCAL2    Frequency synthesizer calibration.
                  0x00,   // FSCAL1    Frequency synthesizer calibration.
                  0x11,   // FSCAL0    Frequency synthesizer calibration.
                  0x59,   // FSTEST    Frequency synthesizer calibration.
                  0x81,   // TEST2     Various test settings.
                  0x35,   // TEST1     Various test settings.
                  0x09,   // TEST0     Various test settings.
                  0x0E,   // IOCFG2    GDO2 output pin configuration.
                  0x06,   // IOCFG0D   GDO0 output pin configuration. Refer to SmartRF?Studio User Manual for detailed p
             -seudo register explanation.
              
                 0x04,   // PKTCTRL1  Packet automation control.
                //  0x4b,   // PKTCTRL1  Packet automation control  ,,,,wor
                  0x05,   // PKTCTRL0  Packet automation control.
                  0x00,   // ADDR      Device address.
                  LENGTH,   // PKTLEN    Packet length.
              ///////////////////////////////////////////////////////////////////////////////////////////
              //      0x18,  //MCSM2     // 主通信控制状态机配置************/ 
               //   0x01, // WOREVT1   // 高字节时间0暂停*****************/ High uchar Event 0 timeout
               //   0xF1, // WOREVT0   // 低字节时间0暂停*****************/ Low uchar Event 0 timeout
               //   0x38, // WORCTRL   // 电磁波激活控制******************/ Wake On Radio control
              /*
                  0x09,  //MCSM2     // 主通信控制状态机配置************ / 
                  0x02, // WOREVT1   // 高字节时间0暂停***************** / High uchar Event 0 timeout
                  0x08, // WOREVT0   // 低字节时间0暂停***************** / Low uchar Event 0 timeout
                  0x38, // WORCTRL     // 电磁波激活控制****************** / Wake On Radio control
                      */
C51 COMPILER V9.00   CC1101                                                                06/26/2019 10:43:34 PAGE 3   

              };
              #endif
 119          
 120          
 121          
 122          typedef struct S_RF_SETTINGS
 123          {
 124                  INT8U FSCTRL2;          //自已加的
 125              INT8U FSCTRL1;   // Frequency synthesizer control.
 126              INT8U FSCTRL0;   // Frequency synthesizer control.
 127              INT8U FREQ2;     // Frequency control word, high INT8U.
 128              INT8U FREQ1;     // Frequency control word, middle INT8U.
 129              INT8U FREQ0;     // Frequency control word, low INT8U.
 130              INT8U MDMCFG4;   // Modem configuration.
 131              INT8U MDMCFG3;   // Modem configuration.
 132              INT8U MDMCFG2;   // Modem configuration.
 133              INT8U MDMCFG1;   // Modem configuration.
 134              INT8U MDMCFG0;   // Modem configuration.
 135              INT8U CHANNR;    // Channel number.
 136              INT8U DEVIATN;   // Modem deviation setting (when FSK modulation is enabled).
 137              INT8U FREND1;    // Front end RX configuration.
 138              INT8U FREND0;    // Front end RX configuration.
 139          
 140              INT8U MCSM0;     // Main Radio Control State Machine configuration.
 141              INT8U FOCCFG;    // Frequency Offset Compensation Configuration.
 142              INT8U BSCFG;     // Bit synchronization Configuration.
 143              INT8U AGCCTRL2;  // AGC control.
 144                  INT8U AGCCTRL1;  // AGC control.
 145              INT8U AGCCTRL0;  // AGC control.
 146              INT8U FSCAL3;    // Frequency synthesizer calibration.
 147              INT8U FSCAL2;    // Frequency synthesizer calibration.
 148                  INT8U FSCAL1;    // Frequency synthesizer calibration.
 149              INT8U FSCAL0;    // Frequency synthesizer calibration.
 150              INT8U FSTEST;    // Frequency synthesizer calibration control
 151              INT8U TEST2;     // Various test settings.
 152              INT8U TEST1;     // Various test settings.
 153              INT8U TEST0;     // Various test settings.
 154              INT8U IOCFG2;    // GDO2 output pin configuration
 155              INT8U IOCFG0;    // GDO0 output pin configuration
 156              INT8U PKTCTRL1;  // Packet automation control.
 157              INT8U PKTCTRL0;  // Packet automation control.
 158              INT8U ADDR;      // Device address.
 159              INT8U PKTLEN;    // Packet length.
 160          /////////////////////////////////////////////////////////////////////////////////////////
 161          //              INT8U MCSM2;       // 主通信控制状态机配置*********** 
 162              INT8U WOREVT1;   // 高字节时间0暂停***************** // High uchar Event 0 timeout
 163              INT8U WOREVT0;   // 低字节时间0暂停***************** // Low uchar Event 0 timeout
 164              INT8U WORCTRL;   // 电磁波激活控制****************** // Wake On Radio control
 165          
 166          } RF_SETTINGS;
 167          
 168          
 169          
 170          
 171          
 172          //4.8K
 173          // Channel spacing = 199.951172 kHz
 174          // Channel number = 0
 175          // Optimization = -
 176          // Sync mode = (3) 30/32 sync word bits detected
 177          // Format of RX/TX data = (0) Normal mode, use FIFOs for RX and TX
 178          // CRC operation = (1) CRC calculation in TX and CRC check in RX enabled
C51 COMPILER V9.00   CC1101                                                                06/26/2019 10:43:34 PAGE 4   

 179          // Forward Error Correction = (0) FEC disabled
 180          // Length configuration = (1) Variable length packets, packet length configured by the first received byte
             - after sync word.
 181          // Packetlength = 255
 182          // Preamble count = (2)  4 bytes
 183          // Append status = 1
 184          // Address check = (0) No address check
 185          // FIFO autoflush = 0
 186          // Device address = 0
 187          // GDO0 signal selection = ( 6) Asserts when sync word has been sent / received, and de-asserts at the end
             - of the packet
 188          // GDO2 signal selection = (41) CHIP_RDY
 189          const RF_SETTINGS rfSettings= {
 190                  0x00,
 191              0x06,   // FSCTRL1   Frequency synthesizer control.
 192              0x00,   // FSCTRL0   Frequency synthesizer control.
 193              0x10,   // FREQ2     Frequency control word, high byte.
 194              0xA7,   // FREQ1     Frequency control word, middle byte.
 195              0x62,   // FREQ0     Frequency control word, low byte.
 196              0xC7,   // MDMCFG4   Modem configuration.
 197              0x83,   // MDMCFG3   Modem configuration.
 198          //    0x03,   // MDMCFG2   Modem configuration.
 199                  0x01,   // MDMCFG2       [2:0] SYNC_MODE[2:0] 复合同步字限定符模式 0--无前导与同步 1--15/16同步 2--16/16同步 3--
             -30/32同步
 200          
 201              0x22,   // MDMCFG1   Modem configuration.
 202              0xF8,   // MDMCFG0   Modem configuration.
 203              0x00,   // CHANNR    Channel number.
 204              0x40,   // DEVIATN   Modem deviation setting (when FSK modulation is enabled).
 205              0x56,   // FREND1    Front end RX configuration.
 206              0x10,   // FREND0    Front end TX configuration.
 207              0x18,   // MCSM0     Main Radio Control State Machine configuration.
 208              0x16,   // FOCCFG    Frequency Offset Compensation Configuration.
 209              0x6C,   // BSCFG     Bit synchronization Configuration.
 210              0x43,   // AGCCTRL2  AGC control.
 211              0x40,   // AGCCTRL1  AGC control.
 212              0x91,   // AGCCTRL0  AGC control.
 213              0xE9,   // FSCAL3    Frequency synthesizer calibration.
 214              0x2A,   // FSCAL2    Frequency synthesizer calibration.
 215              0x00,   // FSCAL1    Frequency synthesizer calibration.
 216              0x1F,   // FSCAL0    Frequency synthesizer calibration.
 217              0x59,   // FSTEST    Frequency synthesizer calibration.
 218              0x81,   // TEST2     Various test settings.
 219              0x35,   // TEST1     Various test settings.
 220              0x09,   // TEST0     Various test settings.
 221          
 222              0x29,   // IOCFG2    GDO2 output pin configuration.
 223              0x06,   // IOCFG0D   GDO0 output pin configuration. Refer to SmartRF?Studio User Manual for detailed p
             -seudo register explanation.
 224              0x04,   // PKTCTRL1  Packet automation control.
 225              0x05,   // PKTCTRL0  Packet automation control.
 226              0x00,   // ADDR      Device address.
 227              0xFF    // PKTLEN    Packet length.
 228          };
 229          
 230          
 231          //*****************************************************************************************
 232          //函数名：delay(unsigned int s)
 233          //输入：时间
 234          //输出：无
 235          //功能描述：普通廷时,内部用
 236          //*****************************************************************************************             
C51 COMPILER V9.00   CC1101                                                                06/26/2019 10:43:34 PAGE 5   

 237          void delay(unsigned int s)
 238          {
 239   1              unsigned int i;
 240   1              for(i=0; i<s; i++);
 241   1              for(i=0; i<s; i++);
 242   1      }
 243          
 244          
 245          void halWait(INT16U timeout) {
 246   1          do {
 247   2              _nop_();
 248   2                      _nop_();
 249   2                      _nop_();
 250   2                      _nop_();
 251   2                      _nop_();
 252   2                      _nop_();
 253   2                      _nop_();
 254   2                      _nop_();
 255   2                      _nop_();
 256   2                      _nop_();
 257   2                      _nop_();
 258   2                      _nop_();
 259   2                      _nop_();
 260   2                      _nop_();
 261   2                      _nop_(); 
 262   2          } while (--timeout);
 263   1      }
 264          
 265          
 266          void SpiInit(void)
 267          {
 268   1              CSN=0;
 269   1              SCK=0;
 270   1              CSN=1;
 271   1      }
 272          
 273          /*****************************************************************************************
 274          //函数名：CpuInit()
 275          //输入：无
 276          //输出：无
 277          //功能描述：SPI初始化程序
 278          /*****************************************************************************************/
 279          void CpuInit(void)
 280          {
 281   1              SpiInit();
 282   1              delay(5000);
 283   1              POWER_UP_RESET_CC1100();
 284   1              halRfWriteRfSettings();
 285   1              halSpiWriteBurstReg(CCxxx0_PATABLE, PaTabel, 8);
 286   1      }
 287                  
 288          
 289          //*****************************************************************************************
 290          //函数名：SpisendByte(INT8U dat)
 291          //输入：发送的数据
 292          //输出：无
 293          //功能描述：SPI发送一个字节
 294          //*****************************************************************************************
 295          INT8U SpiTxRxByte(INT8U dat)
 296          {
 297   1              INT8U i,temp;
 298   1              temp = 0;
C51 COMPILER V9.00   CC1101                                                                06/26/2019 10:43:34 PAGE 6   

 299   1              
 300   1              SCK = 0;
 301   1              for(i=0; i<8; i++)
 302   1              {
 303   2                      if(dat & 0x80)
 304   2                      {
 305   3                              MOSI = 1;
 306   3                      }
 307   2                      else MOSI = 0;
 308   2                      dat <<= 1;
 309   2      
 310   2                      SCK = 1; 
 311   2                      _nop_();
 312   2                      _nop_();
 313   2      
 314   2                      temp <<= 1;
 315   2                      if(MISO)temp++; 
 316   2                      SCK = 0;
 317   2                      _nop_();
 318   2                      _nop_();        
 319   2              }
 320   1              return temp;
 321   1      }
 322          
 323          //*****************************************************************************************
 324          //函数名：void RESET_CC1100(void)
 325          //输入：无
 326          //输出：无
 327          //功能描述：复位CC1100
 328          //*****************************************************************************************
 329          void RESET_CC1100(void) 
 330          {
 331   1              CSN = 0; 
 332   1              while (MISO);
 333   1          SpiTxRxByte(CCxxx0_SRES);           //写入复位命令
 334   1              while (MISO); 
 335   1          CSN = 1; 
 336   1      }
 337          
 338          //*****************************************************************************************
 339          //函数名：void POWER_UP_RESET_CC1100(void) 
 340          //输入：无
 341          //输出：无
 342          //功能描述：上电复位CC1100
 343          //*****************************************************************************************
 344          void POWER_UP_RESET_CC1100(void) 
 345          {
 346   1              CSN = 1; 
 347   1              halWait(1); 
 348   1              CSN = 0; 
 349   1              halWait(1); 
 350   1              CSN = 1; 
 351   1              halWait(41); 
 352   1              RESET_CC1100();                 //复位CC1100
 353   1      }
 354          
 355          //*****************************************************************************************
 356          //函数名：void halSpiWriteReg(INT8U addr, INT8U value)
 357          //输入：地址和配置字
 358          //输出：无
 359          //功能描述：SPI写寄存器
 360          //*****************************************************************************************
C51 COMPILER V9.00   CC1101                                                                06/26/2019 10:43:34 PAGE 7   

 361          void halSpiWriteReg(INT8U addr, INT8U value) 
 362          {
 363   1          CSN = 0;
 364   1          while (MISO);
 365   1          SpiTxRxByte(addr);          //写地址
 366   1          SpiTxRxByte(value);         //写入配置
 367   1          CSN = 1;
 368   1      }
 369          
 370          //*****************************************************************************************
 371          //函数名：void halSpiWriteBurstReg(INT8U addr, INT8U *buffer, INT8U count)
 372          //输入：地址，写入缓冲区，写入个数
 373          //输出：无
 374          //功能描述：SPI连续写配置寄存器
 375          //*****************************************************************************************
 376          void halSpiWriteBurstReg(INT8U addr, INT8U *buffer, INT8U count) 
 377          {
 378   1          INT8U i, temp;
 379   1              temp = addr | WRITE_BURST;
 380   1          CSN = 0;
 381   1          while (MISO);
 382   1          SpiTxRxByte(temp);
 383   1          for (i = 0; i < count; i++)
 384   1              {
 385   2              SpiTxRxByte(buffer[i]);
 386   2          }
 387   1          CSN = 1;
 388   1      }
 389          
 390          //*****************************************************************************************
 391          //函数名：void halSpiStrobe(INT8U strobe)
 392          //输入：命令
 393          //输出：无
 394          //功能描述：SPI写命令
 395          //*****************************************************************************************
 396          void halSpiStrobe(INT8U strobe) 
 397          {
 398   1          CSN = 0;
 399   1          while (MISO);
 400   1          SpiTxRxByte(strobe);                //写入命令
 401   1          CSN = 1;
 402   1      }
 403          
 404          
 405          
 406          
 407          
 408          //*****************************************************************************************
 409          //函数名：INT8U halSpiReadReg(INT8U addr)
 410          //输入：地址
 411          //输出：该寄存器的配置字
 412          //功能描述：SPI读寄存器
 413          //*****************************************************************************************
 414          INT8U halSpiReadReg(INT8U addr) 
 415          {
 416   1              INT8U temp, value;
 417   1          temp = addr|READ_SINGLE;//读寄存器命令
 418   1              CSN = 0;
 419   1              while (MISO);
 420   1              SpiTxRxByte(temp);
 421   1              value = SpiTxRxByte(0);
 422   1              CSN = 1;
C51 COMPILER V9.00   CC1101                                                                06/26/2019 10:43:34 PAGE 8   

 423   1              return value;
 424   1      }
 425          
 426          
 427          //*****************************************************************************************
 428          //函数名：void halSpiReadBurstReg(INT8U addr, INT8U *buffer, INT8U count)
 429          //输入：地址，读出数据后暂存的缓冲区，读出配置个数
 430          //输出：无
 431          //功能描述：SPI连续写配置寄存器
 432          //*****************************************************************************************
 433          void halSpiReadBurstReg(INT8U addr, INT8U *buffer, INT8U count) 
 434          {
 435   1          INT8U i,temp;
 436   1              temp = addr | READ_BURST;               //写入要读的配置寄存器地址和读命令
 437   1          CSN = 0;
 438   1          while (MISO);
 439   1              SpiTxRxByte(temp);   
 440   1          for (i = 0; i < count; i++) 
 441   1              {
 442   2              buffer[i] = SpiTxRxByte(0);
 443   2          }
 444   1          CSN = 1;
 445   1      }
 446          
 447          
 448          //*****************************************************************************************
 449          //函数名：INT8U halSpiReadReg(INT8U addr)
 450          //输入：地址
 451          //输出：该状态寄存器当前值
 452          //功能描述：SPI读状态寄存器
 453          //*****************************************************************************************
 454          INT8U halSpiReadStatus(INT8U addr) 
 455          {
 456   1          INT8U value,temp;
 457   1              temp = addr | READ_BURST;               //写入要读的状态寄存器的地址同时写入读命令
 458   1          CSN = 0;
 459   1          while (MISO);
 460   1          SpiTxRxByte(temp);
 461   1              value = SpiTxRxByte(0);
 462   1              CSN = 1;
 463   1              return value;
 464   1      }
 465          //*****************************************************************************************
 466          //函数名：void halRfWriteRfSettings(RF_SETTINGS *pRfSettings)
 467          //输入：无
 468          //输出：无
 469          //功能描述：配置CC1100的寄存器
 470          //*****************************************************************************************
 471          void halRfWriteRfSettings(void) 
 472          {
 473   1      
 474   1              halSpiWriteReg(CCxxx0_FSCTRL0,  rfSettings.FSCTRL2);//自已加的
 475   1          // Write register settings
 476   1          halSpiWriteReg(CCxxx0_FSCTRL1,  rfSettings.FSCTRL1);
 477   1          halSpiWriteReg(CCxxx0_FSCTRL0,  rfSettings.FSCTRL0);
 478   1          halSpiWriteReg(CCxxx0_FREQ2,    rfSettings.FREQ2);
 479   1          halSpiWriteReg(CCxxx0_FREQ1,    rfSettings.FREQ1);
 480   1          halSpiWriteReg(CCxxx0_FREQ0,    rfSettings.FREQ0);
 481   1          halSpiWriteReg(CCxxx0_MDMCFG4,  rfSettings.MDMCFG4);
 482   1          halSpiWriteReg(CCxxx0_MDMCFG3,  rfSettings.MDMCFG3);
 483   1          halSpiWriteReg(CCxxx0_MDMCFG2,  rfSettings.MDMCFG2);
 484   1          halSpiWriteReg(CCxxx0_MDMCFG1,  rfSettings.MDMCFG1);
C51 COMPILER V9.00   CC1101                                                                06/26/2019 10:43:34 PAGE 9   

 485   1          halSpiWriteReg(CCxxx0_MDMCFG0,  rfSettings.MDMCFG0);
 486   1          halSpiWriteReg(CCxxx0_CHANNR,   rfSettings.CHANNR);
 487   1          halSpiWriteReg(CCxxx0_DEVIATN,  rfSettings.DEVIATN);
 488   1          halSpiWriteReg(CCxxx0_FREND1,   rfSettings.FREND1);
 489   1          halSpiWriteReg(CCxxx0_FREND0,   rfSettings.FREND0);
 490   1          halSpiWriteReg(CCxxx0_MCSM0 ,   rfSettings.MCSM0 );
 491   1          halSpiWriteReg(CCxxx0_FOCCFG,   rfSettings.FOCCFG);
 492   1          halSpiWriteReg(CCxxx0_BSCFG,    rfSettings.BSCFG);
 493   1          halSpiWriteReg(CCxxx0_AGCCTRL2, rfSettings.AGCCTRL2);
 494   1              halSpiWriteReg(CCxxx0_AGCCTRL1, rfSettings.AGCCTRL1);
 495   1          halSpiWriteReg(CCxxx0_AGCCTRL0, rfSettings.AGCCTRL0);
 496   1          halSpiWriteReg(CCxxx0_FSCAL3,   rfSettings.FSCAL3);
 497   1              halSpiWriteReg(CCxxx0_FSCAL2,   rfSettings.FSCAL2);
 498   1              halSpiWriteReg(CCxxx0_FSCAL1,   rfSettings.FSCAL1);
 499   1          halSpiWriteReg(CCxxx0_FSCAL0,   rfSettings.FSCAL0);
 500   1          halSpiWriteReg(CCxxx0_FSTEST,   rfSettings.FSTEST);
 501   1          halSpiWriteReg(CCxxx0_TEST2,    rfSettings.TEST2);
 502   1          halSpiWriteReg(CCxxx0_TEST1,    rfSettings.TEST1);
 503   1          halSpiWriteReg(CCxxx0_TEST0,    rfSettings.TEST0);
 504   1          halSpiWriteReg(CCxxx0_IOCFG2,   rfSettings.IOCFG2);
 505   1          halSpiWriteReg(CCxxx0_IOCFG0,   rfSettings.IOCFG0);    
 506   1          halSpiWriteReg(CCxxx0_PKTCTRL1, rfSettings.PKTCTRL1);
 507   1          halSpiWriteReg(CCxxx0_PKTCTRL0, rfSettings.PKTCTRL0);
 508   1          halSpiWriteReg(CCxxx0_ADDR,     rfSettings.ADDR);
 509   1          halSpiWriteReg(CCxxx0_PKTLEN,   rfSettings.PKTLEN);
 510   1      
 511   1      /*
 512   1              halSpiWriteReg(CCxxx0_MCSM2 ,   rfSettings.MCSM2 );
 513   1          halSpiWriteReg(CCxxx0_WOREVT1,  rfSettings.WOREVT1);
 514   1          halSpiWriteReg(CCxxx0_WOREVT0,  rfSettings.WOREVT0);
 515   1          halSpiWriteReg(CCxxx0_WORCTRL,  rfSettings.WORCTRL);
 516   1      */
 517   1      }
 518          
 519          //*****************************************************************************************
 520          //函数名：void halRfSendPacket(INT8U *txBuffer, INT8U size)
 521          //输入：发送的缓冲区，发送数据个数
 522          //输出：无
 523          //功能描述：CC1100发送一组数据
 524          //*****************************************************************************************
 525          
 526          void halRfSendPacket(INT8U *txBuffer, INT8U size) 
 527          {
 528   1              
 529   1              halSpiWriteReg(CCxxx0_TXFIFO, size);
 530   1          halSpiWriteBurstReg(CCxxx0_TXFIFO, txBuffer, size); //写入要发送的数据
 531   1              while(GDO2);
 532   1          halSpiStrobe(CCxxx0_STX);           //进入发送模式发送数据
 533   1      
 534   1          // Wait for GDO0 to be set -> sync transmitted
 535   1          while (!GDO0);
 536   1          // Wait for GDO0 to be cleared -> end of packet
 537   1          while (GDO0);
 538   1              halSpiStrobe(CCxxx0_SFTX);
 539   1      }
 540          
 541          /*
 542          void setRxMode(void)
 543          {
 544              halSpiStrobe(CCxxx0_SRX);           //进入接收状态
 545          }
 546          */
C51 COMPILER V9.00   CC1101                                                                06/26/2019 10:43:34 PAGE 10  

 547          /*
 548          // Bit masks corresponding to STATE[2:0] in the status byte returned on MISO
 549          #define CCxx00_STATE_BM                 0x70
 550          #define CCxx00_FIFO_BYTES_AVAILABLE_BM  0x0F
 551          #define CCxx00_STATE_TX_BM              0x20
 552          #define CCxx00_STATE_TX_UNDERFLOW_BM    0x70
 553          #define CCxx00_STATE_RX_BM              0x10
 554          #define CCxx00_STATE_RX_OVERFLOW_BM     0x60
 555          #define CCxx00_STATE_IDLE_BM            0x00
 556          
 557          static INT8U RfGetRxStatus(void)
 558          {
 559                  INT8U temp, spiRxStatus1,spiRxStatus2;
 560                  INT8U i=4;// 循环测试次数
 561              temp = CCxxx0_SNOP|READ_SINGLE;//读寄存器命令
 562                  CSN = 0;
 563                  while (MISO);
 564                  SpiTxRxByte(temp);
 565                  spiRxStatus1 = SpiTxRxByte(0);
 566                  do
 567                  {
 568                          SpiTxRxByte(temp);
 569                          spiRxStatus2 = SpiTxRxByte(0);
 570                          if(spiRxStatus1 == spiRxStatus2)
 571                          {
 572                                  if( (spiRxStatus1 & CCxx00_STATE_BM) == CCxx00_STATE_RX_OVERFLOW_BM)
 573                                  {
 574                         halSpiStrobe(CCxxx0_SFRX);
 575                                     return 0;
 576                                  }
 577                              return 1;
 578                          }
 579                           spiRxStatus1=spiRxStatus2;
 580                  }
 581                  while(i--);
 582                  CSN = 1;
 583              return 0;   
 584          }
 585           */
 586          INT8U halRfReceivePacket(INT8U *rxBuffer, INT8U *length) 
 587          {
 588   1          INT8U status[2];
 589   1          INT8U packetLength;
 590   1              INT8U i=(*length)*4;  // 具体多少要根据datarate和length来决定
 591   1      
 592   1         // halSpiStrobe(CCxxx0_SRX);         //进入接收状态
 593   1              //delay(5);
 594   1          //while (!GDO1);
 595   1          //while (GDO1);
 596   1              //delay(2);
 597   1      //      while (GDO0)
 598   1      //      {
 599   1              //      delay(2);
 600   1              //      --i;
 601   1              //      if(i<1)
 602   1              //         return 0;        
 603   1      //      }        
 604   1          if ((halSpiReadStatus(CCxxx0_RXBYTES) & BYTES_IN_RXFIFO)) //如果接的字节数不为0
 605   1              {
 606   2              packetLength = halSpiReadReg(CCxxx0_RXFIFO);//读出第一个字节，此字节为该帧数据长度
 607   2              if (packetLength <= *length)            //如果所要的有效数据长度小于等于接收到的数据包的长度
 608   2                      {
C51 COMPILER V9.00   CC1101                                                                06/26/2019 10:43:34 PAGE 11  

 609   3                  halSpiReadBurstReg(CCxxx0_RXFIFO, rxBuffer, packetLength); //读出所有接收到的数据
 610   3                  *length = packetLength;                             //把接收数据长度的修改为当前数据的长度
 611   3              
 612   3                  // Read the 2 appended status bytes (status[0] = RSSI, status[1] = LQI)
 613   3                  halSpiReadBurstReg(CCxxx0_RXFIFO, status, 2);       //读出CRC校验位
 614   3                              halSpiStrobe(CCxxx0_SFRX);              //清洗接收缓冲区
 615   3                  return (status[1] & CRC_OK);                        //如果校验成功返回接收成功
 616   3              }
 617   2                       else 
 618   2                      {
 619   3                  *length = packetLength;
 620   3                  halSpiStrobe(CCxxx0_SFRX);          //清洗接收缓冲区
 621   3                  return 0;
 622   3              }
 623   2          } 
 624   1              else
 625   1              return 0;
 626   1      }
 627          /*
 628          void Delay(unsigned int s)
 629          {
 630                  unsigned int i;
 631                  for(i=0; i<s; i++);
 632                  for(i=0; i<s; i++);
 633          }*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    857    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     46      21
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
