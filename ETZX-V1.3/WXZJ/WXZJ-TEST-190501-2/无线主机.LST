C51 COMPILER V9.00   无线_骰_                                                              06/24/2019 14:54:30 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE 无线_骰_
OBJECT MODULE PLACED IN 无线主机.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE 无线主机.c COMPACT BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*
   2          管理主机无线主机模块程序
   3          修改：将原来转发呼叫指令改为接收总线指示指令并转换为呼叫指令  20140516
   4          
   5          */
   6          #include "cc1101.h"
   7          #include "uart.h"
   8          #include "单总线接口.h"
   9          //#define  cont 6
  10          #define  cont 1
  11          sbit   led0 = P1^0;
  12          sbit   led1 = P1^1;
  13          unsigned char int0_buf;
  14          unsigned char area=0xff; //所属区域
  15          
  16          extern unsigned int data timer;
  17          //unsigned char cont =8;
  18          void int0() interrupt 2
  19          {
  20   1        EX1=0;int0_buf=1;
  21   1      }
  22          void main(void)
  23          {  unsigned long x;
  24   1         unsigned char xdata TxBuf[8],RxBuf[24],RxBak[8];
  25   1      
  26   1      
  27   1      //   unsigned char xdata LastCallBuf[8];
  28   1         unsigned char leng,i;
  29   1         led0=0;led1=0;
  30   1         WDT_CONTR=0x3f;
  31   1         CpuInit();
  32   1         led0=1;
  33   1         x=0;TxBuf[2]=1;
  34   1         timer=6001;
  35   1         UART_init(9600);
  36   1         uart_send_one(0xaa);
  37   1         SingleBusInit();
  38   1         //halRfSendPacket(TxBuf,8);}
  39   1         EA=1;
  40   1         int0_buf=0;
  41   1         ES=1;
  42   1         EX1=1;
  43   1         IT1=1;
  44   1         halSpiStrobe(CCxxx0_SRX);            //进入接收状态
  45   1         TxBuf[7]=0;uart_buf=0;TI=0;RI=0;ES=1;EA=1;
  46   1         while(1)
  47   1         { 
  48   2               x++;
  49   2           WDT_CONTR =0x3f;
  50   2               if (timer>12000) //500us*6000 //3s超时，则自动清除备份数据
  51   2               {
  52   3                      for (i=0;i<8;i++) RxBak[i]=0;
  53   3                      timer=0;
  54   3               }
  55   2           if(int0_buf==1)
C51 COMPILER V9.00   无线_骰_                                                              06/24/2019 14:54:30 PAGE 2   

  56   2               { 
  57   3                      led0=0;
  58   3      //              uart_send_one(0xaa);
  59   3                      leng = 24;
  60   3                      for (i=0;i<8;i++) RxBuf[i]=0;
  61   3              if(halRfReceivePacket(RxBuf,&leng))
  62   3                      {
  63   4      //                for (i=0;i<leng;i++) uart_send_one(RxBuf[i]);
  64   4                        WDT_CONTR =0x3f;
  65   4                        if(RxBuf[7]==0x55)
  66   4                        {
  67   5                              //如果没有从总线获取过区域编号，则允许任何符合规则的数据进入系统，否则只允许相同区域的数据进入系统
  68   5                              if (area==0xff||area==RxBuf[0])
  69   5                              {
  70   6                                      //断定是否与上一帧数据相同
  71   6                                      for (i=0;i<8;i++)
  72   6                                      {
  73   7                                              if (RxBak[i]!=RxBuf[i]) break;
  74   7                                      }
  75   6                                      if (i<8) //如果与备份数据相同则不发送
  76   6                                      {
  77   7                                              //for(i=0;i<leng;i++) uart_send_one(RxBuf[i]);
  78   7                                              timer=0;
  79   7                                              Bus0OutputData(RxBuf);
  80   7                                              for (i=0;i<8;i++) RxBak[i]=RxBuf[i]; //更新备份数据
  81   7                                              //如果是加床呼叫，则需要转发到移动分机报号
  82   7                                              if (RxBuf[1]==250&&RxBuf[3]==0x06)
  83   7                                              {
  84   8                                                 RxBuf[7]=0xaa;
  85   8                                                 for(i=0;i<cont;i++)
  86   8                                                 { 
  87   9                                                       WDT_CONTR =0x3f;
  88   9                                                       halSpiStrobe(CCxxx0_SIDLE);
  89   9                                                       halRfSendPacket(RxBuf,8);}
  90   8                                                 }  
  91   7                                                 halSpiStrobe(CCxxx0_SRX);//delay(1000);                     //进入接收状态
  92   7                                         }
  93   6                                      }
  94   5                              
  95   5                        }
  96   4                      }
  97   3                      int0_buf=0;
  98   3                      WDT_CONTR =0x3f;
  99   3                      halSpiStrobe(CCxxx0_SRX);               //进入接收状态
 100   3                      led0=1;
 101   3                      EX1=1;
 102   3                }
 103   2               if(x>120000)
 104   2               {
 105   3                      x=0;
 106   3                      //Bus0OutputData(RxBuf);
 107   3                //     for(i=0;i<cont;i++){TxBuf[0]=0x01;TxBuf[7]=0xaa;TxBuf[3]=0x06;TxBuf[4]=0x01;TxBuf[5]=0x01;TxBuf[4]+
             -+;
 108   3                      //        halRfSendPacket(TxBuf,8);}
 109   3                      //        halSpiStrobe(CCxxx0_SRX);                    //进入接收状态
 110   3                      //  EX1=1;
 111   3               }
 112   2               if(bBus0SendFinish==1)bBus0SendFinish=0;      //如果数据发送完毕，发送标志清0;
 113   2               if(bBus0RecFinish==1)                         //如果接收到数据，
 114   2               {  
 115   3                      led0=0;
 116   3                      bBus0RecFinish=0; 
C51 COMPILER V9.00   无线_骰_                                                              06/24/2019 14:54:30 PAGE 3   

 117   3                      EA=0;
 118   3                  for(i=0;i<7;i++)
 119   3                      { 
 120   4                              TxBuf[i]=byBus0RecData[i];//uart_send_one(TxBuf[i]);
 121   4                      }
 122   3                      EA=1;
 123   3                      if((TxBuf[3]==0x5a)||(TxBuf[3]==0x2f))
 124   3              {
 125   4                         if (TxBuf[3]==0x2f)
 126   4                         {
 127   5                    //指示码转为呼叫码
 128   5                                TxBuf[3] = TxBuf[4]&0x1f;     
 129   5                                TxBuf[4] = 0;
 130   5                         }
 131   4                         if (TxBuf[3]==0x06)area = TxBuf[0];
 132   4      
 133   4                         TxBuf[7]=0xaa;
 134   4                         for(i=0;i<cont;i++)
 135   4                         { 
 136   5                               WDT_CONTR =0x3f;
 137   5                               halSpiStrobe(CCxxx0_SIDLE);
 138   5                               
 139   5                               halRfSendPacket(TxBuf,8);
 140   5      
 141   5                               //delay(0xffff);
 142   5                         }
 143   4      
 144   4      
 145   4      /*
 146   4                              delay(0xffff);
 147   4                              TxBuf[3] = 0x5d;
 148   4                              TxBuf[7]=0xaa;
 149   4                              WDT_CONTR =0x3f;
 150   4                              halSpiStrobe(CCxxx0_SIDLE);
 151   4                              halRfSendPacket(TxBuf,8);*/                
 152   4                         
 153   4                      }  
 154   3                      halSpiStrobe(CCxxx0_SRX);//delay(1000);                //进入接收状态
 155   3              }
 156   2          led0=1;
 157   2               /*if(uart_buf>0)
 158   2                  { //uart_send_one(0x5a);
 159   2                        TxBuf[0]=0x01;
 160   2                        TxBuf[1]=01;
 161   2                       // TxBuf[2]=1;
 162   2                        TxBuf[3]=0x07;
 163   2                TxBuf[4]=0x01;
 164   2                        TxBuf[5]=255;
 165   2                TxBuf[6]=1;
 166   2                        TxBuf[7]=0xaa;TxBuf[2]++;
 167   2                        
 168   2                        //for(i=0;i<cont;i++){
 169   2                        halRfSendPacket(TxBuf,8);delay(1000);
 170   2                       // }
 171   2                        
 172   2                        halSpiStrobe(CCxxx0_SRX);                    //进入接收状态
 173   2                uart_buf=0;
 174   2                        EX1=1;
 175   2                      }*/
 176   2         }
 177   1      }

C51 COMPILER V9.00   无线_骰_                                                              06/24/2019 14:54:30 PAGE 4   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    663    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      40
   PDATA SIZE       =      2       6
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
