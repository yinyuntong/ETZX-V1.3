C51 COMPILER V9.00   SINGLEBUS                                                             02/17/2017 20:25:02 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SINGLEBUS
OBJECT MODULE PLACED IN SingleBus.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE SingleBus.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*
   2          ************************Copyright(c)************************
   3          *                                  湖南熙旺达科技有限公司
   4          *                               All Rights Reserved
   5          *                                        
   6          *
   7          *-----------------------文件信息---------------------------
   8          *文件名称               :SingleBus.c
   9          *文件描述               :单总线程序
  10          *创建人                 :陈卫国
  11          *创建日期               :2008-9-22
  12          *版本号                 :V1.0
  13          *注释                   :                                       
  14          *----------------------------------------------------------
  15          *修改人                         :
  16          *修改日期                       :
  17          *版本号                 :
  18          *注释                   :
  19          ***********************************************************
  20          */
  21          #define _IN_SINGLE_BUS_
  22          #include "config.h"
  23          
  24          //总线0变量定义
  25          uint8 bdata byBus0State0        = 0;                                                    //单总线0状态字1
  26          sbit  bBus0StartRec                     = byBus0State0^0;                               //单总线0开始接收起始位标志
  27          sbit  bBus0OnRec                        = byBus0State0^1;                               //单总线0开始接收数据位标志
  28          sbit  bBus0Enable                       = byBus0State0^2;                               //单总线0允许发送标志
  29          sbit  bBus0ReqSend                      = byBus0State0^3;                               //单总线0请求发送标志
  30          sbit  bBus0OnSendBit            = byBus0State0^4;                               //单总线0正在发送一个数据位标志
  31          sbit  bBus0OnSendFreq           = byBus0State0^5;                               //单总线0正在发送一个数据帧标志
  32          sbit  bBus0SendError            = byBus0State0^6;                               //单总线0发送错误标志
  33          sbit  bBus0Error                        = byBus0State0^7;                               //单总线0故障标志
  34          uint8 bdata byBus0State1        = 0;                                                    //单总线0状态字2
  35          sbit  bBus0RecFinish            = byBus0State1^0;                               //单总线0接收完成标志
  36          sbit  bBus0RecBit9                      = byBus0State1^1;                               //单总线0接收字节数据的第9位
  37          sbit  bBus0SendFinish           = byBus0State1^2;                               //单总线0发送完成标志
  38          sbit  bBus0Disable                      = byBus0State1^3;                               //单总线0禁止发送标志
  39          sbit  bBus0SendBit                      = byBus0State1^4;                               //单总线0正在发送的数据位
  40          sbit  bBus0RecBit                       = byBus0State1^5;                               //单总线0正在接收的数据位
  41          uint8 data byBus0RecCount = 0;                                                          //高4位是总线0接收定时中断计数，低4位是接收到的位计数
  42          uint8 data byBus0RecBuf;                                                                        //总线0接收缓冲单元
  43          uint8 data byBus0SendBuf;                                                                       //总线0发送缓冲单元     
  44          uint8 data byBus0RecData[BUS0_FREQ_SIZE];                                       //总线0接收缓冲区
  45          uint8 data byBus0SendData[BUS0_FREQ_SIZE];                                      //总线0发送缓冲区
  46          uint8 data byBus0SendCount = 0;                                                         //高4位是总线0发送定时中断计数，低4位是发送的位计数
  47          uint8 data byBus0RecSendCount = 0;                                                      //高4位是总线0接收到的字节计数，低4位是总线0发送完的字节计数
  48          uint8 data byBus0SendStopCount;                                                         //总线0停止时间计数
  49          uint8 data byBus0RecTimeOut = 0;                                                        //总线0接收超时计数
  50          uint8 data byBus0DisableCount = 0;                                                      //总线0禁止计数  
  51          uint8 xdata byBus0TxQ[BUS0_TX_Q_ZISE];                                          //总线0发送队列                                                 
  52          uint8 data byBus0TxHead = 0;                                                            //单总线0发送队列头指针
  53          uint8 data byBus0TxTail = 0;                                                            //单总线0发送队列尾指针
  54          #define IncBus0TxPtr(addr)    {addr=(addr+1)%BUS0_TX_Q_ZISE;}
  55          #define Bus0TxBuffLen()       ((byBus0TxTail+BUS0_TX_Q_ZISE-byBus0TxHead)%BUS0_TX_Q_ZISE) 
C51 COMPILER V9.00   SINGLEBUS                                                             02/17/2017 20:25:02 PAGE 2   

  56          sbit  Bus0RecPin        = P3^2;                                                                 //单总线0接收引脚定义
  57          sbit  Bus0SendPin       = P3^7;                                                                 //单总线0发送引脚定义
  58          extern uint8    OS_Q_MEM_SEL    byMainCmdQ[]; 
  59          extern STLocalControl   xdata stLocalControl; 
  60          //---------------------------------------------------------
  61          bit   SET_BY_SERIAL_FLAG;                                 //单总线对设备编号标志位
  62          uint16 xdata SET_BY_SERIAL_COUNT=0;                       
  63          extern bit   SET_BY_SERIAL_OK_FLAG;
  64          uint16 xdata SET_BY_SERIAL_COUNT1=0;
  65          uint16 xdata TimerCount=0;
  66          extern bit IRHaveRec_Flag;
  67          extern bit IRByteEnd;
  68          extern bit FiveSec_Flag;
  69          extern bit IRStartRec;
  70          extern uint8 xdata IRByteCount;
  71          
  72          
  73          extern uint8 xdata TEMPIRDATA[6];
  74          extern bit IR_SET_BY_SERIAL_FLAG;
  75          
  76          
  77          
  78          uint8 xdata BusLowDTime=100;
  79          
  80          bit bBus0SndBitOk=0;
  81          //---------------------------------------------------------      
  82          /**********************************************************
  83          *函数名称                       :SingleBusInit  
  84          *函数描述               :单总线初始化
  85          *输入参数               :
  86          *返回值                         :       
  87          *全局变量                       :
  88          *调用模块                       :
  89          ***********************************************************
  90          *创建人                 :陈卫国
  91          *创建日期                       :2008-9-22
  92          ***********************************************************
  93          *修改人                         :
  94          *修改日期               :
  95          *注释                   :
  96          **********************************************************/
  97          void SingleBusInit(void)
  98          {
  99   1              //总线0发送脚设置为推挽输出，接收脚设置为高阻输入:M0=0,M1=0:准双向，M0=0,M1=1:推挽，M0=1,M1=0:高阻，M0=1,
             -M1=1:开漏
 100   1              P3M0 |= 0x04;
 101   1              P3M1 &= 0xFB;
 102   1              P3M0 &= 0x7F;
 103   1              P3M1 |= 0x80;   
 104   1              //总线电平设置
 105   1              Bus0SendPin = 0;
 106   1              Bus0RecPin = 1;  
 107   1              //---------------------------------------------
 108   1              //--------------------------------------------- 
 109   1              //定时器0初始化:自动重载方式,定时93.75us     
 110   1          //TMOD |= 0x02;
 111   1              //TL0 = TIMER0_COUNT;
 112   1              //TH0 = TIMER0_COUNT;
 113   1              //---------------------------------------------
 114   1              //---------------------------------------------
 115   1              TMOD |= 0x21;
 116   1              TL0 = TIMER0_L;
C51 COMPILER V9.00   SINGLEBUS                                                             02/17/2017 20:25:02 PAGE 3   

 117   1              TH0 = TIMER0_H;
 118   1              //---------------------------------------------
 119   1              //---------------------------------------------
 120   1              TF0 = 0;                                                                                                //清除中断标志                                                                          
 121   1              AUXR &= 0x1F;                                                                                   //传统12分频速度  
 122   1              ET0 = 1;                                                                                                //允许定时器0中断 
 123   1              TR0 = 1;                                                                                                //启动定时器
 124   1              //其它控制设置
 125   1              byBus0SendStopCount = 240;                                                              //上电总线0禁止发送时间设置             
 126   1              IE0 = 0;                                                                                                //清除中断标志
 127   1              IT0 = 1;                                                                                                //外部中断0为下降沿触发模式                                     
 128   1              if(Bus0RecPin)
 129   1              {       //如果总线正常,开中断   
 130   2                      EX0 = 1;
 131   2              }
 132   1              else
 133   1              {       //如果总线不正常,置总线故障标志                                         
 134   2                      bBus0Error = 1;
 135   2              }       
 136   1      }
 137          /**********************************************************
 138          *函数名称                       :Bus0RecInt     
 139          *函数描述               :外部中断0函数,单总线0接收中断
 140          *输入参数               :
 141          *返回值                         :       
 142          *全局变量                       :
 143          *调用模块                       :
 144          ***********************************************************
 145          *创建人                 :陈卫国
 146          *创建日期                       :2008-9-22
 147          ***********************************************************
 148          *修改人                         :
 149          *修改日期               :
 150          *注释                   :
 151          **********************************************************/
 152          #pragma disable
 153          void Bus0RecInt(void) interrupt 0
 154          { 
 155   1              DisableBus0RecInt();                                                                    //禁止再次下降沿中断
 156   1              bBus0StartRec = 1;                                                                              //启动起始位沿检测
 157   1              bBus0Enable = 0;                                                                                //禁止总线发送                                                  
 158   1              byBus0RecCount = 0;                                                                             //清接收寄存器  
 159   1              IRByteCount=0;  
 160   1      }
 161          /**********************************************************
 162          *函数名称                       :Timer0Int      
 163          *函数描述               :定时器0溢出中断,定时器每93.75us中断一次
 164                                                   程序间隔检查总线0与总线1的接收和发送
 165          *输入参数               :
 166          *返回值                         :       
 167          *全局变量                       :
 168          *调用模块                       :
 169          ***********************************************************
 170          *创建人                 :陈卫国
 171          *创建日期                       :2008-9-22
 172          ***********************************************************
 173          *修改人                         :
 174          *修改日期               :
 175          *注释                   :
 176          **********************************************************/
 177          #pragma disable
 178          void Timer0Int(void) interrupt 1
C51 COMPILER V9.00   SINGLEBUS                                                             02/17/2017 20:25:02 PAGE 4   

 179          { 
 180   1          TR0=0;
 181   1              TH0=TIMER0_H;
 182   1              TL0=TIMER0_L;
 183   1              TR0=1;
 184   1      
 185   1              bBus0RecBit = Bus0RecPin;       
 186   1              
 187   1              /*******************************总线0接收处理***********************************/
 188   1              if(bBus0StartRec)                                                                               //判断总线所处的状态，接收到起始位
 189   1              {                       
 190   2                      byBus0RecCount += 0x10;                                                         //增加定时中断计数次数
 191   2                      if(0x50 == (byBus0RecCount & 0xf0))                                     //到总线起始位检测时间
 192   2                      {                       
 193   3                              bBus0StartRec = 0;
 194   3                              byBus0RecCount = 0x00;                                                  //重新开始计数                  
 195   3                              if(bBus0RecBit)                 
 196   3                              {       //无效起始位                                                                                                                                            
 197   4                                      if((!bBus0SendError)&&bBus0OnSendFreq)
 198   4                                      {       //没有发生过总线发送错误,且有一帧数据正在发送,停止帧数据发送,置发送错误标志                                             
 199   5                                              byBus0State0 &= (~BUS0_SEND_CON);
 200   5                                              bBus0SendError = 1;
 201   5                                              Bus0SendPin = 0;                                                //释放总线                                      
 202   5                                      }                               
 203   4                                      byBus0SendStopCount = 240;                                      
 204   4                                      byBus0RecSendCount = 0x00;                                      //接收出错,重置接收发送计数值
 205   4                                      EnableBus0RecInt();                             
 206   4                              }
 207   3                              else                                                            
 208   3                              {       //有效起始位
 209   4                                      bBus0OnRec = 1;                                                         //开始接收数据位                                                                                        
 210   4                              }
 211   3                      }
 212   2              }
 213   1              else if(bBus0OnRec)
 214   1              {               
 215   2                      byBus0RecCount += 0x10;                                                         //增加定时中断计数次数                  
 216   2                      if(0xa0 == (byBus0RecCount & 0xf0))
 217   2                      {
 218   3                              byBus0RecCount &= 0x0f;                                                 //清除定时中断计数次数
 219   3                              byBus0RecCount += 0x01;
 220   3                              if(0x0a == (byBus0RecCount & 0x0f))     
 221   3                              {       //收到第10位,结束位                                     
 222   4                                      bBus0OnRec = 0;                                                         //停止数据接收                                  
 223   4                                      if(bBus0RecBit)
 224   4                                      {       //有效的结束位                                                  
 225   5                                              if(((bit)(byBus0RecSendCount & 0xf0) == bBus0RecBit9)) 
 226   5                                              {       //数据桢错误
 227   6                                                      byBus0RecTimeOut = 0;
 228   6                                                      byBus0RecSendCount &= 0x0f;                                                                                     
 229   6                                              }
 230   5                                              else 
 231   5                                              {       //数据桢正确                                    
 232   6                                                      byBus0RecTimeOut = 230;                         //设置下一个字节数据接收超时时间
 233   6                                                      byBus0RecData[byBus0RecSendCount>>4] = byBus0RecBuf;
 234   6                                                      byBus0RecSendCount += 0x10;                                                                                                                                                                     
 235   6                                                      if((byBus0RecSendCount & 0xf0) >= BUS0_FREQ_SIZE_HI)
 236   6                                                      {                                                                                                                                                                               
 237   7                                                              byBus0RecSendCount &= 0x0f;                                                     
 238   7                                                              if(!((bBus0OnSendFreq == 1)&&(bBus0ReqSend == 0)))
 239   7                                                              {       //如果接收到的这帧数据是自己发送的不置标志                                                      
 240   8                                                                      bBus0RecFinish = 1;                                                                                                                                                                                                                                                                                                             
C51 COMPILER V9.00   SINGLEBUS                                                             02/17/2017 20:25:02 PAGE 5   

 241   8                                                              }                                                                                                                                               
 242   7                                                              byBus0RecTimeOut = 0;
 243   7                                                              byBus0DisableCount = 10;
 244   7                                                              bBus0Disable = 1;                               //禁止总线使用                                                  
 245   7                                                      }       
 246   6                                              }                               
 247   5                                              byBus0SendStopCount = 240;
 248   5                                              EnableBus0RecInt();                                             
 249   5                                      }
 250   4                                      else                                                    
 251   4                                      {       //无效结束位
 252   5                                              bBus0Error = 1;                                                                         
 253   5                                              if((!bBus0SendError) && bBus0OnSendFreq)
 254   5                                              {       //没有发生过总线发送错误,且有一帧数据正在发送,停止帧数据发送,置发送错误标志
 255   6                                                      byBus0State0 &= (~BUS0_SEND_CON);
 256   6                                                      bBus0SendError = 1;                                                     
 257   6                                                      Bus0SendPin = 0;                                        //释放总线
 258   6                                              }
 259   5                                              byBus0RecSendCount = 0x00;                              //接收出错,重置接收发送计数值                                   
 260   5                                      }
 261   4                              }
 262   3                              else if(0x09 == (byBus0RecCount & 0x0f))
 263   3                              {       //第9位数据
 264   4                                      bBus0RecBit9 = bBus0RecBit;                                     
 265   4                              }
 266   3                              else                                                                                    
 267   3                              {       //有效数据位
 268   4                                      byBus0RecBuf >>= 1;
 269   4                                      if(bBus0RecBit)
 270   4                                      {       //为高电平
 271   5                                              byBus0RecBuf |= 0x80;
 272   5                                      }       
 273   4                              }
 274   3                      }
 275   2              }
 276   1              /*******************************总线0发送处理***********************************/
 277   1              if((byBus0State0 & BUS0_CAN_SEND) == BUS0_CAN_SEND)
 278   1              {       //总线0上有数据发送请求,且总线允许发送          
 279   2                      if(bBus0RecBit)
 280   2                      {       //总线正常,可以发送
 281   3                              Bus0SendPin = 1;
 282   3                              bBus0SendBit = 0;                                                               //发送起始位数据                        
 283   3                              byBus0SendCount = 0;
 284   3                              byBus0State0 &= (~BUS0_CAN_SEND);
 285   3                              byBus0SendBuf = byBus0SendData[byBus0RecSendCount & 0x0f];
 286   3                              bBus0OnSendBit = 1;                                                             //取出待发送的数据并置正在发送标志              
 287   3                      }
 288   2                      else
 289   2                      {       //总线不正常,停止发送
 290   3                              byBus0State0 &= (~BUS0_SEND_CON);
 291   3                              bBus0SendError = 1;                     
 292   3                              byBus0RecSendCount &= 0xf0;
 293   3                              Bus0SendPin = 0;
 294   3                              byBus0SendStopCount = 240;
 295   3                      }
 296   2              }
 297   1              else if(bBus0OnSendBit)
 298   1              {       //有数据位正在发送,首先发送的是起始位                   
 299   2                      byBus0SendCount += 0x10;
 300   2                      if(0x50 == (byBus0SendCount & 0xf0))
 301   2                      {
 302   3                              if(bBus0SendBit == bBus0RecBit)  bBus0SndBitOk=1;
C51 COMPILER V9.00   SINGLEBUS                                                             02/17/2017 20:25:02 PAGE 6   

 303   3                              else
 304   3                              {       //不相同,发送失败                                                               
 305   4                                      byBus0State0 &= ~BUS0_SEND_CON;
 306   4                                      byBus0RecSendCount &= 0xf0;
 307   4                                      bBus0SendError = 1;                                     
 308   4                                      Bus0SendPin = 0; 
 309   4                                      byBus0SendStopCount = 240;
 310   4                                      bBus0SndBitOk =0;
 311   4                              }                       
 312   3                      }
 313   2                      //if(bBus0SendBit == bBus0RecBit)       
 314   2                      else if(bBus0SndBitOk==1)
 315   2                      {       //发送的数据和接收的数据相同
 316   3                              //byBus0SendCount += 0x10;
 317   3                              if(0xa0 == (byBus0SendCount & 0xf0))
 318   3                              {       //一位数据发送完毕,首先发送的是起始位
 319   4                                      bBus0SndBitOk=0;
 320   4                                      
 321   4                                      byBus0SendCount &= 0x0f;
 322   4                                      byBus0SendCount += 0x01;                                
 323   4                                      if(0x09 == (byBus0SendCount & 0x0f))
 324   4                                      {       //发送到第9位了
 325   5                                              bBus0SendBit = !(bit)(byBus0RecSendCount & 0x0f);
 326   5                                              Bus0SendPin = !bBus0SendBit;                                            
 327   5                                      }
 328   4                                      else if(0x0a == (byBus0SendCount & 0x0f))
 329   4                                      {       //发送到结束位了
 330   5                                              bBus0SendBit = 1;
 331   5                                              Bus0SendPin = 0;        
 332   5                                      }
 333   4                                      else if(0x0b == (byBus0SendCount & 0x0f))
 334   4                                      {       //已经发送完结束位了
 335   5                                              bBus0OnSendBit = 0;                                             
 336   5                                              byBus0RecSendCount += 0x01;                                                                     
 337   5                                              if((byBus0RecSendCount & 0x0f) >= BUS0_FREQ_SIZE)
 338   5                                              {       //发送完一帧数据                                                                                                
 339   6                                                      byBus0RecSendCount &= 0xf0;                     //重新进入数据帧的发送阶段
 340   6                                                      byBus0State0 &= (~BUS0_SEND_CON);
 341   6                                                      byBus0SendStopCount = 240;
 342   6                                                      byBus0State1 |= BUS0_SEND_FINISH;                                                               
 343   6                                                      byBus0DisableCount = 10;                                                
 344   6                                              }
 345   5                                              else
 346   5                                              {                                               
 347   6                                                      byBus0SendStopCount = 10;
 348   6                                                      bBus0ReqSend = 1;
 349   6                                              }
 350   5                                              EnableBus0RecInt();                                             //再次使能接收中断
 351   5                                      }
 352   4                                      else
 353   4                                      {
 354   5                                              if(byBus0SendBuf & 0x01)
 355   5                                              {       //发送高电平
 356   6                                                      bBus0SendBit = 1;
 357   6                                                      Bus0SendPin = 0;                                        
 358   6                                              }
 359   5                                              else
 360   5                                              {       //发送低电平
 361   6                                                      bBus0SendBit = 0;
 362   6                                                      Bus0SendPin = 1;
 363   6                                              }
 364   5                                              byBus0SendBuf >>= 1;                                    //发送数据位移位操作
C51 COMPILER V9.00   SINGLEBUS                                                             02/17/2017 20:25:02 PAGE 7   

 365   5                                      }
 366   4                              }
 367   3                      }
 368   2      /*              else
 369   2                      {       //不相同,发送失败                                                               
 370   2                              byBus0State0 &= ~BUS0_SEND_CON;
 371   2                              byBus0RecSendCount &= 0xf0;
 372   2                              bBus0SendError = 1;                                     
 373   2                              Bus0SendPin = 0; 
 374   2                              byBus0SendStopCount = 240;
 375   2                      }*/
 376   2              }       
 377   1              /*******************************总线0控制处理***********************************/
 378   1              if(0 == (byBus0State0 & BUS0_ON_REC))
 379   1              {       
 380   2                      if(byBus0SendStopCount != 0)
 381   2                      {
 382   3                              if((--byBus0SendStopCount) == 0)
 383   3                              {                               
 384   4                                      bBus0Enable = 1;                                                                
 385   4                              }
 386   3                      }               
 387   2                      if(bBus0Error)
 388   2                      {                                                               
 389   3                              bBus0Enable = 0;                        
 390   3                              if(bBus0RecBit)
 391   3                              {                               
 392   4                                      bBus0Error = 0;
 393   4                                      EnableBus0RecInt();
 394   4                                      byBus0SendStopCount = 240;
 395   4                              }
 396   3                      }
 397   2              }       
 398   1              /*******************************总线0超时处理***********************************/
 399   1              if(byBus0RecTimeOut != 0)
 400   1              {
 401   2                      if(--byBus0RecTimeOut == 0)                                                     
 402   2                      {       //接收超时到
 403   3                              byBus0RecSendCount &= 0x0f;                     
 404   3                      }
 405   2              }
 406   1              if(byBus0DisableCount != 0)
 407   1              {
 408   2                      if(--byBus0DisableCount == 0)                                           
 409   2                      {       //禁止超时到            
 410   3                              bBus0Disable = 0;
 411   3                      }
 412   2              }       
 413   1              /***********总线0自动发送管理**********/         
 414   1              if((byBus0State0 & BUS0_ON_WORK) == 0x00)                               
 415   1              {       //总线0没有工作                         
 416   2                      if(bBus0SendError)                                              
 417   2                      {       //产生了发送错误,自动重发                                                               
 418   3                              bBus0SendError = 0;                             
 419   3                              byBus0State0 |= BUS0_REQ_SEND;          
 420   3                      }
 421   2                      else                                                                    
 422   2                      {       //总线0无发送错误               
 423   3                              if(!(bBus0SendFinish|bBus0Disable))
 424   3                              {       //总线0没有禁止使用,且发送结束处理已经完成
 425   4                                      if(Bus0TxBuffLen() >= BUS0_FREQ_SIZE)
 426   4                                      {       //有一帧完整的数据在发送队列中                                                                                                                                          
C51 COMPILER V9.00   SINGLEBUS                                                             02/17/2017 20:25:02 PAGE 8   

 427   5                                              byBus0SendData[0] = byBus0TxQ[byBus0TxHead];
 428   5                                              IncBus0TxPtr(byBus0TxHead);
 429   5                                              byBus0SendData[1] = byBus0TxQ[byBus0TxHead];
 430   5                                              IncBus0TxPtr(byBus0TxHead);
 431   5                                              byBus0SendData[2] = byBus0TxQ[byBus0TxHead];
 432   5                                              IncBus0TxPtr(byBus0TxHead);
 433   5                                              byBus0SendData[3] = byBus0TxQ[byBus0TxHead];
 434   5                                              IncBus0TxPtr(byBus0TxHead);
 435   5                                              byBus0SendData[4] = byBus0TxQ[byBus0TxHead];
 436   5                                              IncBus0TxPtr(byBus0TxHead);
 437   5                                              byBus0SendData[5] = byBus0TxQ[byBus0TxHead];
 438   5                                              IncBus0TxPtr(byBus0TxHead);
 439   5                                              byBus0SendData[6] = byBus0TxQ[byBus0TxHead];
 440   5                                              IncBus0TxPtr(byBus0TxHead);     
 441   5                                              byBus0State0 |= BUS0_REQ_SEND;                                          
 442   5                                      }
 443   4                                      else
 444   4                                      {       //没有一帧完整的数据在发送队列中了
 445   5                                              byBus0TxHead = byBus0TxTail = 0;
 446   5                                      }                                                               
 447   4                              }
 448   3                      }
 449   2              }       
 450   1      } 
 451          /**********************************************************
 452          *函数名称                       :Bus0OutputData 
 453          *函数描述               :单总线0将待发送数据放入缓冲区
 454          *输入参数               :pbyData:待发送的数据指针
 455          *返回值                         :TRUE:发送成功,FALSE:队列满,发送失败    
 456          *全局变量                       :
 457          *调用模块                       :
 458          ***********************************************************
 459          *创建人                 :陈卫国
 460          *创建日期                       :2008-9-22
 461          ***********************************************************
 462          *修改人                         :
 463          *修改日期               :
 464          *注释                   :
 465          **********************************************************/
 466          uint8 Bus0OutputData(uint8* pbyData)
 467          {
 468   1              uint8 byTemp = BUS0_FREQ_SIZE;
 469   1      
 470   1              OS_ENTER_CRITICAL();
 471   1              if(Bus0TxBuffLen() >= (BUS0_TX_Q_ZISE - 1))
 472   1              {       //没有空间存储了,失败   
 473   2                      OS_EXIT_CRITICAL();
 474   2                      return(FALSE);
 475   2              }       
 476   1              while(byTemp--)
 477   1              {       //数据入发送队列
 478   2                      byBus0TxQ[byBus0TxTail] = *pbyData++;
 479   2                      IncBus0TxPtr(byBus0TxTail);
 480   2              }
 481   1              OS_EXIT_CRITICAL();     
 482   1              return(TRUE);   
 483   1      }
 484          /**********************************************************
 485          *函数名称                       :AddrCompare    
 486          *函数描述               :比较地址(含广播地址)
 487          *输入参数               :pstBusFreq:待比较的数据帧指针
 488          *返回值                         :1:发送到本机的数据,0:不是发送到本机的数据      
C51 COMPILER V9.00   SINGLEBUS                                                             02/17/2017 20:25:02 PAGE 9   

 489          *全局变量                       :
 490          *调用模块                       :
 491          ***********************************************************
 492          *创建人                 :陈卫国
 493          *创建日期                       :2008-9-22
 494          ***********************************************************
 495          *修改人                         :
 496          *修改日期               :
 497          *注释                   :
 498          **********************************************************/
 499          bit AddrCompare(pSTBusFreq pstBusFreq)
 500          {
 501   1              if((pstBusFreq->byRecSecAddr != 0xff) && (pstBusFreq->byRecSecAddr != stLocalControl.stEepromCfgData.bySe
             -lfSecAddr))
 502   1              {       
 503   2                      return(0);
 504   2              } 
 505   1              if((pstBusFreq->byRecRoomAddr != 0xff) && (pstBusFreq->byRecRoomAddr != stLocalControl.stEepromCfgData.by
             -SelfRoomAddr))
 506   1              {       
 507   2                      return(0);
 508   2              }
 509   1              if((pstBusFreq->byRecBedAddr != 0xff) && (pstBusFreq->byRecBedAddr != stLocalControl.stEepromCfgData.bySe
             -lfBedAddr))
 510   1              {       
 511   2                      return(0);
 512   2              }
 513   1              return(1); 
 514   1      }
 515          /**********************************************************
 516          *函数名称                       :DirAddrCompare 
 517          *函数描述               :绝对比较地址
 518          *输入参数               :pstBusFreq:待比较的数据帧指针
 519          *返回值                         :1:发送到本机的数据,0:不是发送到本机的数据      
 520          *全局变量                       :
 521          *调用模块                       :
 522          ***********************************************************
 523          *创建人                 :陈卫国
 524          *创建日期                       :2008-9-22
 525          ***********************************************************
 526          *修改人                         :
 527          *修改日期               :
 528          *注释                   :
 529          **********************************************************/
 530          bit DirAddrCompare(pSTBusFreq pstBusFreq)
 531          {
 532   1              if(pstBusFreq->byRecSecAddr != stLocalControl.stEepromCfgData.bySelfSecAddr)
 533   1              {       
 534   2                      return(0);
 535   2              } 
 536   1              if(pstBusFreq->byRecRoomAddr != stLocalControl.stEepromCfgData.bySelfRoomAddr)
 537   1              {       
 538   2                      return(0);
 539   2              }
 540   1              if(pstBusFreq->byRecBedAddr != stLocalControl.stEepromCfgData.bySelfBedAddr)
 541   1              {       
 542   2                      return(0);
 543   2              }
 544   1              return(1); 
 545   1      }
 546          /**********************************************************
 547          *函数名称                       :MakeCH0TimerOut        
C51 COMPILER V9.00   SINGLEBUS                                                             02/17/2017 20:25:02 PAGE 10  

 548          *函数描述               :设置通道0超时参数
 549          *输入参数               :byTimerOut:超时时间,byTimerOutCount:超时次数
 550          *返回值                         :
 551          *全局变量                       :stLocalControl
 552          *调用模块                       :
 553          ***********************************************************
 554          *创建人                 :陈卫国
 555          *创建日期                       :2008-9-22
 556          ***********************************************************
 557          *修改人                         :
 558          *修改日期               :
 559          *注释                   :
 560          **********************************************************/  
 561          void MakeCH0TimerOut(uint8 byTimerOut, uint8 byTimerOutCount)
 562          {
 563   1              stLocalControl.stCH0TimerOut.byTimerOutSet = byTimerOut;
 564   1              stLocalControl.stCH0TimerOut.byTimerOut = byTimerOut;
 565   1              stLocalControl.stCH0TimerOut.byTimerOutCount = byTimerOutCount; 
 566   1      }
 567          /**********************************************************
 568          *函数名称                       :SaveParameter  
 569          *函数描述               :存储配置参数,存储参数前先擦除整个扇区,
 570                                                   然后将所有参数重新写入扇区
 571          *输入参数               :
 572          *返回值                         :
 573          *全局变量                       :stLocalControl
 574          *调用模块                       :EnableIAP,IapErase,IapWriteByte,DisableIAP
 575          ***********************************************************
 576          *创建人                 :陈卫国
 577          *创建日期                       :2008-9-22
 578          ***********************************************************
 579          *修改人                         :
 580          *修改日期               :
 581          *注释                   :
 582          **********************************************************/
 583          void SaveParameter(void)
 584          {  
 585   1              stLocalControl.uiShortType = IAP_ADDR;  
 586   1              stLocalControl.pbyData = &(stLocalControl.stEepromCfgData.bySelfSecAddr);
 587   1              stLocalControl.byChar = sizeof(STEepromCfgData);
 588   1              EnableIAP(IAP_ERASE);
 589   1              IapErase(IAP_ADDR);     
 590   1              EnableIAP(IAP_WRITE); 
 591   1              while(stLocalControl.byChar--)
 592   1              {
 593   2                      IapWriteByte(stLocalControl.uiShortType++, *stLocalControl.pbyData++);
 594   2              }
 595   1              DisableIAP();   
 596   1              //---------------------------------------------
 597   1              //---------------------------------------------
 598   1              EnableIAP(IAP_ERASE);
 599   1              IapErase(0x0800);       
 600   1              EnableIAP(IAP_WRITE);
 601   1              IapWriteByte(0x0800,INIT_FLAG);
 602   1              DisableIAP();
 603   1              //---------------------------------------------
 604   1              //---------------------------------------------
 605   1      
 606   1      }
 607          /**********************************************************
 608          *函数名称                       :ReadParameter  
 609          *函数描述               :将Flash中的配置数据读入到内存中
C51 COMPILER V9.00   SINGLEBUS                                                             02/17/2017 20:25:02 PAGE 11  

 610          *输入参数               :
 611          *返回值                         :
 612          *全局变量                       :stLocalControl
 613          *调用模块                       :EnableIAP,IapReadByte,DisableIAP
 614          ***********************************************************
 615          *创建人                 :陈卫国
 616          *创建日期                       :2008-9-22
 617          ***********************************************************
 618          *修改人                         :
 619          *修改日期               :
 620          *注释                   :
 621          **********************************************************/
 622          void ReadParameter(void)
 623          {
 624   1              stLocalControl.uiShortType = IAP_ADDR;
 625   1              stLocalControl.pbyData = &(stLocalControl.stEepromCfgData.bySelfSecAddr);
 626   1              stLocalControl.byChar = sizeof(STEepromCfgData);
 627   1              EnableIAP(IAP_READ);            
 628   1              while(stLocalControl.byChar--)
 629   1              {               
 630   2                      *stLocalControl.pbyData++ = IapReadByte(stLocalControl.uiShortType++);          
 631   2              }
 632   1              DisableIAP();   
 633   1      }
 634          /**********************************************************
 635          *函数名称                       :Bus0RecDeal    
 636          *函数描述               :单总线0收到一帧数据处理函数,该函数首先
 637                                                   取出收到的数据,针对每条命令执行对应的控
 638                                                   制动作
 639          *输入参数               :
 640          *返回值                         :
 641          *全局变量                       :stLocalControl
 642          *调用模块                       :
 643          ***********************************************************
 644          *创建人                 :陈卫国
 645          *创建日期                       :2008-9-22
 646          ***********************************************************
 647          *修改人                         :
 648          *修改日期               :
 649          *注释                   :
 650          **********************************************************/
 651          void Bus0RecDeal(void)
 652          {       
 653   1              //取出收到的数据帧                      
 654   1              OS_ENTER_CRITICAL();
 655   1              memcpy(&(stLocalControl.stBusDealFreq), byBus0RecData, sizeof(STBusFreq));
 656   1              bBus0RecFinish = 0;     
 657   1              OS_EXIT_CRITICAL();     
 658   1              if(bLanding && (stLocalControl.stBusDealFreq.byCmd != CMD_ENTER))
 659   1              {       //如果是登记状态,收到的命令不是登记确认命令,不作处理    
 660   2                      return;
 661   2              }
 662   1              switch(stLocalControl.stBusDealFreq.byCmd)
 663   1              {
 664   2                case CMD_ENTER:                                                                               //确认登记命令
 665   2                              if(bLanding)
 666   2                              {       
 667   3                                      if(AddrCompare(&(stLocalControl.stBusDealFreq)))
 668   3                                      {       
 669   4                                              bLanding = 0;
 670   4                                              stLocalControl.byLedTime = 50;
 671   4                                              if(stLocalControl.stEepromCfgData.byFlag&0x01)
C51 COMPILER V9.00   SINGLEBUS                                                             02/17/2017 20:25:02 PAGE 12  

 672   4                                              {       //设定为灯长亮
 673   5                                                      SetLedRedState(LED_ON); 
 674   5                                              }
 675   4                                              else
 676   4                                              {       //设定为灯灭
 677   5                                                      SetLedRedState(LED_OFF);        
 678   5                                              }                               
 679   4                                              MakeCH0TimerOut(0, 0);                                                                          
 680   4                                      }
 681   3                              }                       
 682   2                              break;  
 683   2                      case CMD_QUEST:                                                                         //查询命令
 684   2                              if(AddrCompare(&(stLocalControl.stBusDealFreq)))
 685   2                              {
 686   3                                      stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
 687   3                                      stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
 688   3                                      stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
 689   3                                      stLocalControl.stBusDealFreq.byCmd = CMD_ANSWER;                        
 690   3                                      Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
 691   3                              }
 692   2                              break;
 693   2                      case CMD_EMERGENCY_ENTER:                                                       //确认紧急呼叫命令
 694   2                              if(AddrCompare(&(stLocalControl.stBusDealFreq)))
 695   2                              {       //是确认本机的呼叫,设置灯闪烁,置正在呼叫标志    
 696   3                                      SetLedRedState(LED_FLASH);      
 697   3                                      bCalling = 1;   
 698   3                              }       
 699   2                              break; 
 700   2                      case CMD_EMERGENCY_CLEAR:                                                       //清除紧急呼叫命令 
 701   2                      case CMD_EMERGENCY_ANSWER:                                                      //处理紧急呼叫命令                      
 702   2                              if(AddrCompare(&(stLocalControl.stBusDealFreq)))
 703   2                              {       //处理或者清除本机的呼叫,停止灯闪烁,清正在呼叫标志      
 704   3                                      if(stLocalControl.stEepromCfgData.byFlag&0x01)
 705   3                                      {       //设定为灯长亮
 706   4                                              SetLedRedState(LED_ON); 
 707   4                                      }
 708   3                                      else
 709   3                                      {       //设定为灯灭
 710   4                                              SetLedRedState(LED_OFF);        
 711   4                                      }
 712   3                                      bCalling = 0;   
 713   3                              }                       
 714   2                              break;                  
 715   2                      case CMD_SYSTERM_RESET:                                                         //系统复位命令
 716   2                              if(stLocalControl.stEepromCfgData.byFlag&0x01)
 717   2                              {       //设定为灯长亮
 718   3                                      SetLedRedState(LED_ON); 
 719   3                              }
 720   2                              else
 721   2                              {       //设定为灯灭
 722   3                                      SetLedRedState(LED_OFF);        
 723   3                              }       
 724   2                              bCalling = 0;   
 725   2                              break;                  
 726   2                      case CMD_NUMBER_SET:                                                            //修改地址命令
 727   2                              if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
 728   2                              {
 729   3                                      //保存新的地址数据                              
 730   3                                      stLocalControl.stEepromCfgData.bySelfSecAddr = stLocalControl.stBusDealFreq.bySndSecAddr;
 731   3                                      stLocalControl.stEepromCfgData.bySelfRoomAddr = stLocalControl.stBusDealFreq.bySndRoomAddr;
 732   3                                      stLocalControl.stEepromCfgData.bySelfBedAddr = stLocalControl.stBusDealFreq.bySndBedAddr;                                       
 733   3                                      //发送占用总线命令
C51 COMPILER V9.00   SINGLEBUS                                                             02/17/2017 20:25:02 PAGE 13  

 734   3                                      stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS;                       
 735   3                                      Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                   
 736   3                              }
 737   2                              break;
 738   2                      case CMD_ONLINE_WRITE:                                                          //在线写入命令
 739   2                              if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
 740   2                              {       
 741   3                                      if(stLocalControl.stBusDealFreq.bySndSecAddr >= sizeof(STEepromCfgData))
 742   3                                      {       //参数不正确
 743   4                                              break;
 744   4                                      }
 745   3                                      //存储数据
 746   3                                      stLocalControl.pbyData = &(stLocalControl.stEepromCfgData.bySelfSecAddr);
 747   3                                      stLocalControl.pbyData[stLocalControl.stBusDealFreq.bySndSecAddr] = stLocalControl.stBusDealFreq.bySnd
             -RoomAddr;                                
 748   3                                      //发送占用总线命令
 749   3                                      stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS;                       
 750   3                                      Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                   
 751   3                              }
 752   2                              break;
 753   2                      case CMD_ONLIEN_READ:                                                           //在线读出命令
 754   2                              if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
 755   2                              {
 756   3                                      if(stLocalControl.stBusDealFreq.bySndSecAddr >= sizeof(STEepromCfgData))
 757   3                                      {       //参数不正确
 758   4                                              break;
 759   4                                      }                       
 760   3                                      stLocalControl.uiShortType = IAP_ADDR + stLocalControl.stBusDealFreq.bySndSecAddr;
 761   3                                      EnableIAP(IAP_READ);    
 762   3                                      stLocalControl.stBusDealFreq.bySndRoomAddr = IapReadByte(stLocalControl.uiShortType);           
 763   3                                      DisableIAP();
 764   3                                      stLocalControl.stBusDealFreq.byCmd = CMD_ONLINE_OUTPUT;
 765   3                                      Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));   
 766   3                              }               
 767   2                              break;
 768   2                      case CMD_POWER_ON:                                                                      //本机重新热启动
 769   2                              if(AddrCompare(&(stLocalControl.stBusDealFreq)))
 770   2                              {                       
 771   3                                      OS_ENTER_CRITICAL();                                            //关闭中断
 772   3                                      CCAPM0 = 0;
 773   3                                      ET0 = 0;
 774   3                                      TR0 = 0;
 775   3                                      EX0 = 0;
 776   3                                      ISP_CONTR = 0x20;       
 777   3              
 778   3                              } 
 779   2                              break;  
 780   2                      case CMD_WRITE_SERIAL:                                                          //写入序列号命令
 781   2                              if(stLocalControl.stBusDealFreq.byRecSecAddr != stLocalControl.stEepromCfgData.bySerialNum1)
 782   2                              {
 783   3                                      return;
 784   3                              }
 785   2                              if(stLocalControl.stBusDealFreq.byRecRoomAddr != stLocalControl.stEepromCfgData.bySerialNum2)
 786   2                              {
 787   3                                      return;
 788   3                              }
 789   2                              if(stLocalControl.stBusDealFreq.byRecBedAddr != stLocalControl.stEepromCfgData.bySerialNum3)
 790   2                              {
 791   3                                      return;
 792   3                              }
 793   2                              //序列号正确,更改序列号
 794   2                              stLocalControl.stEepromCfgData.bySerialNum1 = stLocalControl.stBusDealFreq.bySndSecAddr;
C51 COMPILER V9.00   SINGLEBUS                                                             02/17/2017 20:25:02 PAGE 14  

 795   2                              stLocalControl.stEepromCfgData.bySerialNum2 = stLocalControl.stBusDealFreq.bySndRoomAddr;
 796   2                              stLocalControl.stEepromCfgData.bySerialNum3 = stLocalControl.stBusDealFreq.bySndBedAddr;
 797   2                              stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS;
 798   2                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
 799   2                              break; 
 800   2                      case CMD_READ_SERIAL:                                                           //读序列号命令
 801   2                              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySerialNum1;
 802   2                              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySerialNum2;
 803   2                              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySerialNum3;
 804   2                              stLocalControl.stBusDealFreq.byCmd = CMD_OUT_SERIAL;
 805   2                              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.bySerialNum1;
 806   2                              stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stEepromCfgData.bySerialNum2;
 807   2                              stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stEepromCfgData.bySerialNum3;
 808   2                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
 809   2                              break;
 810   2                      case CMD_SET_BY_SERIAL:                                                         //根据序列号写地址命令  
 811   2                      /*      if(stLocalControl.stBusDealFreq.byRecSecAddr != stLocalControl.stEepromCfgData.bySerialNum1)
 812   2                              {
 813   2                                      return;
 814   2                              }
 815   2                              if(stLocalControl.stBusDealFreq.byRecRoomAddr != stLocalControl.stEepromCfgData.bySerialNum2)
 816   2                              {
 817   2                                      return;
 818   2                              }
 819   2                              if(stLocalControl.stBusDealFreq.byRecBedAddr != stLocalControl.stEepromCfgData.bySerialNum3)
 820   2                              {
 821   2                                      return;
 822   2                              } 
 823   2                              //序列号正确,保存新的地址数据   
 824   2                              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
 825   2                              stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
 826   2                              stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;                                       
 827   2                              stLocalControl.stEepromCfgData.bySelfSecAddr = stLocalControl.stBusDealFreq.bySndSecAddr;
 828   2                              stLocalControl.stEepromCfgData.bySelfRoomAddr = stLocalControl.stBusDealFreq.bySndRoomAddr;
 829   2                              stLocalControl.stEepromCfgData.bySelfBedAddr = stLocalControl.stBusDealFreq.bySndBedAddr;                                       
 830   2                              //发送占用总线命令
 831   2                              stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS;                       
 832   2                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));  */
 833   2                              //-------------------------------------------------------------------
 834   2                              //-------------------------------------------------------------------
 835   2                              // 开始对设备进行编号
 836   2                              if(stLocalControl.stBusDealFreq.bySndBedAddr==0x00) //床号为0表示为厕所分机编号
 837   2                               {
 838   3                                 SET_BY_SERIAL_FLAG=1;
 839   3                             SetLedRedState(LED_FLASH);
 840   3                               }
 841   2                              //-------------------------------------------------------------------
 842   2                              //-------------------------------------------------------------------
 843   2                              break;
 844   2                      case CMD_SET_SEC_SERIAL:
 845   2                              stLocalControl.stEepromCfgData.bySelfSecAddr=stLocalControl.stBusDealFreq.byRecSecAddr;
 846   2                              SaveParameter();
 847   2                              break;  
 848   2                  case CMD_BUS_TEST:                 //如果是总线测试命令
 849   2                          stLocalControl.stBusDealFreq.bySndSecAddr  = stLocalControl.stEepromCfgData.bySelfSecAddr;
 850   2                          stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
 851   2                      stLocalControl.stBusDealFreq.bySndBedAddr  = stLocalControl.stEepromCfgData.bySelfBedAddr;
 852   2                      stLocalControl.stBusDealFreq.byRecSecAddr  = CMD_BUS_TEST;
 853   2                      stLocalControl.stBusDealFreq.byRecRoomAddr = 0x00;
 854   2                      stLocalControl.stBusDealFreq.byRecBedAddr  = 0x00; 
 855   2                              stLocalControl.stBusDealFreq.byCmd = 0x02;                              
 856   2                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
C51 COMPILER V9.00   SINGLEBUS                                                             02/17/2017 20:25:02 PAGE 15  

 857   2                          break;              
 858   2              }       
 859   1      }
 860          /**********************************************************
 861          *函数名称                       :Bus0SendDeal   
 862          *函数描述               :单总线0发送完一帧数据处理函数,该函数首先
 863                                                   取出收到的数据,针对每条命令执行对应的控
 864                                                   制动作
 865          *输入参数               :
 866          *返回值                         :
 867          *全局变量                       :stLocalControl
 868          *调用模块                       :
 869          ***********************************************************
 870          *创建人                 :陈卫国
 871          *创建日期                       :2008-9-22
 872          ***********************************************************
 873          *修改人                         :
 874          *修改日期               :
 875          *注释                   :
 876          **********************************************************/
 877          void Bus0SendDeal(void)
 878          {       
 879   1              //取出发送完成的数据帧
 880   1              OS_ENTER_CRITICAL();
 881   1              memcpy(&(stLocalControl.stBusDealFreq), byBus0SendData, sizeof(STBusFreq));             
 882   1              bBus0SendFinish = 0;                                                                            
 883   1              OS_EXIT_CRITICAL();     
 884   1              switch(stLocalControl.stBusDealFreq.byCmd)
 885   1              {
 886   2                      case CMD_LANDING:                                                                       //登记命令
 887   2                              if(bLanding)
 888   2                              {       //本机确实处在登记状态,设置等待确认超时
 889   3                                      MakeCH0TimerOut(150, 0);        
 890   3                              }                       
 891   2                              break;                                  
 892   2                      case CMD_EMERGENCY_CLEAR:                                                       //清除紧急呼叫                  
 893   2                              if(stLocalControl.stEepromCfgData.byFlag&0x01)
 894   2                              {       //设定为灯长亮
 895   3                                      SetLedRedState(LED_ON); 
 896   3                              }
 897   2                              else
 898   2                              {       //设定为灯灭
 899   3                                      SetLedRedState(LED_OFF);        
 900   3                              }               
 901   2                              bCalling = 0;                                                   
 902   2                              break;  
 903   2                      case CMD_GET_BUS:                                                                       //占用总线
 904   2                              Bus0SendPin = 1;                                                                //制造总线故障
 905   2                              SaveParameter();
 906   2                              Bus0SendPin = 0;                                                                //释放总线                                      
 907   2                              break;          
 908   2              }       
 909   1      }
 910          /**********************************************************
 911          *函数名称                       :Bus0Manage     
 912          *函数描述               :单总线0管理线程
 913          *输入参数               :
 914          *返回值                         :
 915          *全局变量                       :byMainCmdQ
 916          *调用模块                       :OSQPost
 917          ***********************************************************
 918          *创建人                 :陈卫国
C51 COMPILER V9.00   SINGLEBUS                                                             02/17/2017 20:25:02 PAGE 16  

 919          *创建日期                       :2008-9-22
 920          ***********************************************************
 921          *修改人                         :
 922          *修改日期               :
 923          *注释                   :
 924          **********************************************************/
 925          void Bus0Manage(void)
 926          {       
 927   1              while(TRUE)
 928   1              {               
 929   2                      if(bBus0RecFinish)                                                                      //总线0收到数据
 930   2                      {                       
 931   3                              OSQPost(byMainCmdQ, BUS0_REC);                          
 932   3                      }
 933   2                      if(bBus0SendFinish)                                                                     //总线0发送完数据帧
 934   2                      {
 935   3                              OSQPost(byMainCmdQ, BUS0_SND);                  
 936   3                      } 
 937   2                      OSWait(K_TMO, 1);
 938   2                      WDT_CONTR = 0x3d;
 939   2              }
 940   1      }
 941          
 942          /*---------------------------------------------------------------------------
 943          函数原型: void Delayms(uint ms)
 944          参数说明: ms--需要延时的值
 945          返 回 值: 无
 946          函数功能：延时程序(对于18.432M晶振单指令周期延时1mS)
 947          ----------------------------------------------------------------------------*/
 948          /*void Delayms(uint16 ms)         
 949          {
 950             uint16 xdata i;
 951             for(;ms!=0;ms--)
 952                          for(i=900;i!=0;i--);
 953          }*/
 954          
 955          
 956          
 957          /**********************************************************
 958          *函数名称                       :TimerOutDeal   
 959          *函数描述               :超时处理函数
 960          *输入参数               :
 961          *返回值                         :
 962          *全局变量                       :stLocalControl
 963          *调用模块                       :Bus0OutputData                                  
 964          ***********************************************************
 965          *创建人                 :陈卫国
 966          *创建日期                       :2008-9-22
 967          ***********************************************************
 968          *修改人                         :
 969          *修改日期               :
 970          *注释                   :
 971          **********************************************************/
 972          void TimerOutDeal(void)
 973          { 
 974   1      
 975   1              //通道0超时处理         
 976   1              if(stLocalControl.stCH0TimerOut.byTimerOut != 0)
 977   1              {       //有超时设置存在
 978   2                      stLocalControl.stCH0TimerOut.byTimerOut--;
 979   2                      if(stLocalControl.stCH0TimerOut.byTimerOut == 0)
 980   2                      {       //超时一次到了 
C51 COMPILER V9.00   SINGLEBUS                                                             02/17/2017 20:25:02 PAGE 17  

 981   3                              if(stLocalControl.stCH0TimerOut.byTimerOutCount == 0x00)
 982   3                              {       //所有超时完成
 983   4                                      if(bLanding)
 984   4                                      {       //上电状态
 985   5                                              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
 986   5                                              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
 987   5                                              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
 988   5                                              stLocalControl.stBusDealFreq.byCmd = CMD_LANDING;
 989   5                                              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.bySerialNum1;
 990   5                                              stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stEepromCfgData.bySerialNum2;
 991   5                                              stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stEepromCfgData.bySerialNum3;
 992   5                                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
 993   5                                                                                                                      
 994   5                                      }                                       
 995   4                              }
 996   3                              else
 997   3                              {       //超时次数没有完
 998   4                                      stLocalControl.stCH0TimerOut.byTimerOutCount--;
 999   4                                      if(stLocalControl.stCH0TimerOut.byTimerOutCount == 0x00)
1000   4                                      {       //所有超时完成
1001   5                                              if(bLanding)
1002   5                                              {       //上电状态
1003   6                                                      stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1004   6                                                      stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1005   6                                                      stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1006   6                                                      stLocalControl.stBusDealFreq.byCmd = CMD_LANDING;
1007   6                                                      stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.bySerialNum1;
1008   6                                                      stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stEepromCfgData.bySerialNum2;
1009   6                                                      stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stEepromCfgData.bySerialNum3;
1010   6                                                      Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                           
1011   6                                              }                                                                       
1012   5                                      }
1013   4                                      else
1014   4                                      {       //超时次数没有完成，重新加载单位超时时间                                
1015   5                                              stLocalControl.stCH0TimerOut.byTimerOut = stLocalControl.stCH0TimerOut.byTimerOutSet;
1016   5                                      }                               
1017   4                              }                       
1018   3                      }
1019   2              } 
1020   1              if(--stLocalControl.byLedDelay == 0x00)
1021   1              {
1022   2                      stLocalControl.byLedDelay = stLocalControl.byLedTime;
1023   2                      if(stLocalControl.byLedState == LED_FLASH)
1024   2                      {       //如果灯为闪烁状态,交替灯的状态
1025   3                              bLedRedState = !bLedRedState;
1026   3                              LED_RED = LED_GREEN = bLedRedState;
1027   3                      }
1028   2              }
1029   1      
1030   1      
1031   1              //---------------------------------------------------------
1032   1              //---------------------------------------------------------
1033   1              if(SET_BY_SERIAL_FLAG)//如果收到设备编号命令，则开始5秒定时
1034   1               {
1035   2                 SET_BY_SERIAL_COUNT++;
1036   2               }
1037   1               else SET_BY_SERIAL_COUNT=0;
1038   1               
1039   1               if(SET_BY_SERIAL_COUNT>250)
1040   1               {
1041   2                      SET_BY_SERIAL_FLAG=0;
1042   2                      SET_BY_SERIAL_COUNT=0;
C51 COMPILER V9.00   SINGLEBUS                                                             02/17/2017 20:25:02 PAGE 18  

1043   2                      SetLedRedState(LED_ON);
1044   2                  memset(TEMPIRDATA,0,6);//5S到了之后清除数据
1045   2                  IR_SET_BY_SERIAL_FLAG=0;
1046   2               }
1047   1               if(SET_BY_SERIAL_OK_FLAG)
1048   1               {
1049   2                 SET_BY_SERIAL_COUNT1++;
1050   2               }
1051   1               else  SET_BY_SERIAL_COUNT1=0;
1052   1      
1053   1               
1054   1               if(SET_BY_SERIAL_COUNT1>50)      //定时1秒
1055   1               {
1056   2                 SET_BY_SERIAL_OK_FLAG=0;
1057   2                 SET_BY_SERIAL_COUNT1=0;
1058   2                 SetLedRedState(LED_ON);
1059   2                 stLocalControl.byLedTime = stLocalControl.byLedDelay = 50;
1060   2               }
1061   1              //----------------------------------------------------------
1062   1              //----------------------------------------------------------
1063   1              //红外计时开始
1064   1              if(IRByteEnd==0&&IRHaveRec_Flag==1) //如果没有接收数据则开始五秒计时
1065   1           {
1066   2                 TimerCount++;
1067   2               }
1068   1          if(TimerCount>250) //5S计时
1069   1          {
1070   2            TimerCount=0;
1071   2                FiveSec_Flag=1;
1072   2                IRHaveRec_Flag=0;  //护士离开时才将本标志清除
1073   2                IRByteEnd=1;
1074   2          }
1075   1              //----------------------------------------------------------
1076   1              //----------------------------------------------------------    
1077   1      
1078   1              if(Bus0RecPin ==1)      //总线正常
1079   1              {
1080   2                      BusLowDTime = 100;      //20ms*100=2s           
1081   2              }
1082   1              else
1083   1              {//Bus0RecPin =0
1084   2                      if(BusLowDTime)
1085   2                      {
1086   3                              if(--BusLowDTime ==0)
1087   3                              {
1088   4                                      RST_BUS =1;     //断开SD到总线
1089   4                                      Bus0SendPin =0; //使SD为高电平
1090   4                                      OSWait(K_TMO,100);      //延时500ms    一个单位5ms
1091   4                                      
1092   4                                      if(Bus0RecPin ==0)
1093   4                                      {//本机有故障 //使灯快闪
1094   5                                              do
1095   5                                              {
1096   6                                                      RST_BUS =1;     //断开SD到总线
1097   6                                                      Bus0SendPin =0; //使SD为高电平
1098   6                                                      WDT_CONTR = 0x3d;               //@20MHz,1.25s
1099   6                                                      SetLedRedState(LED_OFF);
1100   6                                                      OSWait(K_TMO,40);               //延时200ms
1101   6                                              
1102   6                                                      WDT_CONTR = 0x3d;               //@20MHz,1.25s
1103   6                                                      SetLedRedState(LED_ON);
1104   6                                                      OSWait(K_TMO,40);
C51 COMPILER V9.00   SINGLEBUS                                                             02/17/2017 20:25:02 PAGE 19  

1105   6                                                      
1106   6                                              }while(Bus0RecPin==0);  //一直等待为高
1107   5      
1108   5                                              
1109   5                                              RST_BUS = 0;    //使SD线路连通                                  
1110   5                                              BusLowDTime = 100;
1111   5                                              //使灯恢复常亮
1112   5                                              SetLedRedState(LED_ON);
1113   5                                      }
1114   4      
1115   4                                      
1116   4                                      else 
1117   4                                      {//是外部总线引起
1118   5                                              RST_BUS = 0;    //使SD线路连通
1119   5                                              Bus0SendPin =0; //使SD为高电平
1120   5      
1121   5                                              do
1122   5                                              {
1123   6                                                              
1124   6                                                      RST_BUS = 0;    //使SD线路连通
1125   6                                                      Bus0SendPin =0; //使SD为高电平
1126   6                                                      
1127   6                                                      SetLedRedState(LED_OFF);        //灯慢闪
1128   6                                                      OSWait(K_TMO,120);              //延时600ms 
1129   6                                                      WDT_CONTR = 0x3d;               //@20MHz,1.25s
1130   6                                                      SetLedRedState(LED_ON);
1131   6                                                      OSWait(K_TMO,120);
1132   6                                                      WDT_CONTR = 0x3d;               //@20MHz,1.25s
1133   6                                                      
1134   6                                              }while(Bus0RecPin==0);  //一直等待为高
1135   5                                              
1136   5      
1137   5                                              //使灯恢复常亮
1138   5      Bus0BugRet:
1139   5                                              SetLedRedState(LED_ON);
1140   5                                              Bus0SendPin =0; //使SD为高电平
1141   5                                              RST_BUS = 0;    //使SD线路连通                                  
1142   5                                              BusLowDTime = 100;
1143   5      
1144   5                                      }                               
1145   4                              }
1146   3                      }
1147   2              }       
1148   1      }
*** WARNING C280 IN LINE 1138 OF SINGLEBUS.C: 'Bus0BugRet': unreferenced label
1149          /**********************************************************
1150          *函数名称                       :TimerOutManager        
1151          *函数描述               :超时管理线程
1152          *输入参数               :
1153          *返回值                         :
1154          *全局变量                       :stLocalControl,byMainCmdQ
1155          *调用模块                       :OSQPost                                
1156          ***********************************************************
1157          *创建人                 :陈卫国
1158          *创建日期                       :2008-9-22
1159          ***********************************************************
1160          *修改人                         :
1161          *修改日期               :
1162          *注释                   :
1163          **********************************************************/             
1164          void TimerOutManager(void)       
1165          {       
C51 COMPILER V9.00   SINGLEBUS                                                             02/17/2017 20:25:02 PAGE 20  

1166   1              while(TRUE)
1167   1              {       
1168   2                      OSWait(K_TMO, 4);                                                                       //延时20ms                                      
1169   2                      if(stLocalControl.stCH0TimerOut.byTimerOut)
1170   2                      {       
1171   3                              OSQPost(byMainCmdQ, TIMER_OUT);                         
1172   3                      }
1173   2                      else
1174   2                      {               
1175   3                              OSQPost(byMainCmdQ, TIMER_OUT); 
1176   3                      }
1177   2                      WDT_CONTR = 0x3d;
1178   2              }
1179   1      } 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2618    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     78    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     26       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
