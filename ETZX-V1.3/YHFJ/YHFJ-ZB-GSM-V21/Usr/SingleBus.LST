C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SINGLEBUS
OBJECT MODULE PLACED IN SingleBus.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE SingleBus.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*
   2          ************************Copyright(c)************************
   3          *                                  湖南一特股份有限公司
   4          *                               All Rights Reserved
   5          *                                        
   6          *
   7          *-----------------------文件信息---------------------------
   8          *文件名称               :SingleBus.c
   9          *文件描述               :单总线程序
  10          *创建人                 :尹运同
  11          *创建日期               :2008-9-22
  12          *版本号                 :V1.0
  13          *注释                   :                                       
  14          *----------------------------------------------------------
  15          *修改人                         :
  16          *修改日期                       :
  17          *版本号                 :
  18          *注释                   :
  19          ***********************************************************
  20          */
  21          #define _IN_SINGLE_BUS_
  22          #include "config.h"
  23          
  24          bit  fled0                                      = 0;
  25          bit  bKeyEnterDown                      = 0;
  26          bit  bKeyBroadDown                      = 0;
  27          bit  bVl0State                          = 0;
  28          bit  bNumSeting                         = 0;
  29          bit  bMainMenuSet                       = 0;
  30          bit  bSendCmdCloseLcd           = 0;
  31          bit  bSendCmdOpenLcd            = 0;
  32          
  33          //总线0变量定义
  34          uint8 bdata byBus0State0        = 0;                                                    //单总线0状态字1
  35          sbit  bBus0StartRec                     = byBus0State0^0;                               //单总线0开始接收起始位标志
  36          sbit  bBus0OnRec                        = byBus0State0^1;                               //单总线0开始接收数据位标志
  37          sbit  bBus0Enable                       = byBus0State0^2;                               //单总线0允许发送标志
  38          sbit  bBus0ReqSend                      = byBus0State0^3;                               //单总线0请求发送标志
  39          sbit  bBus0OnSendBit            = byBus0State0^4;                               //单总线0正在发送一个数据位标志
  40          sbit  bBus0OnSendFreq           = byBus0State0^5;                               //单总线0正在发送一个数据帧标志
  41          sbit  bBus0SendError            = byBus0State0^6;                               //单总线0发送错误标志
  42          sbit  bBus0Error                        = byBus0State0^7;                               //单总线0故障标志
  43          uint8 bdata byBus0State1        = 0;                                                    //单总线0状态字2
  44          sbit  bBus0RecFinish            = byBus0State1^0;                               //单总线0接收完成标志
  45          sbit  bBus0RecBit9                      = byBus0State1^1;                               //单总线0接收字节数据的第9位
  46          sbit  bBus0SendFinish           = byBus0State1^2;                               //单总线0发送完成标志
  47          sbit  bBus0Disable                      = byBus0State1^3;                               //单总线0禁止发送标志
  48          sbit  bBus0SendBit                      = byBus0State1^4;                               //单总线0正在发送的数据位
  49          sbit  bBus0RecBit                       = byBus0State1^5;                               //单总线0正在接收的数据位
  50          
  51          uint8 data byBus0RecCount = 0;                                                          //高4位是总线0接收定时中断计数，低4位是接收到的位计数
  52          uint8 data byBus0RecBuf;                                                                        //总线0接收缓冲单元
  53          uint8 data byBus0SendBuf;                                                                       //总线0发送缓冲单元     
  54          uint8 data byBus0RecData[BUS0_FREQ_SIZE];                                       //总线0接收缓冲区
  55          uint8 data byBus0SendData[BUS0_FREQ_SIZE];                                      //总线0发送缓冲区
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 2   

  56          uint8 data byBus0SendCount = 0;                                                         //高4位是总线0发送定时中断计数，低4位是发送的位计数
  57          uint8 data byBus0RecSendCount = 0;                                                      //高4位是总线0接收到的字节计数，低4位是总线0发送完的字节计数
  58          uint8 data byBus0SendStopCount;                                                         //总线0停止时间计数
  59          uint8 data byBus0RecTimeOut = 0;                                                        //总线0接收超时计数
  60          uint8 data byBus0DisableCount = 0;                                                      //总线0禁止计数  
  61          uint8 xdata byBus0TxQ[BUS0_TX_Q_ZISE];                                          //总线0发送队列                                                 
  62          uint8 data byBus0TxHead = 0;                                                            //单总线0发送队列头指针
  63          uint8 data byBus0TxTail = 0;                                                            //单总线0发送队列尾指针
  64          #define IncBus0TxPtr(addr)    {addr=(addr+1)%BUS0_TX_Q_ZISE;}
  65          #define Bus0TxBuffLen()       ((byBus0TxTail+BUS0_TX_Q_ZISE-byBus0TxHead)%BUS0_TX_Q_ZISE)  
  66          sbit  Bus0RecPin        = P3^2;                                                                 //单总线0接收引脚定义
  67          sbit  Bus0SendPin       = P3^6;                                                                 //单总线0发送引脚定义
  68          //总线1变量定义
  69          uint8 bdata byBus1State0        = 0;                                                    //单总线1状态字1
  70          sbit  bBus1StartRec                     = byBus1State0^0;                               //单总线1开始接收起始位标志
  71          sbit  bBus1OnRec                        = byBus1State0^1;                               //单总线1开始接收数据位标志
  72          sbit  bBus1Enable                       = byBus1State0^2;                               //单总线1允许发送标志
  73          sbit  bBus1ReqSend                      = byBus1State0^3;                               //单总线1请求发送标志
  74          sbit  bBus1OnSendBit            = byBus1State0^4;                               //单总线1正在发送一个数据位标志
  75          sbit  bBus1OnSendFreq           = byBus1State0^5;                               //单总线1正在发送一个数据帧标志
  76          sbit  bBus1SendError            = byBus1State0^6;                               //单总线1发送错误标志
  77          sbit  bBus1Error                        = byBus1State0^7;                               //单总线1故障标志
  78          uint8 bdata byBus1State1        = 0;                                                    //单总线1状态字2
  79          sbit  bBus1RecFinish            = byBus1State1^0;                               //单总线1接收完成标志
  80          sbit  bBus1RecBit9                      = byBus1State1^1;                               //单总线1接收字节数据的第9位
  81          sbit  bBus1SendFinish           = byBus1State1^2;                               //单总线1发送完成标志
  82          sbit  bBus1Disable                      = byBus1State1^3;                               //单总线1禁止发送标志
  83          sbit  bBus1SendBit                      = byBus1State1^4;                               //单总线1正在发送的数据位
  84          sbit  bBus1RecBit                       = byBus1State1^5;                               //单总线1正在接收的数据位
  85          uint8 data byBus1RecCount = 0;                                                          //高4位是总线1接收定时中断计数，低4位是接收到的位计数
  86          uint8 data byBus1RecBuf;                                                                        //总线1接收缓冲单元
  87          uint8 data byBus1SendBuf;                                                                       //总线1发送缓冲单元     
  88          uint8 data byBus1RecData[BUS1_FREQ_SIZE];                                       //总线1接收缓冲区
  89          uint8 data byBus1SendData[BUS1_FREQ_SIZE];                                      //总线1发送缓冲区
  90          uint8 data byBus1SendCount = 0;                                                         //高4位是总线1发送定时中断计数，低4位是发送的位计数
  91          uint8 data byBus1RecSendCount = 0;                                                      //高4位是总线1接收到的字节计数，低4位是总线1发送完的字节计数
  92          uint8 data byBus1SendStopCount;                                                         //总线1停止时间计数
  93          uint8 data byBus1RecTimeOut = 0;                                                        //总线1接收超时计数
  94          uint8 data byBus1DisableCount = 0;                                                      //总线1禁止计数  
  95          uint8 xdata byBus1TxQ[BUS1_TX_Q_ZISE];                                          //总线1发送队列                                                 
  96          uint8 data byBus1TxHead = 0;                                                            //单总线1发送队列头指针
  97          uint8 data byBus1TxTail = 0;                                                            //单总线1发送队列尾指针
  98          #define IncBus1TxPtr(addr)    {addr=(addr+1)%BUS1_TX_Q_ZISE;}
  99          #define Bus1TxBuffLen()       ((byBus1TxTail+BUS1_TX_Q_ZISE-byBus1TxHead)%BUS1_TX_Q_ZISE)  
 100          sbit  Bus1RecPin        = P3^3;                                                                 //单总线1接收引脚定义
 101          sbit  Bus1SendPin       = P3^4;                                                                 //单总线1发送引脚定义
 102          //变量定义  
 103          extern uint8    OS_Q_MEM_SEL    byMainCmdQ[]; 
 104          extern STLocalControl   xdata stLocalControl; 
 105          
 106          extern uint8    xdata byUsart0SndDealBuf[];
 107          extern unsigned char code MyParameter[];
 108          
 109          
 110          uint8 xdata byBus0RxQ[BUS0_RX_Q_ZISE];                                          //总线0接收队列
 111          uint8 xdata byBus0RxHead = 0;                                                           //单总线0接收队列头指针
 112          uint8 xdata byBus0RxTail = 0;                                                           //单总线0接收队列尾指针
 113          uint8 Bus0RecData(uint8* pbyData);
 114          
 115          
 116          
 117          uint8 xdata byBus1RxQ[BUS1_RX_Q_ZISE];                                          //总线1接收队列
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 3   

 118          uint8 xdata byBus1RxHead = 0;                                                           //单总线1接收队列头指针
 119          uint8 xdata byBus1RxTail = 0;                                                           //单总线1接收队列尾指针
 120          
 121          
 122          bit bBus0SndBitOk=0;
 123          
 124          
 125          code uint8 VolValIndex[9]={0,0x01,0x03,0x07,0x0f,0x1f,0x3f,0x7f,0xff };
 126          
 127          
 128          
 129          
 130          uint8 Bus1RecData(uint8* pbyData);
 131          
 132          
 133          
 134          uint8 LevelToValue(uint8 VoiceLevel);
 135          
 136          
 137          
 138          
 139          void led0init(void)
 140          {
 141   1              P5M0 |= Bin(0,0,0,0,1,0,0,0);
 142   1              P5M1 &= (~Bin(0,0,0,0,1,0,0,0));
 143   1              fled0=led0=0;
 144   1      }
 145          
 146          void led0flash(void)
 147          {
 148   1              if(fled0==0)
 149   1              {
 150   2                      led0=1;
 151   2                      fled0=1;
 152   2              }
 153   1              else
 154   1              {
 155   2                      led0=0;
 156   2                      fled0=0;
 157   2              }
 158   1      }
 159          
 160                   
 161          /**********************************************************
 162          *函数名称                       :SingleBusInit  
 163          *函数描述               :单总线初始化
 164          *输入参数               :
 165          *返回值                         :       
 166          *全局变量                       :
 167          *调用模块                       :
 168          ***********************************************************
 169          *创建人                 :尹运同
 170          *创建日期                       :2008-9-22
 171          ***********************************************************
 172          *修改人                         :
 173          *修改日期               :
 174          *注释                   :
 175          **********************************************************/
 176          void SingleBusInit(void)
 177          {
 178   1      //     单总线1
 179   1              //P3^3,高阻输入
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 4   

 180   1              P3M0 &= (~(Bin(0,0,0,0,1,0,0,0)));
 181   1              P3M1 |=   Bin(0,0,0,0,1,0,0,0);
 182   1      
 183   1      
 184   1              //P3^4,开漏输出 
 185   1              P3M0 |=  (Bin(0,0,0,1,0,0,0,0));
 186   1              P3M1 |=  (Bin(0,0,0,1,0,0,0,0));
 187   1      
 188   1      
 189   1      
 190   1      //         单总线0发送管脚P3.6:强推挽输出
 191   1              P3M0 |=    Bin(0,1,0,0,0,0,0,0);
 192   1              P3M1 &= (~(Bin(0,1,0,0,0,0,0,0)));
 193   1      
 194   1      
 195   1              //总线电平设置
 196   1              Bus0SendPin = 0;
 197   1              Bus0RecPin = 1; 
 198   1              Bus1SendPin = 1;
 199   1              Bus1RecPin = 1; 
 200   1      
 201   1          TMOD&= 0xf0;         //  ;t1作波特率发生器(不变)，
 202   1          TMOD|=0X01; //t0作方式1（16位)定时器
 203   1              
 204   1              TL0 = TIMER0_L;
 205   1              TH0 = TIMER0_H;
 206   1              TF0 = 0;                                                                                                //清除中断标志
 207   1              AUXR &= 0x7f;                                                                                   //传统12分频速度  
 208   1              ET0 = 1;                                                                                                //允许定时器0中断 
 209   1              TR0 = 1;                                                                                                //启动定时器
 210   1              //其它控制设置
 211   1              byBus0SendStopCount = 240;                                                              //上电总线0禁止发送时间设置
 212   1              byBus1SendStopCount = 240;                                                              //上电总线1禁止发送时间设置
 213   1              IE0 = 0;                                                                                                //清除外部中断0标志
 214   1              IT0 = 1;                                                                                                //外部中断0为下降沿触发模式      
 215   1              IE1 = 0;                                                                                                //清除外部中断1标志
 216   1              IT1 = 1;                                                                                                //外部中断1为下降沿触发模式                     
 217   1              if(Bus0RecPin)
 218   1              {       //如果总线正常,开中断           
 219   2                      EX0 = 1;
 220   2              }
 221   1              else
 222   1              {       //如果总线不正常,置总线故障标志                         
 223   2                      bBus0Error = 1;
 224   2              } 
 225   1              if(Bus1RecPin)
 226   1              {       //如果总线正常,开中断           
 227   2                      EX1 = 1;
 228   2              }
 229   1              else
 230   1              {       //如果总线不正常,置总线故障标志                         
 231   2                      bBus1Error = 1;
 232   2              }       
 233   1      }
 234          /**********************************************************
 235          *函数名称                       :Bus0RecInt     
 236          *函数描述               :外部中断0函数,单总线0接收中断
 237          *输入参数               :
 238          *返回值                         :       
 239          *全局变量                       :
 240          *调用模块                       :
 241          ***********************************************************
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 5   

 242          *创建人                 :尹运同
 243          *创建日期                       :2008-9-22
 244          ***********************************************************
 245          *修改人                         :
 246          *修改日期               :
 247          *注释                   :
 248          **********************************************************/
 249          #pragma disable
 250          void Bus0RecInt(void) interrupt 0
 251          {       
 252   1              DisableBus0RecInt();                                                                    //禁止再次下降沿中断
 253   1              bBus0StartRec = 1;                                                                              //启动起始位沿检测
 254   1              bBus0Enable = 0;                                                                                //禁止总线发送                                                  
 255   1              byBus0RecCount = 0;                                                                             //清接收寄存器          
 256   1      }
 257          /**********************************************************
 258          *函数名称                       :Bus1RecInt     
 259          *函数描述               :外部中断1函数,单总线1接收中断
 260          *输入参数               :
 261          *返回值                         :       
 262          *全局变量                       :
 263          *调用模块                       :
 264          ***********************************************************
 265          *创建人                 :尹运同
 266          *创建日期                       :2008-9-22
 267          ***********************************************************
 268          *修改人                         :
 269          *修改日期               :
 270          *注释                   :
 271          **********************************************************/
 272          #pragma disable
 273          void Bus1RecInt(void) interrupt 2
 274          {       
 275   1              DisableBus1RecInt();                                                                    //禁止再次下降沿中断
 276   1              bBus1StartRec = 1;                                                                              //启动起始位沿检测
 277   1              bBus1Enable = 0;                                                                                //禁止总线发送                                                  
 278   1              byBus1RecCount = 0;                                                                             //清接收寄存器  
 279   1      }
 280          /**********************************************************
 281          *函数名称                       :Timer0Int      
 282          *函数描述               :定时器0溢出中断,定时器每93.75us中断一次
 283                                                   程序间隔检查总线0与总线1的接收和发送
 284          *输入参数               :
 285          *返回值                         :       
 286          *全局变量                       :
 287          *调用模块                       :
 288          ***********************************************************
 289          *创建人                 :尹运同
 290          *创建日期                       :2008-9-22
 291          ***********************************************************
 292          *修改人                         :
 293          *修改日期               :
 294          *注释                   :
 295          **********************************************************/
 296          #pragma disable
 297          void Timer0Int(void) interrupt 1
 298          { 
 299   1      
 300   1              TR0=0;
 301   1              TH0=TIMER0_H;
 302   1              TL0=TIMER0_L;
 303   1              TR0=1;
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 6   

 304   1      
 305   1              bBus0RecBit = Bus0RecPin; 
 306   1              bBus1RecBit = Bus1RecPin;                                                               //保存总线0、1接收引脚状态                
 307   1              /*******************************总线0接收处理***********************************/
 308   1              if(bBus0StartRec)                                                                               //判断总线所处的状态，接收到起始位
 309   1              {                       
 310   2                      byBus0RecCount += 0x10;                                                         //增加定时中断计数次数
 311   2                      if(0x50 == (byBus0RecCount & 0xf0))                                     //到总线起始位检测时间
 312   2                      {                       
 313   3                              bBus0StartRec = 0;
 314   3                              byBus0RecCount = 0x00;                                                  //重新开始计数                  
 315   3                              if(bBus0RecBit)                 
 316   3                              {       //无效起始位                                                                                                                                            
 317   4                                      if((!bBus0SendError)&&bBus0OnSendFreq)
 318   4                                      {       //没有发生过总线发送错误,且有一帧数据正在发送,停止帧数据发送,置发送错误标志                                             
 319   5                                              byBus0State0 &= (~BUS0_SEND_CON);
 320   5                                              bBus0SendError = 1;
 321   5                                              Bus0SendPin = 0;                                                //释放总线                                      
 322   5                                      }                               
 323   4                                      byBus0SendStopCount = 240;                                      
 324   4                                      byBus0RecSendCount = 0x00;                                      //接收出错,重置接收发送计数值
 325   4                                      EnableBus0RecInt();
 326   4                                      PW = bPWState;                                                          //恢复语音功放的控制引脚
 327   4                                      PW2 = bPW2State;                                                        //恢复语音功放的控制引脚
 328   4                                      VL0 =bVl0State;
 329   4                              }
 330   3                              else                                                            
 331   3                              {       //有效起始位
 332   4                                      bBus0OnRec = 1;                                                         //开始接收数据位        
 333   4                              }
 334   3                      }
 335   2              }
 336   1              else if(bBus0OnRec)
 337   1              {               
 338   2                      byBus0RecCount += 0x10;                                                         //增加定时中断计数次数                  
 339   2                      if(0xa0 == (byBus0RecCount & 0xf0))
 340   2                      {
 341   3                              byBus0RecCount &= 0x0f;                                                 //清除定时中断计数次数
 342   3                              byBus0RecCount += 0x01;
 343   3                              if(0x0a == (byBus0RecCount & 0x0f))     
 344   3                              {       //收到第10位,结束位                                     
 345   4                                      bBus0OnRec = 0;                                                         //停止数据接收                                  
 346   4                                      if(bBus0RecBit)
 347   4                                      {       //有效的结束位                                                  
 348   5                                              if(((bit)(byBus0RecSendCount & 0xf0) == bBus0RecBit9)) 
 349   5                                              {       //数据桢错误
 350   6                                                      byBus0RecTimeOut = 0;
 351   6                                                      byBus0RecSendCount &= 0x0f;                                                                                     
 352   6                                              }
 353   5                                              else 
 354   5                                              {       //数据桢正确                                    
 355   6                                                      byBus0RecTimeOut = 230;                         //设置下一个字节数据接收超时时间
 356   6                                                      byBus0RecData[byBus0RecSendCount>>4] = byBus0RecBuf;
 357   6                                                      byBus0RecSendCount += 0x10;                                                                                                                                                                     
 358   6                                                      if((byBus0RecSendCount & 0xf0) >= BUS0_FREQ_SIZE_HI)
 359   6                                                      {                                                                                                                                                                               
 360   7                                                              byBus0RecSendCount &= 0x0f;                                                     
 361   7                                                              if(!((bBus0OnSendFreq == 1)&&(bBus0ReqSend == 0)))
 362   7                                                              {       //如果接收到的这帧数据是自己发送的不置标志
 363   8                                                                      if(TRUE==Bus0RecData(byBus0RecData))
 364   8                                                                      {//保存到队列中 
 365   9                                                                              //bBus0RecFinish = 1;
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 7   

 366   9                                                                      }                                                                                                                                                                                                                                                                                                                                                                       
 367   8                                                              }                                                                                                                                               
 368   7                                                              byBus0RecTimeOut = 0;
 369   7                                                              byBus0DisableCount = 10;
 370   7                                                              bBus0Disable = 1;                               //禁止总线使用
 371   7                                                              PW = bPWState;                                  //恢复语音功放的控制引脚
 372   7                                                              PW2 = bPW2State;                                //恢复语音功放的控制引脚
 373   7                                                              VL0 =bVl0State;
 374   7                                                      }       
 375   6                                              }                               
 376   5                                              byBus0SendStopCount = 240;
 377   5                                              EnableBus0RecInt();                                             
 378   5                                      }
 379   4                                      else                                                    
 380   4                                      {       //无效结束位
 381   5                                              bBus0Error = 1;                                                                         
 382   5                                              if((!bBus0SendError) && bBus0OnSendFreq)
 383   5                                              {       //没有发生过总线发送错误,且有一帧数据正在发送,停止帧数据发送,置发送错误标志
 384   6                                                      byBus0State0 &= (~BUS0_SEND_CON);
 385   6                                                      bBus0SendError = 1;                                                     
 386   6                                                      Bus0SendPin = 0;                                        //释放总线
 387   6                                              }
 388   5                                              byBus0RecSendCount = 0x00;                              //接收出错,重置接收发送计数值
 389   5                                              PW = bPWState;                                                  //恢复语音功放的控制引脚
 390   5                                              PW2 = bPW2State;                                                //恢复语音功放的控制引脚
 391   5                                              VL0 =bVl0State;
 392   5                                      }
 393   4                              }
 394   3                              else if(0x09 == (byBus0RecCount & 0x0f))
 395   3                              {       //第9位数据
 396   4                                      bBus0RecBit9 = bBus0RecBit;                                     
 397   4                              }
 398   3                              else                                                                                    
 399   3                              {       //有效数据位
 400   4                                      byBus0RecBuf >>= 1;
 401   4                                      if(bBus0RecBit)
 402   4                                      {       //为高电平
 403   5                                              byBus0RecBuf |= 0x80;
 404   5                                      }       
 405   4                              }
 406   3                      }
 407   2              }
 408   1              /*******************************总线1接收处理***********************************/
 409   1              if(bBus1StartRec)                                                                               //判断总线所处的状态,接收到起始位
 410   1              {                       
 411   2                      byBus1RecCount += 0x10;                                                         //增加定时中断计数次数
 412   2                      if(0x50 == (byBus1RecCount & 0xf0))                                     //到总线起始位检测时间
 413   2                      {                       
 414   3                              bBus1StartRec = 0;
 415   3                              byBus1RecCount = 0x00;                                                  //重新开始计数                  
 416   3                              if(bBus1RecBit)                 
 417   3                              {       //无效起始位                                                                                                                                            
 418   4                                      if((!bBus1SendError)&&bBus1OnSendFreq)
 419   4                                      {       //没有发生过总线发送错误,且有一帧数据正在发送,停止帧数据发送,置发送错误标志                                     
 420   5                                              byBus1State0 &= (~BUS1_SEND_CON);
 421   5                                              bBus1SendError = 1;
 422   5                                              Bus1SendPin = 1;                                                //释放总线                                      
 423   5                                      }                               
 424   4                                      byBus1SendStopCount = 240;                                      
 425   4                                      byBus1RecSendCount = 0x00;                                      //接收出错，重置接收发送计数值
 426   4                                      EnableBus1RecInt();
 427   4                              }
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 8   

 428   3                              else                                                                                    //有效起始位
 429   3                              {
 430   4                                      bBus1OnRec = 1;                                                         //开始接收数据位                                                                                        
 431   4                              }
 432   3                      }
 433   2              }
 434   1              else if(bBus1OnRec)
 435   1              {               
 436   2                      byBus1RecCount += 0x10;                                                         //增加定时中断计数次数                  
 437   2                      if(0xa0 == (byBus1RecCount & 0xf0))
 438   2                      {
 439   3                              byBus1RecCount &= 0x0f;                                                 //清除定时中断计数次数
 440   3                              byBus1RecCount += 0x01;
 441   3                              if(0x0a == (byBus1RecCount & 0x0f))     
 442   3                              {       //收到第10位,结束位                                     
 443   4                                      bBus1OnRec = 0;                                                         //停止数据接收                                  
 444   4                                      if(bBus1RecBit)
 445   4                                      {       //有效的结束位                                                  
 446   5                                              if(((bit)(byBus1RecSendCount & 0xf0) == bBus1RecBit9)) 
 447   5                                              {       //数据桢错误
 448   6                                                      byBus1RecTimeOut = 0;
 449   6                                                      byBus1RecSendCount &= 0x0f;                                                                                     
 450   6                                              }
 451   5                                              else 
 452   5                                              {       //数据桢正确                                    
 453   6                                                      byBus1RecTimeOut = 230;
 454   6                                                      byBus1RecData[byBus1RecSendCount>>4] = byBus1RecBuf;
 455   6                                                      byBus1RecSendCount += 0x10;                                                                                                                                                                     
 456   6                                                      if((byBus1RecSendCount & 0xf0) >= BUS1_FREQ_SIZE_HI)
 457   6                                                      {                                                                                                                                                                               
 458   7                                                              byBus1RecSendCount &= 0x0f;     
 459   7                                                              if(!((bBus1OnSendFreq == 1)&&(bBus1ReqSend==0)))
 460   7                                                              {       //如果接收到的这帧数据是自己发送的不置标志
 461   8                                                                      if(TRUE==Bus1RecData(byBus1RecData))
 462   8                                                                      {//保存到队列中 
 463   9                                                                              //bBus1RecFinish = 1;
 464   9                                                                      }                                                                                                                                                                                                                                                                                                                                                                       
 465   8                                                              }                                                                                                                                               
 466   7                                                              byBus1RecTimeOut = 0;
 467   7                                                              byBus1DisableCount = 10;
 468   7                                                              bBus1Disable = 1;                               //禁止总线使用                                                  
 469   7                                                      }       
 470   6                                              }                               
 471   5                                              byBus1SendStopCount = 240;
 472   5                                              EnableBus1RecInt();                                             
 473   5                                      }
 474   4                                      else                                                    
 475   4                                      {       //无效结束位
 476   5                                              bBus1Error = 1;                                                                         
 477   5                                              if((!bBus1SendError) && bBus1OnSendFreq)
 478   5                                              {       //没有发生过总线发送错误,且有一帧数据正在发送,停止帧数据发送,置发送错误标志
 479   6                                                      byBus1State0 &= (~BUS1_SEND_CON);
 480   6                                                      bBus1SendError = 1;                                                     
 481   6                                                      Bus1SendPin = 1;                                        //释放总线
 482   6                                              }
 483   5                                              byBus1RecSendCount = 0x00;                              //接收出错,重置接收发送计数值
 484   5                                      }
 485   4                              }
 486   3                              else if(0x09 == (byBus1RecCount & 0x0f))
 487   3                              {       //第9位数据
 488   4                                      bBus1RecBit9 = bBus1RecBit;                                     
 489   4                              }
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 9   

 490   3                              else                                                                                    //有效数据位
 491   3                              { 
 492   4                                      byBus1RecBuf >>= 1;
 493   4                                      if(bBus1RecBit)
 494   4                                      {       //为高电平
 495   5                                              byBus1RecBuf |= 0x80;
 496   5                                      }       
 497   4                              }
 498   3                      }
 499   2              }       
 500   1              /*******************************总线0发送处理***********************************/
 501   1              if((byBus0State0 & BUS0_CAN_SEND) == BUS0_CAN_SEND)
 502   1              {       //总线0上有数据发送请求,且总线允许发送          
 503   2                      if(bBus0RecBit)
 504   2                      {       //总线正常,可以发送
 505   3                              Bus0SendPin = 1;
 506   3                              bBus0SendBit = 0;                                                               //发送起始位数据                        
 507   3                              byBus0SendCount = 0;
 508   3                              byBus0State0 &= (~BUS0_CAN_SEND);
 509   3                              byBus0SendBuf = byBus0SendData[byBus0RecSendCount & 0x0f];
 510   3                              bBus0OnSendBit = 1;                                                             //取出待发送的数据并置正在发送标志              
 511   3                      }
 512   2                      else
 513   2                      {       //总线不正常,停止发送
 514   3                              byBus0State0 &= (~BUS0_SEND_CON);
 515   3                              bBus0SendError = 1;                     
 516   3                              byBus0RecSendCount &= 0xf0;
 517   3                              Bus0SendPin = 0;
 518   3                              byBus0SendStopCount = 240;
 519   3                      }
 520   2              }
 521   1              else if(bBus0OnSendBit)
 522   1              {       //有数据位正在发送,首先发送的是起始位
 523   2      
 524   2                      byBus0SendCount += 0x10;
 525   2                      if(0x50 == (byBus0SendCount & 0xf0))
 526   2                      {//处于一个数据位的中间
 527   3                              if(bBus0SendBit == bBus0RecBit)  bBus0SndBitOk=1;
 528   3                              else
 529   3                              {       //不相同,发送失败                                                               
 530   4                                      byBus0State0 &= ~BUS0_SEND_CON;
 531   4                                      byBus0RecSendCount &= 0xf0;
 532   4                                      bBus0SendError = 1;                             
 533   4                                      Bus0SendPin = 0; 
 534   4                                      byBus0SendStopCount = 240;
 535   4      
 536   4                                      bBus0SndBitOk =0;
 537   4                              }
 538   3      
 539   3                      }
 540   2      
 541   2      
 542   2              
 543   2                      //if(bBus0SendBit == bBus0RecBit)   
 544   2                      else if(bBus0SndBitOk==1)
 545   2                      {       //发送的数据和接收的数据相同
 546   3                              //byBus0SendCount += 0x10;
 547   3                              if(0xa0 == (byBus0SendCount & 0xf0))
 548   3                              {       //一位数据发送完毕,首先发送的是起始位
 549   4                                      bBus0SndBitOk=0;
 550   4      
 551   4                                      byBus0SendCount &= 0x0f;
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 10  

 552   4                                      byBus0SendCount += 0x01;                                
 553   4                                      if(0x09 == (byBus0SendCount & 0x0f))
 554   4                                      {       //发送到第9位了
 555   5                                              bBus0SendBit = !(bit)(byBus0RecSendCount & 0x0f);
 556   5                                              Bus0SendPin = !bBus0SendBit;                                            
 557   5                                      }
 558   4                                      else if(0x0a == (byBus0SendCount & 0x0f))
 559   4                                      {       //发送到结束位了
 560   5                                              bBus0SendBit = 1;
 561   5                                              Bus0SendPin = 0;        
 562   5                                      }
 563   4                                      else if(0x0b == (byBus0SendCount & 0x0f))
 564   4                                      {       //已经发送完结束位了
 565   5                                              bBus0OnSendBit = 0;                                             
 566   5                                              byBus0RecSendCount += 0x01;                                                                     
 567   5                                              if((byBus0RecSendCount & 0x0f) >= BUS0_FREQ_SIZE)
 568   5                                              {       //发送完一帧数据                                                                                                
 569   6                                                      byBus0RecSendCount &= 0xf0;                     //重新进入数据帧的发送阶段
 570   6                                                      byBus0State0 &= (~BUS0_SEND_CON);
 571   6                                                      byBus0SendStopCount = 240;
 572   6                                                      byBus0State1 |= BUS0_SEND_FINISH;                                                               
 573   6                                                      byBus0DisableCount = 10; 
 574   6                                              }
 575   5                                              else
 576   5                                              {                                               
 577   6                                                      byBus0SendStopCount = 10;
 578   6                                                      bBus0ReqSend = 1;
 579   6                                              }
 580   5                                              EnableBus0RecInt();                                             //再次使能接收中断
 581   5                                      }
 582   4                                      else
 583   4                                      {
 584   5                                              if(byBus0SendBuf & 0x01)
 585   5                                              {       //发送高电平
 586   6                                                      bBus0SendBit = 1;
 587   6                                                      Bus0SendPin = 0;                                        
 588   6                                              }
 589   5                                              else
 590   5                                              {       //发送低电平
 591   6                                                      bBus0SendBit = 0;
 592   6                                                      Bus0SendPin = 1;
 593   6                                              }
 594   5                                              byBus0SendBuf >>= 1;                                    //发送数据位移位操作
 595   5                                      }
 596   4                              }
 597   3                      }
 598   2      /*              else
 599   2                      {       //不相同,发送失败                                                               
 600   2                              byBus0State0 &= ~BUS0_SEND_CON;
 601   2                              byBus0RecSendCount &= 0xf0;
 602   2                              bBus0SendError = 1;                                     
 603   2                              Bus0SendPin = 0; 
 604   2                              byBus0SendStopCount = 240;
 605   2                      }*/
 606   2              }       
 607   1              /*******************************总线1发送处理***********************************/
 608   1              if((byBus1State0 & BUS1_CAN_SEND) == BUS1_CAN_SEND)
 609   1              {       //总线0上有数据发送请求,且总线允许发送          
 610   2                      if(bBus1RecBit)
 611   2                      {       //总线正常,可以发送
 612   3                              Bus1SendPin = 0;
 613   3                              bBus1SendBit = 0;                       
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 11  

 614   3                              byBus1SendCount = 0;
 615   3                              byBus1State0 &= (~BUS1_CAN_SEND);
 616   3                              byBus1SendBuf = byBus1SendData[byBus1RecSendCount & 0x0f];
 617   3                              bBus1OnSendBit = 1;                     
 618   3                      }
 619   2                      else
 620   2                      {       //总线不正常,停止发送
 621   3                              byBus1State0 &= (~BUS1_SEND_CON);
 622   3                              bBus1SendError = 1;                     
 623   3                              byBus1RecSendCount &= 0xf0;
 624   3                              Bus1SendPin = 1;
 625   3                              byBus1SendStopCount = 240;
 626   3                      }
 627   2              }
 628   1              else if(bBus1OnSendBit)
 629   1              {       //有数据位正在发送,首先发送的是起始位                   
 630   2                      if(bBus1SendBit == bBus1RecBit)                 
 631   2                      {       //发送的数据和接收的数据相同
 632   3                              byBus1SendCount += 0x10;
 633   3                              if(0xa0 == (byBus1SendCount & 0xf0))
 634   3                              {       //一位数据发送完毕,首先发送的是起始位
 635   4                                      byBus1SendCount &= 0x0f;
 636   4                                      byBus1SendCount += 0x01;                                
 637   4                                      if(0x09 == (byBus1SendCount & 0x0f))
 638   4                                      {       //发送到第9位了
 639   5                                              bBus1SendBit = !(bit)(byBus1RecSendCount & 0x0f);
 640   5                                              Bus1SendPin = bBus1SendBit;                                             
 641   5                                      }
 642   4                                      else if(0x0a == (byBus1SendCount & 0x0f))
 643   4                                      {       //发送到结束位了
 644   5                                              bBus1SendBit = 1;
 645   5                                              Bus1SendPin = 1;        
 646   5                                      }
 647   4                                      else if(0x0b == (byBus1SendCount & 0x0f))
 648   4                                      {       //已经发送完结束位了
 649   5                                              bBus1OnSendBit = 0;                                             
 650   5                                              byBus1RecSendCount += 0x01;                                                                     
 651   5                                              if((byBus1RecSendCount & 0x0f) >= BUS1_FREQ_SIZE)
 652   5                                              {       //发送完一帧数据                                                                                                
 653   6                                                      byBus1RecSendCount &= 0xf0;                     //重新进入数据帧的发送阶段
 654   6                                                      byBus1State0 &= (~BUS1_SEND_CON);
 655   6                                                      byBus1SendStopCount = 240;
 656   6                                                      byBus1State1 |= BUS1_SEND_FINISH;                                                               
 657   6                                                      byBus1DisableCount = 10;                                                                
 658   6                                              }
 659   5                                              else
 660   5                                              {                                               
 661   6                                                      byBus1SendStopCount = 10;
 662   6                                                      bBus1ReqSend = 1;
 663   6                                              }
 664   5                                              EnableBus1RecInt();                                             //再次使能接收中断
 665   5                                      }
 666   4                                      else
 667   4                                      {
 668   5                                              if(byBus1SendBuf & 0x01)
 669   5                                              {       //发送高电平
 670   6                                                      bBus1SendBit = 1;
 671   6                                                      Bus1SendPin = 1;                                        
 672   6                                              }
 673   5                                              else
 674   5                                              {       //发送低电平
 675   6                                                      bBus1SendBit = 0;
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 12  

 676   6                                                      Bus1SendPin = 0;
 677   6                                              }
 678   5                                              byBus1SendBuf >>= 1;                                    //发送数据位移位操作
 679   5                                      }
 680   4                              }
 681   3                      }
 682   2                      else
 683   2                      {       //不相同,发送失败                                                               
 684   3                              byBus1State0 &= ~BUS1_SEND_CON;
 685   3                              byBus1RecSendCount &= 0xf0;
 686   3                              bBus1SendError = 1;                                     
 687   3                              Bus1SendPin = 1; 
 688   3                              byBus1SendStopCount = 240;
 689   3                      }
 690   2              }       
 691   1              /*******************************总线0控制处理***********************************/
 692   1              if(0 == (byBus0State0 & BUS0_ON_REC))
 693   1              {       
 694   2                      if(byBus0SendStopCount != 0)
 695   2                      {
 696   3                              if((--byBus0SendStopCount) == 0)
 697   3                              {                               
 698   4                                      bBus0Enable = 1;                                                                
 699   4                              }
 700   3                      }               
 701   2                      if(bBus0Error)
 702   2                      {                                                               
 703   3                              bBus0Enable = 0;                        
 704   3                              if(bBus0RecBit)
 705   3                              {                               
 706   4                                      bBus0Error = 0;
 707   4                                      EnableBus0RecInt();
 708   4                                      byBus0SendStopCount = 240;
 709   4                              }
 710   3                      }
 711   2              }  
 712   1              /*******************************总线1控制处理***********************************/
 713   1              if(0 == (byBus1State0 & BUS1_ON_REC))
 714   1              {
 715   2                      if(byBus1SendStopCount != 0)
 716   2                      {
 717   3                              if((--byBus1SendStopCount) == 0)
 718   3                              {                               
 719   4                                      bBus1Enable = 1;                                                                
 720   4                              }
 721   3                      }               
 722   2                      if(bBus1Error)
 723   2                      {                                                               
 724   3                              bBus1Enable = 0;                        
 725   3                              if(bBus1RecBit)
 726   3                              {                               
 727   4                                      bBus1Error = 0;
 728   4                                      EnableBus1RecInt();
 729   4                                      byBus1SendStopCount = 240;
 730   4                              }
 731   3                      }
 732   2              }       
 733   1              /*******************************总线0超时处理***********************************/
 734   1              if(byBus0RecTimeOut != 0)
 735   1              {
 736   2                      if(--byBus0RecTimeOut == 0)                                                     
 737   2                      {       //接收超时到
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 13  

 738   3                              byBus0RecSendCount &= 0x0f;
 739   3                              PW = bPWState;                                                                  //恢复语音功放的控制引脚
 740   3                              PW2 = bPW2State;                                                                //恢复语音功放的控制引脚
 741   3                              VL0 = bVl0State;
 742   3                      }
 743   2              }
 744   1              if(byBus0DisableCount != 0)
 745   1              {
 746   2                      if(--byBus0DisableCount == 0)                                           
 747   2                      {       //禁止超时到            
 748   3                              bBus0Disable = 0;
 749   3                      }
 750   2              }       
 751   1              /*******************************总线1超时处理***********************************/
 752   1              if(byBus1RecTimeOut != 0)
 753   1              {
 754   2                      if(--byBus1RecTimeOut == 0)                                                     
 755   2                      {       //接收超时到
 756   3                              byBus1RecSendCount &= 0x0f;
 757   3                      }
 758   2              }
 759   1              if(byBus1DisableCount != 0)
 760   1              {
 761   2                      if(--byBus1DisableCount == 0)                                           
 762   2                      {       //禁止超时到            
 763   3                              bBus1Disable = 0;
 764   3                      }
 765   2              } 
 766   1              /***********总线0自动发送管理**********/         
 767   1              if((byBus0State0 & BUS0_ON_WORK) == 0x00)                               
 768   1              {       //总线0没有工作                         
 769   2                      if(bBus0SendError)                                              
 770   2                      {       //产生了发送错误,自动重发                                                               
 771   3                              bBus0SendError = 0;                             
 772   3                              byBus0State0 |= BUS0_REQ_SEND;          
 773   3                      }
 774   2                      else                                                                    
 775   2                      {       //总线0无发送错误               
 776   3                              if(!(bBus0SendFinish|bBus0Disable))
 777   3                              {       //总线0没有禁止使用,且发送结束处理已经完成
 778   4                                      if(Bus0TxBuffLen() >= BUS0_FREQ_SIZE)
 779   4                                      {       //有一帧完整的数据在发送队列中                                                                                                                                          
 780   5                                              byBus0SendData[0] = byBus0TxQ[byBus0TxHead];
 781   5                                              IncBus0TxPtr(byBus0TxHead);
 782   5                                              byBus0SendData[1] = byBus0TxQ[byBus0TxHead];
 783   5                                              IncBus0TxPtr(byBus0TxHead);
 784   5                                              byBus0SendData[2] = byBus0TxQ[byBus0TxHead];
 785   5                                              IncBus0TxPtr(byBus0TxHead);
 786   5                                              byBus0SendData[3] = byBus0TxQ[byBus0TxHead];
 787   5                                              IncBus0TxPtr(byBus0TxHead);
 788   5                                              byBus0SendData[4] = byBus0TxQ[byBus0TxHead];
 789   5                                              IncBus0TxPtr(byBus0TxHead);
 790   5                                              byBus0SendData[5] = byBus0TxQ[byBus0TxHead];
 791   5                                              IncBus0TxPtr(byBus0TxHead);
 792   5                                              byBus0SendData[6] = byBus0TxQ[byBus0TxHead];
 793   5                                              IncBus0TxPtr(byBus0TxHead);     
 794   5                                              byBus0State0 |= BUS0_REQ_SEND;                                          
 795   5                                      }
 796   4                                      else
 797   4                                      {       //没有一帧完整的数据在发送队列中了
 798   5                                              byBus0TxHead = byBus0TxTail = 0;
 799   5                                      }                                                               
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 14  

 800   4                              }
 801   3                      }
 802   2              } 
 803   1              /***********总线1自动发送管理**********/         
 804   1              if((byBus1State0 & BUS1_ON_WORK) == 0x00)       
 805   1              {       //总线1没有工作                         
 806   2                      if(bBus1SendError)                                              
 807   2                      {       //产生了发送错误,自动重发                                                               
 808   3                              bBus1SendError = 0;                             
 809   3                              byBus1State0 |= BUS1_REQ_SEND;          
 810   3                      }
 811   2                      else                                                                    
 812   2                      {       //总线1无发送错误               
 813   3                              if(!(bBus1SendFinish|bBus1Disable))
 814   3                              {       //总线0没有禁止使用,且发送结束处理已经完成
 815   4                                      if(Bus1TxBuffLen() >= BUS1_FREQ_SIZE)
 816   4                                      {       //有一帧完整的数据在发送队列中                                                                                                                                                  
 817   5                                              byBus1SendData[0] = byBus1TxQ[byBus1TxHead];
 818   5                                              IncBus1TxPtr(byBus1TxHead);
 819   5                                              byBus1SendData[1] = byBus1TxQ[byBus1TxHead];
 820   5                                              IncBus1TxPtr(byBus1TxHead);
 821   5                                              byBus1SendData[2] = byBus1TxQ[byBus1TxHead];
 822   5                                              IncBus1TxPtr(byBus1TxHead);
 823   5                                              byBus1SendData[3] = byBus1TxQ[byBus1TxHead];
 824   5                                              IncBus1TxPtr(byBus1TxHead);
 825   5                                              byBus1SendData[4] = byBus1TxQ[byBus1TxHead];
 826   5                                              IncBus1TxPtr(byBus1TxHead);
 827   5                                              byBus1SendData[5] = byBus1TxQ[byBus1TxHead];
 828   5                                              IncBus1TxPtr(byBus1TxHead);
 829   5                                              byBus1SendData[6] = byBus1TxQ[byBus1TxHead];
 830   5                                              IncBus1TxPtr(byBus1TxHead);     
 831   5                                              byBus1State0 |= BUS1_REQ_SEND;                                          
 832   5                                      }
 833   4                                      else
 834   4                                      {       //没有一帧完整的数据在发送队列中了
 835   5                                              byBus1TxHead = byBus1TxTail = 0;
 836   5                                      }                                                               
 837   4                              }
 838   3                      }
 839   2              }       
 840   1      } 
 841          /**********************************************************
 842          *函数名称                       :Bus0OutputData 
 843          *函数描述               :单总线0将待发送数据放入缓冲区
 844          *输入参数               :pbyData:待发送的数据指针
 845          *返回值                         :TRUE:发送成功,FALSE:队列满,发送失败    
 846          *全局变量                       :
 847          *调用模块                       :
 848          ***********************************************************
 849          *创建人                 :尹运同
 850          *创建日期                       :2008-9-22
 851          ***********************************************************
 852          *修改人                         :
 853          *修改日期               :
 854          *注释                   :
 855          **********************************************************/
 856          uint8 Bus0OutputData(uint8* pbyData)
 857          {
 858   1              uint8 byTemp = BUS0_FREQ_SIZE;
 859   1      
 860   1              OS_ENTER_CRITICAL();
 861   1              if(Bus0TxBuffLen() >= (BUS0_TX_Q_ZISE - 1))
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 15  

 862   1              {       //没有空间存储了,失败   
 863   2                      OS_EXIT_CRITICAL();
 864   2                      return(FALSE);
 865   2              }       
 866   1              while(byTemp--)
 867   1              {       //数据入发送队列
 868   2                      byBus0TxQ[byBus0TxTail] = *pbyData++;
 869   2                      IncBus0TxPtr(byBus0TxTail);
 870   2              }
 871   1              OS_EXIT_CRITICAL();     
 872   1              return(TRUE);   
 873   1      }
 874          /**********************************************************
 875          *函数名称                       :Bus1OutputData 
 876          *函数描述               :单总线1将待发送数据放入缓冲区
 877          *输入参数               :pbyData:待发送的数据指针
 878          *返回值                         :TRUE:发送成功,FALSE:队列满,发送失败    
 879          *全局变量                       :
 880          *调用模块                       :
 881          ***********************************************************
 882          *创建人                 :尹运同
 883          *创建日期                       :2008-9-22
 884          ***********************************************************
 885          *修改人                         :
 886          *修改日期               :
 887          *注释                   :
 888          **********************************************************/
 889          uint8 Bus1OutputData(uint8* pbyData)
 890          {
 891   1              uint8 byTemp = BUS1_FREQ_SIZE;
 892   1      
 893   1              OS_ENTER_CRITICAL();
 894   1              if(Bus1TxBuffLen() >= (BUS1_TX_Q_ZISE - 1))
 895   1              {       //没有空间存储了,失败   
 896   2                      OS_EXIT_CRITICAL();
 897   2                      return(FALSE);
 898   2              }  
 899   1              while(byTemp--)
 900   1              {       //数据入发送队列
 901   2                      byBus1TxQ[byBus1TxTail] = *pbyData++;
 902   2                      IncBus1TxPtr(byBus1TxTail);
 903   2              }
 904   1              OS_EXIT_CRITICAL();     
 905   1              return(TRUE);   
 906   1      }
 907          
 908          /**********************************************************
 909          *函数名称                       :Bus0RecData    
 910          *函数描述               :单总线0将单总线上接收的数据放入缓冲区
 911          *输入参数               :pbyData:待接收的数据指针
 912          *返回值                         :TRUE:接收成功,FALSE:队列满,接收失败    
 913          *全局变量                       :
 914          *调用模块                       :
 915          ***********************************************************
 916          *创建人                 :尹运同
 917          *创建日期                       :2008-9-22
 918          ***********************************************************
 919          *修改人                         :
 920          *修改日期               :
 921          *注释                   :
 922          **********************************************************/
 923          uint8 Bus0RecData(uint8* pbyData)
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 16  

 924          {
 925   1              uint8 byTemp = BUS0_FREQ_SIZE;
 926   1      
 927   1              OS_ENTER_CRITICAL();
 928   1              if(Bus0RxBuffLen() >= (BUS0_RX_Q_ZISE - 1))
 929   1              {       //没有空间存储了,失败   
 930   2                      OS_EXIT_CRITICAL();
 931   2                      return(FALSE);
 932   2              }       
 933   1              while(byTemp--)
 934   1              {       //数据入发送队列
 935   2                      byBus0RxQ[byBus0RxTail] = *pbyData++;
 936   2                      IncBus0RxPtr(byBus0RxTail);
 937   2              }
 938   1              OS_EXIT_CRITICAL(); 
 939   1              return(TRUE);
 940   1      
 941   1      }
 942          
 943          
 944          /**********************************************************
 945          *函数名称                       :Bus1RecData    
 946          *函数描述               :单总线1将单总线上接收的数据放入缓冲区
 947          *输入参数               :pbyData:待接收的数据指针
 948          *返回值                         :TRUE:接收成功,FALSE:队列满,接收失败    
 949          *全局变量                       :
 950          *调用模块                       :
 951          ***********************************************************
 952          *创建人                 :尹运同
 953          *创建日期                       :2008-9-22
 954          ***********************************************************
 955          *修改人                         :
 956          *修改日期               :
 957          *注释                   :
 958          **********************************************************/
 959          uint8 Bus1RecData(uint8* pbyData)
 960          {       
 961   1              uint8 byTemp = BUS1_FREQ_SIZE;
 962   1      
 963   1              OS_ENTER_CRITICAL();
 964   1              if(Bus1RxBuffLen() >= (BUS1_RX_Q_ZISE - 1))
 965   1              {       //没有空间存储了,失败   
 966   2                      OS_EXIT_CRITICAL();
 967   2                      return(FALSE);
 968   2              }       
 969   1              while(byTemp--)
 970   1              {       //数据入发送队列
 971   2                      byBus1RxQ[byBus1RxTail] = *pbyData++;
 972   2                      IncBus1RxPtr(byBus1RxTail);
 973   2              }
 974   1              OS_EXIT_CRITICAL(); 
 975   1              return(TRUE);
 976   1      }
 977          
 978          
 979          
 980          /**********************************************************
 981          *函数名称                       :AddrCompare    
 982          *函数描述               :比较地址(含广播地址)
 983          *输入参数               :pstBusFreq:待比较的数据帧指针
 984          *返回值                         :1:发送到本机的数据,0:不是发送到本机的数据      
 985          *全局变量                       :
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 17  

 986          *调用模块                       :
 987          ***********************************************************
 988          *创建人                 :尹运同
 989          *创建日期                       :2008-9-22
 990          ***********************************************************
 991          *修改人                         :
 992          *修改日期               :
 993          *注释                   :
 994          **********************************************************/
 995          bit AddrCompare(pSTBusFreq pstBusFreq)
 996          {
 997   1              if((pstBusFreq->byRecSecAddr != 0xff) && (pstBusFreq->byRecSecAddr != stLocalControl.stEepromCfgData.bySe
             -lfSecAddr))
 998   1              {       
 999   2                      return(0);
1000   2              } 
1001   1              if((pstBusFreq->byRecRoomAddr != 0xff) && (pstBusFreq->byRecRoomAddr != stLocalControl.stEepromCfgData.by
             -SelfRoomAddr))
1002   1              {       
1003   2                      return(0);
1004   2              }
1005   1              if((pstBusFreq->byRecBedAddr != 0xff) && (pstBusFreq->byRecBedAddr != stLocalControl.stEepromCfgData.bySe
             -lfBedAddr))
1006   1              {       
1007   2                      return(0);
1008   2              }
1009   1              return(1); 
1010   1      
1011   1      /*      if((pstBusFreq->byRecSecAddr  == 0xff)&&
1012   1                 (pstBusFreq->byRecRoomAddr == 0xff)&&
1013   1                 (pstBusFreq->byRecBedAddr  == 0xff))
1014   1                      return(1);
1015   1              else if((pstBusFreq->byRecSecAddr == stLocalControl.stEepromCfgData.bySelfSecAddr)&&
1016   1                         (pstBusFreq->byRecRoomAddr== stLocalControl.stEepromCfgData.bySelfRoomAddr)&&
1017   1                         (pstBusFreq->byRecBedAddr == stLocalControl.stEepromCfgData.bySelfBedAddr))
1018   1                         return(1);
1019   1              else return(0);
1020   1      */
1021   1      }
1022          
1023          /**********************************************************
1024          *函数名称                       :DirAddrCompare 
1025          *函数描述               :绝对比较地址
1026          *输入参数               :pstBusFreq:待比较的数据帧指针
1027          *返回值                         :1:发送到本机的数据,0:不是发送到本机的数据      
1028          *全局变量                       :
1029          *调用模块                       :
1030          ***********************************************************
1031          *创建人                 :尹运同
1032          *创建日期                       :2008-9-22
1033          ***********************************************************
1034          *修改人                         :
1035          *修改日期               :
1036          *注释                   :
1037          **********************************************************/
1038          bit DirAddrCompare(pSTBusFreq pstBusFreq)
1039          {
1040   1              if(pstBusFreq->byRecSecAddr != stLocalControl.stEepromCfgData.bySelfSecAddr)
1041   1              {       
1042   2                      return(0);
1043   2              } 
1044   1              if(pstBusFreq->byRecRoomAddr != stLocalControl.stEepromCfgData.bySelfRoomAddr)
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 18  

1045   1              {       
1046   2                      return(0);
1047   2              }
1048   1              if(pstBusFreq->byRecBedAddr != stLocalControl.stEepromCfgData.bySelfBedAddr)
1049   1              {       
1050   2                      return(0);
1051   2              }
1052   1              return(1); 
1053   1      }
1054          /**********************************************************
1055          *函数名称                       :MakeCH0TimerOut        
1056          *函数描述               :设置通道0超时参数
1057          *输入参数               :byTimerOut:超时时间,byTimerOutCount:超时次数
1058          *返回值                         :
1059          *全局变量                       :stLocalControl
1060          *调用模块                       :
1061          ***********************************************************
1062          *创建人                 :尹运同
1063          *创建日期                       :2008-9-22
1064          ***********************************************************
1065          *修改人                         :
1066          *修改日期               :
1067          *注释                   :
1068          **********************************************************/  
1069          void MakeCH0TimerOut(uint8 byTimerOut, uint8 byTimerOutCount)
1070          {
1071   1              stLocalControl.stCH0TimerOut.byTimerOutSet = byTimerOut;
1072   1              stLocalControl.stCH0TimerOut.byTimerOut = byTimerOut;
1073   1              stLocalControl.stCH0TimerOut.byTimerOutCount = byTimerOutCount; 
1074   1      }
1075          /**********************************************************
1076          *函数名称                       :MakeCH1TimerOut        
1077          *函数描述               :设置通道1超时参数
1078          *输入参数               :byTimerOut:超时时间,byTimerOutCount:超时次数
1079          *返回值                         :
1080          *全局变量                       :stLocalControl
1081          *调用模块                       :
1082          ***********************************************************
1083          *创建人                 :尹运同
1084          *创建日期                       :2008-9-22
1085          ***********************************************************
1086          *修改人                         :
1087          *修改日期               :
1088          *注释                   :
1089          **********************************************************/   
1090          void MakeCH1TimerOut(uint8 byTimerOut, uint8 byTimerOutCount)
1091          {
1092   1              stLocalControl.stCH1Timerout.byTimerOutSet = byTimerOut;
1093   1              stLocalControl.stCH1Timerout.byTimerOut = byTimerOut;
1094   1              stLocalControl.stCH1Timerout.byTimerOutCount = byTimerOutCount; 
1095   1      } 
1096          /**********************************************************
1097          *函数名称                       :SaveIndicationData     
1098          *函数描述               :保存信息指示数据内容
1099          *输入参数               :pstBus0SendFreq:待保存的数据帧指针
1100          *返回值                         :
1101          *全局变量                       :stLocalControl
1102          *调用模块                       :
1103          ***********************************************************
1104          *创建人                 :尹运同
1105          *创建日期                       :2008-9-22
1106          ***********************************************************
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 19  

1107          *修改人                         :
1108          *修改日期               :
1109          *注释                   :
1110          **********************************************************/
1111          void SaveIndicationData(pSTBusFreq pstBus0SendFreq)
1112          {       
1113   1              stLocalControl.stIndicationData.stAddr.bySndSecAddr = pstBus0SendFreq->bySndSecAddr;
1114   1              stLocalControl.stIndicationData.stAddr.bySndRoomAddr = pstBus0SendFreq->bySndRoomAddr;
1115   1              stLocalControl.stIndicationData.stAddr.bySndBedAddr = pstBus0SendFreq->bySndBedAddr;
1116   1              stLocalControl.stIndicationData.byCallCmd = pstBus0SendFreq->byRecSecAddr; 
1117   1      }
1118          /**********************************************************
1119          *函数名称                       :SaveCallAddr   
1120          *函数描述               :保存主动通话方地址
1121          *输入参数               :pstBus0SendFreq:待保存的数据帧指针
1122          *返回值                         :
1123          *全局变量                       :stLocalControl
1124          *调用模块                       :
1125          ***********************************************************
1126          *创建人                 :尹运同
1127          *创建日期                       :2008-9-22
1128          ***********************************************************
1129          *修改人                         :
1130          *修改日期               :
1131          *注释                   :
1132          **********************************************************/
1133          void SaveCallAddr(pSTBusFreq pstBusFreq)
1134          {       
1135   1              stLocalControl.stCallAddr.bySndSecAddr = pstBusFreq->bySndSecAddr;
1136   1              stLocalControl.stCallAddr.bySndRoomAddr = pstBusFreq->bySndRoomAddr;
1137   1              stLocalControl.stCallAddr.bySndBedAddr = pstBusFreq->bySndBedAddr;
1138   1      
1139   1              stLocalControl.stCallAddr.byRecSecAddr = pstBusFreq->byRecSecAddr;
1140   1              stLocalControl.stCallAddr.byRecRoomAddr = pstBusFreq->byRecRoomAddr;
1141   1              stLocalControl.stCallAddr.byRecBedAddr = pstBusFreq->byRecBedAddr;      
1142   1      }
1143          /**********************************************************
1144          *函数名称                       :VoiceChannelCtx        
1145          *函数描述               :语音通道切换处理函数
1146          *输入参数               :
1147          *返回值                         :
1148          *全局变量                       :
1149          *调用模块                       :
1150          ***********************************************************
1151          *创建人                 :尹运同
1152          *创建日期                       :2008-9-22
1153          ***********************************************************
1154          *修改人                         :
1155          *修改日期               :
1156          *注释                   :
1157          **********************************************************/ 
1158          void VoiceChannelCtx(void)
1159          { 
1160   1              if(bChannel1Talk)
1161   1              {       //通道1通话状态                 
1162   2                      if(bHandleDown)
1163   2                      {       //免提通话
1164   3      //                      bPW2State = PW2 = 1;            
1165   3      //                      P2 = stLocalControl.stEepromCfgData.byCH1HDwnTalkVol;
1166   3                              CloseHandleMIC();
1167   3                              OpenPanelMIC();         
1168   3                      }
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 20  

1169   2                      else
1170   2                      {//摘机通话
1171   3      //                      bPW2State = PW2 = 1;            
1172   3      //                      P2 = stLocalControl.stEepromCfgData.byCH1HUpTalkVol; 
1173   3                              ClosePanelMIC();
1174   3                              OpenHandleMIC();                
1175   3                      }
1176   2                      P2 = stLocalControl.stEepromCfgData.byCH1HDwnTalkVol;           //只用此音量作为通道1通话音量           
1177   2                      bPW2State = PW2 = 0;            //打开LM4871    
1178   2                      CloseCGB();             
1179   2                      XTD = 0;
1180   2                      OpenCBD();
1181   2                      XTA = 1;
1182   2                      bPWState = PW = 0;                              //打开34018
1183   2                      bVl0State=1;
1184   2              }
1185   1              else if(bChannel1Talked)
1186   1              {       //通道1通话状态         
1187   2                      if(bHandleDown)
1188   2                      {
1189   3      //                      bPW2State = PW2 = 1;            
1190   3      //                      P2 = stLocalControl.stEepromCfgData.byCH1HDwnTalkedVol;
1191   3                              CloseHandleMIC();
1192   3                              OpenPanelMIC();                 
1193   3                      }
1194   2                      else
1195   2                      {
1196   3      //                      bPW2State = PW2 = 1;            
1197   3      //                      P2 = stLocalControl.stEepromCfgData.byCH1HUpTalkedVol;  
1198   3                              ClosePanelMIC();
1199   3                              OpenHandleMIC();                
1200   3                      }
1201   2                      P2 = stLocalControl.stEepromCfgData.byCH1HDwnTalkVol;           //只用此音量作为通道1通话音量           
1202   2                      bPW2State = PW2 = 0;            //打开LM4871                    
1203   2                      CloseCGB();
1204   2                      XTD = 0;
1205   2                      OpenCBD();      //接收
1206   2                      XTA = 1;        //发送
1207   2                      bPWState = PW = 0;                              //打开34018
1208   2                      bVl0State=1;
1209   2              }
1210   1              else if((bSickRoomBroad|bOfficeBroad|bAllBroad))
1211   1              {       //广播状态              
1212   2      
1213   2                      CloseHandleMIC();
1214   2                      ClosePanelMIC();
1215   2                      
1216   2                      CloseCBD();
1217   2                      XTA = XTD = 0;
1218   2                      OpenCGB();
1219   2                      bPW2State = PW2 = 0;            //打开LM4871    
1220   2                      bPWState = PW = 0;                              //打开34018     
1221   2                      bVl0State=1;
1222   2              }
1223   1              else if(bChannel0Talk)
1224   1              {       //通道0主动通话状态                     
1225   2                      if(bHandleDown)
1226   2                      {
1227   3      //                      bPW2State = PW2 = 1;            
1228   3      //                      P2 = stLocalControl.stEepromCfgData.byCH0HDwnTalkVol;
1229   3                              CloseHandleMIC();
1230   3                              OpenPanelMIC();                 
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 21  

1231   3                      }
1232   2                      else
1233   2                      {
1234   3      //                      bPW2State = PW2 = 1;            
1235   3      //                      P2 = stLocalControl.stEepromCfgData.byCH0HUpTalkVol;
1236   3                              ClosePanelMIC();
1237   3                              OpenHandleMIC();                
1238   3                      }
1239   2                      P2 = stLocalControl.stEepromCfgData.byCH0HDwnTalkVol;           //只用此音量作为通道0通话音量           
1240   2                      bPW2State = PW2 = 0;            //打开LM4871            
1241   2                      CloseCBD();
1242   2                      XTA = 0;
1243   2                      OpenCGB();
1244   2                      XTD = 1;
1245   2                      bPWState = PW = 0;                              //打开34018
1246   2                      bVl0State=1;
1247   2              } 
1248   1              else if(bChannel0Talked)
1249   1              {       //通道0被叫通话状态                     
1250   2                      if(bHandleDown)
1251   2                      {
1252   3      //                      bPW2State = PW2 = 1;            
1253   3      //                      P2 = stLocalControl.stEepromCfgData.byCH0HDwnTalkedVol;
1254   3                              CloseHandleMIC();
1255   3                              OpenPanelMIC();         
1256   3                      }
1257   2                      else
1258   2                      {
1259   3      //                      bPW2State = PW2 = 1;                            
1260   3      //                      P2 = stLocalControl.stEepromCfgData.byCH0HUpTalkedVol;  
1261   3                              ClosePanelMIC();
1262   3                              OpenHandleMIC();                
1263   3                      }
1264   2                      P2 = stLocalControl.stEepromCfgData.byCH0HDwnTalkVol;           //只用此音量作为通道0通话音量           
1265   2                      bPW2State = PW2 = 0;            //打开LM4871            
1266   2                      CloseCBD();
1267   2                      XTA = 0;
1268   2                      OpenCGB();
1269   2                      XTD = 1;
1270   2                      bPWState = PW = 0;                              //打开34018
1271   2                      bVl0State=1;
1272   2              }
1273   1              else if(bSelfBroad)
1274   1              {       //主动广播状态
1275   2                      if(bHandleDown)
1276   2                      {
1277   3                              CloseHandleMIC();
1278   3                              OpenPanelMIC();
1279   3                              bPWState = PW = 0;                              //打开34018                     
1280   3                      }
1281   2                      else
1282   2                      {
1283   3                              ClosePanelMIC();
1284   3                              OpenHandleMIC();
1285   3                              bPWState = PW = 1;                              //关闭34018
1286   3                      }
1287   2                      CloseCGB();
1288   2                      CloseCBD();
1289   2                      bPW2State = PW2 = 1;            //关闭lm7841
1290   2                      XTA = 0;
1291   2                      XTD = 1;
1292   2                      bVl0State=0;
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 22  

1293   2              } 
1294   1              else if(bCalledRing)
1295   1              {       //被呼叫振铃    //信息指示
1296   2      
1297   2                      bPW2State = PW2 = 1;            //打开LM4871    
1298   2                      bPWState = PW = 0;                              //打开34018
1299   2                      P2=stLocalControl.stEepromCfgData.byHDwnSelfRingVol;
1300   2                      CloseHandleMIC();
1301   2                      ClosePanelMIC();
1302   2      
1303   2                      CloseCBD();             
1304   2                      XTA = XTD = 0;  
1305   2                      OpenCGB();
1306   2                      bVl0State=1;
1307   2              }       
1308   1              else if(bWaitListen)
1309   1              {       //等待接听      
1310   2                      bPW2State = PW2 = 0;            //打开LM4871
1311   2                      bPWState = PW = 0;                              //打开34018
1312   2                      P2=stLocalControl.stEepromCfgData.byHDwnSelfRingVol;            
1313   2                      CloseHandleMIC();
1314   2                      ClosePanelMIC();                
1315   2                      CloseCBD();                     
1316   2                      XTA = XTD = 0; 
1317   2                      OpenCGB();      
1318   2                      bVl0State=1;
1319   2              }                               
1320   1              else if(bIndicatingOther)
1321   1              {       //正在指示其它分机              
1322   2                      bPW2State = PW2 = 0;            //打开LM4871
1323   2                      bPWState = PW = 0;                              //打开34018
1324   2      
1325   2                      if( stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartHour==stLocalControl.stEepromCfgData.stVoiceTi
             -meZone.byEndHour && stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartMin==stLocalControl.stEepromCfgData.stVoiceTim
             -eZone.byEndMin)
1326   2                      {
1327   3                              P2=stLocalControl.stEepromCfgData.byHDwnRingVol;
1328   3                      }
1329   2                      else
1330   2                      {
1331   3                              if( (stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartHour<stLocalControl.stEepromCfgData.stVoiceT
             -imeZone.byEndHour) ||
1332   3                                      (stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartHour==stLocalControl.stEepromCfgData.stVoiceTim
             -eZone.byEndHour && stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartMin<stLocalControl.stEepromCfgData.stVoiceTimeZ
             -one.byEndMin))
1333   3                              {//属于Start<End这种情况
1334   4                                      if(stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartHour!=stLocalControl.stEepromCfgData.stVoiceT
             -imeZone.byEndHour)
1335   4                                      {//start.hour<end.hour
1336   5                                              if( (stLocalControl.stTime.byHour>stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartHour && stLoc
             -alControl.stTime.byHour<stLocalControl.stEepromCfgData.stVoiceTimeZone.byEndHour) ||
1337   5                                                      (stLocalControl.stTime.byHour==stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartHour && stLocal
             -Control.stTime.byMin>=stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartMin)||
1338   5                                                      (stLocalControl.stTime.byHour==stLocalControl.stEepromCfgData.stVoiceTimeZone.byEndHour && stLocalCo
             -ntrol.stTime.byMin<stLocalControl.stEepromCfgData.stVoiceTimeZone.byEndMin))
1339   5                                              {//现在时间在此区间内,使用小音量值
1340   6                                              
1341   6                                                      P2 = LevelToValue(stLocalControl.stEepromCfgData.byMicroVoiceVal);
1342   6                                              }
1343   5      
1344   5                                              else 
1345   5                                              {//现在时间不在此区间内,使用原始值
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 23  

1346   6                                                      P2 = stLocalControl.stEepromCfgData.byHDwnRingVol;
1347   6      
1348   6                                              }                               
1349   5                                      }
1350   4                                      else
1351   4                                      {//start.hour==end.hour
1352   5                                              if(stLocalControl.stTime.byHour != stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartHour)
1353   5                                              {//现在时间不在此区间内,使用原始值
1354   6                                                      P2 = stLocalControl.stEepromCfgData.byHDwnRingVol;
1355   6                                              
1356   6                                              }
1357   5      
1358   5                                              else
1359   5                                              {//stLocalControl.stTime.byHour == start.hour
1360   6                                                      if(stLocalControl.stTime.byMin>=stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartMin && stLocal
             -Control.stTime.byMin<stLocalControl.stEepromCfgData.stVoiceTimeZone.byEndMin)
1361   6                                                      {//现在时间在此区间内,使用小音量值
1362   7                                                      
1363   7                                                              P2 = LevelToValue(stLocalControl.stEepromCfgData.byMicroVoiceVal);
1364   7                                                      }
1365   6      
1366   6                                                      else 
1367   6                                                      {
1368   7                                                              //现在时间不在此区间内,使用原始值
1369   7                                                              P2 = stLocalControl.stEepromCfgData.byHDwnRingVol;
1370   7                                                      }       
1371   6                              
1372   6                                              }
1373   5                                      }
1374   4                                                      
1375   4                              }
1376   3                              else
1377   3                              {//属于Start>End这种情况   时间段跨零点 
1378   4                              
1379   4                                      if(stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartHour!=stLocalControl.stEepromCfgData.stVoiceT
             -imeZone.byEndHour)
1380   4                                      {//start.hour>end.hour
1381   5                                              if( (stLocalControl.stTime.byHour>stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartHour || stLoc
             -alControl.stTime.byHour<stLocalControl.stEepromCfgData.stVoiceTimeZone.byEndHour) ||
1382   5                                                      (stLocalControl.stTime.byHour==stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartHour && stLocal
             -Control.stTime.byMin>=stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartMin)||
1383   5                                                      (stLocalControl.stTime.byHour==stLocalControl.stEepromCfgData.stVoiceTimeZone.byEndHour && stLocalCo
             -ntrol.stTime.byMin<stLocalControl.stEepromCfgData.stVoiceTimeZone.byEndMin))
1384   5                                              {//现在时间在此区间内,使用小音量值
1385   6                                              
1386   6                                                      P2 = LevelToValue(stLocalControl.stEepromCfgData.byMicroVoiceVal);
1387   6                                              }
1388   5      
1389   5                                              else 
1390   5                                              {
1391   6                                                      //现在时间不在此区间内,使用原始值
1392   6                                                      P2 = stLocalControl.stEepromCfgData.byHDwnRingVol;
1393   6                                              }                               
1394   5                                      }
1395   4                                      else
1396   4                                      {//start.hour==end.hour  start.min>end.min
1397   5                                              if(stLocalControl.stTime.byHour != stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartHour)
1398   5                                              {//现在时间在此区间内,使用小音量值
1399   6                                              
1400   6                                                      P2 = LevelToValue(stLocalControl.stEepromCfgData.byMicroVoiceVal);
1401   6                                              }
1402   5                              
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 24  

1403   5                                              else
1404   5                                              {//stLocalControl.stTime.byHour == start.hour
1405   6                                                      if(stLocalControl.stTime.byMin>=stLocalControl.stEepromCfgData.stVoiceTimeZone.byEndMin && stLocalCo
             -ntrol.stTime.byMin<stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartMin)
1406   6                                                      {
1407   7                                                              //现在时间不在此区间内,使用原始值
1408   7                                                              P2 = stLocalControl.stEepromCfgData.byHDwnRingVol;
1409   7                                                      }                                       
1410   6                              
1411   6                                                      else 
1412   6                                                      {//现在时间在此区间内,使用小音量值
1413   7                                                      
1414   7                                                              P2 = LevelToValue(stLocalControl.stEepromCfgData.byMicroVoiceVal);
1415   7                                                      }       
1416   6                              
1417   6                                              }
1418   5                                      }
1419   4                                                      
1420   4                              }
1421   3                      }
1422   2      
1423   2                                              
1424   2                      CloseHandleMIC();
1425   2                      ClosePanelMIC();                
1426   2                      CloseCBD();
1427   2                      XTA = XTD = 0;
1428   2                      OpenCGB();
1429   2                      bVl0State=1;
1430   2              } 
1431   1              else if(bVoiceNoting)
1432   1              {       //语音提示                      
1433   2                      bPW2State = PW2 = 0;            //打开LM4871    
1434   2                      bPWState = PW = 0;                              //打开34018             
1435   2                      P2 = stLocalControl.stEepromCfgData.byCH0HUpTalkedVol;          
1436   2                      CloseHandleMIC();
1437   2                      ClosePanelMIC();                
1438   2                      CloseCGB();
1439   2                      XTA = XTD = 0;
1440   2                      OpenCBD();
1441   2                      bVl0State=1;
1442   2              }                
1443   1              else if(bMusicPlaying)
1444   1              {       //背景音乐播放状态                              
1445   2                      bPW2State = PW2 = 0;            //打开LM4871
1446   2                      bPWState = PW = 0;                              //打开34018             
1447   2                      P2 = stLocalControl.stEepromCfgData.byHDwnMusicVol;                     
1448   2                      CloseHandleMIC();
1449   2                      ClosePanelMIC();                
1450   2                      CloseCGB();
1451   2                      XTA = XTD = 0;
1452   2                      OpenCBD();      
1453   2                      bVl0State=1;
1454   2              }               
1455   1              else
1456   1              {
1457   2                      bPW2State = PW2 = 1;            //关闭LM4871
1458   2                      bPWState = PW = 1;                              //关闭34018
1459   2                      CloseCBD();
1460   2                      CloseCGB();
1461   2                      CloseHandleMIC();
1462   2                      ClosePanelMIC();
1463   2                      XTA = XTD=0;
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 25  

1464   2                      bVl0State=0;
1465   2              }       
1466   1      } 
1467          /**********************************************************
1468          *函数名称                       :SysReset       
1469          *函数描述               :系统复位,该函数仅仅将通道0复位,将通道0
1470                                                   恢复到空闲状态
1471          *输入参数               :
1472          *返回值                         :
1473          *全局变量                       :
1474          *调用模块                       :
1475          ***********************************************************
1476          *创建人                 :尹运同
1477          *创建日期                       :2008-9-22
1478          ***********************************************************
1479          *修改人                         :
1480          *修改日期               :
1481          *注释                   :
1482          **********************************************************/
1483          void SysReset(void)
1484          {
1485   1              //清除对应标志
1486   1              if(!(bChannel1Talk|bChannel1Talked))
1487   1              {
1488   2                      bKeyAnswer = bHandAnswer = 0;
1489   2              }       
1490   1              bBusy = bWaitAck = bWaitListen = bCalledRing = bChannel0Talked = bChannel0Talk = 
1491   1                      bSickRoomBroad = bOfficeBroad = bAllBroad = bSelfBroad = 0;             
1492   1              MakeCH0TimerOut(0, 0);  
1493   1              VoiceChannelCtx();
1494   1              if(!(bChannel1Talk|bChannel1Talked))
1495   1              {
1496   2                      if(bIndicatingOther)
1497   2                      { 
1498   3                              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stIndicationData.stAddr.bySndSecAddr;
1499   3                              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stIndicationData.stAddr.bySndRoomAddr;
1500   3                              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stIndicationData.stAddr.bySndBedAddr;
1501   3                              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stIndicationData.byCallCmd;
1502   3                              stLocalControl.stBusDealFreq.byCmd = CMD_INFO_INDICATION;
1503   3                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1504   3      //                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1505   3                      }
1506   2                      else
1507   2                      {
1508   3                              stLocalControl.stBusDealFreq.byCmd = CMD_STOP_INDICATION;
1509   3                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1510   3      //                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
1511   3                      }       
1512   2              }       
1513   1      }
1514          
1515          
1516          uint8 ParaCrcCheck(uint16 addr)
1517          {
1518   1              uint8 crcResult=0;
1519   1              uint8 crcData =0;
1520   1              uint8 i;
1521   1              uint8 paraData;
1522   1              EnableIAP(IAP_READ);
1523   1              for(i=0;i<sizeof(STEepromCfgData)-1;i++)
1524   1              {
1525   2                      paraData = IapReadByte(addr);
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 26  

1526   2                      crcResult +=paraData; /*IapReadByte(addr)*/;
1527   2                      addr++;
1528   2              }
1529   1              crcData = IapReadByte(addr);
1530   1              DisableIAP();
1531   1              
1532   1              if(crcData == crcResult) return 1;
1533   1              else return 0;
1534   1      }
1535          
1536          
1537          
1538          uint8 CalcParaCrc(void)
1539          {
1540   1              uint8 crcResult=0;
1541   1              uint8 i;
1542   1              uint8 *addr= &(stLocalControl.stEepromCfgData.byInitFlag);
1543   1              EnableIAP(IAP_READ);
1544   1              for(i=0;i<sizeof(STEepromCfgData)-1;i++)
1545   1              {
1546   2                      crcResult += *addr;
1547   2                      addr++;
1548   2              }
1549   1              DisableIAP();
1550   1              return crcResult;
1551   1      }
1552          
1553          
1554          
1555          
1556          
1557          /**********************************************************
1558          *函数名称                       :SaveParameter  
1559          *函数描述               :存储配置参数,存储参数前先擦除整个扇区,
1560                                                   然后将所有参数重新写入扇区
1561          *输入参数               :
1562          *返回值                         :
1563          *全局变量                       :stLocalControl
1564          *调用模块                       :EnableIAP,IapErase,IapWriteByte,DisableIAP
1565          ***********************************************************
1566          *创建人                 :尹运同
1567          *创建日期                       :2008-9-22
1568          ***********************************************************
1569          *修改人                         :
1570          *修改日期               :
1571          *注释                   :
1572          **********************************************************/
1573          void SaveParameter(uint16 addr)
1574          {  
1575   1              uint8 i;
1576   1              uint16 addr_temp=addr;
1577   1              uint8 *pbyData;
1578   1              uint8 readtimes;
1579   1              uint8 writetimes;
1580   1      
1581   1              stLocalControl.stEepromCfgData.byCrc = CalcParaCrc();
1582   1              WDT_CONTR = 0x3d;       //喂狗
1583   1              writetimes =3;
1584   1              do
1585   1              {
1586   2                      EnableIAP(IAP_ERASE);
1587   2                      IapErase(addr); 
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 27  

1588   2      
1589   2                      
1590   2                      EnableIAP(IAP_WRITE); 
1591   2                      addr = addr_temp;
1592   2                      pbyData=&(stLocalControl.stEepromCfgData.byInitFlag);
1593   2                      for(i=0;i<sizeof(STEepromCfgData);i++)
1594   2                      {
1595   3                              IapWriteByte(addr,*pbyData);
1596   3                              pbyData++;
1597   3                              addr++;
1598   3                      }
1599   2      
1600   2                      //地址紧跟前一数据区
1601   2                      pbyData=&(stLocalControl.stEepromCfgData.byInitFlag);
1602   2                      for(i=0;i<sizeof(STEepromCfgData);i++)
1603   2                      {
1604   3                              IapWriteByte(addr,*pbyData);
1605   3                              pbyData++;
1606   3                              addr++;
1607   3                      }
1608   2                      
1609   2      
1610   2                      EnableIAP(IAP_READ);
1611   2                      readtimes=3;
1612   2                      do
1613   2                      {
1614   3                              WDT_CONTR = 0x3d;       //喂狗
1615   3                              pbyData=&(stLocalControl.stEepromCfgData.byInitFlag);
1616   3                              addr = addr_temp;
1617   3      
1618   3      
1619   3                              for(i=0;i<(sizeof(STEepromCfgData))*2;)
1620   3                              {
1621   4                                      if(*pbyData != IapReadByte(addr)) break;
1622   4                                      
1623   4                                      pbyData++;
1624   4                                      addr++;
1625   4                                      i++;
1626   4                                      if(i== sizeof(STEepromCfgData)) pbyData=&(stLocalControl.stEepromCfgData.byInitFlag);
1627   4                              }       
1628   3      
1629   3                              if(i>= (sizeof(STEepromCfgData)*2))
1630   3                              {//写进去的数据与读出来的数据相同
1631   4                                      break;
1632   4                              }
1633   3                      
1634   3                      }while(--readtimes);
1635   2      
1636   2                      if(readtimes)
1637   2                      {
1638   3                              break;  //相同
1639   3                      }
1640   2              }while(--writetimes);
1641   1      
1642   1              
1643   1              DisableIAP();
1644   1      
1645   1              //加载使能数据
1646   1              byEnable1 = stLocalControl.stEepromCfgData.byEnable1;
1647   1              byEnable2 = stLocalControl.stEepromCfgData.byEnable2;   
1648   1      }
1649          
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 28  

1650          /**********************************************************
1651          *函数名称                       :ReadParameter  
1652          *函数描述               :将Flash中的配置数据读入到内存中
1653          *输入参数               :
1654          *返回值                         :
1655          *全局变量                       :stLocalControl
1656          *调用模块                       :EnableIAP,IapReadByte,DisableIAP
1657          ***********************************************************
1658          *创建人                 :尹运同
1659          *创建日期                       :2008-9-22
1660          ***********************************************************
1661          *修改人                         :
1662          *修改日期               :
1663          *注释                   :
1664          **********************************************************/
1665          void ReadParameter(uint16 addr)
1666          {
1667   1      
1668   1              uint8 i=0;
1669   1              uint8 *pbyData = &(stLocalControl.stEepromCfgData.byInitFlag);
1670   1              
1671   1              EnableIAP(IAP_READ); 
1672   1              for(i=0;i<sizeof(STEepromCfgData);i++)
1673   1              {
1674   2                      *pbyData = IapReadByte(addr);
1675   2                      pbyData++;
1676   2                      addr++;
1677   2              }
1678   1              DisableIAP();
1679   1      
1680   1              //加载使能数据
1681   1              byEnable1 = stLocalControl.stEepromCfgData.byEnable1;
1682   1              byEnable2 = stLocalControl.stEepromCfgData.byEnable2;   
1683   1      }
1684          
1685          
1686          
1687          void BackLightTimerTreat(pSTBusFreq pstBusFreq)
1688          {
1689   1              
1690   1              pstBusFreq->bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1691   1              pstBusFreq->bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1692   1              pstBusFreq->bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1693   1              pstBusFreq->byRecSecAddr = 0xff;
1694   1              pstBusFreq->byRecRoomAddr= 0xff;
1695   1              pstBusFreq->byRecBedAddr = 0xff;
1696   1              
1697   1              
1698   1              if( (stLocalControl.stEepromCfgData.stBLTimeZone.byStartHour<stLocalControl.stEepromCfgData.stBLTimeZone.
             -byEndHour) ||
1699   1                      (stLocalControl.stEepromCfgData.stBLTimeZone.byStartHour==stLocalControl.stEepromCfgData.stBLTimeZone.by
             -EndHour && stLocalControl.stEepromCfgData.stBLTimeZone.byStartMin<stLocalControl.stEepromCfgData.stBLTimeZone.byEndMin))
1700   1              {//属于Start<End这种情况
1701   2                      if(stLocalControl.stEepromCfgData.stBLTimeZone.byStartHour!=stLocalControl.stEepromCfgData.stBLTimeZone.
             -byEndHour)
1702   2                      {//start.hour<end.hour
1703   3                              if( (stLocalControl.stTime.byHour>stLocalControl.stEepromCfgData.stBLTimeZone.byStartHour && stLocalCon
             -trol.stTime.byHour<stLocalControl.stEepromCfgData.stBLTimeZone.byEndHour) ||
1704   3                                      (stLocalControl.stTime.byHour==stLocalControl.stEepromCfgData.stBLTimeZone.byStartHour && stLocalContr
             -ol.stTime.byMin>=stLocalControl.stEepromCfgData.stBLTimeZone.byStartMin)||
1705   3                                      (stLocalControl.stTime.byHour==stLocalControl.stEepromCfgData.stBLTimeZone.byEndHour && stLocalControl
             -.stTime.byMin<stLocalControl.stEepromCfgData.stBLTimeZone.byEndMin))
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 29  

1706   3                              {//现在时间在此区间内,关闭显示屏
1707   4                                      if(!bSendCmdCloseLcd)
1708   4                                      {
1709   5                                              pstBusFreq->byCmd = CMD_CLOSE_LCD;
1710   5                                              Bus0OutputData(&(pstBusFreq->bySndSecAddr));
1711   5                                              OSWait(K_TMO,200);              //延时1S
1712   5                                              
1713   5                                              pstBusFreq->bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1714   5                                              pstBusFreq->bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1715   5                                              pstBusFreq->bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1716   5                                              pstBusFreq->byCmd = CMD_CLOSE_LCD;
1717   5                                              pstBusFreq->byRecSecAddr = 0xff;
1718   5                                              pstBusFreq->byRecRoomAddr= 0xff;
1719   5                                              pstBusFreq->byRecBedAddr = 0xff;
1720   5                                              Bus0OutputData(&(pstBusFreq->bySndSecAddr));
1721   5                                              bSendCmdCloseLcd =1;
1722   5                                              bSendCmdOpenLcd  =0;
1723   5                                      }
1724   4                              }
1725   3                              else 
1726   3                              {//现在时间不在此区间内,打开显示屏
1727   4                                      if(!bSendCmdOpenLcd)
1728   4                                      {
1729   5                                              pstBusFreq->byCmd = CMD_OPEN_LCD;
1730   5                                              Bus0OutputData(&(pstBusFreq->bySndSecAddr));
1731   5                                              OSWait(K_TMO,200);              //延时1S
1732   5                                              
1733   5                                              pstBusFreq->bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1734   5                                              pstBusFreq->bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1735   5                                              pstBusFreq->bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1736   5                                              pstBusFreq->byCmd = CMD_OPEN_LCD;
1737   5                                              pstBusFreq->byRecSecAddr = 0xff;
1738   5                                              pstBusFreq->byRecRoomAddr= 0xff;
1739   5                                              pstBusFreq->byRecBedAddr = 0xff;
1740   5                                              Bus0OutputData(&(pstBusFreq->bySndSecAddr));                                    
1741   5                                              bSendCmdCloseLcd =0;
1742   5                                              bSendCmdOpenLcd  =1;                                                    
1743   5                                      }
1744   4                              }                               
1745   3                      }
1746   2                      else
1747   2                      {//start.hour==end.hour
1748   3                              if(stLocalControl.stTime.byHour != stLocalControl.stEepromCfgData.stBLTimeZone.byStartHour)
1749   3                              {//现在时间不在此区间内,打开显示屏
1750   4                                      if(!bSendCmdOpenLcd)
1751   4                                      {
1752   5                                              pstBusFreq->byCmd = CMD_OPEN_LCD;
1753   5                                              Bus0OutputData(&(pstBusFreq->bySndSecAddr));
1754   5                                              OSWait(K_TMO,200);              //延时1S
1755   5                                              
1756   5                                              pstBusFreq->bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1757   5                                              pstBusFreq->bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1758   5                                              pstBusFreq->bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1759   5                                              pstBusFreq->byCmd = CMD_OPEN_LCD;
1760   5                                              pstBusFreq->byRecSecAddr = 0xff;
1761   5                                              pstBusFreq->byRecRoomAddr= 0xff;
1762   5                                              pstBusFreq->byRecBedAddr = 0xff;
1763   5                                              Bus0OutputData(&(pstBusFreq->bySndSecAddr));                                    
1764   5                                              bSendCmdCloseLcd =0;
1765   5                                              bSendCmdOpenLcd  =1;                                                    
1766   5                                      }                               
1767   4                              }
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 30  

1768   3                              else
1769   3                              {//stLocalControl.stTime.byHour == start.hour
1770   4                                      if(stLocalControl.stTime.byMin>=stLocalControl.stEepromCfgData.stBLTimeZone.byStartMin && stLocalContr
             -ol.stTime.byMin<stLocalControl.stEepromCfgData.stBLTimeZone.byEndMin)
1771   4                                      {//现在时间在此区间内,关闭显示屏
1772   5                                              if(!bSendCmdCloseLcd)
1773   5                                              {
1774   6                                                      pstBusFreq->byCmd = CMD_CLOSE_LCD;
1775   6                                                      Bus0OutputData(&(pstBusFreq->bySndSecAddr));
1776   6                                                      OSWait(K_TMO,200);              //延时1S
1777   6                                                      
1778   6                                                      pstBusFreq->bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1779   6                                                      pstBusFreq->bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1780   6                                                      pstBusFreq->bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1781   6                                                      pstBusFreq->byCmd = CMD_CLOSE_LCD;
1782   6                                                      pstBusFreq->byRecSecAddr = 0xff;
1783   6                                                      pstBusFreq->byRecRoomAddr= 0xff;
1784   6                                                      pstBusFreq->byRecBedAddr = 0xff;
1785   6                                                      Bus0OutputData(&(pstBusFreq->bySndSecAddr));                                            
1786   6                                                      bSendCmdCloseLcd =1;
1787   6                                                      bSendCmdOpenLcd  =0;
1788   6                                              }
1789   5                                      }
1790   4                                      else 
1791   4                                      {//现在时间不在此区间内,打开显示屏
1792   5                                              if(!bSendCmdOpenLcd)
1793   5                                              {
1794   6                                                      pstBusFreq->byCmd = CMD_OPEN_LCD;
1795   6                                                      Bus0OutputData(&(pstBusFreq->bySndSecAddr));
1796   6                                                      OSWait(K_TMO,200);              //延时1S
1797   6                                                      
1798   6                                                      pstBusFreq->bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1799   6                                                      pstBusFreq->bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1800   6                                                      pstBusFreq->bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1801   6                                                      pstBusFreq->byCmd = CMD_OPEN_LCD;
1802   6                                                      pstBusFreq->byRecSecAddr = 0xff;
1803   6                                                      pstBusFreq->byRecRoomAddr= 0xff;
1804   6                                                      pstBusFreq->byRecBedAddr = 0xff;
1805   6                                                      Bus0OutputData(&(pstBusFreq->bySndSecAddr));                                            
1806   6                                                      bSendCmdCloseLcd =0;
1807   6                                                      bSendCmdOpenLcd  =1;                                                    
1808   6                                              }
1809   5                                      }       
1810   4      
1811   4                              }
1812   3                      }
1813   2                                      
1814   2              }
1815   1              else
1816   1              {//属于Start>End这种情况   时间段跨零点 
1817   2      
1818   2                      if(stLocalControl.stEepromCfgData.stBLTimeZone.byStartHour!=stLocalControl.stEepromCfgData.stBLTimeZone.
             -byEndHour)
1819   2                      {//start.hour>end.hour
1820   3                              if( (stLocalControl.stTime.byHour>stLocalControl.stEepromCfgData.stBLTimeZone.byStartHour || stLocalCon
             -trol.stTime.byHour<stLocalControl.stEepromCfgData.stBLTimeZone.byEndHour) ||
1821   3                                      (stLocalControl.stTime.byHour==stLocalControl.stEepromCfgData.stBLTimeZone.byStartHour && stLocalContr
             -ol.stTime.byMin>=stLocalControl.stEepromCfgData.stBLTimeZone.byStartMin)||
1822   3                                      (stLocalControl.stTime.byHour==stLocalControl.stEepromCfgData.stBLTimeZone.byEndHour && stLocalControl
             -.stTime.byMin<stLocalControl.stEepromCfgData.stBLTimeZone.byEndMin))
1823   3                              {//现在时间在此区间内,关闭显示屏
1824   4                                      if(!bSendCmdCloseLcd)
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 31  

1825   4                                      {
1826   5                                              pstBusFreq->byCmd = CMD_CLOSE_LCD;
1827   5                                              Bus0OutputData(&(pstBusFreq->bySndSecAddr));
1828   5                                              OSWait(K_TMO,200);              //延时1S
1829   5                                              
1830   5                                              pstBusFreq->bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1831   5                                              pstBusFreq->bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1832   5                                              pstBusFreq->bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1833   5                                              pstBusFreq->byCmd = CMD_CLOSE_LCD;
1834   5                                              pstBusFreq->byRecSecAddr = 0xff;
1835   5                                              pstBusFreq->byRecRoomAddr= 0xff;
1836   5                                              pstBusFreq->byRecBedAddr = 0xff;
1837   5                                              Bus0OutputData(&(pstBusFreq->bySndSecAddr));                                    
1838   5                                              bSendCmdCloseLcd =1;
1839   5                                              bSendCmdOpenLcd  =0;
1840   5                                      }
1841   4                              }
1842   3                              else 
1843   3                              {//现在时间不在此区间内,打开显示屏
1844   4                                      if(!bSendCmdOpenLcd)
1845   4                                      {
1846   5                                              pstBusFreq->byCmd = CMD_OPEN_LCD;
1847   5                                              Bus0OutputData(&(pstBusFreq->bySndSecAddr));
1848   5                                              OSWait(K_TMO,200);              //延时1S
1849   5                                              
1850   5                                              pstBusFreq->bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1851   5                                              pstBusFreq->bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1852   5                                              pstBusFreq->bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1853   5                                              pstBusFreq->byCmd = CMD_OPEN_LCD;
1854   5                                              pstBusFreq->byRecSecAddr = 0xff;
1855   5                                              pstBusFreq->byRecRoomAddr= 0xff;
1856   5                                              pstBusFreq->byRecBedAddr = 0xff;
1857   5                                              Bus0OutputData(&(pstBusFreq->bySndSecAddr));                                    
1858   5                                              bSendCmdCloseLcd =0;
1859   5                                              bSendCmdOpenLcd  =1;                                                    
1860   5                                      }
1861   4                              }                               
1862   3                      }
1863   2                      else
1864   2                      {//start.hour==end.hour  start.min>end.min
1865   3                              if(stLocalControl.stTime.byHour != stLocalControl.stEepromCfgData.stBLTimeZone.byStartHour)
1866   3                              {//现在时间在此区间内,关闭显示屏
1867   4                                      if(!bSendCmdCloseLcd)
1868   4                                      {
1869   5                                              pstBusFreq->byCmd = CMD_CLOSE_LCD;
1870   5                                              Bus0OutputData(&(pstBusFreq->bySndSecAddr));
1871   5                                              OSWait(K_TMO,200);              //延时1S
1872   5                                              
1873   5                                              pstBusFreq->bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1874   5                                              pstBusFreq->bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1875   5                                              pstBusFreq->bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1876   5                                              pstBusFreq->byCmd = CMD_CLOSE_LCD;
1877   5                                              pstBusFreq->byRecSecAddr = 0xff;
1878   5                                              pstBusFreq->byRecRoomAddr= 0xff;
1879   5                                              pstBusFreq->byRecBedAddr = 0xff;
1880   5                                              Bus0OutputData(&(pstBusFreq->bySndSecAddr));                                    
1881   5                                              bSendCmdCloseLcd =1;
1882   5                                              bSendCmdOpenLcd  =0;
1883   5                                      }
1884   4                              }
1885   3      
1886   3                              else
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 32  

1887   3                              {//stLocalControl.stTime.byHour == start.hour
1888   4                                      if(stLocalControl.stTime.byMin>=stLocalControl.stEepromCfgData.stBLTimeZone.byEndMin && stLocalControl
             -.stTime.byMin<stLocalControl.stEepromCfgData.stBLTimeZone.byStartMin)
1889   4                                      {//现在时间不在此区间内,打开显示屏
1890   5                                              if(!bSendCmdOpenLcd)
1891   5                                              {
1892   6                                                      pstBusFreq->byCmd = CMD_OPEN_LCD;
1893   6                                                      Bus0OutputData(&(pstBusFreq->bySndSecAddr));
1894   6                                                      OSWait(K_TMO,200);              //延时1S
1895   6                                                      
1896   6                                                      pstBusFreq->bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1897   6                                                      pstBusFreq->bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1898   6                                                      pstBusFreq->bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1899   6                                                      pstBusFreq->byCmd = CMD_OPEN_LCD;
1900   6                                                      pstBusFreq->byRecSecAddr = 0xff;
1901   6                                                      pstBusFreq->byRecRoomAddr= 0xff;
1902   6                                                      pstBusFreq->byRecBedAddr = 0xff;
1903   6                                                      Bus0OutputData(&(pstBusFreq->bySndSecAddr));                                            
1904   6                                                      bSendCmdCloseLcd =0;
1905   6                                                      bSendCmdOpenLcd  =1;                                                    
1906   6                                              }
1907   5                                      }                                       
1908   4      
1909   4                                      else 
1910   4                                      {//现在时间在此区间内,关闭显示屏
1911   5                                              if(!bSendCmdCloseLcd)
1912   5                                              {
1913   6                                                      pstBusFreq->byCmd = CMD_CLOSE_LCD;
1914   6                                                      Bus0OutputData(&(pstBusFreq->bySndSecAddr));
1915   6                                                      OSWait(K_TMO,200);              //延时1S
1916   6                                                      
1917   6                                                      pstBusFreq->bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
1918   6                                                      pstBusFreq->bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
1919   6                                                      pstBusFreq->bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
1920   6                                                      pstBusFreq->byCmd = CMD_CLOSE_LCD;
1921   6                                                      pstBusFreq->byRecSecAddr = 0xff;
1922   6                                                      pstBusFreq->byRecRoomAddr= 0xff;
1923   6                                                      pstBusFreq->byRecBedAddr = 0xff;
1924   6                                                      Bus0OutputData(&(pstBusFreq->bySndSecAddr));                                            
1925   6                                                      bSendCmdCloseLcd =1;
1926   6                                                      bSendCmdOpenLcd  =0;
1927   6                                              }
1928   5                                      }       
1929   4      
1930   4                              }
1931   3                      }
1932   2                                      
1933   2              }
1934   1      
1935   1      }
1936          
1937          /**********************************************************
1938          *函数名称                       :InitParameter  
1939          *函数描述               :初始化Flash中的配置数据
1940          *输入参数               :
1941          *返回值                         :
1942          *全局变量                       :stLocalControl
1943          *调用模块                       :EnableIAP,IapReadByte,DisableIAP
1944          ***********************************************************
1945          *创建人                 :尹运同
1946          *创建日期                       :2008-9-22
1947          ***********************************************************
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 33  

1948          *修改人                         :
1949          *修改日期               :
1950          *注释                   :
1951          **********************************************************/
1952          void InitParameter(void)
1953          {
1954   1              uint8 flagData;
1955   1              uint8 readtimes=3;
1956   1      CheckIapSec0:   
1957   1      
1958   1              do
1959   1              {
1960   2      
1961   2                      if(ParaCrcCheck(IAP0_ADDR) ==1)  break;
1962   2                              
1963   2      
1964   2              }while(--readtimes);
1965   1      
1966   1      
1967   1              if(readtimes)
1968   1              {//第一块校验和正确
1969   2      
1970   2                      EnableIAP(IAP_READ);
1971   2                      flagData = IapReadByte(IAP0_ADDR);
1972   2                      DisableIAP();
1973   2                      
1974   2                      if(flagData == INIT_FLAG)
1975   2                      {//数据已经初始化完毕了,读取数据参数
1976   3                              ReadParameter(IAP0_ADDR);
1977   3                              return;
1978   3                      }
1979   2                      else    goto CheckIapSec1;      
1980   2              }
1981   1      
1982   1              else
1983   1              {
1984   2      CheckIapSec1:   
1985   2                      readtimes=3;    
1986   2                      do
1987   2                      {
1988   3                              if(ParaCrcCheck(IAP0_ADDR+sizeof(STEepromCfgData)) ==1)  break;
1989   3                                      
1990   3                      }while(--readtimes);
1991   2              
1992   2              
1993   2                      if(readtimes)
1994   2                      {//第二块校验和正确
1995   3                              EnableIAP(IAP_READ);
1996   3                              flagData = IapReadByte(IAP0_ADDR+sizeof(STEepromCfgData));
1997   3                              DisableIAP();
1998   3                              
1999   3                              if(flagData == INIT_FLAG)
2000   3                              {//数据已经初始化完毕了,读取数据参数
2001   4                                      ReadParameter(IAP0_ADDR+sizeof(STEepromCfgData));
2002   4                                      SaveParameter(IAP0_ADDR);
2003   4                                      return;
2004   4                              }
2005   3                              else    goto UseInitValue;      
2006   3                      }
2007   2                      else
2008   2                      {//第一块和第二块存储区3次读取都失败或者未初始化，应用初始值，但不保存到内部EEPROM中去
2009   3      UseInitValue:
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 34  

2010   3                              stLocalControl.stEepromCfgData.byInitFlag = MyParameter[0];
2011   3                              stLocalControl.stEepromCfgData.bySelfSecAddr = MyParameter[1];
2012   3                              stLocalControl.stEepromCfgData.bySelfRoomAddr = MyParameter[2];
2013   3                              stLocalControl.stEepromCfgData.bySelfBedAddr = MyParameter[3];
2014   3                              stLocalControl.stEepromCfgData.byEnable1 = MyParameter[4];
2015   3                              stLocalControl.stEepromCfgData.byEnable2 = MyParameter[5];
2016   3                              stLocalControl.stEepromCfgData.byPrio = MyParameter[6];
2017   3                              stLocalControl.stEepromCfgData.byRingTime =MyParameter[7];
2018   3                              stLocalControl.stEepromCfgData.byTalkTime = MyParameter[8];
2019   3                              stLocalControl.stEepromCfgData.byBroadTime = MyParameter[9];
2020   3                              stLocalControl.stEepromCfgData.byListenDelay = MyParameter[10];
2021   3                              stLocalControl.stEepromCfgData.byVolumStep = MyParameter[11];
2022   3                              stLocalControl.stEepromCfgData.byHDwnRingVol= MyParameter[12];
2023   3                              stLocalControl.stEepromCfgData.byHUpRingVol = MyParameter[13];
2024   3                              stLocalControl.stEepromCfgData.byCH0HDwnTalkedVol = MyParameter[14];
2025   3                              stLocalControl.stEepromCfgData.byCH1HDwnTalkedVol = MyParameter[15];
2026   3                              stLocalControl.stEepromCfgData.byCH0HUpTalkedVol = MyParameter[16];
2027   3                              stLocalControl.stEepromCfgData.byCH1HUpTalkedVol = MyParameter[17];
2028   3                              stLocalControl.stEepromCfgData.byHDwnBroadVol = MyParameter[18];
2029   3                              stLocalControl.stEepromCfgData.byHUpBroadVol = MyParameter[19];
2030   3                              stLocalControl.stEepromCfgData.byHDwnNoteVol = MyParameter[20];
2031   3                              stLocalControl.stEepromCfgData.byHUpNoteVol = MyParameter[21];
2032   3                              stLocalControl.stEepromCfgData.byHDwnMusicVol =MyParameter[22];
2033   3                              stLocalControl.stEepromCfgData.byHUpMusicVol =MyParameter[23];
2034   3                              stLocalControl.stEepromCfgData.byCH0HDwnTalkVol =MyParameter[24];
2035   3                              stLocalControl.stEepromCfgData.byCH1HDwnTalkVol =MyParameter[25];
2036   3                              stLocalControl.stEepromCfgData.byCH0HUpTalkVol =MyParameter[26];
2037   3                              stLocalControl.stEepromCfgData.byCH1HUpTalkVol =MyParameter[27];
2038   3                              stLocalControl.stEepromCfgData.byHDwnSelfRingVol =MyParameter[28];
2039   3                              stLocalControl.stEepromCfgData.byHUpSelfRingVol = MyParameter[29];
2040   3                              stLocalControl.stEepromCfgData.byMaxVol =MyParameter[30];
2041   3                              stLocalControl.stEepromCfgData.byMinVol = MyParameter[31];
2042   3                              stLocalControl.stEepromCfgData.byReserve1 =MyParameter[32];
2043   3                              stLocalControl.stEepromCfgData.byReserve2 =MyParameter[33];
2044   3                              stLocalControl.stEepromCfgData.byReserve3 =MyParameter[34];
2045   3                              
2046   3                              stLocalControl.stEepromCfgData.bySerialNum1= MyParameter[35];
2047   3                              stLocalControl.stEepromCfgData.bySerialNum2= MyParameter[36];
2048   3                              stLocalControl.stEepromCfgData.bySerialNum3= MyParameter[37];
2049   3                              stLocalControl.stEepromCfgData.stBLTimeZone.byStartHour = MyParameter[38];
2050   3                              stLocalControl.stEepromCfgData.stBLTimeZone.byStartMin = MyParameter[39];
2051   3                              stLocalControl.stEepromCfgData.stBLTimeZone.byEndHour = MyParameter[40];
2052   3                              stLocalControl.stEepromCfgData.stBLTimeZone.byEndMin = MyParameter[41]; 
2053   3                              
2054   3                              stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartHour = MyParameter[42];
2055   3                              stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartMin = MyParameter[43];
2056   3                              stLocalControl.stEepromCfgData.stVoiceTimeZone.byEndHour = MyParameter[44];
2057   3                              stLocalControl.stEepromCfgData.stVoiceTimeZone.byEndMin = MyParameter[45];
2058   3                              
2059   3                              stLocalControl.stEepromCfgData.byMicroVoiceVal= MyParameter[46];
2060   3                              stLocalControl.stEepromCfgData.byVersionHi = MyParameter[47];
2061   3                              stLocalControl.stEepromCfgData.byVersionLo= MyParameter[48];
2062   3      
2063   3                              stLocalControl.stEepromCfgData.byCrc = CalcParaCrc();
2064   3      
2065   3                                                      //加载使能数据
2066   3                              byEnable1 = stLocalControl.stEepromCfgData.byEnable1;
2067   3                              byEnable2 = stLocalControl.stEepromCfgData.byEnable2;   
2068   3                      }       
2069   2              }
2070   1              DisableIAP();                   
2071   1      }
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 35  

*** WARNING C280 IN LINE 1956 OF SINGLEBUS.C: 'CheckIapSec0': unreferenced label
2072          
2073          /**********************************************************
2074          *函数名称                       :Bus0RecDeal    
2075          *函数描述               :单总线0收到一帧数据处理函数,该函数首先
2076                                                   取出收到的数据,针对每条命令执行对应的控
2077                                                   制动作
2078          *输入参数               :
2079          *返回值                         :
2080          *全局变量                       :stLocalControl
2081          *调用模块                       :
2082          ***********************************************************
2083          *创建人                 :尹运同
2084          *创建日期                       :2008-9-22
2085          ***********************************************************
2086          *修改人                         :
2087          *修改日期               :
2088          *注释                   :
2089          **********************************************************/
2090          void Bus0RecDeal(void)
2091          {
2092   1      /*
2093   1              //取出收到的数据帧                      
2094   1              OS_ENTER_CRITICAL();
2095   1              memcpy(&(stLocalControl.stBusDealFreq), byBus0RecData, sizeof(STBusFreq));
2096   1              bBus0RecFinish = 0;     
2097   1              OS_EXIT_CRITICAL();
2098   1      */
2099   1              //以下仅供测试用
2100   1      //      uart_send((uint8 *)&(stLocalControl.stBusDealFreq),7);
2101   1              /////////////////////////////////////////////////////////////////////////////////////
2102   1              
2103   1              
2104   1              if(bLanding && (stLocalControl.stBusDealFreq.byCmd != CMD_ENTER))
2105   1              {       //如果是登记状态,收到的命令不是登记确认命令,不作处理
2106   2                      return;
2107   2              }       
2108   1              switch(stLocalControl.stBusDealFreq.byCmd)
2109   1              {
2110   2                      case CMD_ENTER:                                                                         //确认登记命令
2111   2                              if(bLanding)
2112   2                              {
2113   3                                      if(AddrCompare(&(stLocalControl.stBusDealFreq)))
2114   3                                      {       //发送到本机,取出系统状态       
2115   4                                              bLanding = 0; 
2116   4                                              stLocalControl.stBusDealFreq.bySndSecAddr &= 0x80;                              
2117   4                                              byDevState1 |= stLocalControl.stBusDealFreq.bySndSecAddr; 
2118   4                                              MakeCH0TimerOut(0, 0);                                                                                                                  
2119   4                                      }
2120   3                              }                       
2121   2                              break;
2122   2                      case CMD_QUEST:                                                                         //查询命令
2123   2                              if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
2124   2                              {
2125   3                                      stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2126   3                                      stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2127   3                                      stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2128   3                                      stLocalControl.stBusDealFreq.byCmd =  CMD_QUEST_ANSWER;                         
2129   3                                      Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                           
2130   3                                      //stLocalControl.stBusDealFreq.byCmd = CMD_QUEST;                       
2131   3                                      //Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); 
2132   3                              }
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 36  

2133   2                              break;                  
2134   2                      case CMD_COMM_CALL:                                                                     //普通呼叫命令
2135   2                              if(!bBusy)
2136   2                              {       //通道0空闲                     
2137   3                                      bBusy = 1;      
2138   3                                      if(bIndicatingOther)
2139   3                                      {       //如果正在指示其他分机,停止指示
2140   4                                              bIndicatingOther = 0;
2141   4                                              VoiceChannelCtx();
2142   4                                              if(!(bChannel1Talk|bChannel1Talked))
2143   4                                              {                               
2144   5                                                      stLocalControl.stBusDealFreq.byCmd = CMD_STOP_INDICATION;
2145   5                                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2146   5                                              }
2147   4                                      }                       
2148   3      //                              //保存主动呼叫方地址
2149   3      //                              SaveCallAddr(&(stLocalControl.stBusDealFreq));
2150   3                                      //设置超时5s    
2151   3                                      MakeCH0TimerOut(250, 0);
2152   3                                      if(AddrCompare(&(stLocalControl.stBusDealFreq)))
2153   3                                      {       //呼叫本机设备 
2154   4                                              //保存主动呼叫方地址
2155   4                                              SaveCallAddr(&(stLocalControl.stBusDealFreq));                          
2156   4                                              bMainMenuSet =0;                                        
2157   4                                              if(!(bChannel1Talk|bChannel1Talked))
2158   4                                              {       //通道1空闲,则本机为空闲状态,返回应答命令       
2159   5                                                      stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2160   5                                                      stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2161   5                                                      stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2162   5                                                      stLocalControl.stBusDealFreq.byCmd = CMD_COMM_ANSWER;
2163   5                                                      stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stCallAddr.bySndSecAddr;
2164   5                                                      stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stCallAddr.bySndRoomAddr;
2165   5                                                      stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stCallAddr.bySndBedAddr;
2166   5                                                      Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); 
2167   5                                              }                               
2168   4                                      }                                                       
2169   3                              }
2170   2                              break;
2171   2                      case CMD_COMM_ANSWER:                                                           //普通应答命令                          
2172   2                              bBusy = 1;
2173   2                              //设置振铃超时                          
2174   2                              MakeCH0TimerOut(50, stLocalControl.stEepromCfgData.byRingTime);
2175   2                              if(AddrCompare(&(stLocalControl.stBusDealFreq)))
2176   2                              {       //应答本机,清等待应答,进入等待接听状态  
2177   3                                      bWaitAck = 0;                                   
2178   3                                      bWaitListen = 1;                                                                                
2179   3                                      if(bChannel1Talk||bChannel1Talked||(bKeyAnswer&&(!bKeyEnterDown))||
2180   3                                              (bHandAnswer&&bHandleDown)||(!(bKeyAnswer||bHandAnswer)))
2181   3                                      {       //如果通道1忙,或者本机主动通话条件不存在了,缩短超时时间 
2182   4                                              //(通话条件:免提通话则要求免提键一直处于按下状态,听筒通话
2183   4                                              //则要求听筒一直处于摘机状态)                   
2184   4                                              MakeCH0TimerOut(5, 0);
2185   4                                              break;
2186   4                                      }
2187   3                                      VoiceChannelCtx();                                                              
2188   3                              }
2189   2                              break;
2190   2                      case CMD_CALL_LISTEN:                                                           //接听命令                      
2191   2                              bBusy = 1;
2192   2                              //设置通话超时
2193   2                              MakeCH0TimerOut(50, stLocalControl.stEepromCfgData.byTalkTime);                 
2194   2                              if(AddrCompare(&(stLocalControl.stBusDealFreq)))
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 37  

2195   2                              {       //接听本机,清等待接听,进入通道0主动通话状态                             
2196   3                                      bWaitAck = bWaitListen = 0;                             
2197   3                                      bChannel0Talk = 1;                                                                                              
2198   3                                      if(bChannel1Talk||bChannel1Talked||(bKeyAnswer&&(!bKeyEnterDown))||
2199   3                                              (bHandAnswer&&bHandleDown)||(!(bKeyAnswer||bHandAnswer)))
2200   3                                      {       //如果通道1忙,或者本机主动通话条件不存在了,缩短超时时间 
2201   4                                              //(通话条件:免提通话则要求免提键一直处于按下状态,听筒通话
2202   4                                              //则要求听筒一直处于摘机状态)                   
2203   4                                              MakeCH0TimerOut(5, 0);                                  
2204   4                                              break;
2205   4                                      }                                                       
2206   3                                      VoiceChannelCtx();
2207   3                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                                                                   
2208   3                              }
2209   2                              break;                  
2210   2                      case CMD_BROADCAST1:                                                            //收到病区广播命令
2211   2                      case CMD_BROADCAST2:                                                            //收到办公区广播命令
2212   2                      case CMD_BROADCAST3:                                                            //收到全区广播命令
2213   2                              if(!bBusy)
2214   2                              {       //通道0空闲                             
2215   3                                      bBusy = 1;      
2216   3                                      //暂存命令                              
2217   3                                      stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stBusDealFreq.byCmd;                         
2218   3                                      //设置广播超时
2219   3                                      MakeCH0TimerOut(50, stLocalControl.stEepromCfgData.byBroadTime);                                
2220   3                                      //保存主动呼叫方地址    
2221   3      //                              SaveCallAddr(&(stLocalControl.stBusDealFreq));
2222   3                                      if(bIndicatingOther)
2223   3                                      {       //如果正在指示其他分机,停止指示
2224   4                                              bIndicatingOther = 0;                                                           
2225   4                                              if(!(bChannel1Talk|bChannel1Talked))
2226   4                                              {                               
2227   5                                                      stLocalControl.stBusDealFreq.byCmd = CMD_STOP_INDICATION;
2228   5                                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2229   5                                              } 
2230   4                                      }                                                       
2231   3                                      if((bChannel1Talk|bChannel1Talked))
2232   3                                      {       //通道1通话中,肯定没有显示呼叫信息了,不做任何处理       
2233   4                                              break;
2234   4                                      }                                                       
2235   3                                      switch(stLocalControl.stBusDealFreq.byRecSecAddr)
2236   3                                      {       //针对具体命令,看本机是否允许相应的广播
2237   4                                              case CMD_BROADCAST1:
2238   4                                                      bSickRoomBroad = bEnSickRoomBroad;                                              
2239   4                                                      break;
2240   4                                              case CMD_BROADCAST2:
2241   4                                                      bOfficeBroad = bEnOfficeBroad;                                          
2242   4                                                      break;
2243   4                                              case CMD_BROADCAST3:
2244   4                                                      bAllBroad = bEnAllBroad;                                                
2245   4                                                      break;
2246   4                                      }
2247   3                                      stLocalControl.stBusDealFreq.byCmd = stLocalControl.stBusDealFreq.byRecSecAddr; 
2248   3                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2249   3                                      VoiceChannelCtx();                              
2250   3                              }
2251   2                              break;                  
2252   2                      case CMD_INFO_INDICATION:                                                       //收到呼叫指示命令                                                                      
2253   2                              if(!bBusy)              
2254   2                              {       //通道0不忙             
2255   3                                      switch(stLocalControl.stBusDealFreq.byRecSecAddr & 0x1f)
2256   3                                      {
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 38  

2257   4                                              case CMD_INFUSION_CALL:                                         //输液呼叫
2258   4                                                      if(!bEnInfusionDeal)
2259   4                                                      {       //不允许处理输液呼叫
2260   5                                                              return;                                                                                                 
2261   5                                                      }                                               
2262   4                                                      break;
2263   4                                              case CMD_SERVICE_CALL:                                          //服务呼叫
2264   4                                                      if(!bEnServiceDeal)
2265   4                                                      {       //不允许处理服务呼叫
2266   5                                                              return;                                                 
2267   5                                                      }                                               
2268   4                                                      break;
2269   4                                              case CMD_HELP_CALL:                                                     //求援呼叫
2270   4                                                      if(!bEnHelpDeal)
2271   4                                                      {       //不允许处理求援呼叫
2272   5                                                              return;                                                 
2273   5                                                      }                                               
2274   4                                                      break;
2275   4                                              case CMD_EMERGENCY_CALL:                                        //紧急呼叫
2276   4                                                      if(!bEnEmergencyDeal)
2277   4                                                      {       //不允许处理紧急呼叫
2278   5                                                              return;                                         
2279   5                                                      }                                               
2280   4                                                      break;
2281   4                                              default:
2282   4                                                      return;
2283   4                                      }
2284   3                                      bMainMenuSet = 0;
2285   3                                      //保存指示方地址                                
2286   3                                      SaveIndicationData(&(stLocalControl.stBusDealFreq));
2287   3                                      //置指示标志                                                                                            
2288   3                                      bIndicatingOther = 1;
2289   3                                      if((bChannel1Talked|bChannel1Talk))
2290   3                                      {       //如果通道1处于通话状态,不作处理
2291   4                                              return;
2292   4                                      }       
2293   3                                      VoiceChannelCtx();                                                                              
2294   3                                      stLocalControl.stBusDealFreq.byCmd = CMD_INFO_INDICATION;
2295   3                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); 
2296   3      //                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2297   3                                      return;                                 
2298   3                              }
2299   2                              break;
2300   2                      case CMD_INFUSION_ANSWER:                                                       //处理输液呼叫命令
2301   2                      case CMD_SERVICE_ANSWER:                                                        //处理服务呼叫命令
2302   2                      case CMD_EMERGENCY_ANSWER:                                                      //处理紧急呼叫命令
2303   2                      case CMD_HELP_ANSWER:                                                           //处理求援呼叫命令
2304   2                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));           
2305   2                              if(!bBusy)
2306   2                              {       //通道0不忙                     
2307   3                                      bBusy = 1;      
2308   3                                      if(bIndicatingOther)
2309   3                                      {       //如果正在指示其他分机,停止指示         
2310   4                                              bIndicatingOther = 0;                                   
2311   4                                              VoiceChannelCtx();                                                                              
2312   4                                              if(!(bChannel1Talk|bChannel1Talked))
2313   4                                              {                               
2314   5                                                      stLocalControl.stBusDealFreq.byCmd = CMD_STOP_INDICATION;
2315   5                                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2316   5      //                                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2317   5                                              }                                                       
2318   4                                      } 
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 39  

2319   3                                      
2320   3      //                              //保存主动呼叫方地址                            
2321   3      //                              SaveCallAddr(&(stLocalControl.stBusDealFreq));
2322   3                                      
2323   3                                      //设置通道0超时                         
2324   3                                      MakeCH0TimerOut(250, 0);
2325   3                                      if((bChannel1Talk|bChannel1Talked))
2326   3                                      {       //如果通道1处于通话状态,缩短超时时间,超时后复位                 
2327   4                                              MakeCH0TimerOut(5, 0);
2328   4                                              break;
2329   4                                      }                               
2330   3                                      VoiceChannelCtx();                              
2331   3                              }
2332   2                              break;
2333   2                      case CMD_STOP_INDICATION:                                                       //停止指示命令                                          
2334   2                              if(bIndicatingOther)
2335   2                              {
2336   3                                      bIndicatingOther = 0;
2337   3                                      VoiceChannelCtx(); 
2338   3                                      if(!(bChannel1Talk|bChannel1Talked))
2339   3                                      {                               
2340   4                                              stLocalControl.stBusDealFreq.byCmd = CMD_STOP_INDICATION;
2341   4                                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2342   4      //                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2343   4                                      }                                       
2344   3                              }
2345   2                              break;
2346   2                      case CMD_INFUSION_CLEAR:                                                        //清除输液呼叫命令
2347   2                      case CMD_SERVICE_CLEAR:                                                         //清除服务呼叫命令
2348   2                      case CMD_HELP_CLEAR:                                                            //清除求援呼叫命令
2349   2                      case CMD_EMERGENCY_CLEAR:                                                       //清除紧急呼叫命令
2350   2                              if((stLocalControl.stBusDealFreq.bySndRoomAddr == MOVE_FJ)&&
2351   2                                 (stLocalControl.stBusDealFreq.bySndSecAddr!=stLocalControl.stEepromCfgData.bySelfSecAddr))
2352   2                              {//是移动分机发过来的清除呼叫且区号不对 ,直接返回
2353   3                                      return;
2354   3                              }       
2355   2                              if((stLocalControl.stBusDealFreq.bySndRoomAddr == ADD_BED_FJ)&&
2356   2                                 (stLocalControl.stBusDealFreq.bySndSecAddr!=stLocalControl.stEepromCfgData.bySelfSecAddr))
2357   2                              {//是加床分机发过来的清除呼叫且区号不对 ,直接返回
2358   3                                      return;
2359   3                              }                       
2360   2                              while(FALSE==Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)))
2361   2                              {
2362   3                                      WDT_CONTR = 0x3d;       //喂狗
2363   3                                      OSWait(K_TMO,100);      //延时500ms
2364   3                                      
2365   3                              }
2366   2      
2367   2                              if(bIndicatingOther && 
2368   2                                      (stLocalControl.stBusDealFreq.byRecSecAddr == stLocalControl.stIndicationData.stAddr.bySndSecAddr) &&
2369   2                                      (stLocalControl.stBusDealFreq.byRecRoomAddr == stLocalControl.stIndicationData.stAddr.bySndRoomAddr) &
             -&
2370   2                                      (stLocalControl.stBusDealFreq.byRecBedAddr == stLocalControl.stIndicationData.stAddr.bySndBedAddr) &&
2371   2                                      ((stLocalControl.stBusDealFreq.byCmd - 0x0a) == (stLocalControl.stIndicationData.byCallCmd & 0x1f)))
2372   2                              {       //清除本机正在指示的呼叫信息                            
2373   3                                      bIndicatingOther = 0;                                           
2374   3                                      VoiceChannelCtx();                              
2375   3                                      if(!(bChannel1Talk|bChannel1Talked))
2376   3                                      {                               
2377   4                                              stLocalControl.stBusDealFreq.byCmd = CMD_STOP_INDICATION;
2378   4                                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2379   4      //                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 40  

2380   4                                      }                                                                                                                                                       
2381   3                              }
2382   2                              break;                  
2383   2                      case CMD_SYSTERM_RESET:                                                         //系统复位命令
2384   2                              if(bBusy|bChannel1Talked|bChannel1Talk)
2385   2                              {//系统(通道0)忙或者通道1忙
2386   3                                      SysReset();
2387   3                              }
2388   2                              break; 
2389   2                      case CMD_START_VOICE:                                                           //启动播音命令
2390   2                              if(AddrCompare(&(stLocalControl.stBusDealFreq)))
2391   2                              {
2392   3                                      if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
2393   3                                      {
2394   4                                              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2395   4                                              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2396   4                                              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2397   4                                              stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER;
2398   4                                              stLocalControl.stBusDealFreq.byRecSecAddr = CMD_START_VOICE;
2399   4                                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2400   4                                      }
2401   3      
2402   3                                      if((bChannel1Talk|bChannel1Talked))
2403   3                                      {       //通话中,清通话信息
2404   4                                              stLocalControl.stBusDealFreq.byCmd = CMD_STOP_INDICATION;
2405   4                                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2406   4                                      }               
2407   3                                      bChannel1Talked = bChannel1Talk = 0;                            
2408   3                                      MakeCH1TimerOut(0, 0);                  
2409   3                                      bVoiceNoting = bEnVoiceNote;                            
2410   3                                      VoiceChannelCtx();                                                                                                      
2411   3                              }
2412   2                              break;
2413   2                      case CMD_MUSIC_PLAY:                                                            //背景音乐播放
2414   2                              if(AddrCompare(&(stLocalControl.stBusDealFreq)))
2415   2                              {
2416   3                                      if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
2417   3                                      {
2418   4                                              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2419   4                                              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2420   4                                              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2421   4                                              stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER;
2422   4                                              stLocalControl.stBusDealFreq.byRecSecAddr = CMD_MUSIC_PLAY;
2423   4                                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2424   4                                      }                       
2425   3                                      if((bChannel1Talk|bChannel1Talked))
2426   3                                      {       //通话中,清通话信息
2427   4                                              stLocalControl.stBusDealFreq.byCmd = CMD_STOP_INDICATION;
2428   4                                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2429   4                                      }       
2430   3                                      bChannel1Talked = bChannel1Talk = 0;
2431   3                                      MakeCH1TimerOut(0, 0);                                  
2432   3                                      bMusicPlaying = bEnMusicplay;                                   
2433   3                                      VoiceChannelCtx();                                                                                                      
2434   3                              }
2435   2                              break;  
2436   2                      case CMD_STOP_VOICE:                                                            //停止所有音乐播放
2437   2                              if(AddrCompare(&(stLocalControl.stBusDealFreq)))
2438   2                              {
2439   3                                      if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
2440   3                                      {
2441   4                                              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 41  

2442   4                                              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2443   4                                              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2444   4                                              stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER;
2445   4                                              stLocalControl.stBusDealFreq.byRecSecAddr = CMD_STOP_VOICE;
2446   4                                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2447   4                                      }                               
2448   3                                      bVoiceNoting = bMusicPlaying = 0;
2449   3                                      VoiceChannelCtx();                                      
2450   3                              }
2451   2                              break; 
2452   2                      case CMD_CHANNEL_CHANGE:                                                        //通道切换命令
2453   2                              //将通道0的状态切换到通道1上,同时清除通道0的状态
2454   2                              bBusy = bWaitAck = bWaitListen = bCalledRing =  
2455   2                                      bSickRoomBroad = bOfficeBroad = bAllBroad = bSelfBroad = 0;     
2456   2                              MakeCH0TimerOut(0, 0);                                                          
2457   2                              if((bChannel0Talked||bChannel0Talk))
2458   2                              {                               
2459   3                                      bChannel1Talked = bChannel0Talked;
2460   3                                      bChannel1Talk = bChannel0Talk;
2461   3                                      bChannel0Talked = bChannel0Talk = 0; 
2462   3                                      //设置通道1通话超时                                                     
2463   3                                      MakeCH1TimerOut(50, stLocalControl.stEepromCfgData.byTalkTime);
2464   3                                      if(bChannel1Talk)
2465   3                                      {       //切换前通道0处于主动通话状态
2466   4                                              if((bKeyAnswer&&(!bKeyEnterDown))||
2467   4                                                      (bHandAnswer&&bHandleDown)||(!(bKeyAnswer||bHandAnswer)))                                       
2468   4                                              {       //本机主动通话条件不存在了,缩短超时时间
2469   5                                                      //(通话条件:免提通话则要求免提键一直处于按下状态,听筒通话
2470   5                                                      //则要求听筒一直处于摘机状态)   
2471   5                                                      MakeCH1TimerOut(5, 0); 
2472   5                                                      break;                                          
2473   5                                              }                                                                                                                                               
2474   4                                      }       
2475   3                                      VoiceChannelCtx();                      
2476   3                              }                                       
2477   2                              break;
2478   2                      case CMD_CHANNEL_CLOSE:                                                         //关闭通道切换命令
2479   2                              if(bChannel1Talked||bChannel1Talk)
2480   2                              {       //如果通道1处于通话状态,清所有通话标志
2481   3                                      bKeyAnswer = bHandAnswer = 0;
2482   3                              }
2483   2                              if((bChannel1Talked|bChannel1Talk))
2484   2                              {       //如果通道1处于通话状态,结束后需指示新的信息,如没有,保持状态
2485   3                                      if(bIndicatingOther)
2486   3                                      {       //如果有指示,立即显示指示信息   
2487   4                                              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stIndicationData.stAddr.bySndSecAddr;
2488   4                                              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stIndicationData.stAddr.bySndRoomAddr;
2489   4                                              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stIndicationData.stAddr.bySndBedAddr;
2490   4                                              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stIndicationData.byCallCmd;
2491   4                                              stLocalControl.stBusDealFreq.byCmd = CMD_INFO_INDICATION;
2492   4                                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2493   4      //                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2494   4                                      }
2495   3                                      else
2496   3                                      {
2497   4                                              stLocalControl.stBusDealFreq.byCmd = CMD_STOP_INDICATION;
2498   4                                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2499   4      //                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2500   4                                      }       
2501   3                              }
2502   2                              bChannel1Talked = bChannel1Talk = 0;  
2503   2                              MakeCH1TimerOut(0, 0);                                                  
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 42  

2504   2                              VoiceChannelCtx();                      
2505   2                              break;
2506   2      
2507   2      /*              case CMD_CLOSE_485BUS:                                                          //关闭485输出
2508   2                              KDR = 1;                        
2509   2                              break;
2510   2      */                      
2511   2                              
2512   2      /*              case CMD_OPEN_485BUS_IN:
2513   2                              if(AddrCompare(&(stLocalControl.stBusDealFreq)))
2514   2                              {   KDR = 0;
2515   2                                      stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2516   2                                      stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2517   2                                      stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2518   2                                      stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER;    
2519   2                                      stLocalControl.stBusDealFreq.byRecSecAddr = CMD_OPEN_485BUS_IN;
2520   2                                      Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2521   2                              }
2522   2                              break;
2523   2      */                      
2524   2      
2525   2                      case CMD_OPEN_LCD:                                                                      //打开LCD背光显示
2526   2                              if(AddrCompare(&(stLocalControl.stBusDealFreq)))
2527   2                              {
2528   3                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2529   3                                      bSendCmdCloseLcd=0;
2530   3                                      bSendCmdOpenLcd =0;
2531   3                              }
2532   2                              break;
2533   2                      case CMD_CLOSE_LCD:                                                                     //关闭LCD背光显示
2534   2                              if(AddrCompare(&(stLocalControl.stBusDealFreq)))
2535   2                              {
2536   3                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2537   3                                      bSendCmdCloseLcd=0;
2538   3                                      bSendCmdOpenLcd =0;                             
2539   3                              }
2540   2                              break;
2541   2                      case CMD_POWER_ON:                                                                      //本机重新热启动
2542   2                              if(AddrCompare(&(stLocalControl.stBusDealFreq)))
2543   2                              {                                       
2544   3                                      if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
2545   3                                      {//绝对地址
2546   4                                              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2547   4                                              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2548   4                                              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2549   4                                              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stBusDealFreq.byCmd;//原命令
2550   4                                              stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER;
2551   4                                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2552   4                                      }
2553   3                                      else
2554   3                                      {//广播地址
2555   4                                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                           
2556   4                                      }
2557   3                              }
2558   2                              break;
2559   2                      case CMD_CLEAR_LCD:                                                                     //清除液晶显示
2560   2                              if(DirAddrCompare(&(stLocalControl.stBusDealFreq)))
2561   2                              {
2562   3                                      stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2563   3                                      stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2564   3                                      stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2565   3                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 43  

2566   3      
2567   3                                      stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stBusDealFreq.byCmd;//原命令
2568   3                                      stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER;    
2569   3                                      Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2570   3                              }
2571   2                              break;
2572   2                      case CMD_DATA_SEND:                                                                     //校时命令,校正液晶显示时间                     
2573   2                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2574   2      
2575   2                              stLocalControl.stTime.bySec = stLocalControl.stBusDealFreq.bySndSecAddr & 0x7f;
2576   2                              stLocalControl.stTime.byMin = stLocalControl.stBusDealFreq.bySndRoomAddr & 0x7f;
2577   2                              stLocalControl.stTime.byHour = stLocalControl.stBusDealFreq.bySndBedAddr & 0x3f;
2578   2                              stLocalControl.stTime.byDay = stLocalControl.stBusDealFreq.byRecSecAddr & 0x3f;
2579   2                              stLocalControl.stTime.byMonth = stLocalControl.stBusDealFreq.byRecRoomAddr & 0x1f;
2580   2                              stLocalControl.stTime.byYear = stLocalControl.stBusDealFreq.byRecBedAddr;
2581   2      
2582   2                              
2583   2                              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2584   2                              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2585   2                              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2586   2                              stLocalControl.stBusDealFreq.byRecSecAddr = 0xff;
2587   2                              stLocalControl.stBusDealFreq.byRecRoomAddr= 0xff;
2588   2                              stLocalControl.stBusDealFreq.byRecBedAddr = 0xff;                       
2589   2      
2590   2                              if( stLocalControl.stEepromCfgData.stBLTimeZone.byStartHour==stLocalControl.stEepromCfgData.stBLTimeZon
             -e.byEndHour && stLocalControl.stEepromCfgData.stBLTimeZone.byStartMin==stLocalControl.stEepromCfgData.stBLTimeZone.byEnd
             -Min)
2591   2                              {
2592   3                                      bSendCmdCloseLcd = 0;
2593   3                                      bSendCmdOpenLcd  = 0;
2594   3                              }
2595   2                              
2596   2                              else 
2597   2                              {
2598   3                                      BackLightTimerTreat(&(stLocalControl.stBusDealFreq));
2599   3                              }
2600   2                              break;
2601   2                              
2602   2                      case CMD_INFUSION_CALL:                                                         //输液呼叫命令
2603   2                      case CMD_SERVICE_CALL:                                                          //服务呼叫命令
2604   2                      case CMD_EMERGENCY_CALL:                                                        //紧急呼叫命令
2605   2                      case CMD_HELP_CALL:                                                                     //求援呼叫命令
2606   2                              if((stLocalControl.stBusDealFreq.bySndRoomAddr == ADD_BED_FJ)&&
2607   2                                 (stLocalControl.stBusDealFreq.bySndSecAddr!=stLocalControl.stEepromCfgData.bySelfSecAddr))
2608   2                              {//是加床分机发过来的呼叫且区号不对 ,直接返回
2609   3                                      return;
2610   3                              }
2611   2      
2612   2                              break;
2613   2      
2614   2                      case CMD_INFUSION_ENTER:                
2615   2                      case CMD_SERVICE_ENTER:
2616   2                      case CMD_EMERGENCY_ENTER:
2617   2                      case CMD_HELP_ENTER:                    
2618   2                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2619   2                              break;
2620   2      
2621   2              case CMD_BL_TIMER_SET:
2622   2                      stLocalControl.stEepromCfgData.stBLTimeZone.byStartHour = stLocalControl.stBusDealFreq.bySndSecAddr;
2623   2                      stLocalControl.stEepromCfgData.stBLTimeZone.byStartMin  = stLocalControl.stBusDealFreq.bySndRoomAddr;
2624   2      
2625   2                      stLocalControl.stEepromCfgData.stBLTimeZone.byEndHour = stLocalControl.stBusDealFreq.byRecSecAddr;
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 44  

2626   2                      stLocalControl.stEepromCfgData.stBLTimeZone.byEndMin  = stLocalControl.stBusDealFreq.byRecRoomAddr;
2627   2                      SaveParameter(IAP0_ADDR);
2628   2                      
2629   2                      stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER;
2630   2                      stLocalControl.stBusDealFreq.byRecSecAddr = CMD_BL_TIMER_SET;
2631   2                      Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));           //给管理主机回应答
2632   2                      
2633   2                      stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2634   2                      stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2635   2                      stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2636   2                      stLocalControl.stBusDealFreq.byRecSecAddr = 0xff;
2637   2                      stLocalControl.stBusDealFreq.byRecRoomAddr= 0xff;
2638   2                      stLocalControl.stBusDealFreq.byRecBedAddr = 0xff;
2639   2                      
2640   2                      
2641   2                      if( stLocalControl.stEepromCfgData.stBLTimeZone.byStartHour==stLocalControl.stEepromCfgData.stBLTimeZone
             -.byEndHour && stLocalControl.stEepromCfgData.stBLTimeZone.byStartMin==stLocalControl.stEepromCfgData.stBLTimeZone.byEndM
             -in)
2642   2                      {
2643   3                              stLocalControl.stBusDealFreq.byCmd = CMD_OPEN_LCD;
2644   3                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));   
2645   3                              OSWait(K_TMO,200);              //延时1S
2646   3                              
2647   3                              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2648   3                              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2649   3                              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2650   3                              stLocalControl.stBusDealFreq.byCmd = CMD_OPEN_LCD;
2651   3                              stLocalControl.stBusDealFreq.byRecSecAddr = 0xff;
2652   3                              stLocalControl.stBusDealFreq.byRecRoomAddr= 0xff;
2653   3                              stLocalControl.stBusDealFreq.byRecBedAddr = 0xff;
2654   3                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                   
2655   3                              bSendCmdCloseLcd = 0;
2656   3                              bSendCmdOpenLcd  = 0;
2657   3                      }
2658   2      
2659   2                      else 
2660   2                      {
2661   3                              BackLightTimerTreat(&(stLocalControl.stBusDealFreq));
2662   3                      }
2663   2                      break;
2664   2      
2665   2              case CMD_VOICE_TIMER_SET:                                       
2666   2                      stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartHour = stLocalControl.stBusDealFreq.bySndSecAddr;
2667   2                      stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartMin  = stLocalControl.stBusDealFreq.bySndRoomAddr;
2668   2      
2669   2                      stLocalControl.stEepromCfgData.stVoiceTimeZone.byEndHour = stLocalControl.stBusDealFreq.byRecSecAddr;
2670   2                      stLocalControl.stEepromCfgData.stVoiceTimeZone.byEndMin  = stLocalControl.stBusDealFreq.byRecRoomAddr;
2671   2      
2672   2                      stLocalControl.stEepromCfgData.byMicroVoiceVal = stLocalControl.stBusDealFreq.byRecBedAddr;
2673   2                      SaveParameter(IAP0_ADDR);
2674   2      
2675   2      
2676   2                      stLocalControl.stBusDealFreq.byCmd = CMD_BUS_ANSWER;
2677   2                      stLocalControl.stBusDealFreq.byRecSecAddr = CMD_VOICE_TIMER_SET;
2678   2                      Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));           //给管理主机回应答
2679   2                      
2680   2                      break;  
2681   2      
2682   2              case CMD_SUPPLY_OX_START:
2683   2              case CMD_SUPPLY_OX_END:
2684   2                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2685   2                      break;          
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 45  

2686   2                      
2687   2              case CMD_WARD_SEC_INFO_SET:
2688   2                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2689   2                      break;  
2690   2      
2691   2              case CMD_GSM_NUM_SEARCH:
2692   2      //      case CMD_GSM_NUM_SET:
2693   2      //      case CMD_GSM_NUM_DEL:
2694   2              case CMD_GSM_FUNC_SEARCH:
2695   2      //      case CMD_GSM_FUNC_SET:
2696   2                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2697   2                      break;  
2698   2                      
2699   2              case CMD_BUS_ANSWER:
2700   2                      switch(stLocalControl.stBusDealFreq.byRecSecAddr)
2701   2                      {
2702   3                              case CMD_GSM_NUM_SET:
2703   3                              case CMD_GSM_NUM_DEL:
2704   3                              case CMD_GSM_FUNC_SET:
2705   3                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2706   3                                      break;                          
2707   3                      }
2708   2                      break;
2709   2                      
2710   2              case CMD_SYSTEM_SEC_SET:
2711   2                      stLocalControl.stEepromCfgData.bySelfSecAddr=   stLocalControl.stBusDealFreq.byRecSecAddr;
2712   2                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2713   2      
2714   2                      stLocalControl.stBusDealFreq.byCmd =    CMD_GET_BUS;
2715   2                      Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2716   2                      break;
2717   2                      
2718   2              case CMD_RS485_BRT_SET:
2719   2                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2720   2                      break;                  
2721   2              }       
2722   1      }
2723          
2724          
2725          
2726          uint8 LevelToValue(uint8 VoiceLevel)
2727          {
2728   1              uint8 xdata VoiceValue;
2729   1              switch(VoiceLevel)
2730   1              {
2731   2                      case 0:
2732   2                              VoiceValue = 0x00;
2733   2                              break;
2734   2                      case 1:
2735   2                              VoiceValue = 0x01;
2736   2                              break;                  
2737   2                      case 2:
2738   2                              VoiceValue = 0x03;
2739   2                              break;
2740   2                      case 3:
2741   2                              VoiceValue = 0x07;
2742   2                              break;
2743   2                      case 4:
2744   2                              VoiceValue = 0x0f;
2745   2                              break;
2746   2                      case 5:
2747   2                              VoiceValue = 0x1f;
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 46  

2748   2                              break;                  
2749   2                      case 6:
2750   2                              VoiceValue = 0x3f;
2751   2                              break;
2752   2                      case 7:
2753   2                              VoiceValue = 0x7f;
2754   2                              break;
2755   2                      case 8:
2756   2                              VoiceValue = 0xff;
2757   2                              break;                  
2758   2              }
2759   1              return(VoiceValue);
2760   1      }
2761          
2762          /**********************************************************
2763          *函数名称                       :Bus0SendDeal   
2764          *函数描述               :单总线0发送完一帧数据处理函数,该函数首先
2765                                                   取出收到的数据,针对每条命令执行对应的控
2766                                                   制动作
2767          *输入参数               :
2768          *返回值                         :
2769          *全局变量                       :stLocalControl
2770          *调用模块                       :
2771          ***********************************************************
2772          *创建人                 :尹运同
2773          *创建日期                       :2008-9-22
2774          ***********************************************************
2775          *修改人                         :
2776          *修改日期               :
2777          *注释                   :
2778          **********************************************************/
2779          void Bus0SendDeal(void)
2780          { 
2781   1              //取出发送完成的数据帧
2782   1              OS_ENTER_CRITICAL();
2783   1              memcpy(&(stLocalControl.stBusDealFreq), byBus0SendData, sizeof(STBusFreq));             
2784   1              bBus0SendFinish = 0;                                                                            
2785   1              OS_EXIT_CRITICAL();     
2786   1      
2787   1              //以下仅供测试用
2788   1      //      uart_send((uint8 *)&(stLocalControl.stBusDealFreq),7);
2789   1      
2790   1              /////////////////////////////////////////////////////////////////////////////////////
2791   1      
2792   1              switch(stLocalControl.stBusDealFreq.byCmd)
2793   1              {
2794   2                      case CMD_LANDING:                                                                       //登记命令
2795   2                              if(bLanding)
2796   2                              {       //本机确实处在登记状态,设置等待确认超时 
2797   3                                      MakeCH0TimerOut(150, 0);                                                                
2798   3                              }                       
2799   2                              break;                  
2800   2                      case CMD_COMM_CALL:                                                                     //普通呼叫命令                          
2801   2                              if(!bBusy)
2802   2                              {       //不忙,进入等待应答状态,保存主叫方地址,设置超时 
2803   3                                      if(bIndicatingOther)
2804   3                                      {       //停止正在指示的呼叫
2805   4                                              bIndicatingOther = 0;
2806   4                                              VoiceChannelCtx();
2807   4                                              if(!(bChannel1Talk|bChannel1Talked))
2808   4                                              {                               
2809   5                                                      stLocalControl.stBusDealFreq.byCmd = CMD_STOP_INDICATION;
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 47  

2810   5                                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2811   5                                              }                                                               
2812   4                                      }       
2813   3                                      bBusy = bWaitAck = 1;
2814   3                                      SaveCallAddr(&(stLocalControl.stBusDealFreq));                          
2815   3                                      MakeCH0TimerOut(50, 0);
2816   3                                      if(bHandleDown)
2817   3                                      {       //如果听筒是挂机状态,查看是否由免提键接听
2818   4                                              if(bKeyEnterDown)
2819   4                                              {
2820   5                                                      bKeyAnswer = 1;
2821   5                                                      bHandAnswer = 0;
2822   5                                              }
2823   4                                              else
2824   4                                              {                                               
2825   5                                                      MakeCH0TimerOut(5, 0);
2826   5                                                      break;
2827   5                                              }       
2828   4                                      }
2829   3                                      else
2830   3                                      {       //如果听筒是摘机状态,那么是由听筒接听的,置听筒接听状态  
2831   4                                              bHandAnswer = 1;
2832   4                                              bKeyAnswer = 0;
2833   4                                      }       
2834   3                                      if(bChannel1Talk||bChannel1Talked||(bKeyAnswer&&(!bKeyEnterDown))||
2835   3                                              (bHandAnswer&&bHandleDown)||(!(bKeyAnswer||bHandAnswer)))                               
2836   3                                      {       //如果通道1已经处于通话状态或者本机主动通话条件不存在了,
2837   4                                              //缩短超时时间
2838   4                                              //(通话条件:免提通话则要求免提键一直处于按下状态,听筒通话
2839   4                                              //则要求听筒一直处于摘机状态)                   
2840   4                                              MakeCH0TimerOut(5, 0);
2841   4                                              break;
2842   4                                      }
2843   3                                      VoiceChannelCtx();                                              
2844   3                              }                       
2845   2                              break;                                                          
2846   2                      case CMD_INFUSION_ANSWER:                                                       //处理输液呼叫
2847   2                      case CMD_SERVICE_ANSWER:                                                        //处理服务呼叫
2848   2                      case CMD_EMERGENCY_ANSWER:                                                      //处理紧急呼叫
2849   2                      case CMD_HELP_ANSWER:                                                           //处理求援呼叫  
2850   2                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2851   2                              bCallDealSending = 0;
2852   2                              if(!bBusy)
2853   2                              {       //不忙,进入等待应答状态,保存主叫方地址,设置超时 
2854   3                                      if(bIndicatingOther)
2855   3                                      {       //停止正在指示的呼叫
2856   4                                              bIndicatingOther = 0;
2857   4                                              VoiceChannelCtx();                                                      
2858   4                                              if(!(bChannel1Talk|bChannel1Talked))
2859   4                                              {                               
2860   5                                                      stLocalControl.stBusDealFreq.byCmd = CMD_STOP_INDICATION;
2861   5                                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2862   5      //                                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2863   5                                              }                               
2864   4                                      }
2865   3                                      bBusy = bWaitAck = 1;
2866   3                                      SaveCallAddr(&(stLocalControl.stBusDealFreq));
2867   3                                      MakeCH0TimerOut(250, 0); 
2868   3                                      if(bHandleDown)
2869   3                                      {       //如果听筒是挂机状态,查看是否由免提键接听
2870   4                                              if(bKeyEnterDown)
2871   4                                              {
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 48  

2872   5                                                      bKeyAnswer = 1;
2873   5                                                      bHandAnswer = 0;
2874   5                                              }
2875   4                                              else
2876   4                                              {                                               
2877   5                                                      MakeCH0TimerOut(5, 0);
2878   5                                                      break;
2879   5                                              }       
2880   4                                      }
2881   3                                      else
2882   3                                      {       //如果听筒是摘机状态,那么是由听筒接听的,置听筒接听状态  
2883   4                                              bHandAnswer = 1;
2884   4                                              bKeyAnswer = 0;
2885   4                                      }                               
2886   3                                      if(bChannel1Talk||bChannel1Talked||(bKeyAnswer&&(!bKeyEnterDown))||
2887   3                                              (bHandAnswer&&bHandleDown)||(!(bKeyAnswer||bHandAnswer)))
2888   3                                      {       //如果通道1已经处于通话状态或者本机主动通话条件不存在了,
2889   4                                              //缩短超时时间
2890   4                                              //(通话条件:免提通话则要求免提键一直处于按下状态,听筒通话
2891   4                                              //则要求听筒一直处于摘机状态)                           
2892   4                                              MakeCH0TimerOut(5, 0);
2893   4                                              break;
2894   4                                      }
2895   3                                      VoiceChannelCtx();                                              
2896   3                              }                       
2897   2                              break;  
2898   2                      case CMD_COMM_ANSWER:                                                           //普通应答命令
2899   2                              if(bBusy)
2900   2                              {                       
2901   3                                      bCalledRing = 1;                                                                
2902   3                                      MakeCH0TimerOut(2, stLocalControl.stEepromCfgData.byListenDelay);                       
2903   3                                      if((bChannel1Talk|bChannel1Talked))
2904   3                                      {       //本机已经处于通话状态了,缩短超时,退出                                  
2905   4                                              MakeCH0TimerOut(5, 0);
2906   4                                              break;
2907   4                                      }                               
2908   3                                      VoiceChannelCtx();                                                              
2909   3                                      if(bEnAutoListen)
2910   3                                      {       //自动接听
2911   4                                          OSWait(K_TMO,50);   //此处延时1000ms,以避免主机会莫名收不到CMD_CALL_LISTEN命令
2912   4                                              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
2913   4                                              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
2914   4                                              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
2915   4                                              stLocalControl.stBusDealFreq.byCmd = CMD_CALL_LISTEN;
2916   4                                              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stCallAddr.bySndSecAddr;
2917   4                                              stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stCallAddr.bySndRoomAddr;
2918   4                                              stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stCallAddr.bySndBedAddr;
2919   4                                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); 
2920   4                                      }                                       
2921   3                              }
2922   2                              break;
2923   2                      case CMD_CALL_LISTEN:                                                           //接听命令
2924   2                              if(bBusy)
2925   2                              {
2926   3                                      bCalledRing = 0;
2927   3                                      bChannel0Talked = 1;                            
2928   3                                      MakeCH0TimerOut(50, stLocalControl.stEepromCfgData.byTalkTime);                         
2929   3                                      if((bChannel1Talk||bChannel1Talked))
2930   3                                      {       //本机已经处于通话状态了,缩短超时,退出                                  
2931   4                                              MakeCH0TimerOut(5, 0);
2932   4                                              break;
2933   4                                      }                                                                                                       
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 49  

2934   3                                      VoiceChannelCtx();
2935   3                                      memcpy(&(stLocalControl.stBusDealFreq.bySndSecAddr),&(stLocalControl.stBusDealFreq.byRecSecAddr),3);    /
             -/满足显示模块显示的要求
2936   3                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                   
2937   3                              }
2938   2                              break;
2939   2                      case CMD_BROADCAST1:
2940   2                      case CMD_BROADCAST2:
2941   2                      case CMD_BROADCAST3:                                                            //广播命令
2942   2                              //暂存命令
2943   2                              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stBusDealFreq.byCmd;
2944   2                              if(!bBusy)
2945   2                              {       
2946   3                                      bBusy = 1;      
2947   3                                      if(bIndicatingOther)
2948   3                                      {       //停止正在指示的呼叫
2949   4                                              bIndicatingOther = 0;
2950   4                                              VoiceChannelCtx();                              
2951   4                                              if(!(bChannel1Talk|bChannel1Talked))
2952   4                                              {                               
2953   5                                                      stLocalControl.stBusDealFreq.byCmd = CMD_STOP_INDICATION;
2954   5                                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
2955   5                                              }       
2956   4                                      }
2957   3                                      if(bHandleDown)
2958   3                                      {       //如果听筒是挂机状态,查看是否由免提键接听
2959   4                                              if(bKeyBroadDown)
2960   4                                              {
2961   5                                                      bKeyAnswer = 1;
2962   5                                                      bHandAnswer = 0;
2963   5                                              }
2964   4                                              else
2965   4                                              {                                               
2966   5                                                      MakeCH0TimerOut(5, 0);
2967   5                                                      break;
2968   5                                              }       
2969   4                                      }
2970   3                                      else
2971   3                                      {       //如果听筒是摘机状态,那么是由听筒接听的,置听筒接听状态  
2972   4                                              bHandAnswer = 1;
2973   4                                              bKeyAnswer = 0;
2974   4                                      }                               
2975   3                                      MakeCH0TimerOut(50, stLocalControl.stEepromCfgData.byBroadTime);
2976   3                                      //保存主动呼叫方地址(本机地址)
2977   3      //                              SaveCallAddr(&(stLocalControl.stBusDealFreq));
2978   3                                      bSelfBroad = 1;
2979   3                                      if((bChannel1Talk|bChannel1Talked))
2980   3                                      {       //本机广播条件不存在了,缩短超时,退出                                                    
2981   4                                              MakeCH0TimerOut(5, 0);
2982   4                                              break;
2983   4                                      }
2984   3                                      if((CMD_BROADCAST1==stLocalControl.stBusDealFreq.byRecSecAddr) &&
2985   3                                              (((!bKeyBroadDown)&&bKeyAnswer)||
2986   3                                              (bHandAnswer&&bHandleDown)||(!(bKeyAnswer||bHandAnswer))))
2987   3                                      {       //病区广播,听筒放下的,病区广播键弹起了
2988   4                                              MakeCH0TimerOut(5, 0);
2989   4                                              break;
2990   4                                      }
2991   3                                      if((CMD_BROADCAST2 == stLocalControl.stBusDealFreq.byRecSecAddr) &&
2992   3                                              (((!bKeyBroadDown)&&bKeyAnswer)||
2993   3                                              (bHandAnswer&&bHandleDown)||(!(bKeyAnswer||bHandAnswer))))
2994   3                                      {       //办公区广播,听筒放下的,办公区广播键弹起了
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 50  

2995   4                                              MakeCH0TimerOut(5, 0);
2996   4                                              break;
2997   4                                      }
2998   3                                      if((CMD_BROADCAST3 == stLocalControl.stBusDealFreq.byRecSecAddr) &&
2999   3                                              (((!bKeyBroadDown)&&bKeyAnswer)||
3000   3                                              (bHandAnswer&&bHandleDown)||(!(bKeyAnswer||bHandAnswer))))
3001   3                                      {       //全区广播,听筒放下的,全区广播键弹起了
3002   4                                              MakeCH0TimerOut(5, 0);
3003   4                                              break;
3004   4                                      }
3005   3                                      stLocalControl.stBusDealFreq.byCmd = stLocalControl.stBusDealFreq.byRecSecAddr;
3006   3                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                                   
3007   3                                      VoiceChannelCtx();                                      
3008   3                              }
3009   2                              break;
3010   2                      case CMD_INFUSION_CLEAR:                                                        //清除输液呼叫
3011   2                      case CMD_SERVICE_CLEAR:                                                         //清除服务呼叫
3012   2                      case CMD_HELP_CLEAR:                                                            //清除求援呼叫
3013   2                      case CMD_EMERGENCY_CLEAR:                                                       //清除紧急呼叫
3014   2                              bCallDealSending = 0; 
3015   2                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3016   2      /*                      if(stLocalControl.stBusDealFreq.byCmd== CMD_EMERGENCY_CLEAR)
3017   2                              {
3018   2                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3019   2                                      break;
3020   2                              }
3021   2      */
3022   2                              if(bIndicatingOther && 
3023   2                                      (stLocalControl.stBusDealFreq.byRecSecAddr == stLocalControl.stIndicationData.stAddr.bySndSecAddr) &&
3024   2                                      (stLocalControl.stBusDealFreq.byRecRoomAddr == stLocalControl.stIndicationData.stAddr.bySndRoomAddr) &
             -&
3025   2                                      (stLocalControl.stBusDealFreq.byRecBedAddr == stLocalControl.stIndicationData.stAddr.bySndBedAddr) &&
3026   2                                      ((stLocalControl.stBusDealFreq.byCmd - 0x0a) == (stLocalControl.stIndicationData.byCallCmd & 0x1f)))
3027   2                              {       //清除本机正在指示的呼叫                        
3028   3                                      bIndicatingOther = 0;                                   
3029   3                                      VoiceChannelCtx();                      
3030   3                                      stLocalControl.stBusDealFreq.byCmd = CMD_STOP_INDICATION;
3031   3                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); 
3032   3      //                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3033   3                              }
3034   2                              break;                  
3035   2                      case CMD_CHANNEL_CLOSE:                                                         //关闭语音通道命令
3036   2                              if(bChannel1Talked||bChannel1Talk)
3037   2                              {
3038   3                                      bKeyAnswer = bHandAnswer = 0;
3039   3                              }
3040   2                              if((bChannel1Talked|bChannel1Talk))
3041   2                              {       //如果通道1处于通话状态,结束后需指示新的信息,如没有,保持状态
3042   3                                      if(bIndicatingOther)
3043   3                                      {       //如果有指示,立即显示指示信息   
3044   4                                              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stIndicationData.stAddr.bySndSecAddr;
3045   4                                              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stIndicationData.stAddr.bySndRoomAddr;
3046   4                                              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stIndicationData.stAddr.bySndBedAddr;
3047   4                                              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stIndicationData.byCallCmd;
3048   4                                              stLocalControl.stBusDealFreq.byCmd = CMD_INFO_INDICATION;
3049   4                                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3050   4                                      }
3051   3                                      else
3052   3                                      {
3053   4                                              stLocalControl.stBusDealFreq.byCmd = CMD_STOP_INDICATION;
3054   4                                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3055   4                                      }       
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 51  

3056   3                              }
3057   2                              bChannel1Talk = bChannel1Talked = 0;                                            
3058   2                              MakeCH1TimerOut(0, 0);
3059   2                              VoiceChannelCtx();
3060   2                              break;
3061   2                      case CMD_GET_BUS:                                                                       //占用总线
3062   2                              Bus0SendPin = 1;                                                                //制造总线故障
3063   2                              SaveParameter(IAP0_ADDR);
3064   2                              Bus0SendPin = 0;                                                                //释放总线
3065   2                              PW = bPWState;
3066   2                              PW2 = bPW2State;
3067   2                              VL0 = bVl0State;                        
3068   2                              break;  
3069   2                      case CMD_SYSTERM_RESET:                                                         //系统复位命令
3070   2                              SysReset();
3071   2                              break; 
3072   2                      case CMD_DATA_SEND:                                                                     //校时命令,校正液晶显示时间                     
3073   2                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3074   2                              break;  
3075   2                      case CMD_BUS_ANSWER:
3076   2                              switch(stLocalControl.stBusDealFreq.byRecSecAddr)
3077   2                              {
3078   3                              
3079   3                                      case CMD_POWER_ON:
3080   3                                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); 
3081   3                                              break;
3082   3                              }
3083   2      
3084   2                              break;  
3085   2              }       
3086   1      }
3087          
3088          /**********************************************************
3089          *函数名称                       :Bus0Manage     
3090          *函数描述               :单总线0管理线程
3091          *输入参数               :
3092          *返回值                         :
3093          *全局变量                       :byMainCmdQ
3094          *调用模块                       :OSQPost
3095          ***********************************************************
3096          *创建人                 :尹运同
3097          *创建日期                       :2008-9-22
3098          ***********************************************************
3099          *修改人                         :
3100          *修改日期               :
3101          *注释                   :
3102          **********************************************************/
3103          void Bus0Manage(void)
3104          {       
3105   1              while(TRUE)
3106   1              {       
3107   2                      WDT_CONTR = 0x3d;       //喂狗
3108   2                      if(bBus0RecFinish)                                                                      //总线0收到数据
3109   2                      {                       
3110   3                              OSQPost(byMainCmdQ, BUS0_REC);                          
3111   3                      }
3112   2                      if(bBus0SendFinish)                                                                     //总线0发送完数据帧
3113   2                      {
3114   3                              OSQPost(byMainCmdQ, BUS0_SND);                  
3115   3                      } 
3116   2                      OSWait(K_TMO, 1);                                       
3117   2              }
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 52  

3118   1      }
3119          /**********************************************************
3120          *函数名称                       :InitKeyCallAddr        
3121          *函数描述               :初始化呼叫地址,将地址初始化为自身的地址
3122          *输入参数               :
3123          *返回值                         :
3124          *全局变量                       :
3125          *调用模块                       :
3126          ***********************************************************
3127          *创建人                 :尹运同
3128          *创建日期                       :2008-9-22
3129          ***********************************************************
3130          *修改人                         :
3131          *修改日期               :
3132          *注释                   :
3133          **********************************************************/
3134          void InitKeyCallAddr(void)
3135          {
3136   1              stLocalControl.stKeyCallAddr.byRecSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
3137   1              stLocalControl.stKeyCallAddr.byRecRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
3138   1              stLocalControl.stKeyCallAddr.byRecBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
3139   1              stLocalControl.byKeyValue[MAX_KEY_SIZE-1] = 0xff;
3140   1              bRoomAddr = 0;
3141   1              bSetPrio = 0;
3142   1      //      stLocalControl.stKeyCallAddr.byCmd = CMD_STOP_INDICATION;
3143   1      //      Bus1OutputData(&(stLocalControl.stKeyCallAddr.bySndSecAddr));
3144   1      }
3145          /**********************************************************
3146          *函数名称                       :AddKeyValue    
3147          *函数描述               :将按键键值送入缓冲区
3148          *输入参数               :byKey:键盘按键键值
3149          *返回值                         :
3150          *全局变量                       :
3151          *调用模块                       :
3152          ***********************************************************
3153          *创建人                 :尹运同
3154          *创建日期                       :2008-9-22
3155          ***********************************************************
3156          *修改人                         :
3157          *修改日期               :
3158          *注释                   :
3159          **********************************************************/
3160          void AddKeyValue(uint8 byKey)
3161          {
3162   1              uint8 byTemp;
3163   1      
3164   1              for(byTemp = 0; byTemp < (MAX_KEY_SIZE-1); byTemp++)
3165   1              {
3166   2                      stLocalControl.byKeyValue[byTemp] = stLocalControl.byKeyValue[byTemp+1]; 
3167   2              }
3168   1              stLocalControl.byKeyValue[MAX_KEY_SIZE-1] = byKey;
3169   1      }
3170          /**********************************************************
3171          *函数名称                       :GetKeyCallAddr 
3172          *函数描述               :获取按键按下的各类呼叫地址
3173          *输入参数               :byFlag:获取地址的类型
3174          *返回值                         :
3175          *全局变量                       :
3176          *调用模块                       :
3177          ***********************************************************
3178          *创建人                 :尹运同
3179          *创建日期                       :2008-9-22
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 53  

3180          ***********************************************************
3181          *修改人                         :
3182          *修改日期               :
3183          *注释                   :
3184          **********************************************************/
3185          uint8 GetKeyCallAddr(uint8 byFlag)
3186          {
3187   1              uint8 byTemp;
3188   1      
3189   1              switch(byFlag)
3190   1              {       //防止使用者没有按下有效的地址信息,预先初始化本机地址
3191   2                      case GET_SEC_ADDR:                                                                      //获取区地址
3192   2                              byTemp = stLocalControl.stEepromCfgData.bySelfSecAddr;
3193   2                              break;
3194   2                      case GET_ROOM_ADDR:                                                                     //获取房地址
3195   2                              byTemp = stLocalControl.stEepromCfgData.bySelfRoomAddr;
3196   2                              break;
3197   2                      case GET_BED_ADDR:                                                                      //获取床地址
3198   2                              byTemp = stLocalControl.stEepromCfgData.bySelfBedAddr;
3199   2                              break;
3200   2                      default:
3201   2                              return(0);
3202   2                              break;
3203   2              }
3204   1              if(stLocalControl.byKeyValue[MAX_KEY_SIZE-1] == 0xff)
3205   1              {       //没有有效数据          
3206   2                      return(byTemp);
3207   2              }
3208   1              byTemp = stLocalControl.byKeyValue[MAX_KEY_SIZE-1];
3209   1              stLocalControl.byKeyValue[MAX_KEY_SIZE-1] = 0xff;
3210   1              if(stLocalControl.byKeyValue[MAX_KEY_SIZE-2] == 0xff)
3211   1              {               
3212   2                      return(byTemp);
3213   2              }
3214   1              byTemp = byTemp + stLocalControl.byKeyValue[MAX_KEY_SIZE-2]*10;
3215   1              if(stLocalControl.byKeyValue[MAX_KEY_SIZE-3] == 0xff)
3216   1              {               
3217   2                      return(byTemp);
3218   2              }
3219   1              byTemp = byTemp + stLocalControl.byKeyValue[MAX_KEY_SIZE-3] * 100;      
3220   1              return(byTemp);
3221   1      }
3222          
3223          /**********************************************************/
3224          //获取对应音值的级别
3225          uint8 GetVolLevel(uint8 VloValue)
3226          {
3227   1              if((VloValue&0x01)==0) return(0);
3228   1              else if(VloValue==0x01) return(1);
3229   1              else if(VloValue==0x03) return(2);      
3230   1              else if(VloValue==0x07) return(3);
3231   1              else if(VloValue==0x0f) return(4);
3232   1              else if(VloValue==0x1f) return(5);
3233   1              else if(VloValue==0x3f) return(6);      
3234   1              else if(VloValue==0x7f) return(7);
3235   1              else if(VloValue==0xff) return(8);
3236   1              else return(8); 
3237   1      }
3238          
3239          
3240          /**********************************************************
3241          *函数名称                       :AddVol
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 54  

3242          *函数描述               :音量增加
3243          *输入参数               :pbyData:待增加的音量存储器地址
3244          *返回值                         :
3245          *全局变量                       :
3246          *调用模块                       :
3247          ***********************************************************
3248          *创建人                 :尹运同
3249          *创建日期                       :2008-9-22
3250          ***********************************************************
3251          *修改人                         :
3252          *修改日期               :
3253          *注释                   :
3254          **********************************************************/
3255          void AddVol(uint8 xdata *pbyData)
3256          {       
3257   1              if(*pbyData < MAX_VOLUMN_VALUE)
3258   1              {
3259   2                      *pbyData = ((*pbyData<<1)|0x01);
3260   2                      VoiceChannelCtx();
3261   2                      //存储改变了的音量值
3262   2      //              stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS;                       
3263   2      //              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                           
3264   2              }
3265   1      }
3266          
3267          
3268          /**********************************************************
3269          *函数名称                       :AddVol
3270          *函数描述               :音量增加
3271          *输入参数               :pbyData:待增加的音量存储器地址
3272          *返回值                         :
3273          *全局变量                       :
3274          *调用模块                       :
3275          ***********************************************************
3276          *创建人                 :尹运同
3277          *创建日期                       :2008-9-22
3278          ***********************************************************
3279          *修改人                         :
3280          *修改日期               :
3281          *注释                   :
3282          **********************************************************/
3283          void AddPlayVoiceVol(uint8 xdata *pbyData)
3284          {       
3285   1              if(*pbyData < stLocalControl.stEepromCfgData.byMaxVol)
3286   1              {
3287   2                      *pbyData = ((*pbyData<<1)|0x01);
3288   2                      VoiceChannelCtx();
3289   2                      //存储改变了的音量值
3290   2      //              stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS;                       
3291   2      //              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                           
3292   2              }
3293   1      }
3294          
3295          
3296          /**********************************************************
3297          *函数名称                       :DecVol
3298          *函数描述               :音量减小
3299          *输入参数               :pbyData:待减小的音量存储器地址
3300          *返回值                         :
3301          *全局变量                       :
3302          *调用模块                       :
3303          ***********************************************************
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 55  

3304          *创建人                 :尹运同
3305          *创建日期                       :2008-9-22
3306          ***********************************************************
3307          *修改人                         :
3308          *修改日期               :
3309          *注释                   :
3310          **********************************************************/
3311          void DecVol(uint8 xdata *pbyData)
3312          {       
3313   1              if(*pbyData > MIN_VOLUMN_VALUE)
3314   1              {
3315   2                      *pbyData = (*pbyData>>1);
3316   2                      VoiceChannelCtx();
3317   2                      //存储改变了的音量值
3318   2      //              stLocalControl.stBusDealFreq.byCmd = CMD_GET_BUS;                       
3319   2      //              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                                                           
3320   2              }
3321   1      }
3322          /**********************************************************
3323          *函数名称                       :KeyDownDeal
3324          *函数描述               :键盘按键按下处理函数
3325          *输入参数               :byKey:键盘按下的键值
3326          *返回值                         :
3327          *全局变量                       :
3328          *调用模块                       :
3329          ***********************************************************
3330          *创建人                 :尹运同
3331          *创建日期                       :2008-9-22
3332          ***********************************************************
3333          *修改人                         :
3334          *修改日期               :
3335          *注释                   :
3336          **********************************************************/
3337          void KeyDownDeal(uint8 byKey)
3338          {
3339   1      
3340   1              byKey &= 0x1f;  
3341   1              if(byKey==KEY_ENTER)  bKeyEnterDown=1;
3342   1              else if(byKey==KEY_BROAD) bKeyBroadDown=1;
3343   1      
3344   1              if(bNumSeting==1)
3345   1              {
3346   2                      if(byKey==KEY_ENTER)            
3347   2                      {//编号状态 确认键按下
3348   3                              bNumSeting=0;
3349   3                              stLocalControl.stKeyCallAddr.byCmd = CMD_NUMBER_SET;
3350   3                              stLocalControl.stKeyCallAddr.byRecSecAddr = 0x02;       //成功编号;
3351   3                              //Bus0OutputData(&(stLocalControl.stKeyCallAddr.bySndSecAddr));                                                         
3352   3                              Bus1OutputData(&(stLocalControl.stKeyCallAddr.bySndSecAddr));
3353   3                              //保存新的地址数据                                              
3354   3                              stLocalControl.stEepromCfgData.bySelfSecAddr = stLocalControl.stKeyCallAddr.bySndSecAddr;
3355   3                              stLocalControl.stEepromCfgData.bySelfRoomAddr = stLocalControl.stKeyCallAddr.bySndRoomAddr;
3356   3                              stLocalControl.stEepromCfgData.bySelfBedAddr = stLocalControl.stKeyCallAddr.bySndBedAddr;                                       
3357   3                              SaveParameter(IAP0_ADDR);
3358   3                              stLocalControl.byKeyValue[MAX_KEY_SIZE-1] = 0xff;
3359   3                              return;
3360   3                      }       
3361   2              }
3362   1              if(bIndicatingOther&&(!bHandAnswer)&&(!bKeyAnswer))
3363   1              {       //正在指示其他分机的呼叫
3364   2                      switch(byKey)
3365   2                      {
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 56  

3366   3                              case KEY_VOICEINC:                                                                      //调整免提或者听筒报号音量
3367   3      /*                              if(bHandleDown)
3368   3                                      {                               
3369   3                                              AddVol(&(stLocalControl.stEepromCfgData.byHDwnRingVol));                                        
3370   3                                      }
3371   3                                      else
3372   3                                      {
3373   3                                              AddVol(&(stLocalControl.stEepromCfgData.byHUpRingVol));                                         
3374   3                                      }*/
3375   3                                      AddPlayVoiceVol(&(stLocalControl.stEepromCfgData.byHDwnRingVol));
3376   3                                      SaveParameter(IAP0_ADDR);
3377   3                                      stLocalControl.stBusDealFreq.byRecSecAddr=GetVolLevel(stLocalControl.stEepromCfgData.byHDwnRingVol);
3378   3                                      stLocalControl.stBusDealFreq.byCmd = CMD_INCREACE_VOL;  //音量增加命令
3379   3                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                                   
3380   3                                      return;
3381   3                              case KEY_VOICEDEC:                                                                      //调整免提或者听筒报号音量
3382   3      /*                              if(bHandleDown)
3383   3                                      {
3384   3                                              DecVol(&(stLocalControl.stEepromCfgData.byHDwnRingVol));                                        
3385   3                                      }
3386   3                                      else
3387   3                                      {
3388   3                                              DecVol(&(stLocalControl.stEepromCfgData.byHUpRingVol));                                 
3389   3                                      }*/
3390   3                                      DecVol(&(stLocalControl.stEepromCfgData.byHDwnRingVol));
3391   3                                      SaveParameter(IAP0_ADDR);
3392   3                                      stLocalControl.stBusDealFreq.byRecSecAddr=GetVolLevel(stLocalControl.stEepromCfgData.byHDwnRingVol);
3393   3                                      stLocalControl.stBusDealFreq.byCmd = CMD_DECREACE_VOL;  //音量减少命令
3394   3                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                           
3395   3                                      return;
3396   3                              case KEY_ENTER:                                                                 //处理正在指示的呼叫信息        
3397   3                                      
3398   3                                      stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
3399   3                                      stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
3400   3                                      stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
3401   3                                      stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stIndicationData.stAddr.bySndSecAddr;
3402   3                                      stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stIndicationData.stAddr.bySndRoomAddr;
3403   3                                      stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stIndicationData.stAddr.bySndBedAddr;                                
3404   3                                      if(CMD_EMERGENCY_CALL == (stLocalControl.stIndicationData.byCallCmd & 0x1f))
3405   3                                      {
3406   4                                              stLocalControl.stBusDealFreq.byCmd = CMD_EMERGENCY_CLEAR;
3407   4                                      }
3408   3                                      else
3409   3                                      {                                                                                       
3410   4                                              stLocalControl.stBusDealFreq.byCmd = stLocalControl.stIndicationData.byCallCmd & 0x1f;
3411   4                                              stLocalControl.stBusDealFreq.byCmd += 0x06; 
3412   4                                      }                                                                                       
3413   3                                      if(TRUE == Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)))
3414   3                                      {
3415   4                                              bCallDealSending = 1;
3416   4                                      }
3417   3                                      InitKeyCallAddr();                              
3418   3                                      return;                 
3419   3                              default:                                                                                //其他按键按下,挂机
3420   3                                      stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
3421   3                                      stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
3422   3                                      stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
3423   3                                      stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stIndicationData.stAddr.bySndSecAddr;
3424   3                                      stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stIndicationData.stAddr.bySndRoomAddr;
3425   3                                      stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stIndicationData.stAddr.bySndBedAddr;
3426   3                                      stLocalControl.stBusDealFreq.byCmd = stLocalControl.stIndicationData.byCallCmd & 0x1f;
3427   3                                      stLocalControl.stBusDealFreq.byCmd += 0x0a;                                                                                                                             
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 57  

3428   3                                      if(TRUE == Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)))
3429   3                                      {
3430   4                                              bCallDealSending = 1;
3431   4                                      } 
3432   3      
3433   3                              
3434   3                                      InitKeyCallAddr(); 
3435   3                                      return;                         
3436   3                      }
3437   2              }
3438   1              if(KEY_CLEAR == byKey)
3439   1              {               
3440   2                      if((bChannel1Talk&bHandAnswer))
3441   2                      {       //确实是用听筒主动呼叫的,缩短超时时间,超时后自动发送通道切换命令                
3442   3                              MakeCH1TimerOut(5, 0);
3443   3                      
3444   3                      }       
3445   2                      else if((bWaitAck|bWaitListen|bChannel0Talk|bSelfBroad)&&bHandAnswer)
3446   2                      {       //确实是用听筒主动呼叫的,缩短超时时间,超时后自动发送复位命令            
3447   3                              MakeCH0TimerOut(5, 0);          
3448   3                      }
3449   2                      InitKeyCallAddr(); 
3450   2                      return; 
3451   2              }
3452   1              if(!(bBusy|bChannel1Talked|bChannel1Talk))
3453   1              {
3454   2                      switch(byKey)
3455   2                      {
3456   3                              case KEY_0:
3457   3                                      AddKeyValue(0);                         
3458   3                                      break;
3459   3                              case KEY_1:
3460   3                                      AddKeyValue(1);                         
3461   3                                      break;
3462   3                              case KEY_2:
3463   3                                      AddKeyValue(2);                 
3464   3                                      break;
3465   3                              case KEY_3:
3466   3                                      AddKeyValue(3);                 
3467   3                                      break;
3468   3                              case KEY_4:
3469   3                                      AddKeyValue(4);
3470   3                                      break;
3471   3                              case KEY_5:
3472   3                                      AddKeyValue(5);
3473   3                                      break;
3474   3                              case KEY_6:
3475   3                                      AddKeyValue(6);
3476   3                                      break;
3477   3                              case KEY_7:
3478   3                                      AddKeyValue(7);
3479   3                                      break;
3480   3                              case KEY_8:
3481   3                                      AddKeyValue(8);
3482   3                                      break;
3483   3                              case KEY_9:
3484   3                                      AddKeyValue(9);
3485   3                                      break;
3486   3                              case KEY_ROOM:
3487   3                                      stLocalControl.stKeyCallAddr.byRecRoomAddr = GetKeyCallAddr(GET_ROOM_ADDR);                             
3488   3                                      bRoomAddr = 1;
3489   3                                      break;
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 58  

3490   3                              case KEY_SEC:
3491   3                                      stLocalControl.stKeyCallAddr.byRecSecAddr = GetKeyCallAddr(GET_SEC_ADDR);                                                               
3492   3                                      break;
3493   3                              case KEY_MODE:                                                                  //功能设置
3494   3                                      AddKeyValue(21);
3495   3                                      //stLocalControl.stKeyCallAddr.byRecBedAddr = GetKeyCallAddr(GET_BED_ADDR);
3496   3                                      //bSetPrio = 1;                                                                 //表明设定护理优先级
3497   3                                      break;  
3498   3      /*                      case K_SICK_BROAD:                                                                      //病区广播键
3499   3                                      stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
3500   3                                      stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
3501   3                                      stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
3502   3                                      stLocalControl.stBusDealFreq.byRecSecAddr = 0xff;
3503   3                                      stLocalControl.stBusDealFreq.byRecRoomAddr = 0xff;
3504   3                                      stLocalControl.stBusDealFreq.byRecBedAddr = 0xff;
3505   3                                      stLocalControl.stBusDealFreq.byCmd = CMD_BROADCAST1;                            
3506   3                                      Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                           
3507   3                                      break;
3508   3                              case K_OFFICE_BROAD:                                                            //办公区广播键
3509   3                                      stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
3510   3                                      stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
3511   3                                      stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
3512   3                                      stLocalControl.stBusDealFreq.byRecSecAddr = 0xff;
3513   3                                      stLocalControl.stBusDealFreq.byRecRoomAddr = 0xff;
3514   3                                      stLocalControl.stBusDealFreq.byRecBedAddr = 0xff;
3515   3                                      stLocalControl.stBusDealFreq.byCmd = CMD_BROADCAST2;                            
3516   3                                      Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3517   3                                      break;*/
3518   3                              case KEY_BROAD:                                                                 //全区广播键
3519   3                                      if(bMainMenuSet==0)
3520   3                                      {
3521   4                                          switch(stLocalControl.byKeyValue[MAX_KEY_SIZE-1])
3522   4                                      {
3523   5                                              case 1:
3524   5                                                              stLocalControl.stBusDealFreq.byCmd = CMD_BROADCAST1;     //  1号类型广播:病区广播
3525   5                                                      break;
3526   5                                                      case 2:
3527   5                                                              stLocalControl.stBusDealFreq.byCmd = CMD_BROADCAST2;     //  2号类型广播:办公区广播
3528   5                                                      break;
3529   5                                                      
3530   5                                                      case 3:
3531   5                                                      default:
3532   5                                                              stLocalControl.stBusDealFreq.byCmd = CMD_BROADCAST3;     //  3号类型广播:全区广播
3533   5                                                      break;                                          
3534   5                                      }
3535   4                                              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
3536   4                                              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
3537   4                                              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
3538   4                                              stLocalControl.stBusDealFreq.byRecSecAddr = 0xff;
3539   4                                              stLocalControl.stBusDealFreq.byRecRoomAddr = 0xff;
3540   4                                              stLocalControl.stBusDealFreq.byRecBedAddr = 0xff;                               
3541   4                                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3542   4                                              stLocalControl.byKeyValue[MAX_KEY_SIZE-1]=0xff;
3543   4                                      }
3544   3                                      break;
3545   3                              case KEY_ENTER:
3546   3                                      if(bMainMenuSet==0)
3547   3                                      {
3548   4                                              if(stLocalControl.byKeyValue[MAX_KEY_SIZE-1] !=0XFF)
3549   4                                              {
3550   5                                              //呼叫功能
3551   5                                                      stLocalControl.stKeyCallAddr.byRecSecAddr  = stLocalControl.stEepromCfgData.bySelfSecAddr;                                      
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 59  

3552   5                                                      stLocalControl.stKeyCallAddr.byRecBedAddr = GetKeyCallAddr(GET_BED_ADDR);
3553   5                                                      if(stLocalControl.stKeyCallAddr.byRecBedAddr <=200)
3554   5                                                      {
3555   6                                                              if(!bRoomAddr)
3556   6                                                              {       
3557   7                                                                      //stLocalControl.stKeyCallAddr.byRecSecAddr  = stLocalControl.stEepromCfgData.bySelfSecAddr;
3558   7                                                                      stLocalControl.stKeyCallAddr.byRecRoomAddr = 0xff;                                                      
3559   7                                                              }       
3560   6                                                      }
3561   5                                                      else
3562   5                                                      {//大于200为医护分机地址
3563   6                                                              if(!bRoomAddr)
3564   6                                                              {//没有输入房号
3565   7                                                                      stLocalControl.stKeyCallAddr.byRecRoomAddr = YHFJ_ROOM_ADDR;
3566   7                                                                      stLocalControl.stKeyCallAddr.byRecBedAddr  -= 200;
3567   7                                                              }
3568   6                                                      }
3569   5                                                      if(!DirAddrCompare(&(stLocalControl.stKeyCallAddr)))
3570   5                                                      {//不是本机
3571   6                                                              stLocalControl.stKeyCallAddr.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
3572   6                                                              stLocalControl.stKeyCallAddr.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
3573   6                                                              stLocalControl.stKeyCallAddr.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
3574   6                                                              stLocalControl.stKeyCallAddr.byCmd = CMD_COMM_CALL;
3575   6                                                              Bus0OutputData(&(stLocalControl.stKeyCallAddr.bySndSecAddr));
3576   6                                                      }                               
3577   5                                              }
3578   4                                      }
3579   3                                      InitKeyCallAddr();                      
3580   3                                      break;                  
3581   3                              default:                        
3582   3                                      break;                          
3583   3                      }
3584   2              }
3585   1              if(bChannel0Talked||bChannel0Talk)
3586   1              {
3587   2                      switch(byKey)
3588   2                      {
3589   3                              case KEY_VOICEINC:                                                                      //调整通道0对讲音量
3590   3                                      AddVol(&(stLocalControl.stEepromCfgData.byCH0HDwnTalkVol));
3591   3                                      SaveParameter(IAP0_ADDR);
3592   3                                      stLocalControl.stBusDealFreq.byRecSecAddr=GetVolLevel(stLocalControl.stEepromCfgData.byCH0HDwnTalkVol)
             -;
3593   3                                      stLocalControl.stBusDealFreq.byCmd = CMD_INCREACE_VOL;  //音量增加命令
3594   3                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                           
3595   3                                      return;
3596   3      
3597   3                              case KEY_VOICEDEC:                                                                      //调整通道0对讲音量
3598   3                                      DecVol(&(stLocalControl.stEepromCfgData.byCH0HDwnTalkVol));
3599   3                                      SaveParameter(IAP0_ADDR);
3600   3                                      stLocalControl.stBusDealFreq.byRecSecAddr=GetVolLevel(stLocalControl.stEepromCfgData.byCH0HDwnTalkVol)
             -;
3601   3                                      stLocalControl.stBusDealFreq.byCmd = CMD_DECREACE_VOL;  //音量减少命令
3602   3                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                           
3603   3                                      return;                 
3604   3                      }
3605   2              }
3606   1              else if(bChannel1Talked||bChannel1Talk)
3607   1              {
3608   2                      switch(byKey)
3609   2                      {
3610   3                              case KEY_VOICEINC:                                                                      //调整通道1对讲音量
3611   3                                      AddVol(&(stLocalControl.stEepromCfgData.byCH1HDwnTalkVol));
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 60  

3612   3                                      SaveParameter(IAP0_ADDR);
3613   3                                      stLocalControl.stBusDealFreq.byRecSecAddr=GetVolLevel(stLocalControl.stEepromCfgData.byCH1HDwnTalkVol)
             -;
3614   3                                      stLocalControl.stBusDealFreq.byCmd = CMD_INCREACE_VOL;  //音量增加命令
3615   3                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                           
3616   3                                      return;
3617   3      
3618   3                              case KEY_VOICEDEC:                                                                      //调整通道1对讲音量
3619   3                                      DecVol(&(stLocalControl.stEepromCfgData.byCH1HDwnTalkVol));
3620   3                                      SaveParameter(IAP0_ADDR);
3621   3                                      stLocalControl.stBusDealFreq.byRecSecAddr=GetVolLevel(stLocalControl.stEepromCfgData.byCH1HDwnTalkVol)
             -;
3622   3                                      stLocalControl.stBusDealFreq.byCmd = CMD_DECREACE_VOL;  //音量减少命令
3623   3                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                           
3624   3                                      return; 
3625   3      
3626   3                      }
3627   2              }
3628   1      }
3629          /**********************************************************
3630          *函数名称                       :KeyUpDeal
3631          *函数描述               :键盘按键弹起处理函数
3632          *输入参数               :byKey:键盘按下的键值
3633          *返回值                         :
3634          *全局变量                       :
3635          *调用模块                       :
3636          ***********************************************************
3637          *创建人                 :尹运同
3638          *创建日期                       :2008-9-22
3639          ***********************************************************
3640          *修改人                         :
3641          *修改日期               :
3642          *注释                   :
3643          **********************************************************/
3644          void KeyUpDeal(uint8 byKey)
3645          {
3646   1              byKey &= 0x1f;
3647   1              if(byKey==KEY_ENTER)  bKeyEnterDown=0;          //键弹起
3648   1              else if(byKey==KEY_BROAD) bKeyBroadDown=0;
3649   1              switch(byKey)
3650   1              {
3651   2                      case KEY_ENTER:                         
3652   2                              if((bChannel1Talk&bKeyAnswer))
3653   2                              {       //缩短超时时间，超时后自动发送复位命令
3654   3                                      MakeCH1TimerOut(5, 0);
3655   3      
3656   3                              }                                                       
3657   2                              else if((bWaitAck|bWaitListen|bChannel0Talk|bSelfBroad)&&bKeyAnswer)
3658   2                              {                               
3659   3                                      MakeCH0TimerOut(5, 0);
3660   3                              }                       
3661   2                              break; 
3662   2                      case KEY_BROAD:                                                                 //全区广播键弹起了
3663   2                              if(bSelfBroad&&bKeyAnswer)
3664   2                              {       //确实处于广播状态,且听筒是放下的
3665   3                                      MakeCH0TimerOut(5, 0);
3666   3                              }
3667   2                              break;  
3668   2              }               
3669   1      }
3670          /**********************************************************
3671          *函数名称                       :Bus1RecDeal    
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 61  

3672          *函数描述               :单总线1收到一帧数据处理函数,该函数首先
3673                                                   取出收到的数据,针对每条命令执行对应的控
3674                                                   制动作
3675          *输入参数               :
3676          *返回值                         :
3677          *全局变量                       :
3678          *调用模块                       :
3679          ***********************************************************
3680          *创建人                 :尹运同
3681          *创建日期                       :2008-9-22
3682          ***********************************************************
3683          *修改人                         :
3684          *修改日期               :
3685          *注释                   :
3686          **********************************************************/
3687          void Bus1RecDeal(void)
3688          {
3689   1      /*
3690   1              //取出单总线1收到的数据帧       
3691   1              OS_ENTER_CRITICAL();
3692   1              memcpy(&(stLocalControl.stBusDealFreq), byBus1RecData, sizeof(STBusFreq));      
3693   1              bBus1RecFinish = 0;
3694   1              OS_EXIT_CRITICAL();
3695   1      */
3696   1              //以下仅供测试用
3697   1      //      uart_send((uint8 *)&(stLocalControl.stBusDealFreq),7);
3698   1              /////////////////////////////////////////////////////////////////////////////////////
3699   1              
3700   1              if(bLanding)
3701   1              {       //登记状态不作处理
3702   2                      return;
3703   2              }
3704   1      
3705   1              switch(stLocalControl.stBusDealFreq.byCmd)
3706   1              {
3707   2                      case CMD_LANDING:                                                                       //登记命令
3708   2                              //相关音量值
3709   2                              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
3710   2                              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
3711   2                              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
3712   2                              
3713   2                              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.byHDwnRingVol;
3714   2                              stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stEepromCfgData.byCH0HDwnTalkVol;
3715   2                              stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stEepromCfgData.byCH1HDwnTalkVol;
3716   2                              stLocalControl.stBusDealFreq.byCmd = CMD_ENTER;
3717   2                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3718   2                                                              
3719   2                              break;          
3720   2                      case CMD_RECEIVE_OK:
3721   2                      case CMD_RECEIVE_ERROR:                                                         //转发单总线数据                                                        
3722   2                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3723   2                              break;
3724   2                      case CMD_KEY_DOWN:                                                                      //收到键盘按键按下命令  
3725   2                              KeyDownDeal(stLocalControl.stBusDealFreq.bySndSecAddr);
3726   2                              break;
3727   2                      case CMD_KEY_UP:                                                                        //收到键盘按键弹起命令
3728   2                              KeyUpDeal(stLocalControl.stBusDealFreq.bySndSecAddr);
3729   2                              break;
3730   2                      case CMD_DATA_ERROR:
3731   2                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3732   2                              break;
3733   2                      case CMD_BUS_ANSWER:
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 62  

3734   2                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3735   2                              break;
3736   2                      case CMD_MAIN_MENU_SET:
3737   2                              bMainMenuSet=1;
3738   2                              break;
3739   2                      case CMD_MAIN_MENU_ESC:
3740   2                              bMainMenuSet = 0;
3741   2                              break;
3742   2                      case CMD_DATA_SEND:
3743   2                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3744   2                              break;
3745   2                      case CMD_NUMBER_SET:
3746   2                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3747   2                              break;  
3748   2      
3749   2                      case CMD_VOICE_TIMER_SET:                                       
3750   2                              stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartHour = stLocalControl.stBusDealFreq.bySndSecAddr;
3751   2                              stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartMin  = stLocalControl.stBusDealFreq.bySndRoomAddr
             -;
3752   2      
3753   2                              stLocalControl.stEepromCfgData.stVoiceTimeZone.byEndHour = stLocalControl.stBusDealFreq.byRecSecAddr;
3754   2                              stLocalControl.stEepromCfgData.stVoiceTimeZone.byEndMin  = stLocalControl.stBusDealFreq.byRecRoomAddr;
3755   2      
3756   2                              stLocalControl.stEepromCfgData.byMicroVoiceVal = stLocalControl.stBusDealFreq.byRecBedAddr;
3757   2                              SaveParameter(IAP0_ADDR);
3758   2                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3759   2                              
3760   2                              break;
3761   2      
3762   2                      case CMD_BL_TIMER_SET:
3763   2                              stLocalControl.stEepromCfgData.stBLTimeZone.byStartHour = stLocalControl.stBusDealFreq.bySndSecAddr;
3764   2                              stLocalControl.stEepromCfgData.stBLTimeZone.byStartMin  = stLocalControl.stBusDealFreq.bySndRoomAddr;
3765   2      
3766   2                              stLocalControl.stEepromCfgData.stBLTimeZone.byEndHour = stLocalControl.stBusDealFreq.byRecSecAddr;
3767   2                              stLocalControl.stEepromCfgData.stBLTimeZone.byEndMin  = stLocalControl.stBusDealFreq.byRecRoomAddr;
3768   2                              
3769   2                              SaveParameter(IAP0_ADDR);
3770   2                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3771   2      
3772   2                              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
3773   2                              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
3774   2                              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
3775   2                              stLocalControl.stBusDealFreq.byRecSecAddr = 0xff;
3776   2                              stLocalControl.stBusDealFreq.byRecRoomAddr= 0xff;
3777   2                              stLocalControl.stBusDealFreq.byRecBedAddr = 0xff;
3778   2                              
3779   2                              
3780   2                              if( stLocalControl.stEepromCfgData.stBLTimeZone.byStartHour==stLocalControl.stEepromCfgData.stBLTimeZon
             -e.byEndHour && stLocalControl.stEepromCfgData.stBLTimeZone.byStartMin==stLocalControl.stEepromCfgData.stBLTimeZone.byEnd
             -Min)
3781   2                              {
3782   3                                      stLocalControl.stBusDealFreq.byCmd = CMD_OPEN_LCD;
3783   3                                      Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3784   3      
3785   3                                      OSWait(K_TMO,200);              //延时1S
3786   3                                      
3787   3                                      stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
3788   3                                      stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
3789   3                                      stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
3790   3                                      stLocalControl.stBusDealFreq.byCmd = CMD_OPEN_LCD;
3791   3                                      stLocalControl.stBusDealFreq.byRecSecAddr = 0xff;
3792   3                                      stLocalControl.stBusDealFreq.byRecRoomAddr= 0xff;
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 63  

3793   3                                      stLocalControl.stBusDealFreq.byRecBedAddr = 0xff;
3794   3                                      Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                           
3795   3                                      bSendCmdCloseLcd = 0;
3796   3                                      bSendCmdOpenLcd  = 0;
3797   3                              }
3798   2      
3799   2                              else
3800   2                              {
3801   3                                      BackLightTimerTreat(&(stLocalControl.stBusDealFreq));
3802   3                              }
3803   2                              break;
3804   2      
3805   2      
3806   2                      case CMD_VOL_VAL_SET:
3807   2                              stLocalControl.stEepromCfgData.byMaxVol=VolValIndex[stLocalControl.stBusDealFreq.bySndSecAddr];
3808   2                              SaveParameter(IAP0_ADDR);
3809   2                              break;
3810   2      
3811   2                      case CMD_SELF_SET_NUMBER:
3812   2                              stLocalControl.stEepromCfgData.bySelfSecAddr = stLocalControl.stBusDealFreq.bySndSecAddr;
3813   2                              stLocalControl.stEepromCfgData.bySelfRoomAddr = stLocalControl.stBusDealFreq.bySndRoomAddr;
3814   2                              stLocalControl.stEepromCfgData.bySelfBedAddr = stLocalControl.stBusDealFreq.bySndBedAddr;
3815   2                              SaveParameter(IAP0_ADDR);
3816   2                              break;
3817   2      
3818   2                      case CMD_VOICE_TIMER_GET:
3819   2                              if((stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartHour>=0x24)||
3820   2                                 (stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartMin>=0x60)||
3821   2                                 (stLocalControl.stEepromCfgData.stVoiceTimeZone.byEndHour>=0x24)||
3822   2                                 (stLocalControl.stEepromCfgData.stVoiceTimeZone.byEndMin>=0x60))
3823   2                              {
3824   3                                      stLocalControl.stBusDealFreq.bySndSecAddr = 0;
3825   3                                      stLocalControl.stBusDealFreq.bySndRoomAddr = 0;                         
3826   3                                      stLocalControl.stBusDealFreq.byRecSecAddr = 0;
3827   3                                      stLocalControl.stBusDealFreq.byRecRoomAddr = 0;
3828   3                                      stLocalControl.stBusDealFreq.byRecBedAddr = 0;
3829   3      
3830   3                              }
3831   2                              else 
3832   2                              {
3833   3                                      stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartHour
             -;
3834   3                                      stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.stVoiceTimeZone.byStartMin
             -;
3835   3                                      stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.stVoiceTimeZone.byEndHour;
3836   3                                      stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stEepromCfgData.stVoiceTimeZone.byEndMin;   
3837   3                                      stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stEepromCfgData.byMicroVoiceVal;
3838   3                              }
3839   2                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3840   2                              break;
3841   2      
3842   2                      case CMD_BL_TIMER_GET:
3843   2                              if((stLocalControl.stEepromCfgData.stBLTimeZone.byStartHour>=0x24)||
3844   2                                 (stLocalControl.stEepromCfgData.stBLTimeZone.byStartMin>=0x60)||
3845   2                                 (stLocalControl.stEepromCfgData.stBLTimeZone.byEndHour>=0x24)||
3846   2                                 (stLocalControl.stEepromCfgData.stBLTimeZone.byEndMin>=0x60))
3847   2                              {
3848   3                                      stLocalControl.stBusDealFreq.bySndSecAddr = 0;
3849   3                                      stLocalControl.stBusDealFreq.bySndRoomAddr = 0;                         
3850   3                                      stLocalControl.stBusDealFreq.byRecSecAddr = 0;
3851   3                                      stLocalControl.stBusDealFreq.byRecRoomAddr = 0;
3852   3      
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 64  

3853   3                              }       
3854   2                              else
3855   2                              {
3856   3                                      stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.stBLTimeZone.byStartHour;
3857   3                                      stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.stBLTimeZone.byStartMin;
3858   3                                      stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.stBLTimeZone.byEndHour;
3859   3                                      stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stEepromCfgData.stBLTimeZone.byEndMin;      
3860   3                              }
3861   2                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                   
3862   2                              break;
3863   2      
3864   2      
3865   2      
3866   2                      case CMD_VOL_VAL_GET:
3867   2                              
3868   2                              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.byMaxVol;
3869   2                              stLocalControl.stBusDealFreq.bySndRoomAddr = 0;
3870   2                              stLocalControl.stBusDealFreq.byRecSecAddr = 0;
3871   2                              stLocalControl.stBusDealFreq.byRecRoomAddr = 0;
3872   2                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                   
3873   2                              break;
3874   2      
3875   2      /*              case CMD_485BUS_OK:
3876   2                              KDR = 1;        //上电485总线成功之后,禁止485接收
3877   2                              break;*/
3878   2      
3879   2                      case CMD_WARD_SEC_INFO_SET:
3880   2                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3881   2                              break;
3882   2      
3883   2                      case CMD_GSM_FUNC_SEARCH:
3884   2                      case CMD_GSM_NUM_SEARCH:
3885   2                              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
3886   2                              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
3887   2                              stLocalControl.stBusDealFreq.bySndBedAddr =  stLocalControl.stEepromCfgData.bySelfBedAddr;
3888   2      
3889   2                              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
3890   2                              stLocalControl.stBusDealFreq.byRecRoomAddr = GSM_MODULE_ADDR;
3891   2                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3892   2                              break;
3893   2      
3894   2                      case CMD_GSM_NUM_SET:
3895   2                      case CMD_GSM_NUM_DEL:
3896   2                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3897   2                              break;
3898   2                      case CMD_GSM_FUNC_SET:
3899   2                              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
3900   2                              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
3901   2                              stLocalControl.stBusDealFreq.bySndBedAddr =  stLocalControl.stEepromCfgData.bySelfBedAddr;
3902   2                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
3903   2                              break;                  
3904   2                      default:
3905   2                              break;
3906   2              }       
3907   1      }
3908          /**********************************************************
3909          *函数名称                       :Bus1SendDeal   
3910          *函数描述               :单总线1发送完一帧数据处理函数,该函数首先
3911                                                   取出收到的数据,针对每条命令执行对应的控
3912                                                   制动作
3913          *输入参数               :
3914          *返回值                         :
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 65  

3915          *全局变量                       :
3916          *调用模块                       :
3917          ***********************************************************
3918          *创建人                 :尹运同
3919          *创建日期                       :2008-9-22
3920          ***********************************************************
3921          *修改人                         :
3922          *修改日期               :
3923          *注释                   :
3924          **********************************************************/
3925          void Bus1SendDeal(void)
3926          { 
3927   1              //取出数据帧
3928   1              OS_ENTER_CRITICAL();    
3929   1              bBus1SendFinish = 0;
3930   1              memcpy(&(stLocalControl.stBusDealFreq), byBus1SendData, sizeof(STBusFreq));     
3931   1              OS_EXIT_CRITICAL();     
3932   1              
3933   1              switch(stLocalControl.stBusDealFreq.byCmd)
3934   1              {
3935   2                      case CMD_LANDING:                                                                       //登记命令
3936   2                              break;
3937   2      
3938   2                      case CMD_POWER_ON:
3939   2                              OS_ENTER_CRITICAL();
3940   2                              //关闭所有打开的中断
3941   2                              CCAPM0 = 0x00;
3942   2                              ET0 = 0;
3943   2                              TR0 = 0;
3944   2                              EX0 = 0;
3945   2                              ISP_CONTR = 0x20; 
3946   2                              break;
3947   2                      default:
3948   2                              break;
3949   2              }
3950   1      
3951   1      }
3952          /**********************************************************
3953          *函数名称                       :Bus1Manage     
3954          *函数描述               :单总线1管理线程
3955          *输入参数               :
3956          *返回值                         :
3957          *全局变量                       :
3958          *调用模块                       :
3959          ***********************************************************
3960          *创建人                 :尹运同
3961          *创建日期                       :2008-9-22
3962          ***********************************************************
3963          *修改人                         :
3964          *修改日期               :
3965          *注释                   :
3966          **********************************************************/
3967          void Bus1Manage(void)
3968          {       
3969   1              while(TRUE)
3970   1              {       
3971   2                      WDT_CONTR = 0x3d;       //喂狗  
3972   2                      if(bBus1RecFinish)                                                                      //总线1收到数据
3973   2                      {                       
3974   3                              OSQPost(byMainCmdQ, BUS1_REC);                          
3975   3                      }
3976   2                      if(bBus1SendFinish)                                                                     //总线1发送完数据帧
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 66  

3977   2                      {
3978   3                              OSQPost(byMainCmdQ, BUS1_SND);                  
3979   3                      } 
3980   2                      OSWait(K_TMO, 1);                                       
3981   2              }
3982   1      }
3983          /**********************************************************
3984          *函数名称                       :TimerOutDeal   
3985          *函数描述               :超时处理函数
3986          *输入参数               :
3987          *返回值                         :
3988          *全局变量                       :stLocalControl
3989          *调用模块                       :Bus0OutputData,Bus1OutputData,VoiceChannelCtx,
3990                                                   LedControl,SetHandLedState
3991          ***********************************************************
3992          *创建人                 :尹运同
3993          *创建日期                       :2008-9-22
3994          ***********************************************************
3995          *修改人                         :
3996          *修改日期               :
3997          *注释                   :
3998          **********************************************************/
3999          void TimerOutDeal(void)
4000          { 
4001   1              //通道0超时处理         
4002   1              if(stLocalControl.stCH0TimerOut.byTimerOut != 0)
4003   1              {       //有超时设置存在
4004   2                      stLocalControl.stCH0TimerOut.byTimerOut--;
4005   2                      if(stLocalControl.stCH0TimerOut.byTimerOut == 0)
4006   2                      {       //超时一次到了 
4007   3                              if(stLocalControl.stCH0TimerOut.byTimerOutCount == 0x00)
4008   3                              {       //所有超时完成
4009   4                                      if(bLanding)
4010   4                                      {       //上电状态
4011   5                                              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
4012   5                                              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
4013   5                                              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
4014   5                                              stLocalControl.stBusDealFreq.byCmd = CMD_LANDING; 
4015   5                                              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.bySerialNum1;
4016   5                                              stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stEepromCfgData.bySerialNum2;
4017   5                                              stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stEepromCfgData.bySerialNum3;                                        
4018   5                                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
4019   5      /*                                      stLocalControl.stBusDealFreq.byCmd = CMD_POWER_ON;
4020   5                                              stLocalControl.stBusDealFreq.byRecSecAddr = 0xff;
4021   5                                              stLocalControl.stBusDealFreq.byRecRoomAddr = 0xff;
4022   5                                              stLocalControl.stBusDealFreq.byRecBedAddr = 0xff;
4023   5                                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));*/
4024   5                                      }
4025   4                                      else if((bWaitAck|bWaitListen|bChannel0Talk|bSelfBroad))
4026   4                                      {                               
4027   5                                              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
4028   5                                              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
4029   5                                              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
4030   5                                              stLocalControl.stBusDealFreq.byCmd = CMD_SYSTERM_RESET;
4031   5                                              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stCallAddr.byRecSecAddr;
4032   5                                              stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stCallAddr.byRecRoomAddr;
4033   5                                              stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stCallAddr.byRecBedAddr;
4034   5                                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
4035   5                                      }
4036   4                                      else if(bCalledRing)
4037   4                                      {       //被呼振铃状态
4038   5                                              bCalledRing = 0;                                                                        
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 67  

4039   5                                              if(bEnAutoListen)
4040   5                                              {       //自动接听
4041   6                                                      stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
4042   6                                                      stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
4043   6                                                      stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
4044   6                                                      stLocalControl.stBusDealFreq.byCmd = CMD_CALL_LISTEN;
4045   6                                                      stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stCallAddr.bySndSecAddr;
4046   6                                                      stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stCallAddr.bySndRoomAddr;
4047   6                                                      stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stCallAddr.bySndBedAddr;
4048   6                                                      Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); 
4049   6                                              }
4050   5                                      }                               
4051   4                                      else
4052   4                                      {
4053   5                                              bBusy = bCalledRing = bChannel0Talked = bSickRoomBroad = bOfficeBroad = bAllBroad = 0;
4054   5                                              VoiceChannelCtx();                                                                              
4055   5                                      }
4056   4                              }
4057   3                              else
4058   3                              {       //超时次数没有完
4059   4                                      stLocalControl.stCH0TimerOut.byTimerOutCount--;
4060   4                                      if(stLocalControl.stCH0TimerOut.byTimerOutCount == 0x00)
4061   4                                      {       //所有超时完成
4062   5                                              if(bLanding)
4063   5                                              {       //上电状态
4064   6                                                      stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
4065   6                                                      stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
4066   6                                                      stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
4067   6                                                      stLocalControl.stBusDealFreq.byCmd = CMD_LANDING;
4068   6                                                      stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stEepromCfgData.bySerialNum1;
4069   6                                                      stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stEepromCfgData.bySerialNum2;
4070   6                                                      stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stEepromCfgData.bySerialNum3;                                        
4071   6                                                      Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));                                                   
4072   6      /*                                              stLocalControl.stBusDealFreq.byCmd = CMD_POWER_ON;
4073   6                                                      stLocalControl.stBusDealFreq.byRecSecAddr = 0xff;
4074   6                                                      stLocalControl.stBusDealFreq.byRecRoomAddr = 0xff;
4075   6                                                      stLocalControl.stBusDealFreq.byRecBedAddr = 0xff;
4076   6                                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
4077   6      */
4078   6                                              }
4079   5                                              else if((bWaitAck|bWaitListen|bChannel0Talk|bSelfBroad))
4080   5                                              {                               
4081   6                                                      stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
4082   6                                                      stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
4083   6                                                      stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
4084   6                                                      stLocalControl.stBusDealFreq.byCmd = CMD_SYSTERM_RESET;
4085   6                                                      stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stCallAddr.byRecSecAddr;
4086   6                                                      stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stCallAddr.byRecRoomAddr;
4087   6                                                      stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stCallAddr.byRecBedAddr;
4088   6                                                      Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
4089   6                                              }
4090   5                                              else if(bCalledRing)
4091   5                                              {       //被呼振铃状态
4092   6                                                      bCalledRing = 0;                                                                                
4093   6                                                      if(bEnAutoListen)
4094   6                                                      {       //自动接听
4095   7                                                              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
4096   7                                                              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
4097   7                                                              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
4098   7                                                              stLocalControl.stBusDealFreq.byCmd = CMD_CALL_LISTEN;
4099   7                                                              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stCallAddr.bySndSecAddr;
4100   7                                                              stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stCallAddr.bySndRoomAddr;
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 68  

4101   7                                                              stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stCallAddr.bySndBedAddr;
4102   7                                                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr)); 
4103   7                                                      }
4104   6                                              }                                               
4105   5                                              else
4106   5                                              {
4107   6                                                      bBusy = bCalledRing = bChannel0Talked = bSickRoomBroad = bOfficeBroad = bAllBroad = 0;
4108   6                                                      VoiceChannelCtx();                                              
4109   6                                              }
4110   5                                      }
4111   4                                      else
4112   4                                      {       //超时次数没有完成，重新加载单位超时时间                                
4113   5                                              stLocalControl.stCH0TimerOut.byTimerOut = stLocalControl.stCH0TimerOut.byTimerOutSet;
4114   5                                      }
4115   4                              }                       
4116   3                      }
4117   2              }
4118   1              //通道1超时处理
4119   1              if(stLocalControl.stCH1Timerout.byTimerOut != 0)
4120   1              {       //有超时设置存在
4121   2                      stLocalControl.stCH1Timerout.byTimerOut--;
4122   2                      if(stLocalControl.stCH1Timerout.byTimerOut == 0)
4123   2                      {       //超时一次到了 
4124   3                              if(stLocalControl.stCH1Timerout.byTimerOutCount == 0x00)
4125   3                              {       //所有超时完成
4126   4                                      if(bChannel1Talk)
4127   4                                      {       //主动通话状态，发送切换命令
4128   5                                      
4129   5      /*                                      stLocalControl.stBusDealFreq.bySndSecAddr = 0x00;
4130   5                                              stLocalControl.stBusDealFreq.bySndRoomAddr = 0x00;
4131   5                                              stLocalControl.stBusDealFreq.bySndBedAddr = 0x00;       
4132   5      */      
4133   5                                              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
4134   5                                              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
4135   5                                              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
4136   5                                              stLocalControl.stBusDealFreq.byCmd = CMD_CHANNEL_CLOSE; 
4137   5      /*                                      stLocalControl.stBusDealFreq.byRecSecAddr = 0x00;
4138   5                                              stLocalControl.stBusDealFreq.byRecRoomAddr = 0x00;
4139   5                                              stLocalControl.stBusDealFreq.byRecBedAddr = 0x00;       
4140   5      */
4141   5                                              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stCallAddr.byRecSecAddr;
4142   5                                              stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stCallAddr.byRecRoomAddr;
4143   5                                              stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stCallAddr.byRecBedAddr;     
4144   5                                              Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));   
4145   5                                      }
4146   4                                      else if(bChannel1Talked)
4147   4                                      {       //被动通话状态，自己复位
4148   5                                              bChannel1Talked = 0; 
4149   5                                              if(bIndicatingOther)
4150   5                                              {       //如果有指示,立即显示指示信息   
4151   6                                                      stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stIndicationData.stAddr.bySndSecAddr;
4152   6                                                      stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stIndicationData.stAddr.bySndRoomAddr;
4153   6                                                      stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stIndicationData.stAddr.bySndBedAddr;
4154   6                                                      stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stIndicationData.byCallCmd;
4155   6                                                      stLocalControl.stBusDealFreq.byCmd = CMD_INFO_INDICATION;
4156   6                                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
4157   6      //                                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
4158   6                                              }
4159   5                                              else
4160   5                                              {
4161   6                                                      stLocalControl.stBusDealFreq.byCmd = CMD_STOP_INDICATION;
4162   6                                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 69  

4163   6      //                                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
4164   6                                              }                               
4165   5                                              VoiceChannelCtx();                                      
4166   5                                      }       
4167   4                              }
4168   3                              else
4169   3                              {       //超时次数没有完
4170   4                                      stLocalControl.stCH1Timerout.byTimerOutCount--;
4171   4                                      if(stLocalControl.stCH1Timerout.byTimerOutCount == 0x00)
4172   4                                      {       //所有超时完成
4173   5                                              if(bChannel1Talk)
4174   5                                              {       //主动通话状态，发送切换命令    
4175   6                                              
4176   6      /*                                              stLocalControl.stBusDealFreq.bySndSecAddr = 0x00;
4177   6                                                      stLocalControl.stBusDealFreq.bySndRoomAddr = 0x00;
4178   6                                                      stLocalControl.stBusDealFreq.bySndBedAddr = 0x00;
4179   6      */
4180   6                                                      stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stEepromCfgData.bySelfSecAddr;
4181   6                                                      stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stEepromCfgData.bySelfRoomAddr;
4182   6                                                      stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stEepromCfgData.bySelfBedAddr;
4183   6                                                      stLocalControl.stBusDealFreq.byCmd = CMD_CHANNEL_CLOSE; 
4184   6      /*
4185   6                                                      stLocalControl.stBusDealFreq.byRecSecAddr = 0x00;
4186   6                                                      stLocalControl.stBusDealFreq.byRecRoomAddr = 0x00;
4187   6                                                      stLocalControl.stBusDealFreq.byRecBedAddr = 0x00;       
4188   6      */
4189   6                                                      stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stCallAddr.byRecSecAddr;
4190   6                                                      stLocalControl.stBusDealFreq.byRecRoomAddr = stLocalControl.stCallAddr.byRecRoomAddr;
4191   6                                                      stLocalControl.stBusDealFreq.byRecBedAddr = stLocalControl.stCallAddr.byRecBedAddr;
4192   6                                                      Bus0OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));   
4193   6                                              }
4194   5                                              else if(bChannel1Talked)
4195   5                                              {       //被动通话状态，自己复位
4196   6                                                      bChannel1Talked = 0; 
4197   6                                                      if(bIndicatingOther)
4198   6                                                      {       //如果有指示,立即显示指示信息   
4199   7                                                              stLocalControl.stBusDealFreq.bySndSecAddr = stLocalControl.stIndicationData.stAddr.bySndSecAddr;
4200   7                                                              stLocalControl.stBusDealFreq.bySndRoomAddr = stLocalControl.stIndicationData.stAddr.bySndRoomAddr;
4201   7                                                              stLocalControl.stBusDealFreq.bySndBedAddr = stLocalControl.stIndicationData.stAddr.bySndBedAddr;
4202   7                                                              stLocalControl.stBusDealFreq.byRecSecAddr = stLocalControl.stIndicationData.byCallCmd;
4203   7                                                              stLocalControl.stBusDealFreq.byCmd = CMD_INFO_INDICATION;
4204   7                                                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
4205   7      //                                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
4206   7                                                      }
4207   6                                                      else
4208   6                                                      {
4209   7                                                              stLocalControl.stBusDealFreq.byCmd = CMD_STOP_INDICATION;
4210   7                                                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
4211   7      //                                                      Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
4212   7                                                      }                                       
4213   6                                                      VoiceChannelCtx();                                      
4214   6                                              }
4215   5                                      }
4216   4                                      else
4217   4                                      {       //超时次数没有完成，重新加载单位超时时间                                
4218   5                                              stLocalControl.stCH1Timerout.byTimerOut = stLocalControl.stCH1Timerout.byTimerOutSet;
4219   5                                      }
4220   4                              }                       
4221   3                      }
4222   2              } 
4223   1              if(stLocalControl.byNumSetTime)
4224   1              {
C51 COMPILER V9.00   SINGLEBUS                                                             02/18/2019 15:28:55 PAGE 70  

4225   2                      if(--stLocalControl.byNumSetTime==0)                            //编号时间到
4226   2                      {
4227   3                              bNumSeting=0;
4228   3                              stLocalControl.stBusDealFreq.byCmd =CMD_NUMBER_SET;
4229   3                              stLocalControl.stBusDealFreq.byRecSecAddr =0x00;        //退出编号
4230   3                              Bus1OutputData(&(stLocalControl.stBusDealFreq.bySndSecAddr));
4231   3                      }
4232   2              }
4233   1      
4234   1      }
4235          /**********************************************************
4236          *函数名称                       :TimerOutManager        
4237          *函数描述               :超时管理线程
4238          *输入参数               :
4239          *返回值                         :
4240          *全局变量                       :stLocalControl,byMainCmdQ
4241          *调用模块                       :OSQPost                                
4242          ***********************************************************
4243          *创建人                 :尹运同
4244          *创建日期                       :2008-9-22
4245          ***********************************************************
4246          *修改人                         :
4247          *修改日期               :
4248          *注释                   :
4249          **********************************************************/     
4250          void TimerOutManager(void)       
4251          {       
4252   1              while(1)
4253   1              {       
4254   2                      WDT_CONTR = 0x3d;       //喂狗  
4255   2                      OSWait(K_TMO, 4);                                                                       //延时20ms                              
4256   2                      if(stLocalControl.stCH0TimerOut.byTimerOut)
4257   2                      {       
4258   3                              OSQPost(byMainCmdQ, TIMER_OUT);                         
4259   3                      }
4260   2                      else
4261   2                      {               
4262   3                              OSQPost(byMainCmdQ, TIMER_OUT); 
4263   3                      }                       
4264   2              }
4265   1      }  
4266          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  10225    ----
   CONSTANT SIZE    =      9    ----
   XDATA SIZE       =    232       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     58      47
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      9    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
