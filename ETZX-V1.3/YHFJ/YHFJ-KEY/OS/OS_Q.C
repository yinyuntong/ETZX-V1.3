/*********************************************************************************************************
**				                               Small RTOS(51)
**                                   The Real-Time Kernel(For Keil c51)
**
**                                  (c) Copyright 2002-2003, chenmingji
**                                           All Rights Reserved
**
**                                                  V1.20.0
**
**
**--------------文件信息--------------------------------------------------------------------------------
**文   件   名: OS_Q.C
**创   建   人: 陈明计
**最后修改日期:  2003年3月8日
**描        述: Small RTOS(51)消息队列代码
**
**--------------历史版本信息----------------------------------------------------------------------------
** 创建人: 陈明计
** 版  本: V1.10~V1.12.0
** 日　期: 2002年6月20日~2002年12月30日
** 描　述: 完善消息队列代码
**
**------------------------------------------------------------------------------------------------------
** 修改人: 陈明计
** 版  本: V1.20.0
** 日　期: 2003年8月3日
** 描　述: 删除OSInt*函数，根据新版本要求改变一些代码
**
**--------------当前版本修订-----------------------------------------------------------------------------
** 修改人:
** 日　期:
** 描　述:
**
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/

#define  IN_OS_Q
#include "config.h"

#if EN_OS_Q > 0
/*********************************************************************************************************
** 函数名称: OSQCreate
** 功能描述: 初始化消息队列
** 输　入: Buf:为队列分配的存储空间地址
**         SizeOfBuf:为队列分配的存储空间大小
** 输　出: NOT_OK:参数错误
**         OS_Q_OK:成功
** 全局变量: 无
** 调用模块: 无
**
** 作　者: 陈明计
** 日　期: 2002年9月1日
**-------------------------------------------------------------------------------------------------------
** 修改人: 陈明计
** 日　期: 2002年10月27日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**-------------------------------------------------------------------------------------------------------
********************************************************************************************************/

        uint8 OSQCreate(uint8 OS_Q_MEM_SEL *Buf, uint8 SizeOfBuf)
//Buf[0]:队列中字节数,Buf[1]:Buf总长度,Buf[2]:出对端,Buf[3](,Buf[4]):等待队列任务列表
{
    OS_ENTER_CRITICAL();

    if ((SizeOfBuf >= 5) && (Buf != NULL))
    {
        Buf[0] = 0;                         /* 队列中消息数目           */
        Buf[1] = SizeOfBuf;                 /* 消息队列占用内存字节数    */
#if OS_MAX_TASKS < 9
        Buf[2] = 4;                         /* 将要出队的消息所在位置    */
#else
        Buf[2] = 5;                         /* 将要出队的消息所在位置    */
#endif
        Buf[3] = 0;                         /* 消息队列的等待任务列表    */
        Buf[4] = 0;                         /* 任务数大于等于8时为等待任务列表的一部分， */
                                            /* 否则为消息缓冲区         */

        OS_EXIT_CRITICAL();
        return OS_Q_OK;
    }
    else
    {
        OS_EXIT_CRITICAL();
        return NOT_OK;
    }

}

/*********************************************************************************************************
** 函数名称: OSQPend
** 功能描述: 等待消息队列中的消息
** 输　入: Ret:返回的消息
**         Buf:指向队列的指针
**         Tick:等待时间
** 输　出: NOT_OK:参数错误
**         OS_Q_OK:收到消息
**         OS_Q_TMO:超时到
**         OS_Q_NOT_OK:无消息
** 全局变量: 无
** 调用模块: OSRunningTaskID,OS_TaskSuspend,OSSched,OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
**
** 作　者: 陈明计
** 日　期: 2002年9月1日
**-------------------------------------------------------------------------------------------------------
** 修改人: 陈明计
** 日　期: 2002年10月9日
**------------------------------------------------------------------------------------------------------
** 修改人: 陈明计
** 日　期: 2002年12月2日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**-------------------------------------------------------------------------------------------------------
********************************************************************************************************/
#if EN_OS_Q_PENT > 0

        uint8 OSQPend(uint8 data *Ret, uint8 OS_Q_MEM_SEL *Buf, uint8 Tick)
{
#ifdef __C51__
    uint8 data *cp;
#endif

#if EN_OS_Q_CHK > 0
    if (Buf == NULL)
    {
        return NOT_OK;
    }
#endif

    OS_ENTER_CRITICAL();

    OSWaitTick[OSRunningTaskID()] = Tick;       /* 设置超时时间         */
                                                /* 可以优化寄存器的使用  */

                /* 使用堆栈是为了使函数具有重入性 */
#ifdef __C51__
    SP++;
    *((uint8 data * data *)SP) = Ret;
#endif

                /* 把任务加入等待任务队列 */
#if OS_MAX_TASKS < 9
    Buf[3] |= OSMapTbl[OSRunningTaskID()];
#else
    if (OSRunningTaskID() < 8)
    {
        Buf[3] |= OSMapTbl[OSRunningTaskID()];
    }
    else
    {
        Buf[4] |= OSMapTbl[OSRunningTaskID() & 0x07];
    }
#endif

    while (Buf[0] == 0)             /* 消息队列中是否有消息 */
    {
                /* 无消息 */
#ifdef __C51__
        SP = SP + sizeof(Buf);
        *((uint8 OS_Q_MEM_SEL * data *)(SP + 1 - sizeof(Buf))) = Buf;
#endif

        OS_TaskSuspend(OSRunningTaskID());   /* 任务进入等待状态 */
        OSSched();                          /* 运行下一个任务 */

#ifdef __C51__
        Buf = *((uint8 OS_Q_MEM_SEL * data *)(SP + 1 - sizeof(Buf)));
        SP = SP - sizeof(Buf);
#endif
                /* 任务再次运行，如果超时到，退出循环 */
        if (OSWaitTick[OSRunningTaskID()] == 0)
        {
            break;
        }
    }

                /* 将任务从等待队列中清除（可以删除） */
#if OS_MAX_TASKS < 9
    Buf[3] &= ~OSMapTbl[OSRunningTaskID()];
#else
    if (OSRunningTaskID() < 8)
    {
        Buf[3] &= ~OSMapTbl[OSRunningTaskID()];
    }
    else
    {
        Buf[4] &= ~OSMapTbl[OSRunningTaskID() & 0x07];
    }
#endif
                /* 判断消息队列中是否有消息 */
    if (Buf[0] > 0)
    {
                /* 有，消息出队 */
        Buf[0]--;           /* 队列的消息数目减一 */
                /* 指向下一个出队位置 */
        Buf[2]++;
        if (Buf[2] >= Buf[1] )
        {
#if OS_MAX_TASKS < 9
            Buf[2] = 4;
#else
            Buf[2] = 5;
#endif
        }
#ifdef __C51__
        cp = (uint8 data *)(*((uint8 data *)SP));
        SP--;
        *cp = Buf[Buf[2]];
#else
        *Ret = Buf[Buf[2]];
#endif
        OS_EXIT_CRITICAL();
        return OS_Q_OK;
    }
    else
    {
                /* 无，返回错误码 */
#ifdef __C51__
        SP--;
#endif

        OS_EXIT_CRITICAL();
        return OS_Q_TMO;
    }
}
#endif

/*********************************************************************************************************
** 函数名称: OSQAccept
** 功能描述: 无等待从消息队列中取得消息
** 输　入: Ret:返回的消息
**         Buf:指向队列的指针
** 输　出: NOT_OK:参数错误
**         OS_Q_OK:收到消息
**         OS_Q_TMO:超时到
**         OS_Q_NOT_OK:无消息
** 全局变量: 无
** 调用模块: OS_TaskSuspend,OSSched,OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
**
** 作　者: 陈明计
** 日　期: 2002年9月1日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**-------------------------------------------------------------------------------------------------------
********************************************************************************************************/
#if EN_OS_Q_ACCEPT > 0
        uint8 OSQAccept(uint8 data *Ret, uint8 OS_Q_MEM_SEL *Buf)
{
#if EN_OS_Q_CHK > 0
    if (Buf == NULL)
    {
        return NOT_OK;
    }
#endif

    OS_ENTER_CRITICAL();

                /* 判断消息队列中是否有消息 */
    if (*Buf != 0)
    {
                /* 有，消息出队 */
        Buf[0]--;
        Buf[2]++;
        if (Buf[2] >= Buf[1])
        {
#if OS_MAX_TASKS < 9
            Buf[2] = 4;
#else
            Buf[2] = 5;
#endif
        }
        *Ret = Buf[Buf[2]];
        OS_EXIT_CRITICAL();
        return OS_Q_OK;
    }
    else
    {
                /* 无，返回错误码 */
        OS_EXIT_CRITICAL();
        return OS_Q_NOT_OK;
    }
}
#endif


/*********************************************************************************************************
** 函数名称: OSQPost
** 功能描述: 中断中FIFO方式发送消息
** 输　入: Buf:指向队列的指针
**         Data:消息数据
** 输　出: OS_Q_FULL:队列满
**         OS_Q_OK:发送成功
** 全局变量: 无
** 调用模块: OSTaskResume,OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
**
** 作　者: 陈明计
** 日　期: 2003年8月3日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**-------------------------------------------------------------------------------------------------------
********************************************************************************************************/
#if EN_OS_Q_POST > 0
        uint8 OSQPost(uint8 OS_Q_MEM_SEL *Buf, uint8 Data)
{
    uint8 temp,i;

#if EN_OS_Q_CHK > 0
    if (Buf == NULL)
    {
        return NOT_OK;
    }
#endif

    OS_ENTER_CRITICAL();

                /* 队列是否已满 */
#if OS_MAX_TASKS < 9
    if (Buf[0] < (Buf[1]-4))
#else
    if (Buf[0] < (Buf[1]-5))
#endif
    {
                /* 使用堆栈是为了使函数具有重入性 */
#ifdef __C51__
        SP++;
        *((uint8 data *)SP) = Data;
#endif
                /* 计算新入队消息存储位置 */
        temp = Buf[2] + Buf[0] + 1;
        if (temp >= Buf[1])
        {
#if OS_MAX_TASKS < 9
            temp = temp - Buf[1]+4;
#else
            temp = temp - Buf[1]+5;
#endif
        }
                /* 存储消息 */
#ifdef __C51__
        Buf[temp] = *((uint8 data *)SP);
        SP--;
#else
        Buf[temp] = Data;
#endif

        Buf[0]++;               /* 消息数目加一 */
                /* 判断消息入队前消息队列是否为空 */
        if (Buf[0] == 1)
        {
                /* 为空，可能有任务等待消息，查找之 */
            temp = Buf[3];
#if OS_MAX_TASKS < 9
            for (i = 0; i < OS_MAX_TASKS; i++)
            {
                if ((temp & 0x01) != 0)
                {
                    break;
                }
                temp = temp >> 1;
            }
            if (i < OS_MAX_TASKS )
            {
                /* 查到，使其中优先级最高的任务进入就绪状态，并将其从等待队列中清除 */
                Buf[3] &= ~OSMapTbl[i];
                OSTaskResume(i);
            }
#else
            for (i = 0; i < 8; i++)
            {
                if ((temp & 0x01) != 0)
                {
                    break;
                }
                temp = temp >> 1;
            }
            if (i >= 8 )
            {
                temp = Buf[4];
                for (; i < OS_MAX_TASKS; i++)
                {
                    if ((temp & 0x01) != 0)
                    {
                        break;
                    }
                    temp = temp >> 1;
                }
            }
            if (i < OS_MAX_TASKS )
            {
                /* 查到，使其中优先级最高的任务进入就绪状态，并将其从等待队列中清除 */
                if (i < 8)
                {
                    Buf[3] &= ~OSMapTbl[i];
                }
                else
                {
                    Buf[4] &= ~OSMapTbl[i & 0x07];
                }
                OSTaskResume(i);
            }
#endif
        }
        OS_EXIT_CRITICAL();
        return OS_Q_OK;
    }
    else
    {
        OS_EXIT_CRITICAL();
        return OS_Q_FULL;
    }
}
#endif

/*********************************************************************************************************
** 函数名称: OSQPostFront
** 功能描述: 中断中LIFO方式发送消息
** 输　入: Buf:指向队列的指针
**         Data:消息数据
** 输　出: OS_Q_FULL:队列满
**         OS_Q_OK:发送成功
** 全局变量: 无
** 调用模块: OSTaskResume,OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
**
** 作　者: 陈明计
** 日　期: 2003年8月3日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**-------------------------------------------------------------------------------------------------------
********************************************************************************************************/
#if EN_OS_Q_POST_FRONT > 0
        uint8 OSQPostFront(uint8 OS_Q_MEM_SEL *Buf, uint8 Data)
{
    uint8 temp,i;

#if EN_OS_Q_CHK > 0
    if (Buf == NULL)
    {
        return NOT_OK;
    }
#endif

    OS_ENTER_CRITICAL();

                /* 队列是否已满 */
#if OS_MAX_TASKS < 9
    if (Buf[0] < (Buf[1]-4))
#else
    if (Buf[0] < (Buf[1]-5))
#endif
    {
                /* 存储消息 */
        Buf[Buf[2]] = Data;
        Buf[0]++;           /* 消息数目增加一 */
                /* 指向新的将要出队的消息 */
        Buf[2]--;
#if OS_MAX_TASKS < 9
        if (Buf[2] < 4)
#else
        if (Buf[2] < 5)
#endif
        {
            Buf[2] = Buf[1]-1;
        }
        
                /* 判断消息入队前消息队列是否为空 */
        if (Buf[0] == 1)
        {
                /* 为空，可能有任务等待消息，查找之 */
            temp = Buf[3];
#if OS_MAX_TASKS < 9
            for (i = 0; i < OS_MAX_TASKS; i++)
            {
                if ((temp & 0x01) != 0)
                {
                    break;
                }
                temp = temp >> 1;
            }
            if (i < OS_MAX_TASKS )
            {
                /* 查到，使其中优先级最高的任务进入就绪状态，并将其从等待队列中清除 */
                Buf[3] &= ~OSMapTbl[i];
                OSTaskResume(i);
            }
#else
            for (i = 0; i < 8; i++)
            {
                if ((temp & 0x01) != 0)
                {
                    break;
                }
                temp = temp >> 1;
            }
            if (i >= 8 )
            {
                temp = Buf[4];
                for (; i < OS_MAX_TASKS; i++)
                {
                    if ((temp & 0x01) != 0)
                    {
                        break;
                    }
                    temp = temp >> 1;
                }
            }
            if (i < OS_MAX_TASKS )
            {
                /* 查到，使其中优先级最高的任务进入就绪状态，并将其从等待队列中清除 */
                if (i < 8)
                {
                    Buf[3] &= ~OSMapTbl[i];
                }
                else
                {
                    Buf[4] &= ~OSMapTbl[i & 0x07];
                }
                OSTaskResume(i);
            }
#endif
        }
        OS_EXIT_CRITICAL();
        return OS_Q_OK;
    }
    else
    {
        OS_EXIT_CRITICAL();
        return OS_Q_FULL;
    }
}
#endif

/*********************************************************************************************************
** 函数名称: OSQNMsgs
** 功能描述: 取得消息队列中消息数
** 输　入: Buf:指向队列的指针
** 输　出: 消息数
** 全局变量: 无
** 调用模块: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
**
** 作　者: 陈明计
** 日　期: 2002年9月1日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**-------------------------------------------------------------------------------------------------------
********************************************************************************************************/
#if EN_OS_Q_NMsgs > 0
        uint8 OSQNMsgs(uint8 OS_Q_MEM_SEL *Buf)
{
    uint8 temp;

#if EN_OS_Q_CHK > 0
    if (Buf == NULL)
    {
        return 0;
    }
#endif

    OS_ENTER_CRITICAL();
    temp = Buf[0];
    OS_EXIT_CRITICAL();
    return temp;
}
#endif

/*********************************************************************************************************
** 函数名称: OSQSize
** 功能描述: 取得消息队列总容量
** 输　入: Buf:指向队列的指针
** 输　出: 消息队列总容量
** 全局变量: 无
** 调用模块: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
**
** 作　者: 陈明计
** 日　期: 2002年9月1日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**-------------------------------------------------------------------------------------------------------
********************************************************************************************************/
#if EN_OS_Q_SIZE > 0
        uint8 OSQSize(uint8 OS_Q_MEM_SEL *Buf)
{
    uint8 temp;

#if EN_OS_Q_CHK > 0
    if (Buf == NULL)
    {
        return 0;
    }
#endif

    OS_ENTER_CRITICAL();
#if OS_MAX_TASKS < 9
    temp = Buf[1] - 4;
#else
    temp = Buf[1] - 5;
#endif
    OS_EXIT_CRITICAL();
    return temp;
}
#endif

/*********************************************************************************************************
** 函数名称: OSQFlush
** 功能描述: 清空队列
** 输　入: Buf:指向队列的指针
** 输　出: 无
** 全局变量: 无
** 调用模块: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
**
** 作　者: 陈明计
** 日　期: 2002年9月1日
**-------------------------------------------------------------------------------------------------------
** 修改人: 陈明计
** 日　期: 2002年10月26日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**-------------------------------------------------------------------------------------------------------
********************************************************************************************************/
#if EN_OS_Q_FLUSH > 0
        void OSQFlush (uint8 OS_Q_MEM_SEL *Buf)
{
#if EN_OS_Q_CHK > 0
    if (Buf == NULL)
    {
        return;
    }
#endif

    Buf[0] = 0;
#if OS_MAX_TASKS < 9
    Buf[2] = 4;
#else
    Buf[2] = 5;
#endif
}
#endif

#endif
/*********************************************************************************************************
**                            End Of File
********************************************************************************************************/
