C51 COMPILER V9.00   GT23                                                                  02/18/2019 16:52:19 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE GT23
OBJECT MODULE PLACED IN GT23.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE GT23.C LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*
   2          ************************Copyright(c)************************
   3          *                                  湖南一特电子股份有限公司
   4          *                               All Rights Reserved
   5          *                                        
   6          *
   7          *-----------------------文件信息---------------------------
   8          *文件名称               :HZ.c
   9          *文件描述               :汉字识别、汉字字库驱动
  10          *创建人                 :尹运同
  11          *创建日期               :2008-9-22
  12          *版本号                 :V1.0
  13          *注释                        :
  14          *----------------------------------------------------------
  15          *修改人                         :
  16          *修改日期                       :
  17          *版本号                 :
  18          *注释                   :
  19          ***********************************************************
  20          */
  21          #define _IN_GT23_
  22          #include "config.h"
  23          
  24          uint8   xdata  GT23_Rec_Data[128];
  25          uint8   xdata  GT23_Rec_Length=0;
  26          uint16  xdata  GT23_16LAddress;
  27          uint16  xdata  GT23_16HAddress;
  28          uint32  xdata  GT23_32Address; 
  29          
  30          void Get_GT23_Data(uint8 highbyte,uint8 lowbyte,uint8 word_size);
  31          void Get_GT23_Data1(uint8 *word,uint8  word_size);
  32          void GT23_TEST(void);
  33          uint8 Rec_GT23_Data(void);
  34          
  35          /*---------------------------------------------------------------------------
  36          函数原型: uint8 Rec_GT23_Data(void)
  37          参数说明: 无
  38          返 回 值: 字库芯片的返回值
  39          函数功能：获取字库芯片的点阵数据
  40          ----------------------------------------------------------------------------*/
  41          uint8 Rec_GT23_Data(void)
  42          {
  43   1              SPI_WriteByte(0xf0);
  44   1              return SPDAT;
  45   1      }
  46           /*-------------------------------------------------------------------------------------------------------
             -----------------------------
  47          函数原型: void Get_GT23_Data(uint8 highbyte,uint8 lowbyte,uint8 word_size)
  48          参数说明: highbyte--汉字国标码的高字节,lowbyte--汉字国标码的低字节,word_size--获取点阵汉字的字体大小 
  49          
  50          1为15*16点阵汉字或者8*16点阵ASCII
  51          2为24*24点阵汉字或者16*24点阵ASCII
  52          3为32*32点阵汉字或者16*32点阵ASCII
  53          
  54          15*16
C51 COMPILER V9.00   GT23                                                                  02/18/2019 16:52:19 PAGE 2   

  55          BaseAdd=0x2C9D0;
  56          if(MSB >=0xA1 && MSB <= 0Xa9 && LSB >=0xA1)
  57          Address =( (MSB - 0xA1) * 94 + (LSB - 0xA1))*32+ BaseAdd;
  58          else if(MSB >=0xB0 && MSB <= 0xF7 && LSB >=0xA1)
  59          Address = ((MSB - 0xB0) * 94 + (LSB - 0xA1)+ 846)*32+ BaseAdd;
  60          
  61          24*24
  62          BaseAdd=0x68190;
  63          if(MSB >=0xA1 && MSB <= 0Xa9 && LSB >=0xA1)
  64          Address =( (MSB - 0xA1) * 94 + (LSB - 0xA1))*72+ BaseAdd;       
  65          else if(MSB >=0xB0 && MSB <= 0xF7 && LSB >=0xA1)
  66          Address = ((MSB - 0xB0) * 94 + (LSB - 0xA1)+ 846)*72+ BaseAdd;
  67          
  68          32*32
  69          BaseAdd=0XEDF00;
  70          if(MSB >=0xA1 && MSB <= 0Xa9 && LSB >=0xA1)
  71          Address =( (MSB - 0xA1) * 94 + (LSB - 0xA1))*128+ BaseAdd;
  72          else if(MSB >=0xB0 && MSB <= 0xF7 && LSB >=0xA1)
  73          Address = ((MSB - 0xB0) * 94 + (LSB - 0xA1)+ 846)*128+ BaseAdd;
  74          
  75          返 回 值: 无
  76          函数功能：通过发送汉字的国标码来获取该汉字的点阵数据
  77          ----------------------------------------------------------------------------------------------------------
             -----------------------------*/
  78          void Get_GT23_Data(uint8 highbyte,uint8 lowbyte,uint8 word_size)
  79          {
  80   1          uint32  xdata address1,address2,address3,address4;
  81   1              GT23L_CS=0;
  82   1              //SPI_CS1=0;
  83   1              WDT_CONTR = 0x3d; 
  84   1              if(highbyte >=0xA1&&highbyte<=0xA9&&lowbyte>=0xA1)        //如果是全角字符,数字 
  85   1              {
  86   2                 if(word_size==1) //15*16
  87   2                      {
  88   3                        address1 = (highbyte-0xa1)*94; 
  89   3                        address2 = (lowbyte-0xA1)+address1;
  90   3                        address3 = address2*32;
  91   3                        address4 = address3+C16BaseAdd;
  92   3                      }
  93   2                else if(word_size==2)//24*24
  94   2                 {
  95   3                        address1 = (highbyte-0xa1)*94; 
  96   3                        address2 = (lowbyte-0xA1)+address1;
  97   3                        address3 = address2*72;
  98   3                        address4 = address3+C24BaseAdd;
  99   3                 }
 100   2                 else if(word_size==3)//32*32
 101   2                 {
 102   3                         address1 = (highbyte-0xa1)*94; 
 103   3                         address2 = (lowbyte-0xA1)+address1;
 104   3                         address3 = address2*128;
 105   3                         address4 = address3+C32BaseAdd; 
 106   3                 }
 107   2               }
 108   1      
 109   1              
 110   1          else if(highbyte >=0xB0&&highbyte<=0xF7&&lowbyte>=0xA1)    //如果是汉字 
 111   1               {
 112   2                      if(word_size==1) //15*16
 113   2                       {
 114   3                         address1 = (highbyte-0xB0)*94; 
 115   3                         address2 = lowbyte-0xA1+846+address1;
C51 COMPILER V9.00   GT23                                                                  02/18/2019 16:52:19 PAGE 3   

 116   3                         address3 = address2*32;
 117   3                         address4 = address3+C16BaseAdd;
 118   3                       }
 119   2                 else if(word_size==2)//24*24
 120   2                  {
 121   3                    address1 = (highbyte-0xB0)*94; 
 122   3                    address2 = lowbyte-0xA1+846+address1;
 123   3                    address3 = address2*72;
 124   3                    address4 = address3+C24BaseAdd;
 125   3                      }
 126   2                      else if(word_size==3)//32*32
 127   2                      {
 128   3                        address1 = (highbyte-0xB0)*94; 
 129   3                    address2 = lowbyte-0xA1+846+address1;
 130   3                    address3 = address2*128;
 131   3                    address4 = address3+C32BaseAdd; 
 132   3                      }
 133   2               }
 134   1              //-------------------------------------------------------------
 135   1              else if(highbyte==0x00&&lowbyte>=0x20&&lowbyte <= 0x7E)   //如果是ASCII
 136   1              { 
 137   2                if(word_size==1)              //8*16
 138   2                  {
 139   3                    address1 = (lowbyte-0x20)*16; 
 140   3                    address4 = address1+A8BaseAdd;
 141   3                      }
 142   2                else if(word_size==2)//12*24
 143   2                  {
 144   3                    address1 = (lowbyte-0x20)*48; 
 145   3                    address4 = address1+A12BaseAdd;       
 146   3                      }
 147   2                else if(word_size==3)//16*32
 148   2                  {
 149   3                    address1 = (lowbyte-0x20)*64; 
 150   3                    address4 = address1+A16BaseAdd;
 151   3      
 152   3                      }
 153   2              }
 154   1              //-------------------------------------------------------------
 155   1          GT23_32Address=address4;
 156   1          GT23_16HAddress=GT23_32Address/65536;
 157   1          GT23_16LAddress=GT23_32Address%65536;
 158   1          GT23L_CS=0;
 159   1          SPI_WriteByte(0x03);
 160   1          SPI_WriteByte(GT23_16HAddress%256);
 161   1          SPI_WriteByte(GT23_16LAddress/256);
 162   1          SPI_WriteByte(GT23_16LAddress%256);
 163   1              
 164   1              if(highbyte >=0xa1&&highbyte<=0xF7&&lowbyte>=0xA1)
 165   1               {
 166   2            if(word_size==1)//15*16
 167   2             {
 168   3               for(GT23_Rec_Length=0;GT23_Rec_Length<32;GT23_Rec_Length++)
 169   3               GT23_Rec_Data[GT23_Rec_Length]=Rec_GT23_Data();
 170   3             }
 171   2            if(word_size==2)//24*24
 172   2             {
 173   3               for(GT23_Rec_Length=0;GT23_Rec_Length<72;GT23_Rec_Length++)
 174   3               GT23_Rec_Data[GT23_Rec_Length]=Rec_GT23_Data();
 175   3             }          
 176   2            else if(word_size==3)//32*32
 177   2            {
C51 COMPILER V9.00   GT23                                                                  02/18/2019 16:52:19 PAGE 4   

 178   3              for(GT23_Rec_Length=0;GT23_Rec_Length<128;GT23_Rec_Length++)
 179   3              GT23_Rec_Data[GT23_Rec_Length]=Rec_GT23_Data();
 180   3            }
 181   2           }
 182   1              else if(highbyte==0x00&&lowbyte>=0x20&&lowbyte <= 0x7E) 
 183   1              {
 184   2               if(word_size==1)//8*16
 185   2             {
 186   3               for(GT23_Rec_Length=0;GT23_Rec_Length<16;GT23_Rec_Length++)
 187   3               GT23_Rec_Data[GT23_Rec_Length]=Rec_GT23_Data();
 188   3             }
 189   2            else if(word_size==2)//12*24
 190   2            {
 191   3              for(GT23_Rec_Length=0;GT23_Rec_Length<48;GT23_Rec_Length++)
 192   3              GT23_Rec_Data[GT23_Rec_Length]=Rec_GT23_Data();
 193   3            }
 194   2                else if(word_size==3)//16*32
 195   2            {
 196   3              for(GT23_Rec_Length=0;GT23_Rec_Length<64;GT23_Rec_Length++)
 197   3              GT23_Rec_Data[GT23_Rec_Length]=Rec_GT23_Data();
 198   3            }
 199   2              }   
 200   1          GT23L_CS=1;
 201   1      }
 202          
 203          
 204          
 205           /*-------------------------------------------------------------------------------------------------------
             -----------------------------
 206          函数原型: void Get_GT23_Data(uint8 highbyte,uint8 lowbyte,uint8 word_size)
 207          参数说明: highbyte--汉字国标码的高字节,lowbyte--汉字国标码的低字节,word_size--获取点阵汉字的字体大小 
 208                            1为15*16点阵汉字或者8*16点阵ASCII
 209                            2为24*24点阵汉字或者16*24点阵ASCII
 210                            3为32*32点阵汉字或者16*32点阵ASCII
 211          
 212          返 回 值: 无
 213          函数功能：通过发送汉字的国标码来获取该汉字的点阵数据
 214          ----------------------------------------------------------------------------------------------------------
             -----------------------------*/
 215          void Get_GT23_Data1(uint8 *word,uint8 word_size)
 216          {
 217   1          uint32  xdata address1,address2,address3,address4;
 218   1              uint8 xdata highbyte,lowbyte;
 219   1              GT23L_CS=0;
 220   1      //      Send_Data((uint8 *)word,2);
 221   1              highbyte=*word;
 222   1              word++;
 223   1              lowbyte= *word;
 224   1      
 225   1              WDT_CONTR = 0x3d; 
 226   1      
 227   1              if(highbyte<0xa1) //是ASCII字符
 228   1              {
 229   2                      lowbyte=highbyte;
 230   2                      highbyte=0x00;  //为了跟下面一致
 231   2              }
 232   1              
 233   1              if(highbyte >=0xA1&&highbyte<=0xA9&&lowbyte>=0xA1)        //如果是全角字符,数字 
 234   1              {
 235   2                       if(word_size==1) //15*16
 236   2                        {
 237   3                              address1 = (highbyte-0xa1)*94; 
C51 COMPILER V9.00   GT23                                                                  02/18/2019 16:52:19 PAGE 5   

 238   3                              address2 = (lowbyte-0xA1)+address1;
 239   3                              address3 = address2*32;
 240   3                              address4 = address3+C16BaseAdd;
 241   3                        }
 242   2                      else if(word_size==2)//24*24
 243   2                       {
 244   3                              address1 = (highbyte-0xa1)*94; 
 245   3                              address2 = (lowbyte-0xA1)+address1;
 246   3                              address3 = address2*72;
 247   3                              address4 = address3+C24BaseAdd;
 248   3                       }
 249   2                       else if(word_size==3)//32*32
 250   2                       {
 251   3                               address1 = (highbyte-0xa1)*94; 
 252   3                               address2 = (lowbyte-0xA1)+address1;
 253   3                               address3 = address2*128;
 254   3                               address4 = address3+C32BaseAdd; 
 255   3                       }
 256   2      
 257   2               }
 258   1      
 259   1              
 260   1           else if(highbyte >=0xB0&&highbyte<=0xF7&&lowbyte>=0xA1)    //如果是汉字 
 261   1               {
 262   2                      if(word_size==1) //15*16
 263   2                       {
 264   3                         address1 = (highbyte-0xB0)*94; 
 265   3                         address2 = lowbyte-0xA1+846+address1;
 266   3                         address3 = address2*32;
 267   3                         address4 = address3+C16BaseAdd;
 268   3                       }
 269   2                 else if(word_size==2)//24*24
 270   2                  {
 271   3                    address1 = (highbyte-0xB0)*94; 
 272   3                    address2 = lowbyte-0xA1+846+address1;
 273   3                    address3 = address2*72;
 274   3                    address4 = address3+C24BaseAdd;
 275   3                      }
 276   2                      else if(word_size==3)//32*32
 277   2                      {
 278   3                        address1 = (highbyte-0xB0)*94; 
 279   3                    address2 = lowbyte-0xA1+846+address1;
 280   3                    address3 = address2*128;
 281   3                    address4 = address3+C32BaseAdd; 
 282   3                      }
 283   2                }
 284   1              //-------------------------------------------------------------
 285   1              else if(highbyte==0x00&&lowbyte>=0x20&&lowbyte <= 0x7E)   //如果是ASCII
 286   1              { 
 287   2                if(word_size==1)              //8*16
 288   2                  {
 289   3                    address1 = (lowbyte-0x20)*16; 
 290   3                    address4 = address1+A8BaseAdd;
 291   3                      }
 292   2                else if(word_size==2)//12*24
 293   2                  {
 294   3                    address1 = (lowbyte-0x20)*48; 
 295   3                    address4 = address1+A12BaseAdd;       
 296   3                      }
 297   2                else if(word_size==3)//16*32
 298   2                  {
 299   3                    address1 = (lowbyte-0x20)*64; 
C51 COMPILER V9.00   GT23                                                                  02/18/2019 16:52:19 PAGE 6   

 300   3                    address4 = address1+A16BaseAdd;
 301   3      
 302   3                      }
 303   2              }
 304   1              //-------------------------------------------------------------
 305   1          GT23_32Address=address4;
 306   1          GT23_16HAddress=GT23_32Address/65536;
 307   1          GT23_16LAddress=GT23_32Address%65536;
 308   1          GT23L_CS=0;
 309   1          SPI_WriteByte(0x03);
 310   1          SPI_WriteByte(GT23_16HAddress%256);
 311   1          SPI_WriteByte(GT23_16LAddress/256);
 312   1          SPI_WriteByte(GT23_16LAddress%256);
 313   1              
 314   1              if(highbyte >=0xa1&&highbyte<=0xF7&&lowbyte>=0xA1)
 315   1               {
 316   2            if(word_size==1)//15*16
 317   2             {
 318   3               for(GT23_Rec_Length=0;GT23_Rec_Length<32;GT23_Rec_Length++)
 319   3               GT23_Rec_Data[GT23_Rec_Length]=Rec_GT23_Data();
 320   3             }
 321   2            if(word_size==2)//24*24
 322   2             {
 323   3               for(GT23_Rec_Length=0;GT23_Rec_Length<72;GT23_Rec_Length++)
 324   3               GT23_Rec_Data[GT23_Rec_Length]=Rec_GT23_Data();
 325   3             }          
 326   2            else if(word_size==3)//32*32
 327   2            {
 328   3              for(GT23_Rec_Length=0;GT23_Rec_Length<128;GT23_Rec_Length++)
 329   3              GT23_Rec_Data[GT23_Rec_Length]=Rec_GT23_Data();
 330   3            }
 331   2           }
 332   1              else if(highbyte==0x00&&lowbyte>=0x20&&lowbyte <= 0x7E) 
 333   1              {
 334   2               if(word_size==1)//8*16
 335   2             {
 336   3               for(GT23_Rec_Length=0;GT23_Rec_Length<16;GT23_Rec_Length++)
 337   3               GT23_Rec_Data[GT23_Rec_Length]=Rec_GT23_Data();
 338   3             }
 339   2            else if(word_size==2)//12*24
 340   2            {
 341   3              for(GT23_Rec_Length=0;GT23_Rec_Length<48;GT23_Rec_Length++)
 342   3              GT23_Rec_Data[GT23_Rec_Length]=Rec_GT23_Data();
 343   3            }
 344   2                else if(word_size==3)//16*32
 345   2            {
 346   3              for(GT23_Rec_Length=0;GT23_Rec_Length<64;GT23_Rec_Length++)
 347   3              GT23_Rec_Data[GT23_Rec_Length]=Rec_GT23_Data();
 348   3            }
 349   2              }   
 350   1      
 351   1          GT23L_CS=1;
 352   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2607    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    137      38
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.00   GT23                                                                  02/18/2019 16:52:19 PAGE 7   

   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
