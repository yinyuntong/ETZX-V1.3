C51 COMPILER V8.08   OS_Q                                                                  08/07/2012 09:07:58 PAGE 1   


C51 COMPILER V8.08, COMPILATION OF MODULE OS_Q
OBJECT MODULE PLACED IN .\OS_Q.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\OS\OS_Q.C OPTIMIZE(SIZE) BROWSE DEBUG OBJECTEXTEND PRINT(.\OS_Q.lst) OBJ
                    -ECT(.\OS_Q.obj)

line level    source

   1          /*********************************************************************************************************
   2          **                                                             Small RTOS(51)
   3          **                                   The Real-Time Kernel(For Keil c51)
   4          **
   5          **                                  (c) Copyright 2002-2003, chenmingji
   6          **                                           All Rights Reserved
   7          **
   8          **                                                  V1.20.0
   9          **
  10          **
  11          **--------------文件信息--------------------------------------------------------------------------------
  12          **文   件   名: OS_Q.C
  13          **创   建   人: 陈明计
  14          **最后修改日期:  2003年3月8日
  15          **描        述: Small RTOS(51)消息队列代码
  16          **
  17          **--------------历史版本信息----------------------------------------------------------------------------
  18          ** 创建人: 陈明计
  19          ** 版  本: V1.10~V1.12.0
  20          ** 日　期: 2002年6月20日~2002年12月30日
  21          ** 描　述: 完善消息队列代码
  22          **
  23          **------------------------------------------------------------------------------------------------------
  24          ** 修改人: 陈明计
  25          ** 版  本: V1.20.0
  26          ** 日　期: 2003年8月3日
  27          ** 描　述: 删除OSInt*函数，根据新版本要求改变一些代码
  28          **
  29          **--------------当前版本修订-----------------------------------------------------------------------------
  30          ** 修改人:
  31          ** 日　期:
  32          ** 描　述:
  33          **
  34          **------------------------------------------------------------------------------------------------------
  35          ********************************************************************************************************/
  36          
  37          #define  IN_OS_Q
  38          #include "config.h"
*** WARNING C318 IN LINE 77 OF config.h: can't open file 'OS_CFG.H'
*** WARNING C318 IN LINE 78 OF config.h: can't open file 'OS_CPU.H'
*** ERROR C129 IN LINE 64 OF ..\OS\OS.H: missing ';' before 'data'
  39          
  40          #if EN_OS_Q > 0
*** WARNING C322 IN LINE 40 OF ..\OS\OS_Q.C: unknown identifier
              /*********************************************************************************************************
              ** 函数名称: OSQCreate
              ** 功能描述: 初始化消息队列
              ** 输　入: Buf:为队列分配的存储空间地址
              **         SizeOfBuf:为队列分配的存储空间大小
              ** 输　出: NOT_OK:参数错误
              **         OS_Q_OK:成功
              ** 全局变量: 无
              ** 调用模块: 无
              **
C51 COMPILER V8.08   OS_Q                                                                  08/07/2012 09:07:58 PAGE 2   

              ** 作　者: 陈明计
              ** 日　期: 2002年9月1日
              **-------------------------------------------------------------------------------------------------------
              ** 修改人: 陈明计
              ** 日　期: 2002年10月27日
              **-------------------------------------------------------------------------------------------------------
              ** 修改人:
              ** 日　期:
              **-------------------------------------------------------------------------------------------------------
              ********************************************************************************************************/
              
                      uint8 OSQCreate(uint8 OS_Q_MEM_SEL *Buf, uint8 SizeOfBuf)
              //Buf[0]:队列中字节数,Buf[1]:Buf总长度,Buf[2]:出对端,Buf[3](,Buf[4]):等待队列任务列表
              {
                  OS_ENTER_CRITICAL();
              
                  if ((SizeOfBuf >= 5) && (Buf != NULL))
                  {
                      Buf[0] = 0;                         /* 队列中消息数目           */
                      Buf[1] = SizeOfBuf;                 /* 消息队列占用内存字节数    */
              #if OS_MAX_TASKS < 9
                      Buf[2] = 4;                         /* 将要出队的消息所在位置    */
              #else
                      Buf[2] = 5;                         /* 将要出队的消息所在位置    */
              #endif
                      Buf[3] = 0;                         /* 消息队列的等待任务列表    */
                      Buf[4] = 0;                         /* 任务数大于等于8时为等待任务列表的一部分， */
                                                          /* 否则为消息缓冲区         */
              
                      OS_EXIT_CRITICAL();
                      return OS_Q_OK;
                  }
                  else
                  {
                      OS_EXIT_CRITICAL();
                      return NOT_OK;
                  }
              
              }
              
              /*********************************************************************************************************
              ** 函数名称: OSQPend
              ** 功能描述: 等待消息队列中的消息
              ** 输　入: Ret:返回的消息
              **         Buf:指向队列的指针
              **         Tick:等待时间
              ** 输　出: NOT_OK:参数错误
              **         OS_Q_OK:收到消息
              **         OS_Q_TMO:超时到
              **         OS_Q_NOT_OK:无消息
              ** 全局变量: 无
              ** 调用模块: OSRunningTaskID,OS_TaskSuspend,OSSched,OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
              **
              ** 作　者: 陈明计
              ** 日　期: 2002年9月1日
              **-------------------------------------------------------------------------------------------------------
              ** 修改人: 陈明计
              ** 日　期: 2002年10月9日
              **------------------------------------------------------------------------------------------------------
              ** 修改人: 陈明计
              ** 日　期: 2002年12月2日
              **-------------------------------------------------------------------------------------------------------
C51 COMPILER V8.08   OS_Q                                                                  08/07/2012 09:07:58 PAGE 3   

              ** 修改人:
              ** 日　期:
              **-------------------------------------------------------------------------------------------------------
              ********************************************************************************************************/
              #if EN_OS_Q_PENT > 0
              
                      uint8 OSQPend(uint8 data *Ret, uint8 OS_Q_MEM_SEL *Buf, uint8 Tick)
              {
              #ifdef __C51__
                  uint8 data *cp;
              #endif
              
              #if EN_OS_Q_CHK > 0
                  if (Buf == NULL)
                  {
                      return NOT_OK;
                  }
              #endif
              
                  OS_ENTER_CRITICAL();
              
                  OSWaitTick[OSRunningTaskID()] = Tick;       /* 设置超时时间         */
                                                              /* 可以优化寄存器的使用  */
              
                              /* 使用堆栈是为了使函数具有重入性 */
              #ifdef __C51__
                  SP++;
                  *((uint8 data * data *)SP) = Ret;
              #endif
              
                              /* 把任务加入等待任务队列 */
              #if OS_MAX_TASKS < 9
                  Buf[3] |= OSMapTbl[OSRunningTaskID()];
              #else
                  if (OSRunningTaskID() < 8)
                  {
                      Buf[3] |= OSMapTbl[OSRunningTaskID()];
                  }
                  else
                  {
                      Buf[4] |= OSMapTbl[OSRunningTaskID() & 0x07];
                  }
              #endif
              
                  while (Buf[0] == 0)             /* 消息队列中是否有消息 */
                  {
                              /* 无消息 */
              #ifdef __C51__
                      SP = SP + sizeof(Buf);
                      *((uint8 OS_Q_MEM_SEL * data *)(SP + 1 - sizeof(Buf))) = Buf;
              #endif
              
                      OS_TaskSuspend(OSRunningTaskID());   /* 任务进入等待状态 */
                      OSSched();                          /* 运行下一个任务 */
              
              #ifdef __C51__
                      Buf = *((uint8 OS_Q_MEM_SEL * data *)(SP + 1 - sizeof(Buf)));
                      SP = SP - sizeof(Buf);
              #endif
                              /* 任务再次运行，如果超时到，退出循环 */
                      if (OSWaitTick[OSRunningTaskID()] == 0)
                      {
C51 COMPILER V8.08   OS_Q                                                                  08/07/2012 09:07:58 PAGE 4   

                          break;
                      }
                  }
              
                              /* 将任务从等待队列中清除（可以删除） */
              #if OS_MAX_TASKS < 9
                  Buf[3] &= ~OSMapTbl[OSRunningTaskID()];
              #else
                  if (OSRunningTaskID() < 8)
                  {
                      Buf[3] &= ~OSMapTbl[OSRunningTaskID()];
                  }
                  else
                  {
                      Buf[4] &= ~OSMapTbl[OSRunningTaskID() & 0x07];
                  }
              #endif
                              /* 判断消息队列中是否有消息 */
                  if (Buf[0] > 0)
                  {
                              /* 有，消息出队 */
                      Buf[0]--;           /* 队列的消息数目减一 */
                              /* 指向下一个出队位置 */
                      Buf[2]++;
                      if (Buf[2] >= Buf[1] )
                      {
              #if OS_MAX_TASKS < 9
                          Buf[2] = 4;
              #else
                          Buf[2] = 5;
              #endif
                      }
              #ifdef __C51__
                      cp = (uint8 data *)(*((uint8 data *)SP));
                      SP--;
                      *cp = Buf[Buf[2]];
              #else
                      *Ret = Buf[Buf[2]];
              #endif
                      OS_EXIT_CRITICAL();
                      return OS_Q_OK;
                  }
                  else
                  {
                              /* 无，返回错误码 */
              #ifdef __C51__
                      SP--;
              #endif
              
                      OS_EXIT_CRITICAL();
                      return OS_Q_TMO;
                  }
              }
              #endif
              
              /*********************************************************************************************************
              ** 函数名称: OSQAccept
              ** 功能描述: 无等待从消息队列中取得消息
              ** 输　入: Ret:返回的消息
              **         Buf:指向队列的指针
              ** 输　出: NOT_OK:参数错误
              **         OS_Q_OK:收到消息
C51 COMPILER V8.08   OS_Q                                                                  08/07/2012 09:07:58 PAGE 5   

              **         OS_Q_TMO:超时到
              **         OS_Q_NOT_OK:无消息
              ** 全局变量: 无
              ** 调用模块: OS_TaskSuspend,OSSched,OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
              **
              ** 作　者: 陈明计
              ** 日　期: 2002年9月1日
              **-------------------------------------------------------------------------------------------------------
              ** 修改人:
              ** 日　期:
              **-------------------------------------------------------------------------------------------------------
              ********************************************************************************************************/
              #if EN_OS_Q_ACCEPT > 0
                      uint8 OSQAccept(uint8 data *Ret, uint8 OS_Q_MEM_SEL *Buf)
              {
              #if EN_OS_Q_CHK > 0
                  if (Buf == NULL)
                  {
                      return NOT_OK;
                  }
              #endif
              
                  OS_ENTER_CRITICAL();
              
                              /* 判断消息队列中是否有消息 */
                  if (*Buf != 0)
                  {
                              /* 有，消息出队 */
                      Buf[0]--;
                      Buf[2]++;
                      if (Buf[2] >= Buf[1])
                      {
              #if OS_MAX_TASKS < 9
                          Buf[2] = 4;
              #else
                          Buf[2] = 5;
              #endif
                      }
                      *Ret = Buf[Buf[2]];
                      OS_EXIT_CRITICAL();
                      return OS_Q_OK;
                  }
                  else
                  {
                              /* 无，返回错误码 */
                      OS_EXIT_CRITICAL();
                      return OS_Q_NOT_OK;
                  }
              }
              #endif
              
              
              /*********************************************************************************************************
              ** 函数名称: OSQPost
              ** 功能描述: 中断中FIFO方式发送消息
              ** 输　入: Buf:指向队列的指针
              **         Data:消息数据
              ** 输　出: OS_Q_FULL:队列满
              **         OS_Q_OK:发送成功
              ** 全局变量: 无
              ** 调用模块: OSTaskResume,OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
              **
C51 COMPILER V8.08   OS_Q                                                                  08/07/2012 09:07:58 PAGE 6   

              ** 作　者: 陈明计
              ** 日　期: 2003年8月3日
              **-------------------------------------------------------------------------------------------------------
              ** 修改人:
              ** 日　期:
              **-------------------------------------------------------------------------------------------------------
              ********************************************************************************************************/
              #if EN_OS_Q_POST > 0
                      uint8 OSQPost(uint8 OS_Q_MEM_SEL *Buf, uint8 Data)
              {
                  uint8 temp,i;
              
              #if EN_OS_Q_CHK > 0
                  if (Buf == NULL)
                  {
                      return NOT_OK;
                  }
              #endif
              
                  OS_ENTER_CRITICAL();
              
                              /* 队列是否已满 */
              #if OS_MAX_TASKS < 9
                  if (Buf[0] < (Buf[1]-4))
              #else
                  if (Buf[0] < (Buf[1]-5))
              #endif
                  {
                              /* 使用堆栈是为了使函数具有重入性 */
              #ifdef __C51__
                      SP++;
                      *((uint8 data *)SP) = Data;
              #endif
                              /* 计算新入队消息存储位置 */
                      temp = Buf[2] + Buf[0] + 1;
                      if (temp >= Buf[1])
                      {
              #if OS_MAX_TASKS < 9
                          temp = temp - Buf[1]+4;
              #else
                          temp = temp - Buf[1]+5;
              #endif
                      }
                              /* 存储消息 */
              #ifdef __C51__
                      Buf[temp] = *((uint8 data *)SP);
                      SP--;
              #else
                      Buf[temp] = Data;
              #endif
              
                      Buf[0]++;               /* 消息数目加一 */
                              /* 判断消息入队前消息队列是否为空 */
                      if (Buf[0] == 1)
                      {
                              /* 为空，可能有任务等待消息，查找之 */
                          temp = Buf[3];
              #if OS_MAX_TASKS < 9
                          for (i = 0; i < OS_MAX_TASKS; i++)
                          {
                              if ((temp & 0x01) != 0)
                              {
C51 COMPILER V8.08   OS_Q                                                                  08/07/2012 09:07:58 PAGE 7   

                                  break;
                              }
                              temp = temp >> 1;
                          }
                          if (i < OS_MAX_TASKS )
                          {
                              /* 查到，使其中优先级最高的任务进入就绪状态，并将其从等待队列中清除 */
                              Buf[3] &= ~OSMapTbl[i];
                              OSTaskResume(i);
                          }
              #else
                          for (i = 0; i < 8; i++)
                          {
                              if ((temp & 0x01) != 0)
                              {
                                  break;
                              }
                              temp = temp >> 1;
                          }
                          if (i >= 8 )
                          {
                              temp = Buf[4];
                              for (; i < OS_MAX_TASKS; i++)
                              {
                                  if ((temp & 0x01) != 0)
                                  {
                                      break;
                                  }
                                  temp = temp >> 1;
                              }
                          }
                          if (i < OS_MAX_TASKS )
                          {
                              /* 查到，使其中优先级最高的任务进入就绪状态，并将其从等待队列中清除 */
                              if (i < 8)
                              {
                                  Buf[3] &= ~OSMapTbl[i];
                              }
                              else
                              {
                                  Buf[4] &= ~OSMapTbl[i & 0x07];
                              }
                              OSTaskResume(i);
                          }
              #endif
                      }
                      OS_EXIT_CRITICAL();
                      return OS_Q_OK;
                  }
                  else
                  {
                      OS_EXIT_CRITICAL();
                      return OS_Q_FULL;
                  }
              }
              #endif
              
              /*********************************************************************************************************
              ** 函数名称: OSQPostFront
              ** 功能描述: 中断中LIFO方式发送消息
              ** 输　入: Buf:指向队列的指针
              **         Data:消息数据
C51 COMPILER V8.08   OS_Q                                                                  08/07/2012 09:07:58 PAGE 8   

              ** 输　出: OS_Q_FULL:队列满
              **         OS_Q_OK:发送成功
              ** 全局变量: 无
              ** 调用模块: OSTaskResume,OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
              **
              ** 作　者: 陈明计
              ** 日　期: 2003年8月3日
              **-------------------------------------------------------------------------------------------------------
              ** 修改人:
              ** 日　期:
              **-------------------------------------------------------------------------------------------------------
              ********************************************************************************************************/
              #if EN_OS_Q_POST_FRONT > 0
                      uint8 OSQPostFront(uint8 OS_Q_MEM_SEL *Buf, uint8 Data)
              {
                  uint8 temp,i;
              
              #if EN_OS_Q_CHK > 0
                  if (Buf == NULL)
                  {
                      return NOT_OK;
                  }
              #endif
              
                  OS_ENTER_CRITICAL();
              
                              /* 队列是否已满 */
              #if OS_MAX_TASKS < 9
                  if (Buf[0] < (Buf[1]-4))
              #else
                  if (Buf[0] < (Buf[1]-5))
              #endif
                  {
                              /* 存储消息 */
                      Buf[Buf[2]] = Data;
                      Buf[0]++;           /* 消息数目增加一 */
                              /* 指向新的将要出队的消息 */
                      Buf[2]--;
              #if OS_MAX_TASKS < 9
                      if (Buf[2] < 4)
              #else
                      if (Buf[2] < 5)
              #endif
                      {
                          Buf[2] = Buf[1]-1;
                      }
                      
                              /* 判断消息入队前消息队列是否为空 */
                      if (Buf[0] == 1)
                      {
                              /* 为空，可能有任务等待消息，查找之 */
                          temp = Buf[3];
              #if OS_MAX_TASKS < 9
                          for (i = 0; i < OS_MAX_TASKS; i++)
                          {
                              if ((temp & 0x01) != 0)
                              {
                                  break;
                              }
                              temp = temp >> 1;
                          }
                          if (i < OS_MAX_TASKS )
C51 COMPILER V8.08   OS_Q                                                                  08/07/2012 09:07:58 PAGE 9   

                          {
                              /* 查到，使其中优先级最高的任务进入就绪状态，并将其从等待队列中清除 */
                              Buf[3] &= ~OSMapTbl[i];
                              OSTaskResume(i);
                          }
              #else
                          for (i = 0; i < 8; i++)
                          {
                              if ((temp & 0x01) != 0)
                              {
                                  break;
                              }
                              temp = temp >> 1;
                          }
                          if (i >= 8 )
                          {
                              temp = Buf[4];
                              for (; i < OS_MAX_TASKS; i++)
                              {
                                  if ((temp & 0x01) != 0)
                                  {
                                      break;
                                  }
                                  temp = temp >> 1;
                              }
                          }
                          if (i < OS_MAX_TASKS )
                          {
                              /* 查到，使其中优先级最高的任务进入就绪状态，并将其从等待队列中清除 */
                              if (i < 8)
                              {
                                  Buf[3] &= ~OSMapTbl[i];
                              }
                              else
                              {
                                  Buf[4] &= ~OSMapTbl[i & 0x07];
                              }
                              OSTaskResume(i);
                          }
              #endif
                      }
                      OS_EXIT_CRITICAL();
                      return OS_Q_OK;
                  }
                  else
                  {
                      OS_EXIT_CRITICAL();
                      return OS_Q_FULL;
                  }
              }
              #endif
              
              /*********************************************************************************************************
              ** 函数名称: OSQNMsgs
              ** 功能描述: 取得消息队列中消息数
              ** 输　入: Buf:指向队列的指针
              ** 输　出: 消息数
              ** 全局变量: 无
              ** 调用模块: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
              **
              ** 作　者: 陈明计
              ** 日　期: 2002年9月1日
C51 COMPILER V8.08   OS_Q                                                                  08/07/2012 09:07:58 PAGE 10  

              **-------------------------------------------------------------------------------------------------------
              ** 修改人:
              ** 日　期:
              **-------------------------------------------------------------------------------------------------------
              ********************************************************************************************************/
              #if EN_OS_Q_NMsgs > 0
                      uint8 OSQNMsgs(uint8 OS_Q_MEM_SEL *Buf)
              {
                  uint8 temp;
              
              #if EN_OS_Q_CHK > 0
                  if (Buf == NULL)
                  {
                      return 0;
                  }
              #endif
              
                  OS_ENTER_CRITICAL();
                  temp = Buf[0];
                  OS_EXIT_CRITICAL();
                  return temp;
              }
              #endif
              
              /*********************************************************************************************************
              ** 函数名称: OSQSize
              ** 功能描述: 取得消息队列总容量
              ** 输　入: Buf:指向队列的指针
              ** 输　出: 消息队列总容量
              ** 全局变量: 无
              ** 调用模块: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
              **
              ** 作　者: 陈明计
              ** 日　期: 2002年9月1日
              **-------------------------------------------------------------------------------------------------------
              ** 修改人:
              ** 日　期:
              **-------------------------------------------------------------------------------------------------------
              ********************************************************************************************************/
              #if EN_OS_Q_SIZE > 0
                      uint8 OSQSize(uint8 OS_Q_MEM_SEL *Buf)
              {
                  uint8 temp;
              
              #if EN_OS_Q_CHK > 0
                  if (Buf == NULL)
                  {
                      return 0;
                  }
              #endif
              
                  OS_ENTER_CRITICAL();
              #if OS_MAX_TASKS < 9
                  temp = Buf[1] - 4;
              #else
                  temp = Buf[1] - 5;
              #endif
                  OS_EXIT_CRITICAL();
                  return temp;
              }
              #endif
              
C51 COMPILER V8.08   OS_Q                                                                  08/07/2012 09:07:58 PAGE 11  

              /*********************************************************************************************************
              ** 函数名称: OSQFlush
              ** 功能描述: 清空队列
              ** 输　入: Buf:指向队列的指针
              ** 输　出: 无
              ** 全局变量: 无
              ** 调用模块: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
              **
              ** 作　者: 陈明计
              ** 日　期: 2002年9月1日
              **-------------------------------------------------------------------------------------------------------
              ** 修改人: 陈明计
              ** 日　期: 2002年10月26日
              **-------------------------------------------------------------------------------------------------------
              ** 修改人:
              ** 日　期:
              **-------------------------------------------------------------------------------------------------------
              ********************************************************************************************************/
              #if EN_OS_Q_FLUSH > 0
                      void OSQFlush (uint8 OS_Q_MEM_SEL *Buf)
              {
              #if EN_OS_Q_CHK > 0
                  if (Buf == NULL)
                  {
                      return;
                  }
              #endif
              
                  Buf[0] = 0;
              #if OS_MAX_TASKS < 9
                  Buf[2] = 4;
              #else
                  Buf[2] = 5;
              #endif
              }
              #endif
              
              #endif
 647          /*********************************************************************************************************
 648          **                            End Of File
 649          ********************************************************************************************************/

C51 COMPILATION COMPLETE.  3 WARNING(S),  1 ERROR(S)
